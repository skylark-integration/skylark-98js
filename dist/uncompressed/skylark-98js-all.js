/**
 * skylark-98js - A version of 98js.js that ported to running on skylarkjs
 * @author Hudaokeji, Inc.
 * @version v0.9.0
 * @link https://github.com/skylark-integration/skylark-98js/
 * @license MIT
 */
(function(factory,globals) {
  var define = globals.define,
      require = globals.require,
      isAmd = (typeof define === 'function' && define.amd),
      isCmd = (!isAmd && typeof exports !== 'undefined');

  if (!isAmd && !define) {
    var map = {};
    function absolute(relative, base) {
        if (relative[0]!==".") {
          return relative;
        }
        var stack = base.split("/"),
            parts = relative.split("/");
        stack.pop(); 
        for (var i=0; i<parts.length; i++) {
            if (parts[i] == ".")
                continue;
            if (parts[i] == "..")
                stack.pop();
            else
                stack.push(parts[i]);
        }
        return stack.join("/");
    }
    define = globals.define = function(id, deps, factory) {
        if (typeof factory == 'function') {
            map[id] = {
                factory: factory,
                deps: deps.map(function(dep){
                  return absolute(dep,id);
                }),
                resolved: false,
                exports: null
            };
            require(id);
        } else {
            map[id] = {
                factory : null,
                resolved : true,
                exports : factory
            };
        }
    };
    require = globals.require = function(id) {
        if (!map.hasOwnProperty(id)) {
            throw new Error('Module ' + id + ' has not been defined');
        }
        var module = map[id];
        if (!module.resolved) {
            var args = [];

            module.deps.forEach(function(dep){
                args.push(require(dep));
            })

            module.exports = module.factory.apply(globals, args) || null;
            module.resolved = true;
        }
        return module.exports;
    };
  }
  
  if (!define) {
     throw new Error("The module utility (ex: requirejs or skylark-utils) is not loaded!");
  }

  factory(define,require);

  if (!isAmd) {
    var skylarkjs = require("skylark-langx-ns");

    if (isCmd) {
      module.exports = skylarkjs;
    } else {
      globals.skylarkjs  = skylarkjs;
    }
  }

})(function(define,require) {

define('skylark-langx-ns/_attach',[],function(){
    return  function attach(obj1,path,obj2) {
        if (typeof path == "string") {
            path = path.split(".");//[path]
        };
        var length = path.length,
            ns=obj1,
            i=0,
            name = path[i++];

        while (i < length) {
            ns = ns[name] = ns[name] || {};
            name = path[i++];
        }

        if (ns[name]) {
            if (obj2) {
                throw new Error("This namespace already exists:" + path);
            }

        } else {
            ns[name] = obj2 || {};
        }
        return ns[name];
    }
});
define('skylark-langx-ns/ns',[
    "./_attach"
], function(_attach) {
    var root = {
    	attach : function(path,obj) {
    		return _attach(root,path,obj);
    	}
    };
    return root;
});

define('skylark-langx-ns/main',[
	"./ns"
],function(skylark){
	return skylark;
});
define('skylark-langx-ns', ['skylark-langx-ns/main'], function (main) { return main; });

define('skylark-langx/skylark',[
    "skylark-langx-ns"
], function(ns) {
	return ns;
});

define('skylark-langx-arrays/arrays',[
  "skylark-langx-ns"
],function(skylark){
    return skylark.attach("langx.arrays");
});
define('skylark-langx-arrays/base-find-index',[
  "./arrays"
],function(arrays){
    /**
     * The base implementation of `_.findIndex` and `_.findLastIndex` without
     * support for iteratee shorthands.
     *
     * @param {Array} array The array to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {number} fromIndex The index to search from.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length,
          index = fromIndex + (fromRight ? 1 : -1);

      while ((fromRight ? index-- : ++index < length)) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    return arrays.baseFindIndex = baseFindIndex;
});
define('skylark-langx-arrays/base-indexof',[
  "./arrays",
  "./base-find-index"
],function(arrays,baseFindIndex){

    /**
     * The base implementation of `isNaN` without support for number objects.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     */
    function baseIsNaN(value) {
      return value !== value;
    }

    /**
     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
     *
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1,
          length = array.length;

      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
	
	return arrays.baseIndexOf = baseIndexOf;
});
define('skylark-langx-arrays/filter',[
  "./arrays"
],function(arrays){
   var _filter = Array.prototype.filter;
 
    function filter(array,func) {
      return _filter.call(array,func);
    }

    return arrays.filter = filter;
	
});
define('skylark-langx-arrays/compact',[
  "./arrays",
  "./filter"
],function(arrays,filter){

    function compact(array) {
        return filter(array, function(item) {
            return item != null;
        });
    }

    return arrays.compact = compact;
});
define('skylark-langx-arrays/in-array',[
  "./arrays"
],function(arrays){
    function inArray(item, array) {
        if (!array) {
            return -1;
        }
        var i;

        if (array.indexOf) {
            return array.indexOf(item);
        }

        i = array.length;
        while (i--) {
            if (array[i] === item) {
                return i;
            }
        }

        return -1;
    }

    return arrays.inArray = inArray;
	
});
define('skylark-langx-arrays/contains',[
  "./arrays",
  "./in-array"
],function(arrays,inArray){

    function contains(array,item) {
      return inArray(item,array);
    }
	
	return arrays.contains = contains;
});
define('skylark-langx-funcs/funcs',[
  "skylark-langx-ns",
],function(skylark,types,objects){
        



    function noop() {
    }




    return skylark.attach("langx.funcs",{
        noop : noop,

        returnTrue: function() {
            return true;
        },

        returnFalse: function() {
            return false;
        }

    });
});
define('skylark-langx-funcs/rest-arguments',[
	"./funcs"
],function(funcs){

  // Some functions take a variable number of arguments, or a few expected
  // arguments at the beginning and then a variable number of values to operate
  // on. This helper accumulates all remaining arguments past the function’s
  // argument length (or an explicit `startIndex`), into an array that becomes
  // the last argument. Similar to ES6’s "rest parameter".
  function restArguments(func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function() {
      var length = Math.max(arguments.length - startIndex, 0),
          rest = Array(length),
          index = 0;
      for (; index < length; index++) {
        rest[index] = arguments[index + startIndex];
      }
      switch (startIndex) {
        case 0: return func.call(this, rest);
        case 1: return func.call(this, arguments[0], rest);
        case 2: return func.call(this, arguments[0], arguments[1], rest);
      }
      var args = Array(startIndex + 1);
      for (index = 0; index < startIndex; index++) {
        args[index] = arguments[index];
      }
      args[startIndex] = rest;
      return func.apply(this, args);
    };
  }

  return funcs.restArguments = restArguments;	
});
define('skylark-langx-funcs/bind-all',[
	"./funcs",
	"./rest-arguments"
],function(funcs,restArguments){

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  return funcs.bindAll = restArguments(function(obj, keys) {
    ///keys = flatten(keys, false, false);
    var index = keys.length;
    if (index < 1) throw new Error('bindAll must be passed function names');
    while (index--) {
      var key = keys[index];
      obj[key] = obj[key].bind(obj);
    }
  });

});

define('skylark-langx-types/types',[
    "skylark-langx-ns"
],function(skylark){
    var nativeIsArray = Array.isArray, 
        toString = {}.toString;
    
    var type = (function() {
        var class2type = {};

        // Populate the class2type map
        "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" ").forEach(function(name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
        });

        return function type(obj) {
            return obj == null ? String(obj) :
                class2type[toString.call(obj)] || "object";
        };
    })();

 
    var  isArray = nativeIsArray || function(obj) {
        return object && object.constructor === Array;
    };


    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function/string/element and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * isArrayLike([1, 2, 3])
     * // => true
     *
     * isArrayLike(document.body.children)
     * // => false
     *
     * isArrayLike('abc')
     * // => true
     *
     * isArrayLike(Function)
     * // => false
     */    
    function isArrayLike(obj) {
        return !isString(obj) && !isHtmlNode(obj) && typeof obj.length == 'number' && !isFunction(obj);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * isBoolean(false)
     * // => true
     *
     * isBoolean(null)
     * // => false
     */
    function isBoolean(obj) {
       return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
       //return typeof(obj) === "boolean";
    }

    function isDefined(obj) {
        return typeof obj !== 'undefined';
    }

    function isDocument(obj) {
        return obj != null && obj.nodeType == obj.DOCUMENT_NODE;
    }

   // Is a given value a DOM element?
    function isElement(obj) {
        return !!(obj && obj.nodeType === 1);
    }   

    function isEmptyObject(obj) {
        var name;
        for (name in obj) {
            if (obj[name] !== null) {
                return false;
            }
        }
        return true;
    }


    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * isFunction(parseInt)
     * // => true
     *
     * isFunction(/abc/)
     * // => false
     */
    function isFunction(value) {
        return type(value) == "function";
    }



    function isHtmlNode(obj) {
        return obj && obj.nodeType; // obj instanceof Node; //Consider the elements in IFRAME
    }

    function isInstanceOf( /*Object*/ value, /*Type*/ type) {
        //Tests whether the value is an instance of a type.
        if (value === undefined) {
            return false;
        } else if (value === null || type == Object) {
            return true;
        } else if (typeof value === "number") {
            return type === Number;
        } else if (typeof value === "string") {
            return type === String;
        } else if (typeof value === "boolean") {
            return type === Boolean;
        } else if (typeof value === "string") {
            return type === String;
        } else {
            return (value instanceof type) || (value && value.isInstanceOf ? value.isInstanceOf(type) : false);
        }
    }

    function isNull(obj) {
        return obj === null;
    }

    function isNumber(obj) {
        return typeof obj == 'number';
    }

    function isObject(obj) {
        var type = typeof obj;
        return type === 'function' || type === 'object' && !!obj;        
        //return type(obj) == "object";
    }

    function isPlainObject(obj) {
        return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype;
    }

    function isString(obj) {
        return typeof obj === 'string';
    }

    function isWindow(obj) {
        return obj && obj == obj.window;
    }

    function isSameOrigin(href) {
        if (href) {
            var origin = location.protocol + '//' + location.hostname;
            if (location.port) {
                origin += ':' + location.port;
            }
            return href.startsWith(origin);
        }
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ;
       //|| (isObjectLike(value) && objectToString.call(value) == symbolTag); // modified by lwf
    }

    // Is a given variable undefined?
    function isUndefined(obj) {
        return obj === void 0;
    }


    var INFINITY = 1 / 0,
        MAX_SAFE_INTEGER = 9007199254740991,
        MAX_INTEGER = 1.7976931348623157e+308,
        NAN = 0 / 0;

    /** Used to match leading and trailing whitespace. */
    var reTrim = /^\s+|\s+$/g;

    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;

    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;

    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }   

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }





    return skylark.attach("langx.types",{

        isArray: isArray,

        isArrayLike: isArrayLike,

        isBoolean: isBoolean,

        isDefined: isDefined,

        isDocument: isDocument,

        isElement,

        isEmpty : isEmptyObject,

        isEmptyObject: isEmptyObject,

        isFunction: isFunction,

        isHtmlNode: isHtmlNode,

        isNaN : function (obj) {
            return isNaN(obj);
        },

        isNull: isNull,


        isNumber: isNumber,

        isNumeric: isNumber,

        isObject: isObject,

        isPlainObject: isPlainObject,

        isString: isString,

        isSameOrigin: isSameOrigin,

        isSymbol : isSymbol,

        isUndefined: isUndefined,

        isWindow: isWindow,

        type: type,

        toFinite : toFinite,
        toNumber : toNumber,
        toInteger : toInteger
        
    });

});
define('skylark-langx-types/main',[
	"./types"
],function(types){
	return types;
});
define('skylark-langx-types', ['skylark-langx-types/main'], function (main) { return main; });

define('skylark-langx-funcs/defer',[
    "skylark-langx-types",
    "./funcs"
],function(types,funcs){

    function defer(fn,trigger,args,context) {
        var ret = {
            cancel : null
        },
        fn1 = fn;

        if (!types.isNumber(trigger) && !types.isFunction(trigger)) {
            context = args;
            args = trigger;
            trigger = 0;
        }

        if (args) {
            fn1 = function() {
                fn.apply(context,args);
            };
        }

        if (types.isFunction(trigger)) {
            var canceled = false;
            trigger(function(){
                if (!canceled) {
                    fn1();
                }
            });

            ret.cancel = function() {
                canceled = true;
            }

        } else {
            var  id;
            if (trigger == 0 && requestAnimationFrame) {
                id = requestAnimationFrame(fn1);
                ret.cancel = function() {
                    return cancelAnimationFrame(id);
                };
            } else {
                id = setTimeout(fn1,trigger);
                ret.cancel = function() {
                    return clearTimeout(id);
                };
            }            
        }

        return ret;
    }

    return funcs.defer = defer;
});
define('skylark-langx-funcs/debounce',[
	"./funcs",
    "./defer"
],function(funcs,defer){
   
    function debounce(fn, wait,useAnimationFrame) {
        var timeout,
            defered,
            debounced = function () {
                var context = this, args = arguments;
                var later = function () {
                    timeout = null;
                    if (useAnimationFrame) {
                        defered = defer(fn,args,context);
                    } else {
                        fn.apply(context, args);
                    }
                };

                cancel();
                timeout = setTimeout(later, wait);

                return {
                    cancel 
                };
            },
            cancel = debounced.cancel = function () {
                if (timeout) {
                    clearTimeout(timeout);
                }
                if (defered) {
                    defered.cancel();
                }
                timeout = void 0;
                defered = void 0;
            };

        return debounced;
    }

    return funcs.debounce = debounce;

});
define('skylark-langx-objects/objects',[
    "skylark-langx-ns",
    "skylark-langx-types"
],function(skylark,types){

    return skylark.attach("langx.objects",{
        attach : skylark.attach
    });

});
define('skylark-langx-objects/all-keys',[
    "skylark-langx-types",
    "./objects"
],function(types,objects){

    // Retrieve all the property names of an object.
    function allKeys(obj) {
        if (!types.isObject(obj)) return [];
        var keys = [];
        for (var key in obj) keys.push(key);
        return keys;
    }

    return objects.allKeys = allKeys;

});
define('skylark-langx-objects/assign',[
	"skylark-langx-types",
	"./objects"
],function(types,objects) {

	return objects.assign = Object.assign;
});
define('skylark-langx-objects/to-key',[
	"skylark-langx-types",
	"./objects"
],function(types,objects) {

	const isSymbol = types.isSymbol,
		  isString = types.isString;

	/** Used as references for various `Number` constants. */
	const INFINITY = 1 / 0

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (isString(value) || isSymbol(value)) {
	    return value
	  }
	  const result = `${value}`
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result
	}

	return objects.toKey = toKey;

});
define('skylark-langx-objects/is-key',[
	"skylark-langx-types",
	"./objects"
],function(types,objects) {

	const isSymbol = types.isSymbol,
		  isArray = types.isArray;

	/** Used to match property names within property paths. */
	const reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/
	const reIsPlainProp = /^\w*$/

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false
	  }
	  const type = typeof value
	  if (type === 'number' || type === 'boolean' || value == null || isSymbol(value)) {
	    return true
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object))
	}

	return objects.isKey = isKey;
});
define('skylark-langx-objects/_cast_path',[
	"skylark-langx-types",
	"./objects",
	"./is-key"
],function(types,objects,isKey) {
	const charCodeOfDot = '.'.charCodeAt(0)
	const reEscapeChar = /\\(\\)?/g
	const rePropName = RegExp(
	  // Match anything that isn't a dot or bracket.
	  '[^.[\\]]+' + '|' +
	  // Or match property names within brackets.
	  '\\[(?:' +
	    // Match a non-string expression.
	    '([^"\'][^[]*)' + '|' +
	    // Or match strings (supports escaping characters).
	    '(["\'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2' +
	  ')\\]'+ '|' +
	  // Or match "" as the space between consecutive dots or empty brackets.
	  '(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))'
	  , 'g')

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	const stringToPath = ((string) => {
	  const result = []
	  if (string.charCodeAt(0) === charCodeOfDot) {
	    result.push('')
	  }
	  string.replace(rePropName, (match, expression, quote, subString) => {
	    let key = match
	    if (quote) {
	      key = subString.replace(reEscapeChar, '$1')
	    }
	    else if (expression) {
	      key = expression.trim()
	    }
	    result.push(key)
	  })
	  return result
	});

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (types.isArray(value)) {
	    return value
	  }
	  return isKey(value, object) ? [value] : stringToPath(value)
	}

	return castPath;
});
define('skylark-langx-objects/get',[
	"skylark-langx-types",
	"./objects",
	"./to-key",
	"./_cast_path"
],function(types,objects,toKey,castPath) {

	/**
	 * The base implementation of `get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = castPath(path, object)

	  let index = 0
	  const length = path.length

	  while (object != null && index < length) {
	    object = object[toKey(path[index++])]
	  }
	  return (index && index == length) ? object : undefined
	}


	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @see has, hasIn, set, unset
	 * @example
	 *
	 * const object = { 'a': [{ 'b': { 'c': 3 } }] }
	 *
	 * get(object, 'a[0].b.c')
	 * // => 3
	 *
	 * get(object, ['a', '0', 'b', 'c'])
	 * // => 3
	 *
	 * get(object, 'a.b.c', 'default')
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  const result = object == null ? undefined : baseGet(object, path)
	  return result === undefined ? defaultValue : result
	}

	return objects.get = get;
});
define('skylark-langx-objects/base-at',[
	"./objects",
	"./get"
],function(objects,get) {

	/**
	 * The base implementation of `at` without support for individual paths.
	 *
	 * @param {Object} object The object to iterate over.
	 * @param {string[]} paths The property paths to pick.
	 * @returns {Array} Returns the picked elements.
	 */
	function baseAt(object, paths) {
	  let index = -1
	  const length = paths.length
	  const result = new Array(length)
	  const skip = object == null

	  while (++index < length) {
	    result[index] = skip ? undefined : get(object, paths[index])
	  }
	  return result
	}

	return objects.baseAt = baseAt;
});
define('skylark-langx-objects/clone',[
    "skylark-langx-types",
    "./objects"
],function(types,objects) {
    var isPlainObject = types.isPlainObject,
        isArray = types.isArray;

    function clone( /*anything*/ src,checkCloneMethod) {
        var copy;
        if (src === undefined || src === null) {
            copy = src;
        } else if (checkCloneMethod && src.clone) {
            copy = src.clone();
        } else if (isArray(src)) {
            copy = [];
            for (var i = 0; i < src.length; i++) {
                copy.push(clone(src[i]));
            }
        } else if (isPlainObject(src)) {
            copy = {};
            for (var key in src) {
                copy[key] = clone(src[key]);
            }
        } else {
            copy = src;
        }

        return copy;

    }

    return objects.clone = clone;
});
define('skylark-langx-objects/defaults',[
    "./objects",
    "./all-keys"
],function(objects,allKeys){
  // An internal function for creating assigner functions.
  function createAssigner(keysFunc, defaults) {
      return function(obj) {
        var length = arguments.length;
        if (defaults) obj = Object(obj);  
        if (length < 2 || obj == null) return obj;
        for (var index = 1; index < length; index++) {
          var source = arguments[index],
              keys = keysFunc(source),
              l = keys.length;
          for (var i = 0; i < l; i++) {
            var key = keys[i];
            if (!defaults || obj[key] === void 0) obj[key] = source[key];
          }
        }
        return obj;
     };
  }
  
  return objects.defaults = createAssigner(allKeys, true);
});
define('skylark-langx-objects/each',[
    "./objects"
],function(objects) {

    function each(obj, callback,isForEach) {
        var length, key, i, undef, value;

        if (obj) {
            length = obj.length;

            if (length === undef) {
                // Loop object items
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        value = obj[key];
                        if ((isForEach ? callback.call(value, value, key) : callback.call(value, key, value) ) === false) {
                            break;
                        }
                    }
                }
            } else {
                // Loop array items
                for (i = 0; i < length; i++) {
                    value = obj[i];
                    if ((isForEach ? callback.call(value, value, i) : callback.call(value, i, value) )=== false) {
                        break;
                    }
                }
            }
        }

        return this;
    }

    return objects.each = each;
});
define('skylark-langx-objects/_mixin',[
    "skylark-langx-types",
    "./objects"
],function(types,objects) {

    var isPlainObject = types.isPlainObject;

    function _mixin(target, source, deep, safe) {
        for (var key in source) {
            //if (!source.hasOwnProperty(key)) {
            //    continue;
            //}
            if (safe && target[key] !== undefined) {
                continue;
            }
            // if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
            //    if (isPlainObject(source[key]) && !isPlainObject(target[key])) {
            if (deep && isPlainObject(source[key])) {
                if (!isPlainObject(target[key])) {
                    target[key] = {};
                }
                //if (isArray(source[key]) && !isArray(target[key])) {
                //    target[key] = [];
                //}
                _mixin(target[key], source[key], deep, safe);
            } else if (source[key] !== undefined) {
                target[key] = source[key]
            }
        }
        return target;
    }

    return _mixin;
});
define('skylark-langx-objects/_parse_mixin_args',[
    "skylark-langx-types",
    "./objects"
],function(types,objects) {

    var slice = Array.prototype.slice,
        isBoolean = types.isBoolean;

    function _parseMixinArgs(args) {
        var params = slice.call(arguments, 0),
            target = params.shift(),
            deep = false;
        if (isBoolean(params[params.length - 1])) {
            deep = params.pop();
        }

        return {
            target: target,
            sources: params,
            deep: deep
        };
    }
    
    return _parseMixinArgs;
});
define('skylark-langx-objects/mixin',[
	"skylark-langx-types",
	"./objects",
  "./_mixin",
  "./_parse_mixin_args"
],function(types,objects,_mixin,_parseMixinArgs) {


    function mixin() {
        var args = _parseMixinArgs.apply(this, arguments);

        args.sources.forEach(function(source) {
            _mixin(args.target, source, args.deep, false);
        });
        return args.target;
    }


    return objects.mixin = mixin;
	
});
define('skylark-langx-objects/extend',[
    "./objects",
    "./mixin"
],function(objects,mixin) {
    var slice = Array.prototype.slice;

    function extend(target) {
        var deep, args = slice.call(arguments, 1);
        if (typeof target == 'boolean') {
            deep = target
            target = args.shift()
        }
        if (args.length == 0) {
            args = [target];
            target = this;
        }
        args.forEach(function(arg) {
            mixin(target, arg, deep);
        });
        return target;
    }

    return objects.extend = extend;
});
define('skylark-langx-objects/for-each',[
 	"./objects",
 	"./each"
],function(objects,each){

    function forEach (obj, fn) {
    	if (!obj) {
    		return;
    	}
     	if (obj.forEach) {
     		obj.forEach(fn);
     	} else {
     		each(obj,fn,true);
     	}
    }

	return objects.forEach = forEach;
});
define('skylark-langx-objects/has',[
    "skylark-langx-types",
    "./objects"
],function(types,objects){
    var hasOwnProperty = Object.prototype.hasOwnProperty;

    function has(obj, path) {
        if (!types.isArray(path)) {
            return obj != null && hasOwnProperty.call(obj, path);
        }
        var length = path.length;
        for (var i = 0; i < length; i++) {
            var key = path[i];
            if (obj == null || !hasOwnProperty.call(obj, key)) {
                return false;
            }
            obj = obj[key];
        }
        return !!length;
    }

    return objects.has = has;
});
define('skylark-langx-objects/includes',[
    "./objects"
],function(objects) {

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }



    return objects.includes = includes;
});
define('skylark-langx-objects/is-equal',[
	"skylark-langx-types",
	"./objects"
],function(types,objects) {
    var isFunction = types.isFunction;


    // Internal recursive comparison function for `isEqual`.
    var eq, deepEq;
    var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

    eq = function(a, b, aStack, bStack) {
        // Identical objects are equal. `0 === -0`, but they aren't identical.
        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
        if (a === b) return a !== 0 || 1 / a === 1 / b;
        // `null` or `undefined` only equal to itself (strict comparison).
        if (a == null || b == null) return false;
        // `NaN`s are equivalent, but non-reflexive.
        if (a !== a) return b !== b;
        // Exhaust primitive checks
        var type = typeof a;
        if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
        return deepEq(a, b, aStack, bStack);
    };

    // Internal recursive comparison function for `isEqual`.
    deepEq = function(a, b, aStack, bStack) {
        // Unwrap any wrapped objects.
        //if (a instanceof _) a = a._wrapped;
        //if (b instanceof _) b = b._wrapped;
        // Compare `[[Class]]` names.
        var className = toString.call(a);
        if (className !== toString.call(b)) return false;
        switch (className) {
            // Strings, numbers, regular expressions, dates, and booleans are compared by value.
            case '[object RegExp]':
            // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
            case '[object String]':
                // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
                // equivalent to `new String("5")`.
                return '' + a === '' + b;
            case '[object Number]':
                // `NaN`s are equivalent, but non-reflexive.
                // Object(NaN) is equivalent to NaN.
                if (+a !== +a) return +b !== +b;
                // An `egal` comparison is performed for other numeric values.
                return +a === 0 ? 1 / +a === 1 / b : +a === +b;
            case '[object Date]':
            case '[object Boolean]':
                // Coerce dates and booleans to numeric primitive values. Dates are compared by their
                // millisecond representations. Note that invalid dates with millisecond representations
                // of `NaN` are not equivalent.
                return +a === +b;
            case '[object Symbol]':
                return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
        }

        var areArrays = className === '[object Array]';
        if (!areArrays) {
            if (typeof a != 'object' || typeof b != 'object') return false;
            // Objects with different constructors are not equivalent, but `Object`s or `Array`s
            // from different frames are.
            var aCtor = a.constructor, bCtor = b.constructor;
            if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor &&
                               isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
                return false;
            }
        }
        // Assume equality for cyclic structures. The algorithm for detecting cyclic
        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

        // Initializing stack of traversed objects.
        // It's done here since we only need them for objects and arrays comparison.
        aStack = aStack || [];
        bStack = bStack || [];
        var length = aStack.length;
        while (length--) {
            // Linear search. Performance is inversely proportional to the number of
            // unique nested structures.
            if (aStack[length] === a) return bStack[length] === b;
        }

        // Add the first object to the stack of traversed objects.
        aStack.push(a);
        bStack.push(b);

        // Recursively compare objects and arrays.
        if (areArrays) {
            // Compare array lengths to determine if a deep comparison is necessary.
            length = a.length;
            if (length !== b.length) return false;
            // Deep compare the contents, ignoring non-numeric properties.
            while (length--) {
                if (!eq(a[length], b[length], aStack, bStack)) return false;
            }
        } else {
            // Deep compare objects.
            var keys = Object.keys(a), key;
            length = keys.length;
            // Ensure that both objects contain the same number of properties before comparing deep equality.
            if (Object.keys(b).length !== length) return false;
            while (length--) {
                // Deep compare each member
                key = keys[length];
                if (!(b[key]!==undefined && eq(a[key], b[key], aStack, bStack))) return false;
            }
        }
        // Remove the first object from the stack of traversed objects.
        aStack.pop();
        bStack.pop();
        return true;
    };


   // Perform a deep comparison to check if two objects are equal.
    function isEqual(a, b) {
        return eq(a, b);
    }

    return objects.isEqual = isEqual;
	
});
define('skylark-langx-objects/keys',[
    "skylark-langx-types",
    "./objects",
    "./has"
],function(types,objects,has){

    // Retrieve the names of an object's own properties.
    // Delegates to **ECMAScript 5**'s native `Object.keys`.
    function keys(obj) {
        if (!types.isObject(obj)) return [];  
        var keys = [];
        for (var key in obj) if (has(obj, key)) keys.push(key);
        return keys;
    }

    return objects.keys = keys;
});
define('skylark-langx-objects/is-match',[
    "skylark-langx-types",
    "./objects",
    "./keys"
],function(types,objects,keys) {

    // Returns whether an object has a given set of `key:value` pairs.
    function isMatch(object, attrs) {
        var keys = keys(attrs), length = keys.length;
        if (object == null) return !length;
        var obj = Object(object);
        for (var i = 0; i < length; i++) {
          var key = keys[i];
          if (attrs[key] !== obj[key] || !(key in obj)) return false;
        }
        return true;
    }    

    return objects.isMatch = isMatch;
});
define('skylark-langx-objects/omit',[
    "./objects",
    "./mixin"
],function(objects,mixin) {

   // Return a copy of the object without the blacklisted properties.
    function omit(obj, prop1,prop2) {
        if (!obj) {
            return null;
        }
        var result = mixin({},obj);
        for(var i=1;i<arguments.length;i++) {
            var pn = arguments[i];
            if (pn in obj) {
                delete result[pn];
            }
        }
        return result;

    }
    
    return objects.omit = omit;
});
define('skylark-langx-objects/pick',[
    "./objects"
],function(objects) {

   // Return a copy of the object only containing the whitelisted properties.
    function pick(obj,prop1,prop2) {
        if (!obj) {
            return null;
        }
        var result = {};
        for(var i=1;i<arguments.length;i++) {
            var pn = arguments[i];
            if (pn in obj) {
                result[pn] = obj[pn];
            }
        }
        return result;
    }
    
    return objects.pick = pick;
});
define('skylark-langx-objects/remove-items',[
    "skylark-langx-types",
    "./objects"
],function(types,objects){
    function removeItem(items, item) {
        if (types.isArray(items)) {
            var idx = items.indexOf(item);
            if (idx != -1) {
                items.splice(idx, 1);
            }
        } else if (types.isPlainObject(items)) {
            for (var key in items) {
                if (items[key] == item) {
                    delete items[key];
                    break;
                }
            }
        }

        return this;
    }

    return objects.removeItem = removeItem;
});
define('skylark-langx-objects/result',[
  "skylark-langx-types",
  "./objects",
  "./to-key",
  "./_cast_path"
],function(types,objects,toKey,castPath) {
	var isArray = types.isArray,
		isFunction = types.isFunction;

  /**
   * This method is like `get` except that if the resolved value is a
   * function it's invoked with the `this` binding of its parent object and
   * its result is returned.
   *
   * @since 0.1.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to resolve.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * const object = { 'a': [{ 'b': { 'c1': 3, 'c2': () => 4 } }] }
   *
   * result(object, 'a[0].b.c1')
   * // => 3
   *
   * result(object, 'a[0].b.c2')
   * // => 4
   *
   * result(object, 'a[0].b.c3', 'default')
   * // => 'default'
   *
   * result(object, 'a[0].b.c3', () => 'default')
   * // => 'default'
   */
  function result(object, path, defaultValue) {
    path = castPath(path, object)

    let index = -1
    let length = path.length

    // Ensure the loop is entered when path is empty.
    if (!length) {
      length = 1
      object = undefined
    }
    while (++index < length) {
      let value = object == null ? undefined : object[toKey(path[index])]
      if (value === undefined) {
        index = length
        value = defaultValue
      }
      object = isFunction(value) ? value.call(object) : value
    }
    return object
  }

  return objects.result = result;	
});
define('skylark-langx-objects/safe-mixin',[
	"./objects",
  "./_mixin",
  "./_parse_mixin_args"
],function(objects,_mixin,_parseMixinArgs) {

    function safeMixin() {
        var args = _parseMixinArgs.apply(this, arguments);

        args.sources.forEach(function(source) {
            _mixin(args.target, source, args.deep, true);
        });
        return args.target;
    }

    return objects.safeMixin = safeMixin;
});
define('skylark-langx-objects/scall',[
    "./objects"
],function(objects) {
    const  slice = Array.prototype.slice;

    function scall(obj,method,arg1,arg2) {
        if (obj && obj[method]) {
            var args = slice.call(arguments, 2);

            return obj[method].apply(obj,args);
        }
    }

    return objects.scall = scall;
});
define('skylark-langx-objects/is-index',[
	"skylark-langx-types",
	"./objects"
],function(types,objects) {
	/** Used as references for various `Number` constants. */
	const MAX_SAFE_INTEGER = 9007199254740991

	/** Used to detect unsigned integer values. */
	const reIsUint = /^(?:0|[1-9]\d*)$/

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  const type = typeof value
	  length = length == null ? MAX_SAFE_INTEGER : length

	  return !!length &&
	    (type === 'number' ||
	      (type !== 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length)
	}

	return objects.isIndex = isIndex;
});
define('skylark-langx-objects/set',[
	"skylark-langx-types",
	"./objects",
	"./_cast_path",
	"./is-index",
	"./to-key"
],function(types,objects,castPath,isIndex,toKey) {
	/**
	 * The base implementation of `set`.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @param {Function} [customizer] The function to customize path creation.
	 * @returns {Object} Returns `object`.
	 */
	function baseSet(object, path, value, customizer) {
	  if (!types.isObject(object)) {
	    return object
	  }
	  path = castPath(path, object)

	  const length = path.length
	  const lastIndex = length - 1

	  let index = -1
	  let nested = object

	  while (nested != null && ++index < length) {
	    const key = toKey(path[index])
	    let newValue = value

	    if (index != lastIndex) {
	      const objValue = nested[key]
	      newValue = customizer ? customizer(objValue, key, nested) : undefined
	      if (newValue === undefined) {
	        newValue = types.isObject(objValue)
	          ? objValue
	          : (isIndex(path[index + 1]) ? [] : {})
	      }
	    }
	    nested[key] = newValue; //  assignValues() lwf
	    nested = nested[key];
	  }
	  return object
	}

	/**
	 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	 * it's created. Arrays are created for missing index properties while objects
	 * are created for all other missing properties. Use `setWith` to customize
	 * `path` creation.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns `object`.
	 * @see has, hasIn, get, unset
	 * @example
	 *
	 * const object = { 'a': [{ 'b': { 'c': 3 } }] }
	 *
	 * set(object, 'a[0].b.c', 4)
	 * console.log(object.a[0].b.c)
	 * // => 4
	 *
	 * set(object, ['x', '0', 'y', 'z'], 5)
	 * console.log(object.x[0].y.z)
	 * // => 5
	 */
	function set(object, path, value) {
	  return object == null ? object : baseSet(object, path, value)
	}


	return objects.set = set;

});
 define('skylark-langx-objects/shadow',[
	"./objects"
],function(objects) {

    function shadow(obj, prop, value) {
        Object.defineProperty(obj, prop, {
            value,
            enumerable: true,
            configurable: true,
            writable: false
        });
        return value;
    }

    return objects.shadow = shadow;
});
define('skylark-langx-objects/unset',[
	"skylark-langx-types",
	"./objects",
	"./set"
],function(types,objects,set) {

	/**
	 * Removes the property at `path` of `object`.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to unset.
	 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	 * @see get, has, set
	 * @example
	 *
	 * const object = { 'a': [{ 'b': { 'c': 7 } }] }
	 * unset(object, 'a[0].b.c')
	 * // => true
	 *
	 * console.log(object)
	 * // => { 'a': [{ 'b': {} }] }
	 *
	 * unset(object, ['a', '0', 'b', 'c'])
	 * // => true
	 *
	 * console.log(object)
	 * // => { 'a': [{ 'b': {} }] }
	 */
	function unset(object, path) {
	  return object == null ? true : set(object, path,undefined)
	}

	return objects.unset = unset;
});
define('skylark-langx-objects/values',[
    "skylark-langx-types",
    "./objects",
    "./all-keys"
],function(types,objects,allKeys){
    // Retrieve the values of an object's properties.
    function values(obj) {
        var keys = allKeys(obj);
        var length = keys.length;
        var values = Array(length);
        for (var i = 0; i < length; i++) {
            values[i] = obj[keys[i]];
        }
        return values;
    }

    return objects.values = values;
});
define('skylark-langx-objects/main',[
	"./objects",
	"./all-keys",
	"./assign",
	"./base-at",
	"./clone",
	"./defaults",
	"./each",
	"./extend",
	"./for-each",
	"./get",
	"./has",
	"./includes",
	"./is-equal",
	"./is-key",
	"./is-match",
	"./keys",
	"./mixin",
	"./omit",
	"./pick",
	"./remove-items",
	"./result",
	"./safe-mixin",
	"./scall",
	"./set",
	"./shadow",
	"./to-key",
	"./unset",
	"./values"
],function(objects){
	return objects;
});
define('skylark-langx-objects', ['skylark-langx-objects/main'], function (main) { return main; });

define('skylark-langx-funcs/delegate',[
  "skylark-langx-objects",
  "./funcs"
],function(objects,funcs){
	var mixin = objects.mixin;

    var delegate = (function() {
        // boodman/crockford delegation w/ cornford optimization
        function TMP() {}
        return function(obj, props) {
            TMP.prototype = obj;
            var tmp = new TMP();
            TMP.prototype = null;
            if (props) {
                mixin(tmp, props);
            }
            return tmp; // Object
        };
    })();

    return funcs.delegate = delegate;

});
define('skylark-langx-funcs/loop',[
	"./funcs"
],function(funcs){

	/**
	 * Animation timer is a special type of timer that uses the requestAnimationFrame method.
	 *
	 * This timer calls the method with the same rate as the screen refesh rate.
	 * 
	 * Loop time can be changed dinamically.
	 *
	 * @class AnimationTimer
	 * @param {Function} callback Timer callback function.
	 */
	function AnimationTimer(callback)
	{
		this.callback = callback;

		this.running = false;
		this.id = -1;
	}

	/**
	 * Start timer, is the timer is already running dosen't do anything.
	 * 
	 * @method start
	 */
	AnimationTimer.prototype.start = function()
	{
		if(this.running)
		{
			return;
		}

		this.running = true;

		var self = this;
		function run()
		{
			self.callback();

			if(self.running)
			{
				self.id = requestAnimationFrame(run);
			}
		}

		run();
	};

	/**
	 * Stop animation timer.
	 * 
	 * @method stop
	 */
	AnimationTimer.prototype.stop = function()
	{
		this.running = false;
		cancelAnimationFrame(this.id);
	};

	function loop(fn) {
		return new AnimationTimer(fn);
    }

    return funcs.loop = loop;
});
define('skylark-langx-funcs/negate',[
	"./funcs"
],function(funcs){
   
    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0
     * }
     *
     * filter([1, 2, 3, 4, 5, 6], negate(isEven))
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate !== 'function') {
        throw new TypeError('Expected a function')
      }
      return function(...args) {
        return !predicate.apply(this, args)
      }
    }


    return funcs.negate = negate;

});
define('skylark-langx-funcs/proxy',[
  "skylark-langx-types",
	"./funcs"
],function(types,funcs){
    var slice = Array.prototype.slice,
        isFunction = types.isFunction,
        isString = types.isString;

    function proxy(fn, context) {
        var args = (2 in arguments) && slice.call(arguments, 2)
        if (isFunction(fn)) {
            var proxyFn = function() {
                return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments);
            }
            return proxyFn;
        } else if (isString(context)) {
            if (args) {
                args.unshift(fn[context], fn)
                return proxy.apply(null, args)
            } else {
                return proxy(fn[context], fn);
            }
        } else {
            throw new TypeError("expected function");
        }
    }

    return funcs.bind = funcs.proxy = proxy;

});
define('skylark-langx-funcs/template',[
  "skylark-langx-objects",
  "./funcs",
  "./proxy"
],function(objects,funcs,proxy){
    //ref : underscore
    var slice = Array.prototype.slice;
   
    // By default, Underscore uses ERB-style template delimiters, change the
    // following template settings to use alternative delimiters.
    var templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    };

    // When customizing `templateSettings`, if you don't want to define an
    // interpolation, evaluation or escaping regex, we need one that is
    // guaranteed not to match.
    var noMatch = /(.)^/;


    // Certain characters need to be escaped so that they can be put into a
    // string literal.
    var escapes = {
      "'":      "'",
      '\\':     '\\',
      '\r':     'r',
      '\n':     'n',
      '\t':     't',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };

    var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;


    function template(text, data, settings) {
        var render;
        settings = objects.defaults({}, settings,templateSettings);

        // Combine delimiters into one regular expression via alternation.
        var matcher = RegExp([
          (settings.escape || noMatch).source,
          (settings.interpolate || noMatch).source,
          (settings.evaluate || noMatch).source
        ].join('|') + '|$', 'g');

        // Compile the template source, escaping string literals appropriately.
        var index = 0;
        var source = "__p+='";
        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
          source += text.slice(index, offset)
              .replace(escaper, function(match) { return '\\' + escapes[match]; });

          if (escape) {
            source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
          }
          if (interpolate) {
            source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
          }
          if (evaluate) {
            source += "';\n" + evaluate + "\n__p+='";
          }
          index = offset + match.length;
          return match;
        });
        source += "';\n";

        // If a variable is not specified, place data values in local scope.
        if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

        source = "var __t,__p='',__j=Array.prototype.join," +
          "print=function(){__p+=__j.call(arguments,'');};\n" +
          source + 'return __p;\n';

        try {
          render = new Function(settings.variable || 'obj', '_', source);
        } catch (e) {
          e.source = source;
          throw e;
        }

        if (data) {
          return render(data,this)
        }
        var template = proxy(function(data) {
          return render.call(this, data,this);
        },this);

        // Provide the compiled source as a convenience for precompilation.
        var argument = settings.variable || 'obj';
        template.source = 'function(' + argument + '){\n' + source + '}';

        return template;
    }

    template.templateSettings = funcs.templateSettings = templateSettings;

    return funcs.template = template;

});
define('skylark-langx-funcs/throttle',[
  "./funcs"
],function(funcs){

    const throttle = function (fn, wait) {
        let last = window.performance.now();
        const throttled = function (...args) {
            const now = window.performance.now();
            if (now - last >= wait) {
                fn(...args);
                last = now;
            }
        };
        return throttled;
    };

    /*
    function throttle(func, delay) {
        var timer = null;

        return function() {
            var context = this,
                args = arguments;

            if ( timer === null ) {
                timer = setTimeout(function() {
                    func.apply(context, args);
                    timer = null;
                }, delay);
            }
        };
    }
    */


    return funcs.throttle = throttle;
});
define('skylark-langx-funcs/main',[
	"./funcs",
	"./bind-all",
	"./debounce",
	"./defer",
	"./delegate",
	"./loop",
	"./negate",
	"./proxy",
	"./rest-arguments",
	"./template",
	"./throttle"
],function(funcs){
	return funcs;
});
define('skylark-langx-funcs', ['skylark-langx-funcs/main'], function (main) { return main; });

define('skylark-langx-arrays/flatten',[
  "skylark-langx-types",
  "./arrays"
],function(types,arrays){

    function flatten(array) {
        if (types.isArrayLike(array)) {
            var result = [];
            for (var i = 0; i < array.length; i++) {
                var item = array[i];
                if (types.isArrayLike(item)) {
                    for (var j = 0; j < item.length; j++) {
                        result.push(item[j]);
                    }
                } else {
                    result.push(item);
                }
            }
            return result;
        } else {
            return array;
        }
        //return array.length > 0 ? concat.apply([], array) : array;
    }

    return arrays.flatten = flatten;
});
define('skylark-langx-arrays/difference',[
  "skylark-langx-funcs",
  "./arrays",
  "./flatten",
  "./filter",
  "./contains"
],function(funcs,arrays,flatten,filter,contains){
   // Take the difference between one array and a number of other arrays.
    // Only the elements present in just the first array will remain.
    var difference  = funcs.restArguments(function(array, rest) {
      rest = flatten(rest, true, true);
      return filter(array, function(value){
        return !contains(rest, value);
      });
    });

    return arrays.difference = difference;
	
});
define('skylark-langx-arrays/find',[
  "./arrays"
],function(arrays){
    var _find = Array.prototype.find;

    function find(array,func) {
      return _find.call(array,func);
    }

    return arrays.find = find;
});
define('skylark-langx-arrays/first',[
  "./arrays"
],function(arrays){
    function first(items,n) {
      if (n) {
          return items.slice(0,n);
      } else {
          return items[0];
      }
    }

    return arrays.first = first;
});
define('skylark-langx-arrays/grep',[
  "skylark-langx-objects",
  "./arrays"
],function(objects,arrays){
    function grep(array, callback) {
        var out = [];

        objects.each(array, function(i, item) {
            if (callback(item, i)) {
                out.push(item);
            }
        });

        return out;
    }

    return arrays.grep = grep;
});
define('skylark-langx-arrays/indexof',[
  "./arrays"
],function(arrays){

    function indexOf(array,item) {
      return array.indexOf(item);
    }

    return arrays.indexOf = indexOf;
});
define('skylark-langx-arrays/last',[
  "./arrays"
],function(arrays){
    // Get the last element of an array. 
    function last(arr) {
        return arr[arr.length - 1];     
    }

    return arrays.last = last;
});
define('skylark-langx-arrays/make-array',[
	"skylark-langx-types",
 	"./arrays"
],function(types,arrays){
    function makeArray(obj, offset, startWith) {
       if (types.isArrayLike(obj) ) {
        return (startWith || []).concat(Array.prototype.slice.call(obj, offset || 0));
      }

      // array of single index
      return [ obj ];             
    }

	return arrays.makeArray = makeArray;	
});
define('skylark-langx-arrays/map',[
	"skylark-langx-types",
  	"./arrays",
  	"./flatten"
],function(types,arrays,flatten){
    function map(elements, callback) {
        var value, values = [],
            i, key
        if (types.isArrayLike(elements))
            for (i = 0; i < elements.length; i++) {
                value = callback.call(elements[i], elements[i], i);
                if (value != null) values.push(value)
            }
        else
            for (key in elements) {
                value = callback.call(elements[key], elements[key], key);
                if (value != null) values.push(value)
            }
        return flatten(values)
    }

    return arrays.map = map;
});
define('skylark-langx-arrays/merge',[
  "./arrays"
],function(arrays){

    function merge( first, second ) {
      var l = second.length,
          i = first.length,
          j = 0;

      if ( typeof l === "number" ) {
        for ( ; j < l; j++ ) {
          first[ i++ ] = second[ j ];
        }
      } else {
        while ( second[j] !== undefined ) {
          first[ i++ ] = second[ j++ ];
        }
      }

      first.length = i;

      return first;
    }

    return arrays.merge = merge;
	
});
define('skylark-langx-arrays/pull-at',[
  "skylark-langx-types",
  "skylark-langx-objects",
  "./arrays"
],function(types,objects,arrays){

	/**
	 * Removes elements from `array` corresponding to `indexes` and returns an
	 * array of removed elements.
	 *
	 * **Note:** Unlike `at`, this method mutates `array`.
	 *
	 * @category Array
	 * @param {Array} array The array to modify.
	 * @param {...(number|number[])} [indexes] The indexes of elements to remove.
	 * @returns {Array} Returns the new array of removed elements.
	 * @see pull, pullAll, pullAllBy, pullAllWith, remove, reject
	 * @example
	 *
	 * const array = ['a', 'b', 'c', 'd']
	 * const pulled = pullAt(array, [1, 3])
	 *
	 * console.log(array)
	 * // => ['a', 'c']
	 *
	 * console.log(pulled)
	 * // => ['b', 'd']
	 */
	function pullAt(array, ...indexes) {
	  const length = array == null ? 0 : array.length
	  const result = objects.baseAt(array, indexes)

	  indexes.sort(function(a, b) {
  		return a - b;
	  });

	  for (let i= indexes.length-1;i>=0;i--) {
	  	array.slice(indexes[i],1);
	  }

	  return result
	}

	return arrays.pullAt = pullAt;
});

define('skylark-langx-arrays/reduce',[
  "./arrays"
],function(arrays){

    function reduce(array,callback,initialValue) {
        return Array.prototype.reduce.call(array,callback,initialValue);
    }

    return arrays.reduce = reduce;	
});
define('skylark-langx-arrays/uniq',[
  "./arrays",
  "./filter"
],function(arrays,filter){

    function uniq(array) {
        return filter(array, function(item, idx) {
            return array.indexOf(item) == idx;
        })
    }
	
	return arrays.uniq = uniq;
});
define('skylark-langx-arrays/without',[
	"skylark-langx-funcs",
  "./arrays",
  "./difference"
],function(funcs,arrays,difference){

    // Return a version of the array that does not contain the specified value(s).
    var without = funcs.restArguments(function(array, otherArrays) {
      return difference(array, otherArrays);
    });

    return arrays.without = without;
});
define('skylark-langx-arrays/main',[
	"./arrays",
	"./base-find-index",
	"./base-indexof",
	"./compact",
	"./contains",
	"./difference",
	"./filter",
	"./find",
	"./first",
	"./flatten",
	"./grep",
	"./in-array",
	"./indexof",
	"./last",
	"./make-array",
	"./map",
	"./merge",
	"./pull-at",
	"./reduce",
	"./uniq",
	"./without"
],function(arrays){
	return arrays;
});
define('skylark-langx-arrays', ['skylark-langx-arrays/main'], function (main) { return main; });

define('skylark-langx/arrays',[
	"skylark-langx-arrays"
],function(arrays){
  return arrays;
});
define('skylark-langx-constructs/constructs',[
  "skylark-langx-ns"
],function(skylark){

    return skylark.attach("langx.constructs",{});
});
define('skylark-langx-constructs/inherit',[
	"./constructs"
],function(constructs){

    function inherit(ctor,base) {
        ///var f = function() {};
        ///f.prototype = base.prototype;
        ///
        ///ctor.prototype = new f();

	    if ((typeof base !== "function") && base) {
	      throw new TypeError("Super expression must either be null or a function");
	    }

	    ctor.prototype = Object.create(base && base.prototype, {
	      constructor: {
	        value: ctor,
	        writable: true,
	        configurable: true
	      }
	    });

	    if (base) {
	    	//tor.__proto__ = base;
	    	Object.setPrototypeOf(ctor, base);
	    } 
    }

    return constructs.inherit = inherit
});
define('skylark-langx-constructs/klass',[
  "skylark-langx-ns",
  "skylark-langx-types",
  "skylark-langx-objects",
  "skylark-langx-arrays",
  "./constructs",
  "./inherit"
],function(skylark,types,objects,arrays,constructs,inherit){
    var uniq = arrays.uniq,
        has = objects.has,
        mixin = objects.mixin,
        isArray = types.isArray,
        isDefined = types.isDefined;

/* for reference 
 function klass(props,parent) {
    var ctor = function(){
        this._construct();
    };
    ctor.prototype = props;
    if (parent) {
        ctor._proto_ = parent;
        props.__proto__ = parent.prototype;
    }
    return ctor;
}

// Type some JavaScript code here.
let animal = klass({
  _construct(){
      this.name = this.name + ",hi";
  },
    
  name: "Animal",
  eat() {         // [[HomeObject]] == animal
    alert(`${this.name} eats.`);
  }
    
    
});


let rabbit = klass({
  name: "Rabbit",
  _construct(){
      super._construct();
  },
  eat() {         // [[HomeObject]] == rabbit
    super.eat();
  }
},animal);

let longEar = klass({
  name: "Long Ear",
  eat() {         // [[HomeObject]] == longEar
    super.eat();
  }
},rabbit);
*/
    


    var f1 = function() {
        function extendClass(ctor, props, options) {
            // Copy the properties to the prototype of the class.
            var proto = ctor.prototype,
                _super = ctor.superclass.prototype,
                noOverrided = options && options.noOverrided,
                overrides = options && options.overrides || {};

            for (var name in props) {
                if (name === "constructor") {
                    continue;
                }

                // Check if we're overwriting an existing function
                var prop = props[name];
                if (typeof props[name] == "function") {
                    proto[name] =  !prop._constructor && !noOverrided && typeof _super[name] == "function" ?
                          (function(name, fn, superFn) {
                            return function() {
                                var tmp = this.overrided;

                                // Add a new ._super() method that is the same method
                                // but on the super-class
                                this.overrided = superFn;

                                // The method only need to be bound temporarily, so we
                                // remove it when we're done executing
                                var ret = fn.apply(this, arguments);

                                this.overrided = tmp;

                                return ret;
                            };
                        })(name, prop, _super[name]) :
                        prop;
                } else if (types.isPlainObject(prop) && prop!==null && (prop.get)) {
                    Object.defineProperty(proto,name,prop);
                } else {
                    proto[name] = prop;
                }
            }
            return ctor;
        }

        function serialMixins(ctor,mixins) {
            var result = [];

            mixins.forEach(function(mixin){
                if (has(mixin,"__mixins__")) {
                     throw new Error("nested mixins");
                }
                var clss = [];
                while (mixin) {
                    clss.unshift(mixin);
                    mixin = mixin.superclass;
                }
                result = result.concat(clss);
            });

            result = uniq(result);

            result = result.filter(function(mixin){
                var cls = ctor;
                while (cls) {
                    if (mixin === cls) {
                        return false;
                    }
                    if (has(cls,"__mixins__")) {
                        var clsMixines = cls["__mixins__"];
                        for (var i=0; i<clsMixines.length;i++) {
                            if (clsMixines[i]===mixin) {
                                return false;
                            }
                        }
                    }
                    cls = cls.superclass;
                }
                return true;
            });

            if (result.length>0) {
                return result;
            } else {
                return false;
            }
        }

        function mergeMixins(ctor,mixins) {
            var newCtor =ctor;
            for (var i=0;i<mixins.length;i++) {
                var xtor = new Function();

                inherit(xtor,newCtor)
                //xtor.prototype = Object.create(newCtor.prototype);
                //xtor.__proto__ = newCtor;
                xtor.superclass = null;
                mixin(xtor.prototype,mixins[i].prototype);
                xtor.prototype.__mixin__ = mixins[i];
                newCtor = xtor;
            }

            return newCtor;
        }

        function _constructor ()  {
            if (this._construct) {
                return this._construct.apply(this, arguments);
            } else  if (this.init) {
                return this.init.apply(this, arguments);
            }
        }

        return function createClass(props, parent, mixins,options) {
            if (isArray(parent)) {
                options = mixins;
                mixins = parent;
                parent = null;
            }
            parent = parent || Object;

            if (isDefined(mixins) && !isArray(mixins)) {
                options = mixins;
                mixins = false;
            }

            var innerParent = parent;

            if (mixins) {
                mixins = serialMixins(innerParent,mixins);
            }

            if (mixins) {
                innerParent = mergeMixins(innerParent,mixins);
            }

            var klassName = props.klassName || "",
                ctor = new Function(
                    "return function " + klassName + "() {" +
                    "var inst = this," +
                    " ctor = arguments.callee;" +
                    "if (!(inst instanceof ctor)) {" +
                    "inst = Object.create(ctor.prototype);" +
                    "}" +
                    "return ctor._constructor.apply(inst, arguments) || inst;" + 
                    "}"
                )();


            // Populate our constructed prototype object
            ///ctor.prototype = Object.create(innerParent.prototype);

            // Enforce the constructor to be what we expect
            ///ctor.prototype.constructor = ctor;
  
            // And make this class extendable
            ///ctor.__proto__ = innerParent;

            inherit(ctor,innerParent);

            ctor.superclass = parent;

            if (!ctor._constructor) {
                ctor._constructor = _constructor;
            } 

            if (mixins) {
                ctor.__mixins__ = mixins;
            }

            if (!ctor.partial) {
                ctor.partial = function(props, options) {
                    return extendClass(this, props, options);
                };
            }
            if (!ctor.inherit) {
                ctor.inherit = function(props, mixins,options) {
                    return createClass(props, this, mixins,options);
                };
            }

            ctor.partial(props, options);

            return ctor;
        };
    }

    var createClass = f1();

    return constructs.klass = createClass;
});
define('skylark-langx-constructs/main',[
	"./constructs",
	"./inherit",
	"./klass"
],function(constructs){
	return constructs;
});
define('skylark-langx-constructs', ['skylark-langx-constructs/main'], function (main) { return main; });

define('skylark-langx-klass/klass',[
  "skylark-langx-ns",
  "skylark-langx-constructs"
],function(skylark,constructs){

    return skylark.attach("langx.klass",constructs.klass);
});
define('skylark-langx-klass/main',[
	"./klass"
],function(klass){
	return klass;
});
define('skylark-langx-klass', ['skylark-langx-klass/main'], function (main) { return main; });

define('skylark-langx/klass',[
    "skylark-langx-klass"
],function(klass){
    return klass;
});
define('skylark-langx/array-store',[
    "./klass"
],function(klass){
    var SimpleQueryEngine = function(query, options){
        // summary:
        //      Simple query engine that matches using filter functions, named filter
        //      functions or objects by name-value on a query object hash
        //
        // description:
        //      The SimpleQueryEngine provides a way of getting a QueryResults through
        //      the use of a simple object hash as a filter.  The hash will be used to
        //      match properties on data objects with the corresponding value given. In
        //      other words, only exact matches will be returned.
        //
        //      This function can be used as a template for more complex query engines;
        //      for example, an engine can be created that accepts an object hash that
        //      contains filtering functions, or a string that gets evaluated, etc.
        //
        //      When creating a new dojo.store, simply set the store's queryEngine
        //      field as a reference to this function.
        //
        // query: Object
        //      An object hash with fields that may match fields of items in the store.
        //      Values in the hash will be compared by normal == operator, but regular expressions
        //      or any object that provides a test() method are also supported and can be
        //      used to match strings by more complex expressions
        //      (and then the regex's or object's test() method will be used to match values).
        //
        // options: dojo/store/api/Store.QueryOptions?
        //      An object that contains optional information such as sort, start, and count.
        //
        // returns: Function
        //      A function that caches the passed query under the field "matches".  See any
        //      of the "query" methods on dojo.stores.
        //
        // example:
        //      Define a store with a reference to this engine, and set up a query method.
        //
        //  |   var myStore = function(options){
        //  |       //  ...more properties here
        //  |       this.queryEngine = SimpleQueryEngine;
        //  |       //  define our query method
        //  |       this.query = function(query, options){
        //  |           return QueryResults(this.queryEngine(query, options)(this.data));
        //  |       };
        //  |   };

        // create our matching query function
        switch(typeof query){
            default:
                throw new Error("Can not query with a " + typeof query);
            case "object": case "undefined":
                var queryObject = query;
                query = function(object){
                    for(var key in queryObject){
                        var required = queryObject[key];
                        if(required && required.test){
                            // an object can provide a test method, which makes it work with regex
                            if(!required.test(object[key], object)){
                                return false;
                            }
                        }else if(required != object[key]){
                            return false;
                        }
                    }
                    return true;
                };
                break;
            case "string":
                // named query
                if(!this[query]){
                    throw new Error("No filter function " + query + " was found in store");
                }
                query = this[query];
                // fall through
            case "function":
                // fall through
        }
        
        function filter(arr, callback, thisObject){
            // summary:
            //      Returns a new Array with those items from arr that match the
            //      condition implemented by callback.
            // arr: Array
            //      the array to iterate over.
            // callback: Function|String
            //      a function that is invoked with three arguments (item,
            //      index, array). The return of this function is expected to
            //      be a boolean which determines whether the passed-in item
            //      will be included in the returned array.
            // thisObject: Object?
            //      may be used to scope the call to callback
            // returns: Array
            // description:
            //      This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
            //      run over sparse arrays, this implementation passes the "holes" in the sparse array to
            //      the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
            //      For more details, see:
            //      https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
            // example:
            //  | // returns [2, 3, 4]
            //  | array.filter([1, 2, 3, 4], function(item){ return item>1; });

            // TODO: do we need "Ctr" here like in map()?
            var i = 0, l = arr && arr.length || 0, out = [], value;
            if(l && typeof arr == "string") arr = arr.split("");
            if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
            if(thisObject){
                for(; i < l; ++i){
                    value = arr[i];
                    if(callback.call(thisObject, value, i, arr)){
                        out.push(value);
                    }
                }
            }else{
                for(; i < l; ++i){
                    value = arr[i];
                    if(callback(value, i, arr)){
                        out.push(value);
                    }
                }
            }
            return out; // Array
        }

        function execute(array){
            // execute the whole query, first we filter
            var results = filter(array, query);
            // next we sort
            var sortSet = options && options.sort;
            if(sortSet){
                results.sort(typeof sortSet == "function" ? sortSet : function(a, b){
                    for(var sort, i=0; sort = sortSet[i]; i++){
                        var aValue = a[sort.attribute];
                        var bValue = b[sort.attribute];
                        // valueOf enables proper comparison of dates
                        aValue = aValue != null ? aValue.valueOf() : aValue;
                        bValue = bValue != null ? bValue.valueOf() : bValue;
                        if (aValue != bValue){
                            // modified by lwf 2016/07/09
                            //return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;
                            return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;
                        }
                    }
                    return 0;
                });
            }
            // now we paginate
            if(options && (options.start || options.count)){
                var total = results.length;
                results = results.slice(options.start || 0, (options.start || 0) + (options.count || Infinity));
                results.total = total;
            }
            return results;
        }
        execute.matches = query;
        return execute;
    };

    var QueryResults = function(results){
        // summary:
        //      A function that wraps the results of a store query with additional
        //      methods.
        // description:
        //      QueryResults is a basic wrapper that allows for array-like iteration
        //      over any kind of returned data from a query.  While the simplest store
        //      will return a plain array of data, other stores may return deferreds or
        //      promises; this wrapper makes sure that *all* results can be treated
        //      the same.
        //
        //      Additional methods include `forEach`, `filter` and `map`.
        // results: Array|dojo/promise/Promise
        //      The result set as an array, or a promise for an array.
        // returns:
        //      An array-like object that can be used for iterating over.
        // example:
        //      Query a store and iterate over the results.
        //
        //  |   store.query({ prime: true }).forEach(function(item){
        //  |       //  do something
        //  |   });

        if(!results){
            return results;
        }

        var isPromise = !!results.then;
        // if it is a promise it may be frozen
        if(isPromise){
            results = Object.delegate(results);
        }
        function addIterativeMethod(method){
            // Always add the iterative methods so a QueryResults is
            // returned whether the environment is ES3 or ES5
            results[method] = function(){
                var args = arguments;
                var result = Deferred.when(results, function(results){
                    //Array.prototype.unshift.call(args, results);
                    return QueryResults(Array.prototype[method].apply(results, args));
                });
                // forEach should only return the result of when()
                // when we're wrapping a promise
                if(method !== "forEach" || isPromise){
                    return result;
                }
            };
        }

        addIterativeMethod("forEach");
        addIterativeMethod("filter");
        addIterativeMethod("map");
        if(results.total == null){
            results.total = Deferred.when(results, function(results){
                return results.length;
            });
        }
        return results; // Object
    };

    var ArrayStore = klass({
        "klassName": "ArrayStore",

        "queryEngine": SimpleQueryEngine,
        
        "idProperty": "id",


        get: function(id){
            // summary:
            //      Retrieves an object by its identity
            // id: Number
            //      The identity to use to lookup the object
            // returns: Object
            //      The object in the store that matches the given id.
            return this.data[this.index[id]];
        },

        getIdentity: function(object){
            return object[this.idProperty];
        },

        put: function(object, options){
            var data = this.data,
                index = this.index,
                idProperty = this.idProperty;
            var id = object[idProperty] = (options && "id" in options) ? options.id : idProperty in object ? object[idProperty] : Math.random();
            if(id in index){
                // object exists
                if(options && options.overwrite === false){
                    throw new Error("Object already exists");
                }
                // replace the entry in data
                data[index[id]] = object;
            }else{
                // add the new object
                index[id] = data.push(object) - 1;
            }
            return id;
        },

        add: function(object, options){
            (options = options || {}).overwrite = false;
            // call put with overwrite being false
            return this.put(object, options);
        },

        remove: function(id){
            // summary:
            //      Deletes an object by its identity
            // id: Number
            //      The identity to use to delete the object
            // returns: Boolean
            //      Returns true if an object was removed, falsy (undefined) if no object matched the id
            var index = this.index;
            var data = this.data;
            if(id in index){
                data.splice(index[id], 1);
                // now we have to reindex
                this.setData(data);
                return true;
            }
        },
        query: function(query, options){
            // summary:
            //      Queries the store for objects.
            // query: Object
            //      The query to use for retrieving objects from the store.
            // options: dojo/store/api/Store.QueryOptions?
            //      The optional arguments to apply to the resultset.
            // returns: dojo/store/api/Store.QueryResults
            //      The results of the query, extended with iterative methods.
            //
            // example:
            //      Given the following store:
            //
            //  |   var store = new Memory({
            //  |       data: [
            //  |           {id: 1, name: "one", prime: false },
            //  |           {id: 2, name: "two", even: true, prime: true},
            //  |           {id: 3, name: "three", prime: true},
            //  |           {id: 4, name: "four", even: true, prime: false},
            //  |           {id: 5, name: "five", prime: true}
            //  |       ]
            //  |   });
            //
            //  ...find all items where "prime" is true:
            //
            //  |   var results = store.query({ prime: true });
            //
            //  ...or find all items where "even" is true:
            //
            //  |   var results = store.query({ even: true });
            return QueryResults(this.queryEngine(query, options)(this.data));
        },

        setData: function(data){
            // summary:
            //      Sets the given data as the source for this store, and indexes it
            // data: Object[]
            //      An array of objects to use as the source of data.
            if(data.items){
                // just for convenience with the data format IFRS expects
                this.idProperty = data.identifier || this.idProperty;
                data = this.data = data.items;
            }else{
                this.data = data;
            }
            this.index = {};
            for(var i = 0, l = data.length; i < l; i++){
                this.index[data[i][this.idProperty]] = i;
            }
        },

        init: function(options) {
            for(var i in options){
                this[i] = options[i];
            }
            this.setData(this.data || []);
        }

    });

	return ArrayStore;
});
define('skylark-langx-aspect/aspect',[
    "skylark-langx-ns"
],function(skylark){

  var undefined, nextId = 0;
    function advise(dispatcher, type, advice, receiveArguments){
        var previous = dispatcher[type];
        var around = type == "around";
        var signal;
        if(around){
            var advised = advice(function(){
                return previous.advice(this, arguments);
            });
            signal = {
                remove: function(){
                    if(advised){
                        advised = dispatcher = advice = null;
                    }
                },
                advice: function(target, args){
                    return advised ?
                        advised.apply(target, args) :  // called the advised function
                        previous.advice(target, args); // cancelled, skip to next one
                }
            };
        }else{
            // create the remove handler
            signal = {
                remove: function(){
                    if(signal.advice){
                        var previous = signal.previous;
                        var next = signal.next;
                        if(!next && !previous){
                            delete dispatcher[type];
                        }else{
                            if(previous){
                                previous.next = next;
                            }else{
                                dispatcher[type] = next;
                            }
                            if(next){
                                next.previous = previous;
                            }
                        }

                        // remove the advice to signal that this signal has been removed
                        dispatcher = advice = signal.advice = null;
                    }
                },
                id: nextId++,
                advice: advice,
                receiveArguments: receiveArguments
            };
        }
        if(previous && !around){
            if(type == "after"){
                // add the listener to the end of the list
                // note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug
                while(previous.next && (previous = previous.next)){}
                previous.next = signal;
                signal.previous = previous;
            }else if(type == "before"){
                // add to beginning
                dispatcher[type] = signal;
                signal.next = previous;
                previous.previous = signal;
            }
        }else{
            // around or first one just replaces
            dispatcher[type] = signal;
        }
        return signal;
    }
    function aspect(type){
        return function(target, methodName, advice, receiveArguments){
            var existing = target[methodName], dispatcher;
            if(!existing || existing.target != target){
                // no dispatcher in place
                target[methodName] = dispatcher = function(){
                    var executionId = nextId;
                    // before advice
                    var args = arguments;
                    var before = dispatcher.before;
                    while(before){
                        args = before.advice.apply(this, args) || args;
                        before = before.next;
                    }
                    // around advice
                    if(dispatcher.around){
                        var results = dispatcher.around.advice(this, args);
                    }
                    // after advice
                    var after = dispatcher.after;
                    while(after && after.id < executionId){
                        if(after.receiveArguments){
                            var newResults = after.advice.apply(this, args);
                            // change the return value only if a new value was returned
                            results = newResults === undefined ? results : newResults;
                        }else{
                            results = after.advice.call(this, results, args);
                        }
                        after = after.next;
                    }
                    return results;
                };
                if(existing){
                    dispatcher.around = {advice: function(target, args){
                        return existing.apply(target, args);
                    }};
                }
                dispatcher.target = target;
            }
            var results = advise((dispatcher || existing), type, advice, receiveArguments);
            advice = null;
            return results;
        };
    }

    return skylark.attach("langx.aspect",{
        after: aspect("after"),
 
        around: aspect("around"),
        
        before: aspect("before")
    });
});
define('skylark-langx-aspect/main',[
	"./aspect"
],function(aspect){
	return aspect;
});
define('skylark-langx-aspect', ['skylark-langx-aspect/main'], function (main) { return main; });

define('skylark-langx/aspect',[
    "skylark-langx-aspect"
],function(aspect){
  return aspect;
});
define('skylark-langx-async/async',[
    "skylark-langx-ns"
],function(skylark){
	return skylark.attach("langx.async");	
});
define('skylark-langx-async/deferred',[
    "skylark-langx-arrays",
	"skylark-langx-funcs",
    "skylark-langx-objects",
    "./async"
],function(arrays,funcs,objects,async){
    "use strict";

    var slice = Array.prototype.slice,
        proxy = funcs.proxy,
        makeArray = arrays.makeArray,
        result = objects.result,
        mixin = objects.mixin;

    mixin(Promise.prototype,{
        always: function(handler) {
            //this.done(handler);
            //this.fail(handler);
            this.then(handler,handler);
            return this;
        },
        done : function() {
            for (var i = 0;i<arguments.length;i++) {
                this.then(arguments[i]);
            }
            return this;
        },
        fail : function(handler) { 
            //return mixin(Promise.prototype.catch.call(this,handler),added);
            //return this.then(null,handler);
            this.catch(handler);
            return this;
         }
    });


    var Deferred = function() {
        var self = this,
            p = this.promise = makePromise2(new Promise(function(resolve, reject) {
                self._resolve = resolve;
                self._reject = reject;
            }));

        //wrapPromise(p,self);

        //this[PGLISTENERS] = [];
        //this[PGNOTIFIES] = [];

        //this.resolve = Deferred.prototype.resolve.bind(this);
        //this.reject = Deferred.prototype.reject.bind(this);
        //this.progress = Deferred.prototype.progress.bind(this);

    };

   
    function makePromise2(promise) {
        // Don't modify any promise that has been already modified.
        if (promise.isResolved) return promise;

        // Set initial state
        var isPending = true;
        var isRejected = false;
        var isResolved = false;

        // Observe the promise, saving the fulfillment in a closure scope.
        var result = promise.then(
            function(v) {
                isResolved = true;
                isPending = false;
                return v; 
            }, 
            function(e) {
                isRejected = true;
                isPending = false;
                throw e; 
            }
        );

        result.isResolved = function() { return isResolved; };
        result.isPending = function() { return isPending; };
        result.isRejected = function() { return isRejected; };

        result.state = function() {
            if (isResolved) {
                return 'resolved';
            }
            if (isRejected) {
                return 'rejected';
            }
            return 'pending';
        };

        var notified = [],
            listeners = [];

          
        result.then = function(onResolved,onRejected,onProgress) {
            if (onProgress) {
                this.progress(onProgress);
            }
            return makePromise2(Promise.prototype.then.call(this,
                onResolved && function(args) {
                    if (args && args.__ctx__ !== undefined) {
                        return onResolved.apply(args.__ctx__,args);
                    } else {
                        return onResolved(args);
                    }
                },
                onRejected && function(args){
                    if (args && args.__ctx__ !== undefined) {
                        return onRejected.apply(args.__ctx__,args);
                    } else {
                        return onRejected(args);
                    }
                }
            ));
        };

        result.progress = function(handler) {
            notified.forEach(function (value) {
                handler(value);
            });
            listeners.push(handler);
            return this;
        };

        result.pipe = result.then;

        result.notify = function(value) {
            try {
                notified.push(value);

                return listeners.forEach(function (listener) {
                    return listener(value);
                });
            } catch (error) {
            this.reject(error);
            }
            return this;
        };

        return result;
    }

 
    Deferred.prototype.resolve = function(value) {
        var args = slice.call(arguments);
        return this.resolveWith(null,args);
    };

    Deferred.prototype.resolveWith = function(context,args) {
        args = args ? makeArray(args) : []; 
        args.__ctx__ = context;
        this._resolve(args);
        this._resolved = true;
        return this;
    };

    Deferred.prototype.notify = function(value) {
        var p = result(this,"promise");
        p.notify(value);
        return this;
    };

    Deferred.prototype.reject = function(reason) {
        var args = slice.call(arguments);
        return this.rejectWith(null,args);
    };

    Deferred.prototype.rejectWith = function(context,args) {
        args = args ? makeArray(args) : []; 
        args.__ctx__ = context;
        this._reject(args);
        this._rejected = true;
        return this;
    };

    Deferred.prototype.isResolved = function() {
        var p = result(this,"promise");
        return p.isResolved();
    };

    Deferred.prototype.isRejected = function() {
        var p = result(this,"promise");
        return p.isRejected();
    };

    Deferred.prototype.state = function() {
        var p = result(this,"promise");
        return p.state();
    };

    Deferred.prototype.then = function(callback, errback, progback) {
        var p = result(this,"promise");
        return p.then(callback, errback, progback);
    };

    Deferred.prototype.progress = function(progback){
        var p = result(this,"promise");
        return p.progress(progback);
    };
   
    Deferred.prototype.catch = function(errback) {
        var p = result(this,"promise");
        return p.catch(errback);
    };


    Deferred.prototype.always  = function() {
        var p = result(this,"promise");
        p.always.apply(p,arguments);
        return this;
    };

    Deferred.prototype.done  = function() {
        var p = result(this,"promise");
        p.done.apply(p,arguments);
        return this;
    };

    Deferred.prototype.fail = function(errback) {
        var p = result(this,"promise");
        p.fail(errback);
        return this;
    };


    Deferred.all = function(array) {
        //return wrapPromise(Promise.all(array));
        var d = new Deferred();
        Promise.all(array).then(d.resolve.bind(d),d.reject.bind(d));
        return result(d,"promise");
    };

    Deferred.first = function(array) {
        return makePromise2(Promise.race(array));
    };


    Deferred.when = function(valueOrPromise, callback, errback, progback) {
        var receivedPromise = valueOrPromise && typeof valueOrPromise.then === "function";
        var nativePromise = receivedPromise && valueOrPromise instanceof Promise;

        if (!receivedPromise) {
            if (arguments.length > 1) {
                return callback ? callback(valueOrPromise) : valueOrPromise;
            } else {
                return new Deferred().resolve(valueOrPromise);
            }
        } else if (!nativePromise) {
            var deferred = new Deferred(valueOrPromise.cancel);
            valueOrPromise.then(proxy(deferred.resolve,deferred), proxy(deferred.reject,deferred), deferred.notify);
            valueOrPromise = deferred.promise;
        }

        if (callback || errback || progback) {
            return valueOrPromise.then(callback, errback, progback);
        }
        return valueOrPromise;
    };

    Deferred.reject = function(err) {
        var d = new Deferred();
        d.reject(err);
        return d.promise;
    };

    Deferred.resolve = function(data) {
        var d = new Deferred();
        d.resolve.apply(d,arguments);
        return d.promise;
    };

    Deferred.immediate = Deferred.resolve;


    Deferred.promise = function(callback) {
        var d = new Deferred();

        callback(d.resolve.bind(d),d.reject.bind(d),d.progress.bind(d));

        return d.promise;
    };

    return async.Deferred = Deferred;
});
define('skylark-langx-async/each',[
	"./async"
],function(async){

	function each(items, next, callback) {
		if (items.length === 0) return callback(undefined, items);

		var transformed = new Array(items.length);
		var count = 0;
		var returned = false;

		items.forEach(function(item, index) {
			next(item, function(error, transformedItem) {
		    	if (returned) return;
		    	if (error) {
		      		returned = true;
		      		return callback(error);
		    	}
		    	transformed[index] = transformedItem;
		    	count += 1;
		    	if (count === items.length) {
		    		return callback(undefined, transformed);
		    	}
			});
		});
	}

	return async.each = each;

});
define('skylark-langx-async/parallel',[
    "skylark-langx-objects",
    "./async",
    "./deferred"
],function(objects,async,Deferred){
    function parallel(arr,args,ctx) {
        var rets = [];
        ctx = ctx || null;
        args = args || [];

        objects.each(arr,function(i,func){
            rets.push(func.apply(ctx,args));
        });

        return Deferred.all(rets);
    }

	return async.parallel = parallel;
});
define('skylark-langx-async/series',[
    "skylark-langx-objects",
    "./async",
    "./deferred"
],function(objects,async,Deferred){
     function series(arr,args,ctx) {
        var rets = [],
            d = new Deferred(),
            p = d.promise;

        ctx = ctx || null;
        args = args || [];

        d.resolve();
        objects.each(arr,function(i,func){
            p = p.then(function(){
                return func.apply(ctx,args);
            });
            rets.push(p);
        });

        return Deferred.all(rets);
    }

	return async.series = series;
});
define('skylark-langx-async/waterful',[
    "skylark-langx-objects",
    "./async",
    "./deferred"
],function(objects,async,Deferred){
    function waterful(arr,args,ctx) {
        var d = new Deferred(),
            p = d.promise;

        ctx = ctx || null;
        args = args || [];

        d.resolveWith(ctx,args);

        objects.each(arr,function(i,func){
            p = p.then(func);
        });
        return p;
    }

	return async.waterful = waterful;
});
define('skylark-langx-async/main',[
	"./async",
	"./deferred",
	"./each",
	"./parallel",
	"./series",
	"./waterful"
],function(async){
	return async;
});
define('skylark-langx-async', ['skylark-langx-async/main'], function (main) { return main; });

define('skylark-langx/async',[
    "skylark-langx-async"
],function(async){
    return async;
});
define('skylark-langx-binary/binary',[
  "skylark-langx-ns",
],function(skylark){
	"use strict";


	/**
	 * Create arraybuffer from binary string
	 *
	 * @method fromBinaryString
	 * @param {String} str
	 * @return {Arraybuffer} data
	 */
	function fromBinaryString(str) {
		var length = str.length;
		var arraybuffer = new ArrayBuffer(length);
		var view = new Uint8Array(arraybuffer);

		for(var i = 0; i < length; i++)
		{
			view[i] = str.charCodeAt(i);
		}

		return arraybuffer;
	}

	/**
	 * Create arraybuffer from base64 string
	 *
	 * @method fromBase64
	 * @param {String} base64
	 * @return {Arraybuffer} data
	 */
	function fromBase64(str){
		var encoding = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		var length = str.length / 4 * 3;
		var arraybuffer = new ArrayBuffer(length);
		var view = new Uint8Array(arraybuffer);

		var a, b, c, d;

		for(var i = 0, j = 0; i < length; i += 3)
		{
			a = encoding.indexOf(str.charAt(j++));
			b = encoding.indexOf(str.charAt(j++));
			c = encoding.indexOf(str.charAt(j++));
			d = encoding.indexOf(str.charAt(j++));

			view[i] = (a << 2) | (b >> 4);
			if(c !== 64)
			{
				view[i+1] = ((b & 15) << 4) | (c >> 2);
			}
			if(d !== 64)
			{
				view[i+2] = ((c & 3) << 6) | d;
			}
		}

		return arraybuffer;
	}

	/**
	 * Create arraybuffer from Nodejs buffer
	 *
	 * @method fromBuffer
	 * @param {Buffer} buffer
	 * @return {Arraybuffer} data
	 */
	function fromBuffer(buffer)	{
		var array = new ArrayBuffer(buffer.length);
		var view = new Uint8Array(array);

		for(var i = 0; i < buffer.length; i++)
		{
			view[i] = buffer[i];
		}

		return array;

		//Faster but the results is failing the "instanceof ArrayBuffer" test
		//return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
	}

    function readInt8(data, offset) {
        return data[offset] << 24 >> 24;
    }
    function readUint16(data, offset) {
        return data[offset] << 8 | data[offset + 1];
    }
    function readUint32(data, offset) {
        return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
    }


	return skylark.attach("langx.binary",{
		fromBase64,
		fromBinaryString,
		fromBuffer,
		readInt8,
		readUint16,
		readUint32
	});
});
define('skylark-langx-binary/main',[
	"./binary"
],function(binary){
	return binary;
});
define('skylark-langx-binary', ['skylark-langx-binary/main'], function (main) { return main; });

define('skylark-langx/binary',[
	"skylark-langx-binary"
],function(binary){
  return binary;
});
define('skylark-langx/constructs',[
	"skylark-langx-constructs"
],function(constructs){
  return constructs;
});
define('skylark-langx-datetimes/datetimes',[
    "skylark-langx-ns"
],function(skylark){
     function parseMilliSeconds(str) {

        var strs = str.split(' ');
        var number = parseInt(strs[0]);

        if (isNaN(number)){
            return 0;
        }

        var min = 60000 * 60;

        switch (strs[1].trim().replace(/\./g, '')) {
            case 'minutes':
            case 'minute':
            case 'min':
            case 'mm':
            case 'm':
                return 60000 * number;
            case 'hours':
            case 'hour':
            case 'HH':
            case 'hh':
            case 'h':
            case 'H':
                return min * number;
            case 'seconds':
            case 'second':
            case 'sec':
            case 'ss':
            case 's':
                return 1000 * number;
            case 'days':
            case 'day':
            case 'DD':
            case 'dd':
            case 'd':
                return (min * 24) * number;
            case 'months':
            case 'month':
            case 'MM':
            case 'M':
                return (min * 24 * 28) * number;
            case 'weeks':
            case 'week':
            case 'W':
            case 'w':
                return (min * 24 * 7) * number;
            case 'years':
            case 'year':
            case 'yyyy':
            case 'yy':
            case 'y':
                return (min * 24 * 365) * number;
            default:
                return 0;
        }
    };
	
	return skylark.attach("langx.datetimes",{
		parseMilliSeconds
	});
});
define('skylark-langx-datetimes/to_date',[
	"skylark-langx-types",
    "./datetimes"
],function(types,datetimes){

//original :pdf.js-2.7.750/src/display/display_utils.js

  /**
class PDFDateString {
   * Convert a PDF date string to a JavaScript `Date` object.
   *
   * The PDF date string format is described in section 7.9.4 of the official
   * PDF 32000-1:2008 specification. However, in the PDF 1.7 reference (sixth
   * edition) Adobe describes the same format including a trailing apostrophe.
   * This syntax in incorrect, but Adobe Acrobat creates PDF files that contain
   * them. We ignore all apostrophes as they are not necessary for date parsing.
   *
   * Moreover, Adobe Acrobat doesn't handle changing the date to universal time
   * and doesn't use the user's time zone (effectively ignoring the HH' and mm'
   * parts of the date string).
   *
   * @param {string} input
   * @returns {Date|null}
   *
  static toDateObject(input) {
   **/


	let pdfDateStringRegex;

	function toDate(input) {
    if (!input || !types.isString(input)) {
      return null;
    }

    // Lazily initialize the regular expression.
    if (!pdfDateStringRegex) {
      pdfDateStringRegex = new RegExp(
        "^D:" + // Prefix (required)
          "(\\d{4})" + // Year (required)
          "(\\d{2})?" + // Month (optional)
          "(\\d{2})?" + // Day (optional)
          "(\\d{2})?" + // Hour (optional)
          "(\\d{2})?" + // Minute (optional)
          "(\\d{2})?" + // Second (optional)
          "([Z|+|-])?" + // Universal time relation (optional)
          "(\\d{2})?" + // Offset hour (optional)
          "'?" + // Splitting apostrophe (optional)
          "(\\d{2})?" + // Offset minute (optional)
          "'?" // Trailing apostrophe (optional)
      );
    }

    // Optional fields that don't satisfy the requirements from the regular
    // expression (such as incorrect digit counts or numbers that are out of
    // range) will fall back the defaults from the specification.
    const matches = pdfDateStringRegex.exec(input);
    if (!matches) {
      return null;
    }

    // JavaScript's `Date` object expects the month to be between 0 and 11
    // instead of 1 and 12, so we have to correct for that.
    const year = parseInt(matches[1], 10);
    let month = parseInt(matches[2], 10);
    month = month >= 1 && month <= 12 ? month - 1 : 0;
    let day = parseInt(matches[3], 10);
    day = day >= 1 && day <= 31 ? day : 1;
    let hour = parseInt(matches[4], 10);
    hour = hour >= 0 && hour <= 23 ? hour : 0;
    let minute = parseInt(matches[5], 10);
    minute = minute >= 0 && minute <= 59 ? minute : 0;
    let second = parseInt(matches[6], 10);
    second = second >= 0 && second <= 59 ? second : 0;
    const universalTimeRelation = matches[7] || "Z";
    let offsetHour = parseInt(matches[8], 10);
    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
    let offsetMinute = parseInt(matches[9], 10) || 0;
    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;

    // Universal time relation 'Z' means that the local time is equal to the
    // universal time, whereas the relations '+'/'-' indicate that the local
    // time is later respectively earlier than the universal time. Every date
    // is normalized to universal time.
    if (universalTimeRelation === "-") {
      hour += offsetHour;
      minute += offsetMinute;
    } else if (universalTimeRelation === "+") {
      hour -= offsetHour;
      minute -= offsetMinute;
    }

    return new Date(Date.UTC(year, month, day, hour, minute, second));
  }

  return datetimes.toDate = toDate;

});
define('skylark-langx-datetimes/main',[
	"./datetimes",
	"./to_date"
],function(datetimes){
	return datetimes;
});
define('skylark-langx-datetimes', ['skylark-langx-datetimes/main'], function (main) { return main; });

define('skylark-langx/datetimes',[
    "skylark-langx-datetimes"
],function(datetimes){
    return datetimes;
});
define('skylark-langx/deferred',[
    "skylark-langx-async"
],function(async){
    return async.Deferred;
});
define('skylark-langx-events/events',[
	"skylark-langx-ns"
],function(skylark){
	return skylark.attach("langx.events",{});
});
define('skylark-langx-hoster/hoster',[
    "skylark-langx-ns"
],function(skylark){
	// The javascript host environment, brower and nodejs are supported.
	var hoster = {
		"isBrowser" : true, // default
		"isNode" : null,
		"global" : this,
		"browser" : null,
		"node" : null
	};

	if (typeof process == "object" && process.versions && process.versions.node && process.versions.v8) {
		hoster.isNode = true;
		hoster.isBrowser = false;
	}

	hoster.global = (function(){
		if (typeof global !== 'undefined' && typeof global !== 'function') {
			// global spec defines a reference to the global object called 'global'
			// https://github.com/tc39/proposal-global
			// `global` is also defined in NodeJS
			return global;
		} else if (typeof window !== 'undefined') {
			// window is defined in browsers
			return window;
		}
		else if (typeof self !== 'undefined') {
			// self is defined in WebWorkers
			return self;
		}
		return this;
	})();

	var _document = null;

	Object.defineProperty(hoster,"document",function(){
		if (!_document) {
			var w = typeof window === 'undefined' ? require('html-element') : window;
			_document = w.document;
		}

		return _document;
	});

	if (hoster.global.CustomEvent === undefined) {
		hoster.global.CustomEvent = function(type,props) {
			this.type = type;
			this.props = props;
		};
	}

	if (hoster.isBrowser) {
	    function uaMatch( ua ) {
		    ua = ua.toLowerCase();

			//IE11OrLess = !!navigator.userAgent.match(/(?:Trident.*rv[ :]?11\.|msie|iemobile)/i),
			//Edge = !!navigator.userAgent.match(/Edge/i),
			//FireFox = !!navigator.userAgent.match(/firefox/i),
			//Safari = !!(navigator.userAgent.match(/safari/i) && !navigator.userAgent.match(/chrome/i) && !navigator.userAgent.match(/android/i)),
			//IOS = !!(navigator.userAgent.match(/iP(ad|od|hone)/i)),

		    var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
		      /(webkit)[ \/]([\w.]+)/.exec( ua ) ||
		      /(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
		      /(msie) ([\w.]+)/.exec( ua ) ||
		      ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
		      [];

		    return {
		      browser: match[ 1 ] || '',
		      version: match[ 2 ] || '0'
		    };
	  	};

	    var matched = uaMatch( navigator.userAgent );

	    var browser = hoster.browser = {};

	    if ( matched.browser ) {
	      browser[ matched.browser ] = true;
	      browser.version = matched.version;
	    }

	    // Chrome is Webkit, but Webkit is also Safari.
	    if ( browser.chrome ) {
	      browser.webkit = true;
	    } else if ( browser.webkit ) {
	      browser.safari = true;
	    }
	}

	hoster.detects = {};

	return  skylark.attach("langx.hoster",hoster);
});
define('skylark-langx-hoster/detects/mobile',[
    "../hoster"
],function(hoster){
    //refer : https://github.com/kaimallea/isMobile

    var appleIphone = /iPhone/i;
    var appleIpod = /iPod/i;
    var appleTablet = /iPad/i;
    var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
    var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
    var androidTablet = /Android/i;
    var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
    var amazonTablet = /Silk/i;
    var windowsPhone = /Windows Phone/i;
    var windowsTablet = /\bWindows(?:.+)ARM\b/i;
    var otherBlackBerry = /BlackBerry/i;
    var otherBlackBerry10 = /BB10/i;
    var otherOpera = /Opera Mini/i;
    var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
    var otherFirefox = /Mobile(?:.+)Firefox\b/i;
    var isAppleTabletOnIos13 = function (navigator) {
        return (typeof navigator !== 'undefined' &&
            navigator.platform === 'MacIntel' &&
            typeof navigator.maxTouchPoints === 'number' &&
            navigator.maxTouchPoints > 1 &&
            typeof MSStream === 'undefined');
    };
    function createMatch(userAgent) {
        return function (regex) { return regex.test(userAgent); };
    }
    
    function detectMobile(param) {
        var nav = {
            userAgent: '',
            platform: '',
            maxTouchPoints: 0
        };
        if (!param && typeof navigator !== 'undefined') {
            nav = {
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                maxTouchPoints: navigator.maxTouchPoints || 0
            };
        }
        else if (typeof param === 'string') {
            nav.userAgent = param;
        }
        else if (param && param.userAgent) {
            nav = {
                userAgent: param.userAgent,
                platform: param.platform,
                maxTouchPoints: param.maxTouchPoints || 0
            };
        }
        var userAgent = nav.userAgent;
        var tmp = userAgent.split('[FBAN');
        if (typeof tmp[1] !== 'undefined') {
            userAgent = tmp[0];
        }
        tmp = userAgent.split('Twitter');
        if (typeof tmp[1] !== 'undefined') {
            userAgent = tmp[0];
        }
        var match = createMatch(userAgent);
        var result = {
            apple: {
                phone: match(appleIphone) && !match(windowsPhone),
                ipod: match(appleIpod),
                tablet: !match(appleIphone) &&
                    (match(appleTablet) || isAppleTabletOnIos13(nav)) &&
                    !match(windowsPhone),
                universal: match(appleUniversal),
                device: (match(appleIphone) ||
                    match(appleIpod) ||
                    match(appleTablet) ||
                    match(appleUniversal) ||
                    isAppleTabletOnIos13(nav)) &&
                    !match(windowsPhone)
            },
            amazon: {
                phone: match(amazonPhone),
                tablet: !match(amazonPhone) && match(amazonTablet),
                device: match(amazonPhone) || match(amazonTablet)
            },
            android: {
                phone: (!match(windowsPhone) && match(amazonPhone)) ||
                    (!match(windowsPhone) && match(androidPhone)),
                tablet: !match(windowsPhone) &&
                    !match(amazonPhone) &&
                    !match(androidPhone) &&
                    (match(amazonTablet) || match(androidTablet)),
                device: (!match(windowsPhone) &&
                    (match(amazonPhone) ||
                        match(amazonTablet) ||
                        match(androidPhone) ||
                        match(androidTablet))) ||
                    match(/\bokhttp\b/i)
            },
            windows: {
                phone: match(windowsPhone),
                tablet: match(windowsTablet),
                device: match(windowsPhone) || match(windowsTablet)
            },
            other: {
                blackberry: match(otherBlackBerry),
                blackberry10: match(otherBlackBerry10),
                opera: match(otherOpera),
                firefox: match(otherFirefox),
                chrome: match(otherChrome),
                device: match(otherBlackBerry) ||
                    match(otherBlackBerry10) ||
                    match(otherOpera) ||
                    match(otherFirefox) ||
                    match(otherChrome)
            },
            any: false,
            phone: false,
            tablet: false
        };
        result.any =
            result.apple.device ||
                result.android.device ||
                result.windows.device ||
                result.other.device;
        result.phone =
            result.apple.phone || result.android.phone || result.windows.phone;
        result.tablet =
            result.apple.tablet || result.android.tablet || result.windows.tablet;
        return result;
    }

    return hoster.detects.mobile = detectMobile;
});

define('skylark-langx-hoster/is-mobile',[
    "./hoster",
    "./detects/mobile"
],function(hoster,detectMobile){
    if (hoster.isMobile == undefined) {
        hoster.isMobile = detectMobile();
    }

    return hoster.isMobile;
});

define('skylark-langx-hoster/main',[
	"./hoster",
	"./is-mobile"
],function(hoster){
	return hoster;
});
define('skylark-langx-hoster', ['skylark-langx-hoster/main'], function (main) { return main; });

define('skylark-langx-events/event',[
  "skylark-langx-objects",
  "skylark-langx-funcs",
  "skylark-langx-klass",
  "skylark-langx-hoster",
    "./events"
],function(objects,funcs,klass,events){
    var eventMethods = {
        preventDefault: "isDefaultPrevented",
        stopImmediatePropagation: "isImmediatePropagationStopped",
        stopPropagation: "isPropagationStopped"
     };
        

    function compatible(event, source) {
        if (source || !event.isDefaultPrevented) {
            if (!source) {
                source = event;
            }

            objects.each(eventMethods, function(name, predicate) {
                var sourceMethod = source[name];
                event[name] = function() {
                    this[predicate] = funcs.returnTrue;
                    return sourceMethod && sourceMethod.apply(source, arguments);
                }
                event[predicate] = funcs.returnFalse;
            });
        }
        return event;
    }


    /*
    var Event = klass({
        _construct : function(type,props) {
            CustomEvent.call(this,type.props);
            objects.safeMixin(this, props);
            compatible(this);
        }
    },CustomEvent);
    */

    class Event extends CustomEvent {
        constructor(type,props) {
            super(type,props);
            objects.safeMixin(this, props);
            compatible(this);
        } 
    }


    Event.compatible = compatible;

    return events.Event = Event;
    
});
define('skylark-langx-events/listener',[
  "skylark-langx-types",
  "skylark-langx-objects",
  "skylark-langx-arrays",
  "skylark-langx-klass",
  "./events",
  "./event"
],function(types,objects,arrays,klass,events,Event){
    var slice = Array.prototype.slice,
        compact = arrays.compact,
        isDefined = types.isDefined,
        isUndefined = types.isUndefined,
        isPlainObject = types.isPlainObject,
        isFunction = types.isFunction,
        isBoolean = types.isBoolean,
        isString = types.isString,
        isEmptyObject = types.isEmptyObject,
        mixin = objects.mixin,
        safeMixin = objects.safeMixin;


    var Listener = klass({

        listenTo: function(obj, event, selector,callback, /*used internally*/ one) {
            if (!obj) {
                return this;
            }

            if (types.isPlainObject(event)){
                //listenTo(obj,callbacks,one)
                if (types.isBoolean(selector)) {
                    one = selector;
                    selector = null;
                } else if (types.isBoolean(callback)) {
                    one = callback;
                }
                var callbacks = event;
                for (var name in callbacks) {

                    var match = name.match( /^([\w:-]*)\s*(.*)$/ );
                    var name1 = match[ 1 ];
                    var selector1 = match[ 2 ] || selector;

                    if (selector1) {
                        this.listenTo(obj,name1,selector1,callbacks[name],one);
                    } else {
                        this.listenTo(obj,name1,callbacks[name],one);
                    }

                }
                return this;
            }

            if (isBoolean(callback)) {
                one = callback;
                callback = selector;
                selector = null;
            } else if (isBoolean(selector)) {
                one = selector;
                callback = selector = null;
            } else if (isUndefined(callback)){
                one = false;
                callback = selector;
                selector = null;
            }



            if (!callback) {
                callback = "handleEvent";
            }
            
            // Bind callbacks on obj,
            if (isString(callback)) {
                callback = this[callback];
            }

            if (one) {
                if (selector) {
                    obj.one(event, selector,callback, this);
                } else {
                    obj.one(event, callback, this);
                }
            } else {
                 if (selector) {
                    obj.on(event, selector, callback, this);
                } else {
                    obj.on(event, callback, this);
                }
            }

            //keep track of them on listening.
            var listeningTo = this._listeningTo || (this._listeningTo = []),
                listening;

            for (var i = 0; i < listeningTo.length; i++) {
                if (listeningTo[i].obj == obj) {
                    listening = listeningTo[i];
                    break;
                }
            }
            if (!listening) {
                listeningTo.push(
                    listening = {
                        obj: obj,
                        events: {}
                    }
                );
            }
            var listeningEvents = listening.events,
                listeningEvent = listeningEvents[event] = listeningEvents[event] || [];
            if (listeningEvent.indexOf(callback) == -1) {
                listeningEvent.push(callback);
            }

            return this;
        },

        listenToOnce: function(obj, event,selector, callback) {
            return this.listenTo(obj, event,selector, callback, 1);
        },

        unlistenTo: function(obj, event, callback) {
            var listeningTo = this._listeningTo;
            if (!listeningTo) {
                return this;
            }

            if (isString(callback)) {
                callback = this[callback];
            }

            for (var i = 0; i < listeningTo.length; i++) {
                var listening = listeningTo[i];

                if (obj && obj != listening.obj) {
                    continue;
                }

                var listeningEvents = listening.events;

                for (var eventName in listeningEvents) {
                    if (event && event != eventName) {
                        continue;
                    }

                    var listeningEvent = listeningEvents[eventName];

                    if (!listeningEvent) { 
                        continue;
                    }

                    for (var j = 0; j < listeningEvent.length; j++) {
                        if (!callback || callback == listeningEvent[i]) {
                            listening.obj.off(eventName, listeningEvent[i], this);
                            listeningEvent[i] = null;
                        }
                    }

                    listeningEvent = listeningEvents[eventName] = compact(listeningEvent);

                    if (isEmptyObject(listeningEvent)) {
                        listeningEvents[eventName] = null;
                    }

                }

                if (isEmptyObject(listeningEvents)) {
                    listeningTo[i] = null;
                }
            }

            listeningTo = this._listeningTo = compact(listeningTo);
            if (isEmptyObject(listeningTo)) {
                this._listeningTo = null;
            }

            return this;
        }
    });

    return events.Listener = Listener;

});
define('skylark-langx-events/emitter',[
  "skylark-langx-types",
  "skylark-langx-objects",
  "skylark-langx-arrays",
  "skylark-langx-klass",
  "./events",
  "./event",
  "./listener"
],function(types,objects,arrays,klass,events,Event,Listener){
    var slice = Array.prototype.slice,
        compact = arrays.compact,
        isDefined = types.isDefined,
        isPlainObject = types.isPlainObject,
        isFunction = types.isFunction,
        isString = types.isString,
        isEmptyObject = types.isEmptyObject,
        mixin = objects.mixin,
        safeMixin = objects.safeMixin;

    function parse(event) {
        var segs = ("" + event).split(".");
        return {
            name: segs[0],
            ns: segs.slice(1).join(" ")
        };
    }

    
    var queues  = new Map();


    var Emitter = Listener.inherit({
        _prepareArgs : function(e,args) {
            if (isDefined(args)) {
                args = [e].concat(args);
            } else {
                args = [e];
            }
            return args;
        },

        on: function(events, selector, data, callback, ctx, /*used internally*/ one) {
            var self = this,
                _hub = this._hub || (this._hub = {});

            if (isPlainObject(events)) {
                ctx = callback;
                each(events, function(type, fn) {
                    self.on(type, selector, data, fn, ctx, one);
                });
                return this;
            }

            if (!isString(selector) && !isFunction(callback)) {
                ctx = callback;
                callback = data;
                data = selector;
                selector = undefined;
            }

            if (isFunction(data)) {
                ctx = callback;
                callback = data;
                data = null;
            }

            if (!callback ) {
                throw new Error("No callback function");
            } else if (!isFunction(callback)) {
                throw new Error("The callback  is not afunction");
            }

            if (isString(events)) {
                events = events.split(/\s/)
            }

            events.forEach(function(event) {
                var parsed = parse(event),
                    name = parsed.name,
                    ns = parsed.ns;

                (_hub[name] || (_hub[name] = [])).push({
                    fn: callback,
                    selector: selector,
                    data: data,
                    ctx: ctx,
                    ns : ns,
                    one: one
                });
            });

            return this;
        },

        one: function(events, selector, data, callback, ctx) {
            return this.on(events, selector, data, callback, ctx, 1);
        },

        emit: function(e /*,argument list*/ ) {
            if (!this._hub) {
                return this;
            }

            var self = this;

            if (isString(e)) {
                e = new Event(e); //new CustomEvent(e);
            }

            Object.defineProperty(e,"target",{
                value : this
            });

            var args = slice.call(arguments, 1);

            args = this._prepareArgs(e,args);

            [e.type || e.name, "all"].forEach(function(eventName) {
                var parsed = parse(eventName),
                    name = parsed.name,
                    ns = parsed.ns;

                var listeners = self._hub[name];
                if (!listeners) {
                    return;
                }

                var len = listeners.length,
                    reCompact = false;

                for (var i = 0; i < len; i++) {
                    if (e.isImmediatePropagationStopped && e.isImmediatePropagationStopped()) {
                        return this;
                    }
                    var listener = listeners[i];
                    if (ns && (!listener.ns ||  !listener.ns.startsWith(ns))) {
                        continue;
                    }

                    if (listener.data) {
                        e.data = mixin({}, listener.data, e.data);
                    }
                    if (args.length == 2 && isPlainObject(args[1])) {
                        e.data = e.data || {};
                        mixin(e.data,args[1]);
                    }

                    listener.fn.apply(listener.ctx, args);
                    if (listener.one) {
                        listeners[i] = null;
                        reCompact = true;
                    }
                }

                if (reCompact) {
                    self._hub[eventName] = compact(listeners);
                }

            });
            return this;
        },

        queueEmit : function (event) {
            const type = event.type || event;
            let map = queues.get(this);
            if (!map) {
                map = new Map();
                queues.set(this, map);
            }
            const oldTimeout = map.get(type);
            map.delete(type);
            window.clearTimeout(oldTimeout);
            const timeout = window.setTimeout(() => {
                if (map.size === 0) {
                    map = null;
                    queues.delete(this);
                }
                this.trigger(event);
            }, 0);
            map.set(type, timeout);
        },

        listened: function(event) {
            var evtArr = ((this._hub || (this._events = {}))[event] || []);
            return evtArr.length > 0;
        },

        off: function(events, callback) {
            if (!events) {
              this._hub = null;
              return;
            }
            var _hub = this._hub || (this._hub = {});
            if (isString(events)) {
                events = events.split(/\s/)
            }

            events.forEach(function(event) {
                var parsed = parse(event),
                    name = parsed.name,
                    ns = parsed.ns;

                var evts = _hub[name];

                if (evts) {
                    var liveEvents = [];

                    if (callback || ns) {
                        for (var i = 0, len = evts.length; i < len; i++) {
                            
                            if (callback && evts[i].fn !== callback && evts[i].fn._ !== callback) {
                                liveEvents.push(evts[i]);
                                continue;
                            } 

                            if (ns && (!evts[i].ns || evts[i].ns.indexOf(ns)!=0)) {
                                liveEvents.push(evts[i]);
                                continue;
                            }
                        }
                    }

                    if (liveEvents.length) {
                        _hub[name] = liveEvents;
                    } else {
                        delete _hub[name];
                    }

                }
            });

            return this;
        },

        trigger  : function() {
            return this.emit.apply(this,arguments);
        },

        queueTrigger : function (event) {
            return this.queueEmit.apply(this,arguments);
        }

    });


    return events.Emitter = Emitter;

});
define('skylark-langx-events/create-event',[
	"./events",
	"./event"
],function(events,Event){
    function createEvent(type,props) {
        //var e = new CustomEvent(type,props);
        //return safeMixin(e, props);
        return new Event(type,props);
    };

    return events.createEvent = createEvent;	
});
define('skylark-langx-events/main',[
	"./events",
	"./event",
	"./listener",
	"./emitter",
	"./create-event"
],function(events){
	return events;
});
define('skylark-langx-events', ['skylark-langx-events/main'], function (main) { return main; });

define('skylark-langx/emitter',[
    "skylark-langx-events"
],function(events){
    return events.Emitter;
});
define('skylark-langx/evented',[
    "./emitter"
],function(Emitter){
    return Emitter;
});
define('skylark-langx/events',[
	"skylark-langx-events"
],function(events){
	return events;
});
define('skylark-langx/funcs',[
    "skylark-langx-funcs"
],function(funcs){
    return funcs;
});
define('skylark-langx-globals/globals',[
	"skylark-langx-ns"
],function(ns) {
	var globals = (function(){
		if (typeof global !== 'undefined' && typeof global !== 'function') {
			// global spec defines a reference to the global object called 'global'
			// https://github.com/tc39/proposal-global
			// `global` is also defined in NodeJS
			return global;
		} else if (typeof window !== 'undefined') {
			// window is defined in browsers
			return window;
		}
		else if (typeof self !== 'undefined') {
			// self is defined in WebWorkers
			return self;
		}
		return this;
	})();

	return ns.attach("langx.globals",globals);

});
define('skylark-langx-globals/console',[
	"./globals"
], function(globals) {
	return globals.console = console;
});
define('skylark-langx-globals/document',[
	"./globals"
], function(globals) {
	var topLevel = typeof global !== 'undefined' ? global :
	    typeof window !== 'undefined' ? window : {};

	var doccy;

	if (typeof document !== 'undefined') {
	    doccy = document;
	} else {
        try {
            doccy  = require('min-document');
        } catch(e) {
            console.warn("min-document is not finded!",e);
        }
   	}


	return globals.document = doccy;
});




define('skylark-langx-globals/window',[
	"./globals"
], function(globals) {

	var win = (function() {
		if (typeof window !== "undefined") {
		    return window;
		} else {
		    return {};
		}
	})();

	return globals.window = win;
});

define('skylark-langx-globals/main',[
	"./globals",
	"./console",
	"./document",
	"./window"
],function(globals){

	return globals;
});
define('skylark-langx-globals', ['skylark-langx-globals/main'], function (main) { return main; });

define('skylark-langx/globals',[
    "skylark-langx-globals"
],function(globals){
    return globals;
});
define('skylark-langx/hoster',[
	"skylark-langx-hoster"
],function(hoster){
	return hoster;
});
define('skylark-langx-maths/maths',[
    "skylark-langx-ns",
    "skylark-langx-types"
],function(skylark,types){


	var _lut = [];

	for ( var i = 0; i < 256; i ++ ) {

		_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

	}

	var maths = {

		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,



		clamp: function ( value, min, max ) {

			return Math.max( min, Math.min( max, value ) );

		},

		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation

		euclideanModulo: function ( n, m ) {

			return ( ( n % m ) + m ) % m;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function ( x, a1, a2, b1, b2 ) {

			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

		},

		// https://en.wikipedia.org/wiki/Linear_interpolation

		lerp: function ( x, y, t ) {

			return ( 1 - t ) * x + t * y;

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * ( 3 - 2 * x );

		},

		smootherstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

		},

		// Random integer from <low, high> interval

		randInt: function ( low, high ) {

			return low + Math.floor( Math.random() * ( high - low + 1 ) );

		},

		// Random float from <low, high> interval

		randFloat: function ( low, high ) {

			return low + Math.random() * ( high - low );

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function ( range ) {

			return range * ( 0.5 - Math.random() );

		},

		degToRad: function ( degrees ) {

			return degrees * maths.DEG2RAD;

		},

		radToDeg: function ( radians ) {

			return radians * maths.RAD2DEG;

		},

		isPowerOfTwo: function ( value ) {

			return ( value & ( value - 1 ) ) === 0 && value !== 0;

		},

		ceilPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

		},

		floorPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

		},

		setQuaternionFromProperEuler: function ( q, a, b, c, order ) {

			// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

			// rotations are applied to the axes in the order specified by 'order'
			// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
			// angles are in radians

			var cos = Math.cos;
			var sin = Math.sin;

			var c2 = cos( b / 2 );
			var s2 = sin( b / 2 );

			var c13 = cos( ( a + c ) / 2 );
			var s13 = sin( ( a + c ) / 2 );

			var c1_3 = cos( ( a - c ) / 2 );
			var s1_3 = sin( ( a - c ) / 2 );

			var c3_1 = cos( ( c - a ) / 2 );
			var s3_1 = sin( ( c - a ) / 2 );

			if ( order === 'XYX' ) {

				q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );

			} else if ( order === 'YZY' ) {

				q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );

			} else if ( order === 'ZXZ' ) {

				q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );

			} else if ( order === 'XZX' ) {

				q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );

			} else if ( order === 'YXY' ) {

				q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );

			} else if ( order === 'ZYZ' ) {

				q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );

			} else {

				console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.' );

			}

		}

	};



	return  skylark.attach("langx.maths",maths);
});
define('skylark-langx-maths/main',[
	"./maths"
],function(maths){
	return maths;
});
define('skylark-langx-maths', ['skylark-langx-maths/main'], function (main) { return main; });

define('skylark-langx/maths',[
    "skylark-langx-maths"
],function(maths){
    return maths;
});
define('skylark-langx-numerics/numerics',[
    "skylark-langx-ns",
    "skylark-langx-types"
],function(skylark,types){

	return  skylark.attach("langx.numerics",{
		toFinite : types.toFinite,
		toNumber : types.toNumber,
		toInteger : types.toInteger
	});
});
define('skylark-langx-numerics/maths',[
    "skylark-langx-ns",
    "skylark-langx-types",
    "./numerics"
],function(skylark,types,numerics){


	var _lut = [];

	for ( var i = 0; i < 256; i ++ ) {

		_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

	}

	var maths = {

		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,



		clamp: function ( value, min, max ) {

			return Math.max( min, Math.min( max, value ) );

		},

		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation

		euclideanModulo: function ( n, m ) {

			return ( ( n % m ) + m ) % m;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function ( x, a1, a2, b1, b2 ) {

			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

		},

		// https://en.wikipedia.org/wiki/Linear_interpolation

		lerp: function ( x, y, t ) {

			return ( 1 - t ) * x + t * y;

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * ( 3 - 2 * x );

		},

		smootherstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

		},

		// Random integer from <low, high> interval

		randInt: function ( low, high ) {

			return low + Math.floor( Math.random() * ( high - low + 1 ) );

		},

		// Random float from <low, high> interval

		randFloat: function ( low, high ) {

			return low + Math.random() * ( high - low );

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function ( range ) {

			return range * ( 0.5 - Math.random() );

		},

		degToRad: function ( degrees ) {

			return degrees * maths.DEG2RAD;

		},

		radToDeg: function ( radians ) {

			return radians * maths.RAD2DEG;

		},

		isPowerOfTwo: function ( value ) {

			return ( value & ( value - 1 ) ) === 0 && value !== 0;

		},

		ceilPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

		},

		floorPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

		},

		setQuaternionFromProperEuler: function ( q, a, b, c, order ) {

			// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

			// rotations are applied to the axes in the order specified by 'order'
			// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
			// angles are in radians

			var cos = Math.cos;
			var sin = Math.sin;

			var c2 = cos( b / 2 );
			var s2 = sin( b / 2 );

			var c13 = cos( ( a + c ) / 2 );
			var s13 = sin( ( a + c ) / 2 );

			var c1_3 = cos( ( a - c ) / 2 );
			var s1_3 = sin( ( a - c ) / 2 );

			var c3_1 = cos( ( c - a ) / 2 );
			var s3_1 = sin( ( c - a ) / 2 );

			if ( order === 'XYX' ) {

				q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );

			} else if ( order === 'YZY' ) {

				q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );

			} else if ( order === 'ZXZ' ) {

				q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );

			} else if ( order === 'XZX' ) {

				q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );

			} else if ( order === 'YXY' ) {

				q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );

			} else if ( order === 'ZYZ' ) {

				q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );

			} else {

				console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.' );

			}

		}

	};


	return  numerics.maths = maths;
});
define('skylark-langx-numerics/quaternion',[
	"skylark-langx-klass",
	"./numerics",
	"./maths"
] ,function(klass,numerics,maths) {

	var Quaternion = klass({
		"klassName" : "Quaternion",

		x: {

			get: function () {

				return this._x;

			},

			set: function ( value ) {

				this._x = value;
				this._onChangeCallback();

			}

		},

		y: {

			get: function () {

				return this._y;

			},

			set: function ( value ) {

				this._y = value;
				this._onChangeCallback();

			}

		},

		z: {

			get: function () {

				return this._z;

			},

			set: function ( value ) {

				this._z = value;
				this._onChangeCallback();

			}

		},

		w: {

			get: function () {

				return this._w;

			},

			set: function ( value ) {

				this._w = value;
				this._onChangeCallback();

			}

		},

		set: function ( x, y, z, w ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this._onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._w );

		},

		copy: function ( quaternion ) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this._onChangeCallback();

			return this;

		},

		setFromEuler: function ( euler, update ) {

			if ( ! ( euler && euler.isEuler ) ) {

				throw new Error( 'mathsQuaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			var cos = Math.cos;
			var sin = Math.sin;

			var c1 = cos( x / 2 );
			var c2 = cos( y / 2 );
			var c3 = cos( z / 2 );

			var s1 = sin( x / 2 );
			var s2 = sin( y / 2 );
			var s3 = sin( z / 2 );

			if ( order === 'XYZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'YXZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'ZXY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'ZYX' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'YZX' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'XZY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			}

			if ( update !== false ) this._onChangeCallback();

			return this;

		},

		setFromAxisAngle: function ( axis, angle ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			var halfAngle = angle / 2, s = Math.sin( halfAngle );

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );

			this._onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

				trace = m11 + m22 + m33,
				s;

			if ( trace > 0 ) {

				s = 0.5 / Math.sqrt( trace + 1.0 );

				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;

			} else if ( m11 > m22 && m11 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;

			} else if ( m22 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;

			} else {

				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;

			}

			this._onChangeCallback();

			return this;

		},

		setFromUnitVectors: function ( vFrom, vTo ) {

			// assumes direction vectors vFrom and vTo are normalized

			var EPS = 0.000001;

			var r = vFrom.dot( vTo ) + 1;

			if ( r < EPS ) {

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					this._x = - vFrom.y;
					this._y = vFrom.x;
					this._z = 0;
					this._w = r;

				} else {

					this._x = 0;
					this._y = - vFrom.z;
					this._z = vFrom.y;
					this._w = r;

				}

			} else {

				// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

				this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
				this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
				this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
				this._w = r;

			}

			return this.normalize();

		},

		angleTo: function ( q ) {

			return 2 * Math.acos( Math.abs( maths.clamp( this.dot( q ), - 1, 1 ) ) );

		},

		rotateTowards: function ( q, step ) {

			var angle = this.angleTo( q );

			if ( angle === 0 ) return this;

			var t = Math.min( 1, step / angle );

			this.slerp( q, t );

			return this;

		},

		inverse: function () {

			// quaternion is assumed to have unit length

			return this.conjugate();

		},

		conjugate: function () {

			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;

			this._onChangeCallback();

			return this;

		},

		dot: function ( v ) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		},

		lengthSq: function () {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		},

		length: function () {

			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

		},

		normalize: function () {

			var l = this.length();

			if ( l === 0 ) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this._onChangeCallback();

			return this;

		},

		multiply: function ( q, p ) {

			if ( p !== undefined ) {

				console.warn( 'mathsQuaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );

			}

			return this.multiplyQuaternions( this, q );

		},

		premultiply: function ( q ) {

			return this.multiplyQuaternions( q, this );

		},

		multiplyQuaternions: function ( a, b ) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this._onChangeCallback();

			return this;

		},

		slerp: function ( qb, t ) {

			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );

			var x = this._x, y = this._y, z = this._z, w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if ( cosHalfTheta < 0 ) {

				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;

				cosHalfTheta = - cosHalfTheta;

			} else {

				this.copy( qb );

			}

			if ( cosHalfTheta >= 1.0 ) {

				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;

			}

			var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

			if ( sqrSinHalfTheta <= Number.EPSILON ) {

				var s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;

				this.normalize();
				this._onChangeCallback();

				return this;

			}

			var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
			var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );

			this._onChangeCallback();

			return this;

		},

		equals: function ( quaternion ) {

			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];

			this._onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;

			return array;

		},

		fromBufferAttribute: function ( attribute, index ) {

			this._x = attribute.getX( index );
			this._y = attribute.getY( index );
			this._z = attribute.getZ( index );
			this._w = attribute.getW( index );

			return this;

		},

		_onChange: function ( callback ) {

			this._onChangeCallback = callback;

			return this;

		},

		_onChangeCallback: function () {},


		"_construct" : function ( x, y, z, w ) {

			this._x = x || 0;
			this._y = y || 0;
			this._z = z || 0;
			this._w = ( w !== undefined ) ? w : 1;

		}


	})


	Object.assign( Quaternion, {

		slerp: function ( qa, qb, qm, t ) {

			return qm.copy( qa ).slerp( qb, t );

		},

		slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

			// fuzz-free, array-based Quaternion SLERP operation

			var x0 = src0[ srcOffset0 + 0 ],
				y0 = src0[ srcOffset0 + 1 ],
				z0 = src0[ srcOffset0 + 2 ],
				w0 = src0[ srcOffset0 + 3 ],

				x1 = src1[ srcOffset1 + 0 ],
				y1 = src1[ srcOffset1 + 1 ],
				z1 = src1[ srcOffset1 + 2 ],
				w1 = src1[ srcOffset1 + 3 ];

			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

				var s = 1 - t,

					cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

					dir = ( cos >= 0 ? 1 : - 1 ),
					sqrSin = 1 - cos * cos;

				// Skip the Slerp for tiny steps to avoid numeric problems:
				if ( sqrSin > Number.EPSILON ) {

					var sin = Math.sqrt( sqrSin ),
						len = Math.atan2( sin, cos * dir );

					s = Math.sin( s * len ) / sin;
					t = Math.sin( t * len ) / sin;

				}

				var tDir = t * dir;

				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;

				// Normalize in case we just did a lerp:
				if ( s === 1 - t ) {

					var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;

				}

			}

			dst[ dstOffset ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;

		}

	} );

	Object.assign( Quaternion.prototype, {


	} );


	return numerics.Quaternion = Quaternion;


});
define('skylark-langx-numerics/vector3',[
	"skylark-langx-klass",
	"./numerics",
	"./maths",
	"./quaternion"
] ,function(
	klass,
	numerics,
	maths,
	Quaternion
) {

	var _quaternion = new Quaternion();

	var Vector3 = klass({
		"klassName" : "Vector3",

		set: function ( x, y, z ) {

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'mathsVector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'mathsVector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		},

		multiply: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'mathsVector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );

			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;

		},

		multiplyVectors: function ( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		},

		applyEuler: function ( euler ) {

			if ( ! ( euler && euler.isEuler ) ) {

				console.error( 'mathsVector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			return this.applyQuaternion( _quaternion.setFromEuler( euler ) );

		},

		applyAxisAngle: function ( axis, angle ) {

			return this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );

		},

		applyMatrix3: function ( m ) {

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		},

		applyNormalMatrix: function ( m ) {

			return this.applyMatrix3( m ).normalize();

		},

		applyMatrix4: function ( m ) {

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

			return this;

		},

		applyQuaternion: function ( q ) {

			var x = this.x, y = this.y, z = this.z;
			var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

			// calculate quat * vector

			var ix = qw * x + qy * z - qz * y;
			var iy = qw * y + qz * x - qx * z;
			var iz = qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		},

		project: function ( camera ) {

			return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

		},

		unproject: function ( camera ) {

			return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

		},

		transformDirection: function ( m ) {

			// input: mathsMatrix4 affine matrix
			// vector interpreted as a direction

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			return this.normalize();

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );

			return this;

		},

		clampScalar: function ( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
			this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

			return this;

		},

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		},

		// TODO lengthSquared?

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		cross: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'mathsVector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );

			}

			return this.crossVectors( this, v );

		},

		crossVectors: function ( a, b ) {

			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		},

		projectOnVector: function ( v ) {

			var denominator = v.lengthSq();

			if ( denominator === 0 ) return this.set( 0, 0, 0 );

			var scalar = v.dot( this ) / denominator;

			return this.copy( v ).multiplyScalar( scalar );

		},

		projectOnPlane: function ( planeNormal ) {

			_vector.copy( this ).projectOnVector( planeNormal );

			return this.sub( _vector );

		},

		reflect: function ( normal ) {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			return this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		},

		angleTo: function ( v ) {

			var denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

			if ( denominator === 0 ) return Math.PI / 2;

			var theta = this.dot( v ) / denominator;

			// clamp, to handle numerical problems

			return Math.acos( MathUtils.clamp( theta, - 1, 1 ) );

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		},

		manhattanDistanceTo: function ( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

		},

		setFromSpherical: function ( s ) {

			return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

		},

		setFromSphericalCoords: function ( radius, phi, theta ) {

			var sinPhiRadius = Math.sin( phi ) * radius;

			this.x = sinPhiRadius * Math.sin( theta );
			this.y = Math.cos( phi ) * radius;
			this.z = sinPhiRadius * Math.cos( theta );

			return this;

		},

		setFromCylindrical: function ( c ) {

			return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

		},

		setFromCylindricalCoords: function ( radius, theta, y ) {

			this.x = radius * Math.sin( theta );
			this.y = y;
			this.z = radius * Math.cos( theta );

			return this;

		},

		setFromMatrixPosition: function ( m ) {

			var e = m.elements;

			this.x = e[ 12 ];
			this.y = e[ 13 ];
			this.z = e[ 14 ];

			return this;

		},

		setFromMatrixScale: function ( m ) {

			var sx = this.setFromMatrixColumn( m, 0 ).length();
			var sy = this.setFromMatrixColumn( m, 1 ).length();
			var sz = this.setFromMatrixColumn( m, 2 ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;

		},

		setFromMatrixColumn: function ( m, index ) {

			return this.fromArray( m.elements, index * 4 );

		},

		setFromMatrix3Column: function ( m, index ) {

			return this.fromArray( m.elements, index * 3 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'mathsVector3: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );

			return this;

		},


		"_construct" : function ( x, y, z ) {

			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;

		}

	});

	var _vector = new Vector3();


	return numerics.Vector3 = Vector3;
});
define('skylark-langx-numerics/matrix4',[
	"skylark-langx-klass",
	"./numerics",
	"./vector3"
] ,function(
	klass,
	numerics,
	Vector3
) {

	var _v1 = new Vector3();
	var _zero = new Vector3( 0, 0, 0 );
	var _one = new Vector3( 1, 1, 1 );
	var _x = new Vector3();
	var _y = new Vector3();
	var _z = new Vector3();

	var Matrix4 = klass({
		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new Matrix4().fromArray( this.elements );

		},

		copy: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
			te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
			te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
			te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

			return this;

		},

		copyPosition: function ( m ) {

			var te = this.elements, me = m.elements;

			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];

			return this;

		},

		extractBasis: function ( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrixColumn( this, 0 );
			yAxis.setFromMatrixColumn( this, 1 );
			zAxis.setFromMatrixColumn( this, 2 );

			return this;

		},

		makeBasis: function ( xAxis, yAxis, zAxis ) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0, 0, 0, 1
			);

			return this;

		},

		extractRotation: function ( m ) {

			// this method does not support reflection matrices

			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / _v1.setFromMatrixColumn( m, 0 ).length();
			var scaleY = 1 / _v1.setFromMatrixColumn( m, 1 ).length();
			var scaleZ = 1 / _v1.setFromMatrixColumn( m, 2 ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;
			te[ 3 ] = 0;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;
			te[ 7 ] = 0;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;
			te[ 11 ] = 0;

			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		makeRotationFromEuler: function ( euler ) {

			if ( ! ( euler && euler.isEuler ) ) {

				console.error( 'mathsMatrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			var te = this.elements;

			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );

			if ( euler.order === 'XYZ' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;

				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;

				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YXZ' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;

				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;

				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZXY' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;

				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;

				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZYX' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;

				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;

				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YZX' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;

				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;

				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;

			} else if ( euler.order === 'XZY' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;

				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;

				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;

			}

			// bottom row
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// last column
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		makeRotationFromQuaternion: function ( q ) {

			return this.compose( _zero, q, _one );

		},

		lookAt: function ( eye, target, up ) {

			var te = this.elements;

			_z.subVectors( eye, target );

			if ( _z.lengthSq() === 0 ) {

				// eye and target are in the same position

				_z.z = 1;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

			if ( _x.lengthSq() === 0 ) {

				// up and z are parallel

				if ( Math.abs( up.z ) === 1 ) {

					_z.x += 0.0001;

				} else {

					_z.z += 0.0001;

				}

				_z.normalize();
				_x.crossVectors( up, _z );

			}

			_x.normalize();
			_y.crossVectors( _z, _x );

			te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
			te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
			te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

			return this;

		},

		multiply: function ( m, n ) {

			if ( n !== undefined ) {

				console.warn( 'mathsMatrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );

			}

			return this.multiplyMatrices( this, m );

		},

		premultiply: function ( m ) {

			return this.multiplyMatrices( m, this );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

			return this;

		},

		determinant: function () {

			var te = this.elements;

			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);

		},

		transpose: function () {

			var te = this.elements;
			var tmp;

			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

			return this;

		},

		setPosition: function ( x, y, z ) {

			var te = this.elements;

			if ( x.isVector3 ) {

				te[ 12 ] = x.x;
				te[ 13 ] = x.y;
				te[ 14 ] = x.z;

			} else {

				te[ 12 ] = x;
				te[ 13 ] = y;
				te[ 14 ] = z;

			}

			return this;

		},

		getInverse: function ( m, throwOnDegenerate ) {

			if ( throwOnDegenerate !== undefined ) {

				console.warn( "mathsMatrix4: .getInverse() can no longer be configured to throw on degenerate." );

			}

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements,
				me = m.elements,

				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
				n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
				n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
				n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

			var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

			if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

			var detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
			te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
			te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

			te[ 4 ] = t12 * detInv;
			te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
			te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
			te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

			te[ 8 ] = t13 * detInv;
			te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
			te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
			te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

			te[ 12 ] = t14 * detInv;
			te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
			te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
			te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

			return this;

		},

		scale: function ( v ) {

			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;

			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

			return this;

		},

		getMaxScaleOnAxis: function () {

			var te = this.elements;

			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

		},

		makeTranslation: function ( x, y, z ) {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationX: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				1, 0, 0, 0,
				0, c, - s, 0,
				0, s, c, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationY: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1

			);

			return this;

		},

		makeRotationZ: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				c, - s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationAxis: function ( axis, angle ) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			 return this;

		},

		makeScale: function ( x, y, z ) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeShear: function ( x, y, z ) {

			this.set(

				1, y, z, 0,
				x, 1, z, 0,
				x, y, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		compose: function ( position, quaternion, scale ) {

			var te = this.elements;

			var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
			var x2 = x + x,	y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;

			var sx = scale.x, sy = scale.y, sz = scale.z;

			te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
			te[ 1 ] = ( xy + wz ) * sx;
			te[ 2 ] = ( xz - wy ) * sx;
			te[ 3 ] = 0;

			te[ 4 ] = ( xy - wz ) * sy;
			te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
			te[ 6 ] = ( yz + wx ) * sy;
			te[ 7 ] = 0;

			te[ 8 ] = ( xz + wy ) * sz;
			te[ 9 ] = ( yz - wx ) * sz;
			te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
			te[ 11 ] = 0;

			te[ 12 ] = position.x;
			te[ 13 ] = position.y;
			te[ 14 ] = position.z;
			te[ 15 ] = 1;

			return this;

		},

		decompose: function ( position, quaternion, scale ) {

			var te = this.elements;

			var sx = _v1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			var sy = _v1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			var sz = _v1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			var det = this.determinant();
			if ( det < 0 ) sx = - sx;

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part
			_m1.copy( this );

			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;

			_m1.elements[ 0 ] *= invSX;
			_m1.elements[ 1 ] *= invSX;
			_m1.elements[ 2 ] *= invSX;

			_m1.elements[ 4 ] *= invSY;
			_m1.elements[ 5 ] *= invSY;
			_m1.elements[ 6 ] *= invSY;

			_m1.elements[ 8 ] *= invSZ;
			_m1.elements[ 9 ] *= invSZ;
			_m1.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( _m1 );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		},

		makePerspective: function ( left, right, top, bottom, near, far ) {

			if ( far === undefined ) {

				console.warn( 'mathsMatrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

			}

			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );

			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );

			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

			return this;

		},

		makeOrthographic: function ( left, right, top, bottom, near, far ) {

			var te = this.elements;
			var w = 1.0 / ( right - left );
			var h = 1.0 / ( top - bottom );
			var p = 1.0 / ( far - near );

			var x = ( right + left ) * w;
			var y = ( top + bottom ) * h;
			var z = ( far + near ) * p;

			te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

			return this;

		},

		equals: function ( matrix ) {

			var te = this.elements;
			var me = matrix.elements;

			for ( var i = 0; i < 16; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			for ( var i = 0; i < 16; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];

			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];

			array[ offset + 8 ] = te[ 8 ];
			array[ offset + 9 ] = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];

			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];

			return array;

		},

		"_construct" : function() {

			this.elements = [

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			];

			if ( arguments.length > 0 ) {

				console.error( 'mathsMatrix4: the constructor no longer reads arguments. use .set() instead.' );

			}

		}

	});

	var _m1 = new Matrix4();

	return numerics.Matrix4 =  Matrix4 ;

});
define('skylark-langx-numerics/euler',[
	"skylark-langx-klass",
	"./numerics",
	"./maths",
	"./quaternion",
	"./vector3",
	"./matrix4"
] ,function(
	klass,
	numerics,
	maths,
	Quaternion,
	Vector3,
	Matrix4
) {

	var _matrix = new Matrix4();
	var _quaternion = new Quaternion();

	var Euler = klass({
		x: {

			get: function () {

				return this._x;

			},

			set: function ( value ) {

				this._x = value;
				this._onChangeCallback();

			}

		},

		y: {

			get: function () {

				return this._y;

			},

			set: function ( value ) {

				this._y = value;
				this._onChangeCallback();

			}

		},

		z: {

			get: function () {

				return this._z;

			},

			set: function ( value ) {

				this._z = value;
				this._onChangeCallback();

			}

		},

		order: {

			get: function () {

				return this._order;

			},

			set: function ( value ) {

				this._order = value;
				this._onChangeCallback();

			}

		},

		isEuler: true,

		set: function ( x, y, z, order ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;

			this._onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._order );

		},

		copy: function ( euler ) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this._onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m, order, update ) {

			var clamp = maths.clamp;

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			order = order || this._order;

			if ( order === 'XYZ' ) {

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

			} else if ( order === 'YXZ' ) {

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

			} else if ( order === 'ZXY' ) {

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

			} else if ( order === 'ZYX' ) {

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

			} else if ( order === 'YZX' ) {

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

			} else if ( order === 'XZY' ) {

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

			} else {

				console.warn( 'skylark-nunustudio/editor/gui/element/RendererCanvasEuler: .setFromRotationMatrix() given unsupported order: ' + order );

			}

			this._order = order;

			if ( update !== false ) this._onChangeCallback();

			return this;

		},

		setFromQuaternion: function ( q, order, update ) {

			_matrix.makeRotationFromQuaternion( q );

			return this.setFromRotationMatrix( _matrix, order, update );

		},

		setFromVector3: function ( v, order ) {

			return this.set( v.x, v.y, v.z, order || this._order );

		},

		reorder: function ( newOrder ) {

			// WARNING: this discards revolution information -bhouston

			_quaternion.setFromEuler( this );

			return this.setFromQuaternion( _quaternion, newOrder );

		},

		equals: function ( euler ) {

			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

		},

		fromArray: function ( array ) {

			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

			this._onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;

			return array;

		},

		toVector3: function ( optionalResult ) {

			if ( optionalResult ) {

				return optionalResult.set( this._x, this._y, this._z );

			} else {

				return new Vector3( this._x, this._y, this._z );

			}

		},

		_onChange: function ( callback ) {

			this._onChangeCallback = callback;

			return this;

		},

		_onChangeCallback: function () {},


		"_construct" : function ( x, y, z, order ) {

			this._x = x || 0;
			this._y = y || 0;
			this._z = z || 0;
			this._order = order || Euler.DefaultOrder;

		}


	});


	Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

	Euler.DefaultOrder = 'XYZ';


	return numerics.Euler = Euler ;
});

define('skylark-langx-numerics/matrix3',[
	"skylark-langx-klass",
	"./numerics"
] ,function(klass,numerics) {

	var Matrix3 = klass({
		"klassName" : "Matrix3",

		isMatrix3: true,

		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
			te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
			te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new this.constructor().fromArray( this.elements );

		},

		copy: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
			te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
			te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

			return this;

		},

		extractBasis: function ( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrix3Column( this, 0 );
			yAxis.setFromMatrix3Column( this, 1 );
			zAxis.setFromMatrix3Column( this, 2 );

			return this;

		},

		setFromMatrix4: function ( m ) {

			var me = m.elements;

			this.set(

				me[ 0 ], me[ 4 ], me[ 8 ],
				me[ 1 ], me[ 5 ], me[ 9 ],
				me[ 2 ], me[ 6 ], me[ 10 ]

			);

			return this;

		},

		multiply: function ( m ) {

			return this.multiplyMatrices( this, m );

		},

		premultiply: function ( m ) {

			return this.multiplyMatrices( m, this );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
			var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
			var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

			var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
			var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
			var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
			te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
			te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
			te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
			te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
			te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
			te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

			return this;

		},

		determinant: function () {

			var te = this.elements;

			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		},

		getInverse: function ( matrix, throwOnDegenerate ) {

			if ( throwOnDegenerate !== undefined ) {

				console.warn( "mathsMatrix3: .getInverse() can no longer be configured to throw on degenerate." );

			}

			var me = matrix.elements,
				te = this.elements,

				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
				n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
				n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,

				det = n11 * t11 + n21 * t12 + n31 * t13;

			if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

			var detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
			te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

			te[ 3 ] = t12 * detInv;
			te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
			te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

			te[ 6 ] = t13 * detInv;
			te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
			te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

			return this;

		},

		transpose: function () {

			var tmp, m = this.elements;

			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

			return this;

		},

		getNormalMatrix: function ( matrix4 ) {

			return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

		},

		transposeIntoArray: function ( r ) {

			var m = this.elements;

			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];

			return this;

		},

		setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {

			var c = Math.cos( rotation );
			var s = Math.sin( rotation );

			this.set(
				sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
				- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
				0, 0, 1
			);

		},

		scale: function ( sx, sy ) {

			var te = this.elements;

			te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
			te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

			return this;

		},

		rotate: function ( theta ) {

			var c = Math.cos( theta );
			var s = Math.sin( theta );

			var te = this.elements;

			var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
			var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

			te[ 0 ] = c * a11 + s * a21;
			te[ 3 ] = c * a12 + s * a22;
			te[ 6 ] = c * a13 + s * a23;

			te[ 1 ] = - s * a11 + c * a21;
			te[ 4 ] = - s * a12 + c * a22;
			te[ 7 ] = - s * a13 + c * a23;

			return this;

		},

		translate: function ( tx, ty ) {

			var te = this.elements;

			te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
			te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

			return this;

		},

		equals: function ( matrix ) {

			var te = this.elements;
			var me = matrix.elements;

			for ( var i = 0; i < 9; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			for ( var i = 0; i < 9; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];

			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];

			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ] = te[ 8 ];

			return array;

		},


		"_construct" : function () {

			this.elements = [

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			];

			if ( arguments.length > 0 ) {

				console.error( 'Matrix3: the constructor no longer reads arguments. use .set() instead.' );

			}

		}

	});


	return numerics.Matrix3 = Matrix3;
});
define('skylark-langx-numerics/transform',[
	"skylark-langx-klass",	
    "./numerics",
], function(klass,numerics) {

    var Transform =  klass({
        "klassName": "Transform",
		"value": {
			get : function(){
				return this._.value;
			}
		}
	});

	return numerics.Transform =Transform;
});

define('skylark-langx-numerics/matrix-transform',[
    "./numerics",
	"./transform"
],function(numerics,Transform) {

    var MatrixTransform =  Transform.inherit({
        "klassName": "MatrixTransform",

		"value"	:	{
			get : function(){
				return this.matrix.clone();
			}
		},
		
		"matrix" : {
			get : function(){
				return this._.matrix;
			}
		},

		clone : /*ScaleTransform*/function() {
		},
		
		transform : /*Point*/function(/*Point*/point) {
		},
		
		//�w�肳�ꂽ���E�{�b�N�X��ϊ����A��������傤�Ǌi�[�ł���傫���̎����s���E�{�b�N�X��Ԃ��܂��B
		transformBounds : /*Rect*/function(/*Rect*/rect) {
		},		
		"_construct" : function(/*Martix*/matrix) {
            var _ = this._ = {};
			
			_.matrix = matrix;
		}
				
	});

	return numerics.MatrixTransform = MatrixTransform;
	
});	

define('skylark-langx-numerics/plane',[
	"skylark-langx-klass",
	"./numerics",
	"./matrix3",
	"./vector3"
] ,function(
	klass,
	numerics,
	Matrix3,
	Vector3
) {


	var _vector1 = new Vector3();
	var _vector2 = new Vector3();
	var _normalMatrix = new Matrix3();

	var Plane = klass({
		"klassName" : "Plane",

		set: function ( normal, constant ) {

			this.normal.copy( normal );
			this.constant = constant;

			return this;

		},

		setComponents: function ( x, y, z, w ) {

			this.normal.set( x, y, z );
			this.constant = w;

			return this;

		},

		setFromNormalAndCoplanarPoint: function ( normal, point ) {

			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );

			return this;

		},

		setFromCoplanarPoints: function ( a, b, c ) {

			var normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( plane ) {

			this.normal.copy( plane.normal );
			this.constant = plane.constant;

			return this;

		},

		normalize: function () {

			// Note: will lead to a divide by zero if the plane is invalid.

			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;

			return this;

		},

		negate: function () {

			this.constant *= - 1;
			this.normal.negate();

			return this;

		},

		distanceToPoint: function ( point ) {

			return this.normal.dot( point ) + this.constant;

		},

		distanceToSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) - sphere.radius;

		},

		projectPoint: function ( point, target ) {

			if ( target === undefined ) {

				console.warn( 'mathsPlane: .projectPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

		},

		intersectLine: function ( line, target ) {

			if ( target === undefined ) {

				console.warn( 'mathsPlane: .intersectLine() target is now required' );
				target = new Vector3();

			}

			var direction = line.delta( _vector1 );

			var denominator = this.normal.dot( direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) === 0 ) {

					return target.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return undefined;

			}

			return target.copy( direction ).multiplyScalar( t ).add( line.start );

		},

		intersectsLine: function ( line ) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );

			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

		},

		intersectsBox: function ( box ) {

			return box.intersectsPlane( this );

		},

		intersectsSphere: function ( sphere ) {

			return sphere.intersectsPlane( this );

		},

		coplanarPoint: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'mathsPlane: .coplanarPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.normal ).multiplyScalar( - this.constant );

		},

		applyMatrix4: function ( matrix, optionalNormalMatrix ) {

			var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

			var referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

			var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

			this.constant = - referencePoint.dot( normal );

			return this;

		},

		translate: function ( offset ) {

			this.constant -= offset.dot( this.normal );

			return this;

		},

		equals: function ( plane ) {

			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

		},


		"_construct" : function( normal, constant ) {

			// normal is assumed to be normalized

			this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
			this.constant = ( constant !== undefined ) ? constant : 0;

		}

	});


	return numerics.Plane = Plane;
});
define('skylark-langx-numerics/rotate-transform',[
    "./numerics",
	"./transform",
	"./matrix-transform"
],function(numerics,Transform,Matrix) {


    var RotateTransform = numerics.RotateTransform = Transform.inherit({
        "klassName": "RotateTransform",

        "value": {
            get: function() {
                return Matrix.rotateAt(this.angle, this.centerX, this.centerY);
            }
        },

        "angle": {
            get : function() {
                return this._.angle;
            }
        },
        // cy: Number
        //		The Y coordinate of the center of the circle, default value 0.
        "centerX": {
            get : function() {
                return this._.centerX;
            }
        },
        // r: Number
        //		The radius, default value 100.
        "centerY": {
            get : function() {
                return this._.centerY;
            }
        },

		clone : /*ScaleTransform*/function() {
		},
		
		transform : /*Point*/function(/*Point*/point) {
		},
		
		transformBounds : /*Rect*/function(/*Rect*/rect) {
		},
		
		"init" : function(/*Number*/angle,/*Number*/centerX,/*Number*/centerY) {
			var _ = this._ = {};
			_.angle = angle ? angle :0;
			_.centerX = centerX ? centerX :0;
			_.centerY = centerY ? centerY :0;
		}
	});

	return RotateTransform;
	
});	

define('skylark-langx-numerics/scale-transform',[
    "./numerics",
    "./transform",
    "./matrix-transform"
], function(numerics, Transform, Matrix) {

   var ScaleTransform =  Transform.inherit({
        "klassName": "ScaleTransform",

        "value": {
            get: function() {
                    return Matrix.scaleAt(this.scaleX, this.scaleY, this.centerX, this.centerY);
            }
        },

        "scaleX": {
            get : function() {
                return this._.scaleX;
            }
        },

        "scaleY": {
            get : function() {
                return this._.scaleY;
            }
        },

        // cy: Number
        //      The Y coordinate of the center of the circle, default value 0.
        "centerX": {
            get : function() {
                return this._.centerX;
            }
        },
        // r: Number
        //      The radius, default value 100.
        "centerY": {
            get : function() {
                return this._.centerY;
            }
        },

        clone: /*ScaleTransform*/ function() {},

        transform: /*Point*/ function( /*Point*/ point) {},

        transformBounds: /*Rect*/ function( /*Rect*/ rect) {},

        "_construct": function( /*Number*/ scaleX, /*Number*/ scaleY, /*Number*/ centerX, /*Number*/ centerY) {
            var _ = this._ = {};

            _.scaleX = scaleX ? scaleX : 1;
            _.scaleY = scaleY ? scaleY : 1;
            _.centerX = centerX ? centerX : 0;
            _.centerY = centerY ? centerY : 0;
        }
    });

    return numerics.ScaleTransform = ScaleTransform;

});

define('skylark-langx-numerics/skew-transform',[
    "./numerics",
    "./transform",
    "./matrix-transform"
], function(numerics, Transform, Matrix) {

   var SkewTransform = Transform.inherit({
        "klassName": "SkewTransform",

        "value": {
            get: function() {
                    return Matrix.scaleAt(this.skewX, this.skewY);
            }
        },

        "skewX": {
            get : function() {
                return this._.skewX;
            }
        },

        "skewY": {
            get : function() {
                return this._.skewY;
            }
        },

        clone: /*SkewTransform*/ function() {},

        transform: /*Point*/ function( /*Point*/ point) {},

        transformBounds: /*Rect*/ function( /*Rect*/ rect) {},

        "_construct": function( /*Number*/ skewX, /*Number*/ skewY) {
            var _ = this._ = {};

            _.skewX = skewX ? skewX : 0;
            _.skewY = skewY ? skewY : 0;
        }
    });

    return numerics.SkewTransform = SkewTransform;

});

define('skylark-langx-numerics/vector2',[
	"skylark-langx-klass",
	"./numerics"
] ,function(klass,numerics) {

	var Vector2 = klass({
		"klassName" : "Vector2",

		set: function ( x, y ) {

			this.x = x;
			this.y = y;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;

			return this;
		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},


		clone: function () {

			return new this.constructor( this.x, this.y );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		},

		multiply: function ( v ) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;

			return this;

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		applyMatrix3: function ( m ) {

			var x = this.x, y = this.y;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

			return this;

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );

			return this;

		},

		clampScalar: function ( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

			return this;

		},

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y;

		},

		cross: function ( v ) {

			return this.x * v.y - this.y * v.x;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		angle: function () {

			// computes the angle in radians with respect to the positive x-axis

			var angle = Math.atan2( - this.y, - this.x ) + Math.PI;

			return angle;

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		},

		manhattanDistanceTo: function ( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;

			return array;

		},


		rotateAround: function ( center, angle ) {

			var c = Math.cos( angle ), s = Math.sin( angle );

			var x = this.x - center.x;
			var y = this.y - center.y;

			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;

			return this;
		},

		"_construct" : function ( x, y ) {

			this.x = x || 0;
			this.y = y || 0;

		}


	});


	/*
	Object.defineProperties( Vector2.prototype, {

		"width": {

			get: function () {

				return this.x;

			},

			set: function ( value ) {

				this.x = value;

			}

		},

		"height": {

			get: function () {

				return this.y;

			},

			set: function ( value ) {

				this.y = value;

			}

		}

	} );
	*/




	return numerics.Vector2 = Vector2 ;
});

define( 'skylark-langx-numerics/transform-matrix',[
    "skylark-langx-klass",
    "./numerics",
    "./vector2"
], function(klass,numerics,Vector2){
	// reference easeljs/numerics/Matrix2D  and dojox/gfx/matrix
	
	var DEG_TO_RAD = Math.PI/180;
	var _degToRadCache = {};
	var degToRad = function(degree){
		return _degToRadCache[degree] || (_degToRadCache[degree] = (Math.PI * degree / 180));
	};
	var radToDeg = function(radian){ return radian / Math.PI * 180; };
	

	//Represents a 3 x 3 affine transformation matrix used for transformation in 2-D space.
	//|----------|
	//|m11|m21|dx| 
	//|----------|
	//|m12|m22|dy|
	//|----------|
	//|  0|  0| 1|
	//|----------|
	
    var TransformMatrix =  klass({
        "klassName": "TransformMatrix",

		"_multiplyPoint"	: 	function(p){
			// summary:
			//		applies the matrix to a point
			// p: Point
			//		a point
			// returns: Point
			var _ = this._,
				x = p.x * _.m11 + p.y * _.m21  + _.dx,
			    y = p.x * _.m12 +  p.y * _.m22 + _.dy;

			return new Vector2(x,y); // Point
		},

       "m11": {
       		//Position (0, 0) in a 3x3 affine transformation matrix.
            get : function() {
                return this._.m11;
            }
        },

       "m12": {
       		//Position (0, 1) in a 3x3 affine transformation matrix.
            get : function() {
                return this._.m12;
            }
        },

       "m21": {
       		//Position (1, 0) in a 3x3 affine transformation matrix.
            get : function() {
                return this._.m21;
            }
        },

       "m22": {
       		//Position (1, 1) in a 3x3 affine transformation matrix.
            get : function() {
                return this._.m22;
            }
        },

       "dx": {
       		// Position (2, 1) in a 3x3 affine transformation matrix.
            get : function() {
                return this._.dx;
            }
        },

       "dy": {
       		// Position (2, 1) in a 3x3 affine transformation matrix.
            get : function() {
                return this._.dy;
            }
        },

       "alpha": {
       		// Property representing the alpha that will be applied to a display object. This is not part of matrix
       		// operations, but is used for operations like getConcatenatedMatrix to provide concatenated alpha values.
            get : function() {
                return this._.alpha;
            }
        },

       "shadow": {
       		// Property representing the shadow that will be applied to a display object. This is not part of matrix
       		// operations, but is used for operations like getConcatenatedMatrix to provide concatenated shadow values..
            get : function() {
                return this._.shadow;
            }
        },

       "compositeOperation": {
			/**
			 * Property representing the compositeOperation that will be applied to a display object. This is not part of
			 * matrix operations, but is used for operations like getConcatenatedMatrix to provide concatenated
			 * compositeOperation values. You can find a list of valid composite operations at:
			 * <a href="https://developer.mozilla.org/en/Canvas_tutorial/Compositing">https://developer.mozilla.org/en/Canvas_tutorial/Compositing</a>
			 * @property compositeOperation
			 * @type String
			 **/
            get : function() {
                return this._.compositeOperation;
            }
        },

        //Converts the specified point with TransformMatrix and returns the result.
		multiplyPoint: /*Vector2*/function(/*Vector2 */ p){
			// summary:
			//		applies the matrix to a point
			return this._multiplyPoint(p); // Vector2
		},
				/**
				 * 指定した矩形を TransformMatrix で変換し、その結果を返します。
				 */
		multiplyRectangle: /*Rect*/function(/*Rect*/ rect){
			// summary:
			//		Applies the matrix to a rectangle.
			// returns: Rect
			if(this.isIdentity())
				return rect.clone(); // Rect
			var p0 = this.multiplyPoint(rect.leftTop),
				p1 = this.multiplyPoint(rect.leftBottom),
				p2 = this.multiplyPoint(rect.right),
				p3 = this.multiplyPoint(rect.rightBottom),
				minx = Math.min(p0.x, p1.x, p2.x, p3.x),
				miny = Math.min(p0.y, p1.y, p2.y, p3.y),
				maxx = Math.max(p0.x, p1.x, p2.x, p3.x),
				maxy = Math.max(p0.y, p1.y, p2.y, p3.y);
			return new Rect(minx,miny,maxx-minx,maxy-miny);  // Rect
		},
		/**
		 * Concatenates the specified matrix properties with this matrix. All parameters are required.
		 * @method prepend
		 * @param {Number} m11
		 * @param {Number} m12
		 * @param {Number} m21
		 * @param {Number} m22
		 * @param {Number} dx
		 * @param {Number} dy
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		prepend : function(m11, m12, m21, m22, dx, dy) {
			var tx1 = this.dx;
			if (m11 != 1 || m12 != 0 || m21 != 0 || m22 != 1) {
				var a1 = this.m11;
				var c1 = this.m21;
				this.m11  = a1*m11+this.m12*m21;
				this.m12  = a1*m12+this.m12*m22;
				this.m21  = c1*m11+this.m22*m21;
				this.m22  = c1*m12+this.m22*m22;
			}
			this.dx = tx1*m11+this.dy*m21+dx;
			this.dy = tx1*m12+this.dy*m22+dy;
			return this;
		},

		/**
		 * Appends the specified matrix properties with this matrix. All parameters are required.
		 * 指定した Matrixをこの Matrixに追加します。
		 * @method append
		 * @param {Number} m11
		 * @param {Number} m12
		 * @param {Number} m21
		 * @param {Number} m22
		 * @param {Number} dx
		 * @param {Number} dy
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		append : function(m11, m12, m21, m22, dx, dy) {
			var a1 = this.m11;
			var b1 = this.m12;
			var c1 = this.m21;
			var d1 = this.m22;

			this.m11  = m11*a1+m12*c1;
			this.m12  = m11*b1+m12*d1;
			this.m21  = m21*a1+m22*c1;
			this.m22  = m21*b1+m22*d1;
			this.dx = dx*a1+dy*c1+this.dx;
			this.dy = dx*b1+dy*d1+this.dy;
			return this;
		},

		/**
		 * Prepends the specified matrix with this matrix.
		 * @method prependMatrix
		 * @param {TransformMatrix} matrix
		 **/
		prependMatrix : function(matrix) {
			this.prepend(matrix.m11, matrix.m12, matrix.m21, matrix.m22, matrix.dx, matrix.dy);
			this.prependProperties(matrix.alpha, matrix.shadow,  matrix.compositeOperation);
			return this;
		},

		/**
		 * Appends the specified matrix with this matrix.
		 * 指定した Matrixをこの Matrixに追加します。
		 * @method appendMatrix
		 * @param {TransformMatrix} matrix
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		appendMatrix : function(matrix) {
			this.append(matrix.m11, matrix.m12, matrix.m21, matrix.m22, matrix.dx, matrix.dy);
			this.appendProperties(matrix.alpha, matrix.shadow,  matrix.compositeOperation);
			return this;
		},

		/**
		 * Generates matrix properties from the specified display object transform properties, and prepends them with this matrix.
		 * For example, you can use this to generate a matrix from a display object: var mtx = new TransformMatrix();
		 * mtx.prependTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);
		 * @method prependTransform
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} scaleX
		 * @param {Number} scaleY
		 * @param {Number} rotation
		 * @param {Number} skewX
		 * @param {Number} skewY
		 * @param {Number} regX Optional.
		 * @param {Number} regY Optional.
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		prependTransform : function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
			if (rotation%360) {
				var r = rotation*DEG_TO_RAD;
				var cos = Math.cos(r);
				var sin = Math.sin(r);
			} else {
				cos = 1;
				sin = 0;
			}

			if (regX || regY) {
				// append the registration offset:
				this.dx -= regX; this.dy -= regY;
			}
			if (skewX || skewY) {
				// TODO: can this be combined into a single prepend operation?
				skewX *= DEG_TO_RAD;
				skewY *= DEG_TO_RAD;
				this.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);
				this.prepend(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
			} else {
				this.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);
			}
			return this;
		},

		/**
		 * Generates matrix properties from the specified display object transform properties, and appends them with this matrix.
		 * For example, you can use this to generate a matrix from a display object: var mtx = new TransformMatrix();
		 * mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);
		 * @method appendTransform
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} scaleX
		 * @param {Number} scaleY
		 * @param {Number} rotation
		 * @param {Number} skewX
		 * @param {Number} skewY
		 * @param {Number} regX Optional.
		 * @param {Number} regY Optional.
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		appendTransform : function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
			if (rotation%360) {
				var r = rotation*DEG_TO_RAD;
				var cos = Math.cos(r);
				var sin = Math.sin(r);
			} else {
				cos = 1;
				sin = 0;
			}

			if (skewX || skewY) {
				// TODO: can this be combined into a single append?
				skewX *= DEG_TO_RAD;
				skewY *= DEG_TO_RAD;
				this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
				this.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);
			} else {
				this.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);
			}

			if (regX || regY) {
				// prepend the registration offset:
				this.dx -= regX*this.m11+regY*this.m21; 
				this.dy -= regX*this.m12+regY*this.m22;
			}
			return this;
		},

		/**
		 * Applies a rotation transformation to the matrix.
		 * @method rotate
		 * @param {Number} angle The angle in degrees.
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		rotate : function(angle) {
			var cos = Math.cos(angle);
			var sin = Math.sin(angle);

			var a1 = this.m11;
			var c1 = this.m21;
			var tx1 = this.dx;

			this.m11 = a1*cos-this.m12*sin;
			this.m12 = a1*sin+this.m12*cos;
			this.m21 = c1*cos-this.m22*sin;
			this.m22 = c1*sin+this.m22*cos;
			this.dx = tx1*cos-this.dy*sin;
			this.dy = tx1*sin+this.dy*cos;
			return this;
		},

		/**
		 * Applies a skew transformation to the matrix.
		 * @method skew
		 * @param {Number} skewX The amount to skew horizontally in degrees.
		 * @param {Number} skewY The amount to skew vertically in degrees.
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		*/
		skew : function(skewX, skewY) {
			skewX = skewX*DEG_TO_RAD;
			skewY = skewY*DEG_TO_RAD;
			this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), 0, 0);
			return this;
		},

		/**
		 * Applies a scale transformation to the matrix.
		 * @method scale
		 * @param {Number} x
		 * @param {Number} y
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		scale : function(x, y) {
			this.m11 *= x;
			this.m22 *= y;
			this.dx *= x;
			this.dy *= y;
			return this;
		},

		/**
		 * Translates the matrix on the x and y axes.
		 * @method translate
		 * @param {Number} x
		 * @param {Number} y
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		translate : function(x, y) {
			this.dx += x;
			this.dy += y;
			return this;
		},

		/**
		 * Sets the properties of the matrix to those of an identity matrix (one that applies a null transformation).
		 * @method identity
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		identity : function() {
			this.alpha = this.m11 = this.m22 = 1;
			this.m12 = this.m21 = this.dx = this.dy = 0;
			this.shadow = this.compositeOperation = null;
			return this;
		},

		/**
		 * Inverts the matrix, causing it to perform the opposite transformation.
		 * @method invert
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		invert : function() {
			var a1 = this.m11;
			var b1 = this.m12;
			var c1 = this.m21;
			var d1 = this.m22;
			var tx1 = this.dx;
			var n = a1*d1-b1*c1;

			this.m11 = d1/n;
			this.m12 = -b1/n;
			this.m21 = -c1/n;
			this.m22 = a1/n;
			this.dx = (c1*this.dy-d1*tx1)/n;
			this.dy = -(a1*this.dy-b1*tx1)/n;
			return this;
		},

		/**
		 * Returns true if the matrix is an identity matrix.
		 * @method isIdentity
		 * @return {Boolean}
		 **/
		isIdentity : function() {
			return this.dx == 0 && this.dy == 0 && this.m11 == 1 && this.m12 == 0 && this.m21 == 0 && this.m22 == 1;
		},

		/**
		 * Decomposes the matrix into transform properties (x, y, scaleX, scaleY, and rotation). Note that this these values
		 * may not match the transform properties you used to generate the matrix, though they will produce the same visual
		 * results.
		 * @method decompose
		 * @param {Object} target The object to apply the transform properties to. If null, then a new object will be returned.
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		*/
		decompose : function(target) {
			// TODO: it would be nice to be able to solve for whether the matrix can be decomposed into only scale/rotation
			// even when scale is negative
			if (target == null) { target = {}; }
			target.x = this.dx;
			target.y = this.dy;
			target.scaleX = Math.sqrt(this.m11 * this.m11 + this.m12 * this.m12);
			target.scaleY = Math.sqrt(this.m21 * this.m21 + this.m22 * this.m22);

			var skewX = Math.atan2(-this.m21, this.m22);
			var skewY = Math.atan2(this.m12, this.m11);

			if (skewX == skewY) {
				target.rotation = skewY/DEG_TO_RAD;
				if (this.m11 < 0 && this.m22 >= 0) {
					target.rotation += (target.rotation <= 0) ? 180 : -180;
				}
				target.skewX = target.skewY = 0;
			} else {
				target.skewX = skewX/DEG_TO_RAD;
				target.skewY = skewY/DEG_TO_RAD;
			}
			return target;
		},

		/**
		 * Reinitializes all matrix properties to those specified.
		 * @method appendProperties
		 * @param {Number} m11
		 * @param {Number} m12
		 * @param {Number} m21
		 * @param {Number} m22
		 * @param {Number} dx
		 * @param {Number} dy
		 * @param {Number} alpha desired alpha value
		 * @param {Shadow} shadow desired shadow value
		 * @param {String} compositeOperation desired composite operation value
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		*/
		reinitialize : function(m11,m12,m21,m22,dx,dy,alpha,shadow,compositeOperation) {
			this._initialize(m11,m12,m21,m22,dx,dy);
			this.alpha = alpha || 1;
			this.shadow = shadow;
			this.compositeOperation = compositeOperation;
			return this;
		},

		/**
		 * Appends the specified visual properties to the current matrix.
		 * @method appendProperties
		 * @param {Number} alpha desired alpha value
		 * @param {Shadow} shadow desired shadow value
		 * @param {String} compositeOperation desired composite operation value
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		*/
		appendProperties : function(alpha, shadow, compositeOperation) {
			this.alpha *= alpha;
			this.shadow = shadow || this.shadow;
			this.compositeOperation = compositeOperation || this.compositeOperation;
			return this;
		},

		/**
		 * Prepends the specified visual properties to the current matrix.
		 * @method prependProperties
		 * @param {Number} alpha desired alpha value
		 * @param {Shadow} shadow desired shadow value
		 * @param {String} compositeOperation desired composite operation value
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		*/
		prependProperties : function(alpha, shadow, compositeOperation) {
			this.alpha *= alpha;
			this.shadow = this.shadow || shadow;
			this.compositeOperation = this.compositeOperation || compositeOperation;
			return this;
		},

		/**
		 *Multiply TransformMatrix by another TransformMatrix.
		 */
		multiply: function(matrix){
			// summary:
			//		combines matrices by multiplying them sequentially in the given order
			// matrix: TransformMatrix
			//		a 2D matrix-like object,
			//		all subsequent arguments are matrix-like objects too

			// combine matrices
			var m11 = this.m11,m12 = this.m12,m21 = this.m21,m22=this.m22,dx=this.dx,dy=this.dy;
			var r = matrix;
			this.m11 = m11 * r.m11 + m21 * r.m12;
			this.m12 = m12 * r.m11 + m22 * r.m12;
			this.m21 = m11 * r.m21 + m21 * r.m22;
			this.m22 = m12 * r.m21 + m22 * r.m22;
			this.dx =  m11 * r.dx + m21 * r.dy + dx;
			this.dy =  m12 * r.dx + m22 * r.dy + dy;
			return this // TransformMatrix
		},

		/**
		 * Returns a clone of the TransformMatrix instance.
		 * @method clone
		 * @return {TransformMatrix} a clone of the TransformMatrix instance.
		 **/
		clone : function() {

			var _ = this._,
				mtx = new TransformMatrix(_.m11, _.m12, _.m21, _.m22, _.dx, _.dy);
			mtx.shadow = this.shadow;
			mtx.alpha = this.alpha;
			mtx.compositeOperation = this.compositeOperation;
			return mtx;
		},

		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		toString : function() {
			var _ = this._;
			return "[TransformMatrix (m11="+_.m11+" m12="+_.m12+" m21="+_.m21+" m22="+_.m22+" dx="+_.dx+" dy="+_.dy+")]";
		},
		
		"_construct" : function(m11, m12, m21, m22, dx, dy) {
			var _ = this._ = {};
			_.m11 = m11 || 1;
			_.m12 = m12 || 0;
			_.m21 = m21 || 0;
			_.m22 = m22 || 1;
			_.dx = dx || 0;
			_.dy = dy || 0;
		}

	});
	
	Object.assign(TransformMatrix,{
		translate: function(a, b){
			// summary:
			//		forms a translation matrix
			// description:
			//		The resulting matrix is used to translate (move) points by specified offsets.
			// a: Number
			//		an x coordinate value
			// b: Number
			//		a y coordinate value
			// returns: TransformMatrix
			//|----------| |-----------|
			//|m11|m21|dx| |  1|   0| a|
			//|----------| |-----------|
			//|m12|m22|dy| |  0|   1| b|
			//|----------| |-----------|
			//|  0|  0| 1| |  0|   0| 1|
			//|----------| |-----------|

			return new TransformMatrix(1,0,0,1,a,b); // TransformMatrix
		},
		scale: function(a, b){
			// summary:
			//		forms a scaling matrix
			// description:
			//		The resulting matrix is used to scale (magnify) points by specified offsets.
			// a: Number
			//		a scaling factor used for the x coordinate
			// b: Number?
			//		a scaling factor used for the y coordinate
			// returns: TransformMatrix
			//|----------| |-----------|
			//|m11|m21|dx| |  a|   0| 0|
			//|----------| |-----------|
			//|m12|m22|dy| |  0|   b| 0|
			//|----------| |-----------|
			//|  0|  0| 1| |  0|   0| 1|
			//|----------| |-----------|
			return new TransformMatrix(a,0,0,b?b:a,0,0); // TransformMatrix
		},
		rotate: function(angle){
			// summary:
			//		forms a rotating matrix
			// description:
			//		The resulting matrix is used to rotate points
			//		around the origin of coordinates (0, 0) by specified angle.
			// angle: Number
			//		an angle of rotation in radians (>0 for CW)
			// returns: TransformMatrix
			//|----------| |-----------|
			//|m11|m21|dx| |cos|-sin| 0|
			//|----------| |-----------|
			//|m12|m22|dy| |sin| cos| 0|
			//|----------| |-----------|
			//|  0|  0| 1| |  0|   0| 1|
			//|----------| |-----------|
			var cos = Math.cos(angle);
			var sin = Math.sin(angle);
			return new TransformMatrix(cos,sin,-sin,cos,0,0); // TransformMatrix
		},
		rotateg: function(degree){
			// summary:
			//		forms a rotating matrix
			// description:
			//		The resulting matrix is used to rotate points
			//		around the origin of coordinates (0, 0) by specified degree.
			//		Seerotate() for comparison.
			// degree: Number
			//		an angle of rotation in degrees (>0 for CW)
			// returns: TransformMatrix
			return this.rotate(degToRad(degree)); // TransformMatrix
		},
		skewX: function(angle) {
			//TODO : will be modified
			// summary:
			//		forms an x skewing matrix
			// description:
			//		The resulting matrix is used to skew points in the x dimension
			//		around the origin of coordinates (0, 0) by specified angle.
			// angle: Number
			//		a skewing angle in radians
			// returns: TransformMatrix
			//|----------| |-----------|
			//|m11|m21|dx| |  1| tan| 0|
			//|----------| |-----------|
			//|m12|m22|dy| |  0|   1| 0|
			//|----------| |-----------|
			//|  0|  0| 1| |  0|   0| 1|
			//|----------| |-----------|
			var tan = Math.tan(angle);
			return new TransformMatrix(1,0,tan,1); // TransformMatrix
		},
		skewXg: function(degree){
			//TODO : will be modified
			// summary:
			//		forms an x skewing matrix
			// description:
			//		The resulting matrix is used to skew points in the x dimension
			//		around the origin of coordinates (0, 0) by specified degree.
			//		See dojox/gfx/matrix.skewX() for comparison.
			// degree: Number
			//		a skewing angle in degrees
			// returns: TransformMatrix
			return this.skewX(degToRad(degree)); // dojox/gfx/matrix.TransformMatrix
		},
		skewY: function(angle){
			//TODO : will be modified
			// summary:
			//		forms a y skewing matrix
			// description:
			//		The resulting matrix is used to skew points in the y dimension
			//		around the origin of coordinates (0, 0) by specified angle.
			// angle: Number
			//		a skewing angle in radians
			// returns: TransformMatrix
			//|----------| |-----------|
			//|m11|m21|dx| |  1|   0| 0|
			//|----------| |-----------|
			//|m12|m22|dy| |tan|   1| 0|
			//|----------| |-----------|
			//|  0|  0| 1| |  0|   0| 1|
			//|----------| |-----------|
			var tan = Math.tan(angle);

			return new TransformMatrix(1,tan,0,1); // TransformMatrix
		},
		skewYg: function(degree){
			//TODO : will be modified
			// summary:
			//		forms a y skewing matrix
			// description:
			//		The resulting matrix is used to skew points in the y dimension
			//		around the origin of coordinates (0, 0) by specified degree.
			//		See skewY() for comparison.
			// degree: Number
			//		a skewing angle in degrees
			// returns: TransformMatrix
			return this.skewY(degToRad(degree)); // TransformMatrix
		},
		reflect: function(a, b){
			// summary:
			//		forms a reflection matrix
			// description:
			//		The resulting matrix is used to reflect points around a vector,
			//		which goes through the origin.
			// a: dojox/gfx.Point|Number
			//		a point-like object, which specifies a vector of reflection, or an X value
			// b: Number?
			//		a Y value
			// returns: TransformMatrix
			if(arguments.length == 1){
				b = a.y;
				a = a.x;
			}
			// make a unit vector
			var a2 = a * a, b2 = b * b, n2 = a2 + b2, 
				xx=2 * a2 / n2 - 1, 
				xy = 2 * a * b / n2,
				yx = xy,
				yy = 2 * b2 / n2 - 1;
			return new TransformMatrix(xx,yx,xy, yy); // TransformMatrix
		},
		project: function(a, b){
			// summary:
			//		forms an orthogonal projection matrix
			// description:
			//		The resulting matrix is used to project points orthogonally on a vector,
			//		which goes through the origin.
			// a:   Number
			//		an x coordinate value
			// b: Number?
			//		a y coordinate value
			// returns: TransformMatrix

			// make a unit vector
			var a2 = a * a, b2 = b * b, n2 = a2 + b2, 
				xx = a2 / n2,
				xy = a * b / n2
				yx = xy,
				yy = b2 / n2;
			return new TransformMatrix(xx,yx,xy,yy); // TransformMatrix
		},

		// common operations

		// high level operations

		_sandwich: function(matrix, x, y){
			// summary:
			//		applies a matrix at a central point
			// matrix: TransformMatrix
			//		a 2D matrix-like object, which is applied at a central point
			// x: Number
			//		an x component of the central point
			// y: Number
			//		a y component of the central point
			return this.translate(x, y).multiply(matrix)
			                           .multiply(this.translate(-x, -y)); // TransformMatrix
		},
		scaleAt: function(a, b, c, d){
			// summary:
			//		scales a picture using a specified point as a center of scaling
			// description:
			//		Compare with scale().
			// a: Number
			//		a scaling factor used for the x coordinate, or a uniform scaling factor used for both coordinates
			// b: Number?
			//		a scaling factor used for the y coordinate
			// c: Number|Point
			//		an x component of a central point, or a central point
			// d: Number
			//		a y component of a central point
			// returns: TransformMatrix
			switch(arguments.length){
				case 4:
					// a and b are scale factor components, c and d are components of a point
					return this._sandwich(this.scale(a, b), c, d); // TransformMatrix
				case 3:
					if(typeof c == "number"){
						return this._sandwich(this.scale(a), b, c); // TransformMatrix
					}
					return this._sandwich(this.scale(a, b), c.x, c.y); // TransformMatrix
			}
			return this._sandwich(this.scale(a), b.x, b.y); // TransformMatrix
		},
		rotateAt: function(angle, a, b){
			// summary:
			//		rotates a picture using a specified point as a center of rotation
			// description:
			//		Compare with rotate().
			// angle: Number
			//		an angle of rotation in radians (>0 for CW)
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: TransformMatrix
			if(arguments.length > 2){
				return this._sandwich(this.rotate(angle), a, b); // TransformMatrix
			}
			return this._sandwich(this.rotate(angle), a.x, a.y); // TransformMatrix
		},
		rotategAt: function(degree, a, b){
			// summary:
			//		rotates a picture using a specified point as a center of rotation
			// description:
			//		Compare with rotateg().
			// degree: Number
			//		an angle of rotation in degrees (>0 for CW)
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: TransformMatrix
			if(arguments.length > 2){
				return this._sandwich(this.rotateg(degree), a, b); // TransformMatrix
			}
			return this._sandwich(this.rotateg(degree), a.x, a.y); // TransformMatrix
		},
		skewXAt: function(angle, a, b){
			// summary:
			//		skews a picture along the x axis using a specified point as a center of skewing
			// description:
			//		Compare with skewX().
			// angle: Number
			//		a skewing angle in radians
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: TransformMatrix
			if(arguments.length > 2){
				return this._sandwich(this.skewX(angle), a, b); // TransformMatrix
			}
			return this._sandwich(this.skewX(angle), a.x, a.y); // TransformMatrix
		},
		skewXgAt: function(degree, a, b){
			// summary:
			//		skews a picture along the x axis using a specified point as a center of skewing
			// description:
			//		Compare with skewXg().
			// degree: Number
			//		a skewing angle in degrees
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: TransformMatrix
			if(arguments.length > 2){
				return this._sandwich(this.skewXg(degree), a, b); // TransformMatrix
			}
			return this._sandwich(this.skewXg(degree), a.x, a.y); // TransformMatrix
		},
		skewYAt: function(angle, a, b){
			// summary:
			//		skews a picture along the y axis using a specified point as a center of skewing
			// description:
			//		Compare with skewY().
			// angle: Number
			//		a skewing angle in radians
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: TransformMatrix
			if(arguments.length > 2){
				return this._sandwich(this.skewY(angle), a, b); // TransformMatrix
			}
			return this._sandwich(this.skewY(angle), a.x, a.y); // TransformMatrix
		},
		skewYgAt: function(/* Number */ degree, /* Number||Point */ a, /* Number? */ b){
			// summary:
			//		skews a picture along the y axis using a specified point as a center of skewing
			// description:
			//		Compare with skewYg().
			// degree: Number
			//		a skewing angle in degrees
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: TransformMatrix
			if(arguments.length > 2){
				return this._sandwich(this.skewYg(degree), a, b); // TransformMatrix
			}
			return this._sandwich(this.skewYg(degree), a.x, a.y); // TransformMatrix
		}
	
	
	});

	return numerics.TransformMatrix = TransformMatrix;
});

define('skylark-langx-numerics/translate-transform',[
    "./numerics",
    "./transform",
    "./matrix-transform"
],function(numerics,Transform,Matrix,Point,Rect) {

    //|1   0   dx|
    //|0   1   dy|
    //|0   0    1|

   var TranslateTransform =  Transform.inherit({
        "klassName": "TranslateTransform",

        "value": {
            get: function() {
                    return Matrix.scaleAt(this.x, this.y);
            }
        },

        "x": {
            get : function() {
                return this._.x;
            }
        },

        "y": {
            get : function() {
                return this._.y;
            }
        },

        clone: /*SkewTransform*/ function() {},

        transform: /*Point*/ function( /*Point*/ point) {},

        transformBounds: /*Rect*/ function( /*Rect*/ rect) {},

        "init": function( /*Number*/ x, /*Number*/ y) {
            var _ = this._;

            _.x = x ? x : 0;
            _.y = y ? y : 0;
        }
    });

    return numerics.TranslateTransform =TranslateTransform;
});	

define('skylark-langx-numerics/vector4',[
	"skylark-langx-klass",
	"./numerics"
] ,function(klass,numerics) {

	var Vector4 = klass({
		"klassName" : "Vector4",

		set: function ( x, y, z, w ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;
		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setW: function ( w ) {

			this.w = w;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;
		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z, this.w );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

			return this;

		},

		applyMatrix4: function ( m ) {

			var x = this.x, y = this.y, z = this.z, w = this.w;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		setAxisAngleFromQuaternion: function ( q ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos( q.w );

			var s = Math.sqrt( 1 - q.w * q.w );

			if ( s < 0.0001 ) {

				this.x = 1;
				this.y = 0;
				this.z = 0;

			} else {

				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;

			}

			return this;

		},

		setAxisAngleFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
			     ( Math.abs( m13 - m31 ) < epsilon ) &&
			     ( Math.abs( m23 - m32 ) < epsilon ) ) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
				     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
				     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
				     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

					// this singularity is identity matrix so angle = 0

					this.set( 1, 0, 0, 0 );

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;

				if ( ( xx > yy ) && ( xx > zz ) ) {

					// m11 is the largest diagonal term

					if ( xx < epsilon ) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;

					}

				} else if ( yy > zz ) {

					// m22 is the largest diagonal term

					if ( yy < epsilon ) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;

					}

				} else {

					// m33 is the largest diagonal term so base result on this

					if ( zz < epsilon ) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;

					}

				}

				this.set( x, y, z, angle );

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			                   ( m13 - m31 ) * ( m13 - m31 ) +
			                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

			if ( Math.abs( s ) < 0.001 ) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

			return this;

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
			this.w = Math.max( min.w, Math.min( max.w, this.w ) );

			return this;

		},

		clampScalar: function ( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
			this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
			this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

			return this;

		},

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'Vector4: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );
			this.w = attribute.getW( index );

			return this;

		},


		"_construct" :function ( x, y, z, w ) {

			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;
			this.w = ( w !== undefined ) ? w : 1;

		}

	});

/*
	Object.defineProperties( Vector4.prototype, {

		"width": {

			get: function () {

				return this.z;

			},

			set: function ( value ) {

				this.z = value;

			}

		},

		"height": {

			get: function () {

				return this.w;

			},

			set: function ( value ) {

				this.w = value;

			}

		}

	} );
*/

	return numerics.Vector4 = Vector4 ;

});
define('skylark-langx-numerics/main',[
	"./numerics",
	"./euler",
	"./maths",
	"./matrix3",
	"./matrix4",
	"./matrix-transform",
	"./plane",
	"./quaternion",
	"./rotate-transform",
	"./scale-transform",
	"./skew-transform",
	"./transform",
	"./transform-matrix",
	"./translate-transform",
	"./vector2",
	"./vector3",
	"./vector4"
],function(numerics){
	return numerics;
});
define('skylark-langx-numerics', ['skylark-langx-numerics/main'], function (main) { return main; });

define('skylark-langx/numerics',[
	"skylark-langx-numerics"
],function(numerics){
	return numerics;
});
define('skylark-langx/objects',[
    "skylark-langx-objects"
],function(objects){
    return objects;
});
define('skylark-langx/Evented',[
    "./emitter"
],function(Emitter){
    return Emitter;
});
define('skylark-langx-strings/strings',[
    "skylark-langx-ns"
],function(skylark){
    return skylark.attach("langx.strings");
});
define('skylark-langx-strings/base64',[
	"./strings"
],function(strings) {

	// private property
	const _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

	// private method for UTF-8 encoding
	function _utf8_encode(string) {
		string = string.replace(/\r\n/g,"\n");
		var utftext = "";

		for (var n = 0; n < string.length; n++) {

			var c = string.charCodeAt(n);

			if (c < 128) {
				utftext += String.fromCharCode(c);
			}
			else if((c > 127) && (c < 2048)) {
				utftext += String.fromCharCode((c >> 6) | 192);
				utftext += String.fromCharCode((c & 63) | 128);
			}
			else {
				utftext += String.fromCharCode((c >> 12) | 224);
				utftext += String.fromCharCode(((c >> 6) & 63) | 128);
				utftext += String.fromCharCode((c & 63) | 128);
			}

		}

		return utftext;
	}

	// private method for UTF-8 decoding
	function _utf8_decode(utftext) {
		var string = "";
		var i = 0;
		var c = c1 = c2 = 0;

		while ( i < utftext.length ) {

			c = utftext.charCodeAt(i);

			if (c < 128) {
				string += String.fromCharCode(c);
				i++;
			}
			else if((c > 191) && (c < 224)) {
				c2 = utftext.charCodeAt(i+1);
				string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
				i += 2;
			}
			else {
				c2 = utftext.charCodeAt(i+1);
				c3 = utftext.charCodeAt(i+2);
				string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
				i += 3;
			}

		}

		return string;
	}

	// public method for encoding
	function encode(input, binary) {
		binary = (binary != null) ? binary : false;
		var output = "";
		var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
		var i = 0;

		if (!binary)
		{
			input = _utf8_encode(input);
		}

		while (i < input.length) {

			chr1 = input.charCodeAt(i++);
			chr2 = input.charCodeAt(i++);
			chr3 = input.charCodeAt(i++);

			enc1 = chr1 >> 2;
			enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
			enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
			enc4 = chr3 & 63;

			if (isNaN(chr2)) {
				enc3 = enc4 = 64;
			} else if (isNaN(chr3)) {
				enc4 = 64;
			}

			output = output +
			this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +
			this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);

		}

		return output;
	}

	// public method for decoding
	function decode(input, binary) {
		binary = (binary != null) ? binary : false;
		var output = "";
		var chr1, chr2, chr3;
		var enc1, enc2, enc3, enc4;
		var i = 0;

		input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

		while (i < input.length) {

			enc1 = this._keyStr.indexOf(input.charAt(i++));
			enc2 = this._keyStr.indexOf(input.charAt(i++));
			enc3 = this._keyStr.indexOf(input.charAt(i++));
			enc4 = this._keyStr.indexOf(input.charAt(i++));

			chr1 = (enc1 << 2) | (enc2 >> 4);
			chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
			chr3 = ((enc3 & 3) << 6) | enc4;

			output = output + String.fromCharCode(chr1);

			if (enc3 != 64) {
				output = output + String.fromCharCode(chr2);
			}
			if (enc4 != 64) {
				output = output + String.fromCharCode(chr3);
			}

		}

		if (!binary) {
			output = _utf8_decode(output);
		}

		return output;

	}


	return strings.base64 = {
		decode,
		encode
	};
	
});
define('skylark-langx-strings/camel-case',[
	"./strings"
],function(strings){
    function camelCase(str) {
        return str.replace(/-([\da-z])/g, function(a) {
            return a.toUpperCase().replace('-', '');
        });
    }

	
	return strings.camelCase = camelCase;
});
define('skylark-langx-strings/dasherize',[
	"./strings"
],function(strings){
     /*
     * Converts camel case into dashes.
     * @param {String} str
     * @return {String}
     * @exapmle marginTop -> margin-top
     */
    function dasherize(str) {
        return str.replace(/::/g, '/')
            .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')
            .replace(/([a-z\d])([A-Z])/g, '$1_$2')
            .replace(/_/g, '-')
            .toLowerCase();
    }

	
	return strings.dasherize = dasherize;
});
define('skylark-langx-strings/deserialize-value',[
	"./strings"
],function(strings){
    function deserializeValue(value) {
        try {
            return value ?
                value == "true" ||
                (value == "false" ? false :
                    value == "null" ? null :
                    +value + "" == value ? +value :
                    /^[\[\{]/.test(value) ? JSON.parse(value) :
                    value) : value;
        } catch (e) {
            return value;
        }
    }



	
	return strings.deserializeValue = deserializeValue;
});
define('skylark-langx-strings/escape-html',[
	"./strings"
],function(strings){
    // add default escape function for escaping HTML entities
    var escapeCharMap = Object.freeze({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '`': '&#x60;',
        '=': '&#x3D;',
    });
    function replaceChar(c) {
        return escapeCharMap[c];
    }
    var escapeChars = /[&<>"'`=]/g;

    function escapeHTML(str) {
        if (str == null) {
            return '';
        }
        if (!str) {
            return String(str);
        }

        return str.toString().replace(escapeChars, replaceChar);
    }

	
	return strings.escapeHTML = escapeHTML;
});
define('skylark-langx-strings/generate-uuid',[
	"./strings"
],function(strings){
    function generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = Math.random() * 16 | 0;
            var v = c === 'x' ? r : ((r & 0x3) | 0x8);
            return v.toString(16);
        });
    }

	return strings.generateUUID = generateUUID;
});
define('skylark-langx-strings/lower-first',[
	"./strings"
],function(strings){
    function lowerFirst(str) {
        return str.charAt(0).toLowerCase() + str.slice(1);
    }
	
	return strings.lowerFirst = lowerFirst;
});
define('skylark-langx-strings/ltrim',[
	"./strings"
],function(strings){

    function ltrim(str) {
        return str.replace(/^\s+/, '');
    }
	
	return strings.ltrim = ltrim;
});
define('skylark-langx-strings/rtrim',[
	"./strings"
],function(strings){
    function rtrim(str) {
        return str.replace(/\s+$/, '');
    }
	
	return strings.rtrim = rtrim;
});
define('skylark-langx-strings/serialize-value',[
	"./strings"
],function(strings){
    function serializeValue(value) {
        return JSON.stringify(value)
    }
	
	return strings.serializeValue = serializeValue;
});
define('skylark-langx-strings/slugify',[
	"./strings"
],function(strings){
    // Slugify a string
    function slugify(str) {
        str = str.replace(/^\s+|\s+$/g, '');

        // Make the string lowercase
        str = str.toLowerCase();

        // Remove accents, swap ñ for n, etc
        var from = "ÁÄÂÀÃÅČÇĆĎÉĚËÈÊẼĔȆÍÌÎÏŇÑÓÖÒÔÕØŘŔŠŤÚŮÜÙÛÝŸŽáäâàãåčçćďéěëèêẽĕȇíìîïňñóöòôõøðřŕšťúůüùûýÿžþÞĐđßÆa·/_,:;";
        var to   = "AAAAAACCCDEEEEEEEEIIIINNOOOOOORRSTUUUUUYYZaaaaaacccdeeeeeeeeiiiinnooooooorrstuuuuuyyzbBDdBAa------";
        for (var i=0, l=from.length ; i<l ; i++) {
            str = str.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i));
        }

        // Remove invalid chars
        //str = str.replace(/[^a-z0-9 -]/g, '') 
        // Collapse whitespace and replace by -
        str = str.replace(/\s+/g, '-') 
        // Collapse dashes
        .replace(/-+/g, '-'); 

        return str;
    }    

	return strings.slugify = slugify;
});
define('skylark-langx-strings/substitute',[
	"./strings"
],function(strings){
    function substitute( /*String*/ template,
        /*Object|Array*/
        map,
        /*Function?*/
        transform,
        /*Object?*/
        thisObject) {
        // summary:
        //    Performs parameterized substitutions on a string. Throws an
        //    exception if any parameter is unmatched.
        // template:
        //    a string with expressions in the form `${key}` to be replaced or
        //    `${key:format}` which specifies a format function. keys are case-sensitive.
        // map:
        //    hash to search for substitutions
        // transform:
        //    a function to process all parameters before substitution takes


        thisObject = thisObject || window;
        transform = transform ?
            proxy(thisObject, transform) : function(v) {
                return v;
            };

        function getObject(key, map) {
            if (key.match(/\./)) {
                var retVal,
                    getValue = function(keys, obj) {
                        var _k = keys.pop();
                        if (_k) {
                            if (!obj[_k]) return null;
                            return getValue(keys, retVal = obj[_k]);
                        } else {
                            return retVal;
                        }
                    };
                return getValue(key.split(".").reverse(), map);
            } else {
                return map[key];
            }
        }

        return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g,
            function(match, key, format) {
                var value = getObject(key, map);
                if (format) {
                    value = getObject(format, thisObject).call(thisObject, value, key);
                }
                return transform(value, key).toString();
            }); // String
    }

	return strings.substitute = substitute;
});
define('skylark-langx-strings/trim',[
	"./strings"
],function(strings){
    function trim(str) {
        return str == null ? "" : String.prototype.trim.call(str);
    }
	
	return strings.trim = trim;
});
define('skylark-langx-strings/trim-null',[
	"./strings"
],function(strings){
    const NullCharactersRegExp = /\x00/g;

    /**
     * @param {string} str
     */
    function trimNull(str) {
      if (typeof str !== "string") {
        warn("The argument for removeNullCharacters must be a string.");
        return str;
      }
      return str.replace(NullCharactersRegExp, "");
    }

	
	return strings.trimNull = trimNull;
});
define('skylark-langx-strings/unique-id',[
	"./strings"
],function(strings){

    var idCounter = 0;
    function uniqueId (prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
    }

	return strings.uniqueId = uniqueId;
});
define('skylark-langx-strings/upper-first',[
	"./strings"
],function(strings){

    function upperFirst(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
	
	return strings.upperFirst = upperFirst;
});
define('skylark-langx-strings/words',[
	"./strings"
],function(strings){
	/** Used to compose unicode character classes. */
	const rsAstralRange = '\\ud800-\\udfff'
	const rsComboMarksRange = '\\u0300-\\u036f'
	const reComboHalfMarksRange = '\\ufe20-\\ufe2f'
	const rsComboSymbolsRange = '\\u20d0-\\u20ff'
	const rsComboMarksExtendedRange = '\\u1ab0-\\u1aff'
	const rsComboMarksSupplementRange = '\\u1dc0-\\u1dff'
	const rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange
	const rsDingbatRange = '\\u2700-\\u27bf'
	const rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff'
	const rsMathOpRange = '\\xac\\xb1\\xd7\\xf7'
	const rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf'
	const rsPunctuationRange = '\\u2000-\\u206f'
	const rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000'
	const rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde'
	const rsVarRange = '\\ufe0e\\ufe0f'
	const rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange

	/** Used to compose unicode capture groups. */
	const rsApos = "['\u2019]"
	const rsBreak = `[${rsBreakRange}]`
	const rsCombo = `[${rsComboRange}]`
	const rsDigit = '\\d'
	const rsDingbat = `[${rsDingbatRange}]`
	const rsLower = `[${rsLowerRange}]`
	const rsMisc = `[^${rsAstralRange}${rsBreakRange + rsDigit + rsDingbatRange + rsLowerRange + rsUpperRange}]`
	const rsFitz = '\\ud83c[\\udffb-\\udfff]'
	const rsModifier = `(?:${rsCombo}|${rsFitz})`
	const rsNonAstral = `[^${rsAstralRange}]`
	const rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}'
	const rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]'
	const rsUpper = `[${rsUpperRange}]`
	const rsZWJ = '\\u200d'

	/** Used to compose unicode regexes. */
	const rsMiscLower = `(?:${rsLower}|${rsMisc})`
	const rsMiscUpper = `(?:${rsUpper}|${rsMisc})`
	const rsOptContrLower = `(?:${rsApos}(?:d|ll|m|re|s|t|ve))?`
	const rsOptContrUpper = `(?:${rsApos}(?:D|LL|M|RE|S|T|VE))?`
	const reOptMod = `${rsModifier}?`
	const rsOptVar = `[${rsVarRange}]?`
	const rsOptJoin = `(?:${rsZWJ}(?:${[rsNonAstral, rsRegional, rsSurrPair].join('|')})${rsOptVar + reOptMod})*`
	const rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])'
	const rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])'
	const rsSeq = rsOptVar + reOptMod + rsOptJoin
	const rsEmoji = `(?:${[rsDingbat, rsRegional, rsSurrPair].join('|')})${rsSeq}`

	const reUnicodeWords = RegExp([
	  `${rsUpper}?${rsLower}+${rsOptContrLower}(?=${[rsBreak, rsUpper, '$'].join('|')})`,
	  `${rsMiscUpper}+${rsOptContrUpper}(?=${[rsBreak, rsUpper + rsMiscLower, '$'].join('|')})`,
	  `${rsUpper}?${rsMiscLower}+${rsOptContrLower}`,
	  `${rsUpper}+${rsOptContrUpper}`,
	  rsOrdUpper,
	  rsOrdLower,
	  `${rsDigit}+`,
	  rsEmoji
	].join('|'), 'g')

	/**
	 * Splits a Unicode `string` into an array of its words.
	 *
	 * @private
	 * @param {string} The string to inspect.
	 * @returns {Array} Returns the words of `string`.
	 */
	function unicodeWords(string) {
	  return string.match(reUnicodeWords)
	}


	const hasUnicodeWord = RegExp.prototype.test.bind(
	  /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/
	)

	/** Used to match words composed of alphanumeric characters. */
	const reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g

	function asciiWords(string) {
	  return string.match(reAsciiWord)
	}

	/**
	 * Splits `string` into an array of its words.
	 *
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to inspect.
	 * @param {RegExp|string} [pattern] The pattern to match words.
	 * @returns {Array} Returns the words of `string`.
	 * @example
	 *
	 * words('fred, barney, & pebbles')
	 * // => ['fred', 'barney', 'pebbles']
	 *
	 * words('fred, barney, & pebbles', /[^, ]+/g)
	 * // => ['fred', 'barney', '&', 'pebbles']
	 */
	function words(string, pattern) {
	  if (pattern === undefined) {
	    const result = hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string)
	    return result || []
	  }
	  return string.match(pattern) || []
	}

	
	return strings.words = words;
});
define('skylark-langx-strings/main',[
	"./strings",
	"./base64",
	"./camel-case",
	"./dasherize",
	"./deserialize-value",
	"./escape-html",
	"./generate-uuid",
	"./lower-first",
	"./ltrim",
	"./rtrim",
	"./serialize-value",
	"./slugify",
	"./substitute",
	"./trim",
	"./trim-null",
	"./unique-id",
	"./upper-first",
	"./words"
],function(strings){
	return strings;
});
define('skylark-langx-strings', ['skylark-langx-strings/main'], function (main) { return main; });

define('skylark-langx/strings',[
    "skylark-langx-strings"
],function(strings){
    return strings;
});
define('skylark-langx/stateful',[
	"./Evented",
  "./strings",
  "./objects"
],function(Evented,strings,objects){
    var isEqual = objects.isEqual,
        mixin = objects.mixin,
        result = objects.result,
        isEmptyObject = objects.isEmptyObject,
        clone = objects.clone,
        uniqueId = strings.uniqueId;

    var Stateful = Evented.inherit({
        _construct : function(attributes, options) {
            var attrs = attributes || {};
            options || (options = {});
            this.cid = uniqueId(this.cidPrefix);
            this.attributes = {};
            if (options.collection) this.collection = options.collection;
            if (options.parse) attrs = this.parse(attrs, options) || {};
            var defaults = result(this, 'defaults');
            attrs = mixin({}, defaults, attrs);
            this.set(attrs, options);
            this.changed = {};
        },

        // A hash of attributes whose current and previous value differ.
        changed: null,

        // The value returned during the last failed validation.
        validationError: null,

        // The default name for the JSON `id` attribute is `"id"`. MongoDB and
        // CouchDB users may want to set this to `"_id"`.
        idAttribute: 'id',

        // The prefix is used to create the client id which is used to identify models locally.
        // You may want to override this if you're experiencing name clashes with model ids.
        cidPrefix: 'c',


        // Return a copy of the model's `attributes` object.
        toJSON: function(options) {
          return clone(this.attributes);
        },


        // Get the value of an attribute.
        get: function(attr) {
          return this.attributes[attr];
        },

        // Returns `true` if the attribute contains a value that is not null
        // or undefined.
        has: function(attr) {
          return this.get(attr) != null;
        },

        // Set a hash of model attributes on the object, firing `"change"`. This is
        // the core primitive operation of a model, updating the data and notifying
        // anyone who needs to know about the change in state. The heart of the beast.
        set: function(key, val, options) {
          if (key == null) return this;

          // Handle both `"key", value` and `{key: value}` -style arguments.
          var attrs;
          if (typeof key === 'object') {
            attrs = key;
            options = val;
          } else {
            (attrs = {})[key] = val;
          }

          options || (options = {});

          // Run validation.
          if (!this._validate(attrs, options)) return false;

          // Extract attributes and options.
          var unset      = options.unset;
          var silent     = options.silent;
          var changes    = [];
          var changing   = this._changing;
          this._changing = true;

          if (!changing) {
            this._previousAttributes = clone(this.attributes);
            this.changed = {};
          }

          var current = this.attributes;
          var changed = this.changed;
          var prev    = this._previousAttributes;

          // For each `set` attribute, update or delete the current value.
          for (var attr in attrs) {
            val = attrs[attr];
            if (!isEqual(current[attr], val)) changes.push(attr);
            if (!isEqual(prev[attr], val)) {
              changed[attr] = val;
            } else {
              delete changed[attr];
            }
            unset ? delete current[attr] : current[attr] = val;
          }

          // Update the `id`.
          if (this.idAttribute in attrs) this.id = this.get(this.idAttribute);

          // Trigger all relevant attribute changes.
          if (!silent) {
            if (changes.length) this._pending = options;
            for (var i = 0; i < changes.length; i++) {
              this.trigger('change:' + changes[i], this, current[changes[i]], options);
            }
          }

          // You might be wondering why there's a `while` loop here. Changes can
          // be recursively nested within `"change"` events.
          if (changing) return this;
          if (!silent) {
            while (this._pending) {
              options = this._pending;
              this._pending = false;
              this.trigger('change', this, options);
            }
          }
          this._pending = false;
          this._changing = false;
          return this;
        },

        // Remove an attribute from the model, firing `"change"`. `unset` is a noop
        // if the attribute doesn't exist.
        unset: function(attr, options) {
          return this.set(attr, void 0, mixin({}, options, {unset: true}));
        },

        // Clear all attributes on the model, firing `"change"`.
        clear: function(options) {
          var attrs = {};
          for (var key in this.attributes) attrs[key] = void 0;
          return this.set(attrs, mixin({}, options, {unset: true}));
        },

        // Determine if the model has changed since the last `"change"` event.
        // If you specify an attribute name, determine if that attribute has changed.
        hasChanged: function(attr) {
          if (attr == null) return !isEmptyObject(this.changed);
          return this.changed[attr] !== undefined;
        },

        // Return an object containing all the attributes that have changed, or
        // false if there are no changed attributes. Useful for determining what
        // parts of a view need to be updated and/or what attributes need to be
        // persisted to the server. Unset attributes will be set to undefined.
        // You can also pass an attributes object to diff against the model,
        // determining if there *would be* a change.
        changedAttributes: function(diff) {
          if (!diff) return this.hasChanged() ? clone(this.changed) : false;
          var old = this._changing ? this._previousAttributes : this.attributes;
          var changed = {};
          for (var attr in diff) {
            var val = diff[attr];
            if (isEqual(old[attr], val)) continue;
            changed[attr] = val;
          }
          return !isEmptyObject(changed) ? changed : false;
        },

        // Get the previous value of an attribute, recorded at the time the last
        // `"change"` event was fired.
        previous: function(attr) {
          if (attr == null || !this._previousAttributes) return null;
          return this._previousAttributes[attr];
        },

        // Get all of the attributes of the model at the time of the previous
        // `"change"` event.
        previousAttributes: function() {
          return clone(this._previousAttributes);
        },

        // Create a new model with identical attributes to this one.
        clone: function() {
          return new this.constructor(this.attributes);
        },

        // A model is new if it has never been saved to the server, and lacks an id.
        isNew: function() {
          return !this.has(this.idAttribute);
        },

        // Check if the model is currently in a valid state.
        isValid: function(options) {
          return this._validate({}, mixin({}, options, {validate: true}));
        },

        // Run validation against the next complete set of model attributes,
        // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
        _validate: function(attrs, options) {
          if (!options.validate || !this.validate) return true;
          attrs = mixin({}, this.attributes, attrs);
          var error = this.validationError = this.validate(attrs, options) || null;
          if (!error) return true;
          this.trigger('invalid', this, error, mixin(options, {validationError: error}));
          return false;
        }
    });

	return Stateful;
});
define('skylark-langx-topic/topic',[
	"skylark-langx-ns",
	"skylark-langx-events"
],function(skylark,events){
	var hub = new events.Emitter();

	return skylark.attach("langx.topic",{
	    publish: function(name, arg1,argn) {
	        var data = [].slice.call(arguments, 1);

	        return hub.trigger({
	            type : name,
	            data : data
	        });
	    },

        subscribe: function(name, listener,ctx) {
        	var handler = function(e){
                listener.apply(ctx,e.data);
            };
            hub.on(name, handler);
            return {
            	remove : function(){
            		hub.off(name,handler);
            	}
            }

        }

	});
});
define('skylark-langx-topic/main',[
	"./topic"
],function(topic){
	return topic;
});
define('skylark-langx-topic', ['skylark-langx-topic/main'], function (main) { return main; });

define('skylark-langx/topic',[
	"skylark-langx-topic"
],function(topic){
	return topic;
});
define('skylark-langx/types',[
    "skylark-langx-types"
],function(types){
    return types;
});
define('skylark-langx-urls/urls',[
  "skylark-langx-ns"
],function(skylark){


    return skylark.attach("langx.urls",{

    });
});



define('skylark-langx-urls/create_object_url',[
    './urls'
], function (urls) {
    'use strict';

    const digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    function createObjectURL(data, contentType, forceDataSchema = false) {
        if (!forceDataSchema && URL.createObjectURL) {
            const blob = new Blob([data], { type: contentType });
            return URL.createObjectURL(blob);
        }
        let buffer = `data:${ contentType };base64,`;
        for (let i = 0, ii = data.length; i < ii; i += 3) {
            const b1 = data[i] & 255;
            const b2 = data[i + 1] & 255;
            const b3 = data[i + 2] & 255;
            const d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;
            const d3 = i + 1 < ii ? (b2 & 15) << 2 | b3 >> 6 : 64;
            const d4 = i + 2 < ii ? b3 & 63 : 64;
            buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
        }
        return buffer;
    };


    return urls.createObjectURL = createObjectURL;

});


define('skylark-langx-urls/create_valid_absolute_url',[
    './urls'
], function (urls) {
    'use strict';

    function _isValidProtocol(url) {
        if (!url) {
            return false;
        }
        switch (url.protocol) {
        case 'http:':
        case 'https:':
        case 'ftp:':
        case 'mailto:':
        case 'tel:':
            return true;
        default:
            return false;
        }
    }
    function createValidAbsoluteUrl(url, baseUrl) {
        if (!url) {
            return null;
        }
        try {
            const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
            if (_isValidProtocol(absoluteUrl)) {
                return absoluteUrl;
            }
        } catch (ex) {
        }
        return null;
    }

    return urls.createValidAbsoluteUrl = createValidAbsoluteUrl;

});


define('skylark-langx-urls/get-absolute-url',[
    './urls'
], function (urls) {
    'use strict';

    const getAbsoluteUrl = function (url) {
        if (!url.match(/^https?:\/\//)) {
            const div = document.createElement('div');
            div.innerHTML = `<a href="${ url }">x</a>`;
            url = div.firstChild.href;
        }
        return url;
    };

    return urls.getAbsoluteUrl = getAbsoluteUrl;

});
define('skylark-langx-urls/get-file-extension',[
    './urls'
], function (urls) {
    'use strict';

    const getFileExtension = function (path) {
        if (typeof path === 'string') {
            const splitPathRe = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/;
            const pathParts = splitPathRe.exec(path);
            if (pathParts) {
                return pathParts.pop().toLowerCase();
            }
        }
        return '';
    };

    return urls.getFileExtension = getFileExtension;

});
   define('skylark-langx-urls/get-file-name',[
    './urls'
], function (urls) {
    'use strict';

    function getFileName (url) {
        ///var fileName = url.split('/').pop() || "";
        ///return fileName;
        const anchor = url.indexOf('#');
        const query = url.indexOf('?');
        const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
        return url.substring(url.lastIndexOf('/', end) + 1, end);         
    }




    return urls.getFileName = getFileName;

});
define('skylark-langx-urls/get-query',[
    './urls'
], function (urls) {
    'use strict';
	function getQuery(querystring) {
		var query = {};

		var pairs = querystring.split('&'),
		    length = pairs.length,
		    keyval = [],
		    i = 0;

		for (; i < length; i++) {
		  keyval = pairs[i].split('=', 2);
		  try {
		    keyval[0] = decodeURIComponent(keyval[0]); // key
		    keyval[1] = decodeURIComponent(keyval[1]); // value
		  } catch (e) {}

		  if (query[keyval[0]] === undefined) {
		    query[keyval[0]] = keyval[1];
		  } else {
		    query[keyval[0]] += ',' + keyval[1];
		  }
		}

		return query;
	}

	return urls.getQuery = getQuery;

});
define('skylark-langx-urls/parse-url',[
    './urls'
], function (urls) {
    'use strict';
    const parseUrl = function (url) {
        const props = [
            'protocol',
            'hostname',
            'port',
            'pathname',
            'search',
            'hash',
            'host'
        ];
        let a = document.createElement('a');
        a.href = url;
        const addToBody = a.host === '' && a.protocol !== 'file:';
        let div;
        if (addToBody) {
            div = document.createElement('div');
            div.innerHTML = `<a href="${ url }"></a>`;
            a = div.firstChild;
            div.setAttribute('style', 'display:none; position:absolute;');
            document.body.appendChild(div);
        }
        const details = {};
        for (let i = 0; i < props.length; i++) {
            details[props[i]] = a[props[i]];
        }
        if (details.protocol === 'http:') {
            details.host = details.host.replace(/:80$/, '');
        }
        if (details.protocol === 'https:') {
            details.host = details.host.replace(/:443$/, '');
        }
        if (!details.protocol) {
            details.protocol = window.location.protocol;
        }
        if (addToBody) {
            document.body.removeChild(div);
        }
        return details;
    };

    return urls.parseUrl = parseUrl;
});
define('skylark-langx-urls/is-cross-origin',[
    './urls',
    "./parse-url"
], function (urls,parseUrl) {
    'use strict';

    const isCrossOrigin = function (url, winLoc = window.location) {
        const urlInfo = parseUrl(url);
        const srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;
        const crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;
        return crossOrigin;
    };

    return urls.isCrossOrigin = isCrossOrigin;

});
define('skylark-langx-urls/is_same_origin',[
    './urls'
], function (urls) {
    'use strict';

    function isSameOrigin(baseUrl, otherUrl) {
        let base;
        try {
            base = new URL(baseUrl);
            if (!base.origin || base.origin === 'null') {
                return false;
            }
        } catch (e) {
            return false;
        }
        const other = new URL(otherUrl, base);
        return base.origin === other.origin;
    }

    return urls.isSameOrigin = isSameOrigin;

});

define('skylark-langx-urls/path',[
    "skylark-langx-types",
    "skylark-langx-constructs",
    "./urls"
], function(types,constructs,urls) {

    /**
     * @class Path
     * @constructor
     */
    var Path =   constructs.klass({
        _construct : function() {
            var _ = this._ = {
                segments : null,
                hasLeading : false,
                hasTrailing : false
            };
            if (arguments.length == 1 && types.isString(arguments[0])) {
                  this._parse(arguments[0]);
            } else  if (types.isArray(arguments[0])){
                _.segments = arguments[0];
                _.hasLeading = arguments[1] || false;
                _.hasTrailing = arguments[2] || false;
                this._canonicalize();                
            }
        },

        _canonicalize: function() {
            var doIt;
            var segments = this._.segments;
            for (var i = 0; i < segments.length; i++) {
                if (segments[i] == "." || segments[i] == "..") {
                    doIt = true;
                    break;
                }
            }
            if (doIt) {
                var stack = [];
                for (var i = 0; i < segments.length; i++) {
                    if (segments[i] == "..") {
                        if (stack.length == 0) {
                            // if the stack is empty we are going out of our scope
                            // so we need to accumulate segments.  But only if the original
                            // path is relative.  If it is absolute then we can't go any higher than
                            // root so simply toss the .. references.
                            if (!this.hasLeading) {
                                stack.push(segments[i]); //stack push
                            }
                        } else {
                            // if the top is '..' then we are accumulating segments so don't pop
                            if (".." == stack[stack.length - 1]) {
                                stack.push("..");
                            } else {
                                stack.pop();
                            }
                        }
                        //collapse current references
                    } else if (segments[i] != "." || segments.length == 1) {
                        stack.push(segments[i]); //stack push
                    }
                }
                //if the number of segments hasn't changed, then no modification needed
                if (stack.length == segments.length) {
                    return;
                }
                this._.segments = stack;
            }
        },

        _length: function(anotherPath) {
            return this._.segments.length;
        },


        _parse : function( /*String*/ path) {
            if (!path) {
                path = ".";
            }
            var _ = this._,
                segments = path.split("/");

            if (path.charAt(0) == "/") {
                _.hasLeading = true;
                segments.shift();
            }
            if (path.charAt(path.length - 1) == "/") {
                _.hasTrailing = true;
                // If the path ends in '/', split() will create an array whose last element
                // is an empty string. Remove that here.
                segments.pop();
            }
            _.segments = segments;
            _.path = path;

            this._canonicalize()
        },

        /*
         *
         *@method append
         *@parameter {Path|String}tail
         *@return {Path}
         */
        append: /*Path*/ function( /*Path*/ tail) {
            if (types.isString(tail)) {
                return this.appendPathStr(tail);
            } else {
                return this.appendPath(tail);
            }
        },

        /*
         *
         *@method appendPath
         *@parameter {Path}tail
         *@return {Path}
         */
        appendPath: /*Path*/ function( /*Path*/ tail) {
            if (tail.isAbsolute()) {
                return tail;
            }
            var mySegments = this.segments,
                tailSegments = tail.segments,
                newSegments = mySegments.concat(tailSegments),
                result = new Path(newSegments, this.hasLeading, tail.hasTrailing);
            return result;
        },

        /*
         *
         *@method appendPathStr
         *@parameter {String}tail
         *@return {Path}
         */
        appendPathStr: function( /*String*/ tail) {
            tail = new Path(tail || "");
            return this.appendPath(tail);
        },

        /*
         *
         *@method clone
         *@return {Path}
         */
        "clone": function() {
            return new Path(this.segments, this.hasLeading, this.hasTrailing);
        },

        /*
         *Tests if this path ends with the given path.
         *@method endsWidth
         *@parameter {String}tail
         *@return {Boolean}
         */
        "endsWith": /*Boolean*/ function( /*String*/ tail) {
            var segments = this.segments;
            var tailSegments = (new Path(tail)).segments;
            while (tailSegments.length > 0 && segments.length > 0) {
                if (tailSegments.pop() != segments.pop()) {
                    return false;
                }
            }
            return true;
        },

        /*
         *Tests this path for equality with the given object.
         *@method equals
         *@parameter {Path}another
         *@return {Boolean}
         */
        "equals": /*Boolean*/ function( /*Path*/ another) {
            var segments = this._.segments,
                anotherSegments = another._.segments;
            if (segments.length != anotherSegments.length) {
                return false;
            }
            for (var i = 0; i < segments.length; i++) {
                if (anotherSegments[i] != segments[i]) {
                    return false;
                };
            }
            return true;
        },

        /*
         *
         *@method firstSegment
         *@parameter {Number}length
         *@return {String}
         */
        firstSegment: /*String*/ function( /*Number*/ length) {
            var segments = this._.segments;
            return segments[length || 0];
        },

        /*
         *
         *@method getExtension
         *@return {String}
         */
        getExtension: function() {
            var extension = this._.extension,
                path = this._.path;
            if (!textension) {
                extension = this._.extension = path.substr(path.lastIndexOf('.') + 1);
            }
            return extension;
        },

        /*
         *
         *@method getSegments
         *@return {Array}
         */
        getSegments: /*Array*/ function() {
            return this.segments;
        },

        /*
         *Returns the parent path, or null if this path does not have a parent.
         *@method getParentPath
         *@return {Path}
         */
        getParentPath: /*Path*/ function() {
            var parentPath = this._.parentPath;
            if (!parentPath) {
                var parentSegments = this.segments;
                parentSegments.pop();
                parentPath = this._.parentPath = new Path(parentSegments, this.hasLeading);
            }
            return parentPath;
        },


        /*
         *Returns the root component of this path as a Path object, or null if this path does not have a root component.
         *@method getRoot
         *@return {Path}
         */
        "getRoot": /*Path*/ function() {
            //TODO: will be implemented
        },

        /*
         *Tells whether or not this path is absolute.
         *@method isAbsolute
         *@return {Boolean}
         */
        isAbsolute: /*Boolean*/ function() {
            return this.hasLeading;
        },


        /*
         *
         *@method lastSegment
         *@ return {String}
         */
        lastSegment: /*String*/ function() {
            var segments = this._.segments;
            return segments[segments.length - 1];
        },

        /*
         *
         *@method matchingFirstSegments
         *@parameter {Path}another
         *@return {Number}
         */
        matchingFirstSegments: /*Number*/ function( /*Path*/ another) {
            var mySegments = this.segments;
            var pathSegments = another.segments;
            var max = Math.min(mySegments.length, pathSegments.length);
            var count = 0;
            for (var i = 0; i < max; i++) {
                if (mySegments[i] != pathSegments[i]) {
                    return count;
                }
                count++;
            }
            return count;
        },

        /*
         *Returns a path that is this path with redundant name elements eliminated.
         *@method normalize
         *@return {Path}
         */
        "normalize": /*Path*/ function() {
            //TODO: will be implemented
        },


        /*
         *
         *@method removeFirstSegments
         *@parameter {Number}count
         *@return {Path}
         */
        removeFirstSegments: /*Path*/ function( /*Number*/ count) {
            var segments = this._.segments,
                hasLeading = this._.hasLeading;
            hasTrailing = this._.hasTrailing;

            return new Path(segments.slice(count, segments.length), hasLeading, hasTrailing);
        },

        /*
         *
         *@method removeLastSegments
         *@parameter {Number}count
         *@return {Path}
         */
        removeLastSegments: /*Path*/ function( /*Number?*/ count) {
            var segments = this._.segments,
                hasLeading = this._.hasLeading;
            hasTrailing = this._.hasTrailing;

            if (!count) {
                count = 1;
            }

            return new Path(segments.slice(0, segments.length - count), hasLeading, hasTrailing);
        },

        /*
         *
         *@method removeMatchingFirstSegments
         *@parameter {Path}another
         *@return {Path}
         */
        removeMatchingFirstSegments: /*Path*/ function( /*Path*/ another) {
            var match = this.matchingFirstSegments(another);
            return this.removeFirstSegments(match);
        },

        /*
         *
         *@method removeMatchingLastSegments
         *@parameter {Path}another
         *@return {Path}
         */
        removeMatchingLastSegments: /*Path*/ function( /*Path*/ another) {
            var match = this.matchingFirstSegments(anotherPath);
            return this.removeLastSegments(match);
        },

        /*
         *
         *@method removeRelative
         *@return {Path}
         */
        removeRelative: function() {
            var segs = this.segments;
            if (segs.length > 0 && segs[1] == ".")
                return this.removeFirstSegments(1);
            return this;
        },

        /*
         *Constructs a relative path between this path and a given path.
         *@method relativeTo
         *@parameter {Path}base
         *@return {Path}
         */
        relativeTo: /*Path*/ function( /*Path|String*/ base, /*Boolean*/ ignoreFilename) {
            if (typeof base == 'string') {
                base = new Path(base);
            }
            var mySegments = this.segments;
            if (this.isAbsolute()) {
                return this;
            }
            var baseSegments = base.segments;
            var commonLength = this.matchingFirstSegments(base);
            var baseSegmentLength = baseSegments.length;
            if (ignoreFilename) {
                baseSegmentLength = baseSegmentLength - 1;
            }
            var differenceLength = baseSegmentLength - commonLength;
            var newSegmentLength = differenceLength + mySegments.length - commonLength;
            if (newSegmentLength == 0) {
                return Path.EMPTY;
            }
            var newSegments = [];
            for (var i = 0; i < differenceLength; i++) {
                newSegments.push('..');
            }
            for (var i = commonLength; i < mySegments.length; i++) {
                newSegments.push(mySegments[i]);
            }
            return new Path(newSegments, false, this.hasTrailing);
        },

        /*
         *
         *@method segment
         *@parameter {Number}index
         *@return {String}
         */
        segment: /*String*/ function( /*Number*/ index) {
            var segments = this._.segments;
            if (segments.length < index) return null;
            return segments[index];
        },

        /*
         *
         *@method startsWith
         *@parameter {Path}index
         *@return {Boolean}
         */
        startsWith: /*Boolean*/ function( /*Path*/ another) {
            var count = this.matchingFirstSegments(another);
            return another._length() == count;
        },

        /*
         *
         *@method toString
         *@return {String}
         */
        toString: function() {
            var result = [],
                segments = this._.segments;
            if (this.hasLeading) {
                result.push("/");
            }
            for (var i = 0; i < segments.length; i++) {
                if (i > 0) {
                    result.push("/");
                }
                result.push(segments[i]);
            }
            if (this.hasTrailing) {
                result.push("/");
            }
            return result.join("");
        },

        hasLeading : {
            get : function() {
                return this._.hasLeading
            }
        },

        hasTrailing : {
            get : function() {
                return this._.hasTrailing
            }
        }

    });


    Path.EMPTY = new Path("");

    return urls.Path = Path;
});

define('skylark-langx-urls/main',[
	"./urls",
	"./create_object_url",
	"./create_valid_absolute_url",
	"./get-absolute-url",
	"./get-file-extension",
	"./get-file-name",
	"./get-query",
	"./is-cross-origin",
	"./is_same_origin",
	"./parse-url",
	"./path"
],function(urls){
	return urls;
});
define('skylark-langx-urls', ['skylark-langx-urls/main'], function (main) { return main; });

define('skylark-langx/urls',[
	"skylark-langx-urls"
],function(urls){
	return urls;
});
define('skylark-langx/langx',[
    "./skylark",
    "./arrays",
    "./array-store",
    "./aspect",
    "./async",
    "./binary",
    "./constructs",
    "./datetimes",
    "./deferred",
    "./emitter",
    "./evented",
    "./events",
    "./funcs",
    "./globals",
    "./hoster",
    "./klass",
    "./maths",
    "./numerics",
    "./objects",
    "./stateful",
    "./strings",
    "./topic",
    "./types",
    "./urls"
], function(
    skylark,
    arrays,
    ArrayStore,
    aspect,
    async,
    binary,
    constructs,
    datetimes,
    Deferred,
    Emitter,
    Evented,
    events,
    funcs,
    globals,
    hoster,
    klass,
    maths,
    numerics,
    objects,
    Stateful,
    strings,
    topic,
    types,
    urls
) {
    "use strict";
    var toString = {}.toString,
        concat = Array.prototype.concat,
        indexOf = Array.prototype.indexOf,
        slice = Array.prototype.slice,
        filter = Array.prototype.filter,
        mixin = objects.mixin,
        safeMixin = objects.safeMixin,
        isFunction = types.isFunction;


    function funcArg(context, arg, idx, payload) {
        return isFunction(arg) ? arg.call(context, idx, payload) : arg;
    }

    function getQueryParams(url) {
        var url = url || window.location.href,
            segs = url.split("?"),
            params = {};

        if (segs.length > 1) {
            segs[1].split("&").forEach(function(queryParam) {
                var nv = queryParam.split('=');
                params[nv[0]] = nv[1];
            });
        }
        return params;
    }


    function toPixel(value) {
        // style values can be floats, client code may want
        // to round for integer pixels.
        return parseFloat(value) || 0;
    }


    var _uid = 1;

    function uid(obj) {
        return obj._uid || (obj._uid = _uid++);
    }

    function langx() {
        return langx;
    }

    mixin(langx, {
        createEvent : Emitter.createEvent,

        funcArg: funcArg,

        getQueryParams: getQueryParams,

        toPixel: toPixel,

        uid: uid,

        URL: typeof window !== "undefined" ? window.URL || window.webkitURL : null

    });


    mixin(langx, arrays,aspect,datetimes,funcs,numerics,objects,strings,types,{
        ArrayStore : ArrayStore,

        async : async,
        
        Deferred: Deferred,

        Emitter: Emitter,

        Evented: Evented,

        hoster : hoster,

        klass : klass,
       
        Stateful: Stateful,

        topic : topic
    });

    return skylark.langx = langx;
});
define('skylark-domx-browser/browser',[
    "skylark-langx/skylark",
    "skylark-langx/langx"
], function(skylark,langx) {
    "use strict";

    var browser = langx.hoster.browser;


    langx.mixin(browser, {

        isIE : !!/msie/i.exec( window.navigator.userAgent ),

        location: function() {
            return window.location;
        },

        support : {

        }

    });



    return skylark.attach("domx.browser",browser);
});

define('skylark-domx-browser/support/css3',[
    "skylark-langx/langx",
    "../browser"
], function(langx,browser) {
    "use strict";

    var checkedCssProperties = {
            "transitionproperty": "TransitionProperty",
        },
        transEndEventNames = {
          WebkitTransition : 'webkitTransitionEnd',
          MozTransition    : 'transitionend',
          OTransition      : 'oTransitionEnd otransitionend',
          transition       : 'transitionend'
        },
        transEndEventName = null;


    var css3PropPrefix = "",
        css3StylePrefix = "",
        css3EventPrefix = "",

        cssStyles = {},
        cssProps = {},

        vendorPrefix,
        vendorPrefixRE,
        vendorPrefixesRE = /^(Webkit|webkit|O|Moz|moz|ms)(.*)$/,

        document = window.document,
        testEl = document.createElement("div"),

        matchesSelector = testEl.webkitMatchesSelector ||
                          testEl.mozMatchesSelector ||
                          testEl.oMatchesSelector ||
                          testEl.matchesSelector,

        testStyle = testEl.style;

    for (var name in testStyle) {
        var matched = name.match(vendorPrefixRE || vendorPrefixesRE);
        if (matched) {
            if (!vendorPrefixRE) {
                vendorPrefix = matched[1];
                vendorPrefixRE = new RegExp("^(" + vendorPrefix + ")(.*)$");

                css3StylePrefix = vendorPrefix;
                css3PropPrefix = '-' + vendorPrefix.toLowerCase() + '-';
                css3EventPrefix = vendorPrefix.toLowerCase();
            }

            cssStyles[langx.lowerFirst(matched[2])] = name;
            var cssPropName = langx.dasherize(matched[2]);
            cssProps[cssPropName] = css3PropPrefix + cssPropName;

            if (transEndEventNames[name]) {
              transEndEventName = transEndEventNames[name];
            }
        }
    }

    if (!transEndEventName) {
        if (testStyle["transition"] !== undefined) {
            transEndEventName = transEndEventNames["transition"];
        }
    }

    function normalizeCssEvent(name) {
        return css3EventPrefix ? css3EventPrefix + name : name.toLowerCase();
    }

    function normalizeCssProperty(name) {
        return cssProps[name] || name;
    }

    function normalizeStyleProperty(name) {
        return cssStyles[name] || name;
    }


    var css3 = {

        normalizeStyleProperty: normalizeStyleProperty,

        normalizeCssProperty: normalizeCssProperty,

        normalizeCssEvent: normalizeCssEvent,

        matchesSelector: matchesSelector        
    };

    langx.mixin(browser,css3);

    browser.css3PropPrefix = css3.propPrefix =  css3PropPrefix;

    if  (transEndEventName) {
        browser.support.transition = css3.transition = {
            end : transEndEventName
        };
    }

    browser.support.cssPointerEvents = css3.pointerEvents =  (function() {
        testEl.style.cssText = 'pointer-events:auto';
        return testEl.style.pointerEvents === 'auto';
    })(),




    testEl = null;

    return browser.support.css3 = css3;
});

define('skylark-domx-browser/support/fullscreen',[
    "../browser"
],function(browser){

    const FullscreenApi = { 
        prefixed: true 
    };

    const apiMap = [
        [
            'requestFullscreen',
            'exitFullscreen',
            'fullscreenElement',
            'fullscreenEnabled',
            'fullscreenchange',
            'fullscreenerror',
            'fullscreen'
        ],
        [
            'webkitRequestFullscreen',
            'webkitExitFullscreen',
            'webkitFullscreenElement',
            'webkitFullscreenEnabled',
            'webkitfullscreenchange',
            'webkitfullscreenerror',
            '-webkit-full-screen'
        ],
        [
            'mozRequestFullScreen',
            'mozCancelFullScreen',
            'mozFullScreenElement',
            'mozFullScreenEnabled',
            'mozfullscreenchange',
            'mozfullscreenerror',
            '-moz-full-screen'
        ],
        [
            'msRequestFullscreen',
            'msExitFullscreen',
            'msFullscreenElement',
            'msFullscreenEnabled',
            'MSFullscreenChange',
            'MSFullscreenError',
            '-ms-fullscreen'
        ]
    ];
    const specApi = apiMap[0];
    let browserApi;
    for (let i = 0; i < apiMap.length; i++) {
        if (apiMap[i][1] in document) {
            browserApi = apiMap[i];
            break;
        }
    }
    if (browserApi) {
        for (let i = 0; i < browserApi.length; i++) {
            FullscreenApi[specApi[i]] = browserApi[i];
        }
        FullscreenApi.prefixed = browserApi[0] !== specApi[0];

        browser.requestFullscreen = function() {
            return document.body[FullscreenApi["requestFullscreen"]].apply(this,arguments);
        };
        browser.exitFullscreen = function() {
            return document[FullscreenApi["exitFullscreen"]].apply(this,arguments);
        };

        browser.support.fullscreen = FullscreenApi;
    } else {
        browser.support.fullscreen = null;
    }

    return browser.support.fullscreen;
});
define('skylark-domx-browser/support/touch',[
	"../browser"
],function(browser){

    function supportTouch() {
        return !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch);
    }

    return browser.support.tocuh = supportTouch();
});
define('skylark-domx-browser/main',[
	"./browser",
	"./support/css3",
	"./support/fullscreen",
	"./support/touch"
],function(browser){
	return browser;
});
define('skylark-domx-browser', ['skylark-domx-browser/main'], function (main) { return main; });

define('skylark-langx/main',[
    "./langx"
], function(langx) {
    return langx;
});

define('skylark-langx', ['skylark-langx/main'], function (main) { return main; });

define('skylark-langx-scripter/scripter',[
    "skylark-langx/skylark",
    "skylark-langx"
], function(skylark, langx) {

    var head = document.getElementsByTagName('head')[0],
        scriptsByUrl = {},
        scriptElementsById = {},
        count = 0;

    function scripter() {
        return scripter;
    }


    var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
    };

    function evaluate(code,node, doc ) {
        doc = doc || document;

        var i, val,
            script = doc.createElement("script");

        script.text = code;
        if ( node ) {
            for ( i in preservedScriptAttributes ) {

                // Support: Firefox 64+, Edge 18+
                // Some browsers don't support the "nonce" property on scripts.
                // On the other hand, just using `getAttribute` is not enough as
                // the `nonce` attribute is reset to an empty string whenever it
                // becomes browsing-context connected.
                // See https://github.com/whatwg/html/issues/2369
                // See https://html.spec.whatwg.org/#nonce-attributes
                // The `node.getAttribute` check was added for the sake of
                // `jQuery.globalEval` so that it can fake a nonce-containing node
                // via an object.
                val = node[ i ] || node.getAttribute && node.getAttribute( i );
                if ( val ) {
                    script.setAttribute( i, val );
                }
            }
        }
        doc.head.appendChild( script ).parentNode.removeChild( script );

        return this;
    }

    langx.mixin(scripter, {
        /*
         * Load a script from a url into the document.
         * @param {} url
         * @param {} loadedCallback
         * @param {} errorCallback
         */
        loadJavaScript: function(url, loadedCallback, errorCallback) {
            var script = scriptsByUrl[url];
            if (!script) {
                script = scriptsByUrl[url] = {
                    state: 0, //0:unload,1:loaded,-1:loaderror
                    loadedCallbacks: [],
                    errorCallbacks: []
                }
            }

            script.loadedCallbacks.push(loadedCallback);
            script.errorCallbacks.push(errorCallback);

            if (script.state === 1) {
                script.node.onload();
            } else if (script.state === -1) {
                script.node.onerror();
            } else {
                var node = script.node = document.createElement("script"),
                    id = script.id = (count++);

                node.type = "text/javascript";
                node.async = false;
                node.defer = false;
                startTime = new Date().getTime();
                head.appendChild(node);

                node.onload = function() {
                        script.state = 1;

                        var callbacks = script.loadedCallbacks,
                            i = callbacks.length;

                        while (i--) {
                            callbacks[i]();
                        }
                        script.loadedCallbacks = [];
                        script.errorCallbacks = [];
                    },
                    node.onerror = function() {
                        script.state = -1;
                        var callbacks = script.errorCallbacks,
                            i = callbacks.length;

                        while (i--) {
                            callbacks[i]();
                        }
                        script.loadedCallbacks = [];
                        script.errorCallbacks = [];
                    };
                node.src = url;

                scriptElementsById[id] = node;
            }
            return script.id;
        },
        /*
         * Remove the specified script from the document.
         * @param {Number} id
         */
        deleteJavaScript: function(id) {
            var node = scriptElementsById[id];
            if (node) {
                var url = node.src;
                if (node.parentNode) {
                    node.parentNode.remove(node);
                }
                delete scriptElementsById[id];
                delete scriptsByUrl[url];
            }
        },

        evaluate : evaluate,

        loadScript : function(url) {
            var d = new langx.Deferred();

            d.promise.scriptId = this.loadJavaScript(url,function(){
                d.resolve();
            },function(e){
                d.reject(e);
            });

            return d.promise;
        }


    });

    return skylark.attach("langx.scripter", scripter);
});
define('skylark-langx-scripter/main',[
	"./scripter"
],function(scripter){
	
	return scripter;
});
define('skylark-langx-scripter', ['skylark-langx-scripter/main'], function (main) { return main; });

define('skylark-domx-noder/noder',[
    "skylark-langx-ns",
    "skylark-langx-types",
    "skylark-langx-arrays",
    "skylark-langx-strings",
    "skylark-langx-scripter",
    "skylark-domx-browser"
], function(skylark, types, arrays, strings,scripter,browser) {
    var  
        map = Array.prototype.map,
        slice = Array.prototype.slice;


    /**
     * Generate id
     * @param   {HTMLElement} el
     * @returns {String}
     * @private
     */
    function generateId(el) {
        var str = el.tagName + el.className + el.src + el.href + el.textContent,
            i = str.length,
            sum = 0;

        while (i--) {
            sum += str.charCodeAt(i);
        }

        return sum.toString(36);
    }


    function noder() {
        return noder;
    }

    Object.assign(noder, {


        blur : function(el) {
            el.blur();
        },


        generateId
    });

    return skylark.attach("domx.noder" , noder);
});
define('skylark-domx-noder/active',[
	"./noder"
],function(noder){

    function activeElement(doc) {
        doc = doc || document;
        var el;

        // Support: IE 9 only
        // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
        try {
            el = doc.activeElement;
        } catch ( error ) {
            el = doc.body;
        }

        // Support: IE 9 - 11 only
        // IE may return null instead of an element
        // Interestingly, this only seems to occur when NOT in an iframe
        if ( !el ) {
            el = doc.body;
        }

        // Support: IE 11 only
        // IE11 returns a seemingly empty object in some cases when accessing
        // document.activeElement from an <iframe>
        if ( !el.nodeName ) {
            el = doc.body;
        }

        return el;
    };
	return noder.active = activeElement;
});
define('skylark-domx-noder/_enhance_place_content',[
    "skylark-langx-types",
    "skylark-langx-arrays",
	"./noder"
],function(types,arrays,noder){
    function enhancePlaceContent(placing,node) {
        if (types.isFunction(placing)) {
            return placing.apply(node,[]);
        }
        if (types.isArrayLike(placing)) {
            var neddsFlattern;
            for (var i=0;i<placing.length;i++) {
                if (types.isFunction(placing[i])) {
                    placing[i] = placing[i].apply(node,[]);
                    if (types.isArrayLike(placing[i])) {
                        neddsFlattern = true;
                    }
                }
            }
            if (neddsFlattern) {
                placing = arrays.flatten(placing);
            }
        }
        return placing;
    }

	return enhancePlaceContent;
});
define('skylark-domx-noder/is-element',[
	"./noder"
],function(noder){
 
    function isElement(node) {
        return node && node.nodeType === 1;
    }

	
	return noder.isElement = isElement;
});
define('skylark-domx-noder/is-text-node',[
	"./noder"
],function(noder){
 
    function isTextNode(node) {
        return node && node.nodeType === 3;
    }

	
	return noder.isTextNode = isTextNode;
});
define('skylark-domx-noder/is-fragment',[
	"./noder"
],function(noder){
 
    function isFragment(node) {
        return node && node.nodeType === 11;
    }

	return noder.isFragment = isFragment;
});
define('skylark-domx-noder/_normalize_content',[
    "skylark-langx-types",
	"./noder",
    "./is-element",
    "./is-text-node",
    "./is-fragment"
],function(types,noder,isElement,isTextNode,isFragment){
    var  
        map = Array.prototype.map;
        
    function normalizeContent(content) {
        if (typeof content === 'function') {
            content = content();
        }
        return map.call(types.isArrayLike(content) ? content : [content],value => {
            if (typeof value === 'function') {
                value = value();
            }
            if (isElement(value) || isTextNode(value) || isFragment(value)) {
                return value;
            }
            if (typeof value === 'string' && /\S/.test(value)) {
                return document.createTextNode(value);
            }
        }).filter(value => value);
    }

	return normalizeContent;
});
define('skylark-domx-noder/_ensure_nodes',[
    "skylark-langx-arrays",
	"./noder",
    "./_normalize_content"
],function(arrays,noder,normalizeContent){
    var  
        map = Array.prototype.map;

    function ensureNodes(content, copyByClone) {
        var nodes = normalizeContent(content);


        //if (!types.isArrayLike(nodes)) {
        //    nodes = [nodes];
        //}
        if (copyByClone) {
            nodes = map.call(nodes, function(node) {
                return node.cloneNode(true);
            });
        }
        return arrays.flatten(nodes);
    }

	return ensureNodes;
});
define('skylark-domx-noder/after',[
	"./noder",
    "./_enhance_place_content",
    "./_ensure_nodes"
],function(noder,enhancePlaceContent,ensureNodes){
 
    function after(node, placing, copyByClone) {
        placing = enhancePlaceContent(placing,node);
        var refNode = node,
            parent = refNode.parentNode;
        if (parent) {
            var nodes = ensureNodes(placing, copyByClone),
                refNode = refNode.nextSibling;

            for (var i = 0; i < nodes.length; i++) {
                if (refNode) {
                    parent.insertBefore(nodes[i], refNode);
                } else {
                    parent.appendChild(nodes[i]);
                }
            }
        }
        return this;
    }

	
	return noder.after = after;
});
define('skylark-domx-noder/append',[
    "./noder",
    "./_enhance_place_content",
    "./_ensure_nodes"
],function(noder,enhancePlaceContent,ensureNodes){
 
    function append(node, placing, copyByClone) {
        placing = enhancePlaceContent(placing,node);
        var parentNode = node,
            nodes = ensureNodes(placing, copyByClone);
        for (var i = 0; i < nodes.length; i++) {
            parentNode.appendChild(nodes[i]);
        }
        return this;
    }
    
    return noder.append = append;
});
define('skylark-domx-noder/before',[
    "./noder",
    "./_enhance_place_content",
    "./_ensure_nodes"
],function(noder,enhancePlaceContent,ensureNodes){
 

    function before(node, placing, copyByClone) {
        placing = enhancePlaceContent(placing,node);
        var refNode = node,
            parent = refNode.parentNode;
        if (parent) {
            var nodes = ensureNodes(placing, copyByClone);
            for (var i = 0; i < nodes.length; i++) {
                parent.insertBefore(nodes[i], refNode);
            }
        }
        return this;
    }

	
	return noder.before = before;
});
define('skylark-domx-noder/body',[
	"./noder"
],function(noder){
	function body() {
		return  document.body;
	}
	
	return noder.body = body;
});
define('skylark-domx-noder/clone',[
	"./noder"
],function(noder){
 
    /*   
     * Create a deep copy of the set of matched elements.
     * @param {HTMLElement} node
     * @param {Boolean} deep
     */
    function clone(node, deep) {
        return node.cloneNode(deep);
    }

	
	return noder.clone = clone;
});
define('skylark-domx-noder/is-child-of',[
	"./noder"
],function(noder){
    /*   
     * Check to see if a dom node is a descendant of another dom node.
     * @param {Node} node
     * @param {Node} parent
     * @param {Node} directly
     */
    function isChildOf(node, parent, directly) {
        if (directly) {
            return node.parentNode === parent;
        }
        if (document.documentElement.contains) {
            return parent.contains(node);
        }
        while (node) {
            if (parent === node) {
                return true;
            }

            node = node.parentNode;
        }

        return false;
    }
	
	return noder.isChildOf = isChildOf;
});
define('skylark-domx-noder/contains',[
	"./noder",
    "./is-child-of"
],function(noder,isChildOf){
 
    /*   
     * Check to see if a dom node is a descendant of another dom node .
     * @param {String} node
     * @param {Node} child
     */
    function contains(node, child) {
        return isChildOf(child, node);
    }
	
	return noder.contains = contains;
});
define('skylark-domx-noder/create-element',[
    "skylark-langx-types",
	"./noder"
],function(types,noder){
 
    /*   
     * Create a element and set attributes on it.
     * @param {HTMLElement} tag
     * @param {attrs} attrs
     * @param } parent
     */
    function createElement(tag, props,attrs, parent) {
        var node;

        if (/svg/i.test(tag)) {
            node = document.createElementNS("http://www.w3.org/2000/svg", tag)
        } else {
            node = document.createElement(tag);
        }

        if (types.isHtmlNode(props)) {
            parent = props;
            props = null;
            attrs = null;
        } else if (types.isHtmlNode(attrs)){
            parent = attrs;
            attrs = null;
        }

        if (props) {
            for (var name in props) {
                node[name] = props[name];
            }
        }

        if (attrs) {
            for (var name in attrs) {
                node.setAttribute(name, attrs[name]);
            }
        }
        if (parent) {
            noder.append(parent, node);
        }
        return node;
    }

	
	return noder.createElement = createElement;
});
define('skylark-domx-noder/create-fragment',[
    "skylark-langx-strings",
	"./noder",
    "./create-element"
],function(strings,noder,createElement){
    var fragmentRE = /^\s*<(\w+|!)[^>]*>/,
        singleTagRE = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
        div = document.createElement("div"),
        table = document.createElement('table'),
        tableBody = document.createElement('tbody'),
        tableRow = document.createElement('tr'),
        containers = {
            'tr': tableBody,
            'tbody': table,
            'thead': table,
            'tfoot': table,
            'td': tableRow,
            'th': tableRow,
            '*': div
        },
        slice = Array.prototype.slice;


    function removeSelfClosingTags(xml) {
        var split = xml.split("/>");
        var newXml = "";
        for (var i = 0; i < split.length - 1;i++) {
            var edsplit = split[i].split("<");
            newXml += split[i] + "></" + edsplit[edsplit.length - 1].split(" ")[0] + ">";
        }
        return newXml + split[split.length-1];
    }


    /*   
     * Create a DocumentFragment from the HTML fragment.
     * @param {String} html
     */
    function createFragment(html) {
        // A special case optimization for a single tag
        html = strings.trim(html);
        if (singleTagRE.test(html)) {
            return [createElement(RegExp.$1)];
        }

        var name = fragmentRE.test(html) && RegExp.$1
        if (!(name in containers)) {
            name = "*"
        }
        var container = containers[name];
        container.innerHTML = removeSelfClosingTags("" + html);
        dom = slice.call(container.childNodes);

        dom.forEach(function(node) {
            container.removeChild(node);
        })

        return dom;
    }

	
	return noder.createFragment = createFragment;
});
define('skylark-domx-noder/create-text-node',[
	"./noder"
],function(noder){
 
    /*   
     * Create a new Text node.
     * @param {String} text
     * @param {Node} child
     */
    function createTextNode(text) {
        return document.createTextNode(text);
    }


	return noder.createTextNode = createTextNode;
});
define('skylark-domx-noder/doc',[
	"./noder"
],function(noder){
 
    /*   
     * Get the current document object.
     */
    function doc() {
        return document;
    }

	return noder.doc = doc;
});
define('skylark-domx-noder/empty',[
	"./noder"
],function(noder){
 
    /*   
     * Remove all child nodes of the set of matched elements from the DOM.
     * @param {Object} node
     */
    function empty(node) {
        while (node.hasChildNodes()) {
            var child = node.firstChild;
            node.removeChild(child);
        }
        return this;
    }
	
	return noder.empty = empty;
});
define('skylark-domx-noder/focusable',[
	"./noder"
],function(noder){
 
    // Selectors
    function focusable( element, hasTabindex ) {
        var map, mapName, img, focusableIfVisible, fieldset,
            nodeName = element.nodeName.toLowerCase();

        if ( "area" === nodeName ) {
            map = element.parentNode;
            mapName = map.name;
            if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
                return false;
            }
            img = $( "img[usemap='#" + mapName + "']" );
            return img.length > 0 && img.is( ":visible" );
        }

        if ( /^(input|select|textarea|button|object)$/.test( nodeName ) ) {
            focusableIfVisible = !element.disabled;

            if ( focusableIfVisible ) {

                // Form controls within a disabled fieldset are disabled.
                // However, controls within the fieldset's legend do not get disabled.
                // Since controls generally aren't placed inside legends, we skip
                // this portion of the check.
                fieldset = $( element ).closest( "fieldset" )[ 0 ];
                if ( fieldset ) {
                    focusableIfVisible = !fieldset.disabled;
                }
            }
        } else if ( "a" === nodeName ) {
            focusableIfVisible = element.href || hasTabindex;
        } else {
            focusableIfVisible = hasTabindex;
        }

        return focusableIfVisible && $( element ).is( ":visible" ) && visible( $( element ) );
    };
	
	return noder.focusable = focusable;
});
define('skylark-domx-noder/from-point',[
	"./noder"
],function(noder){

    function fromPoint(x,y) {
        return document.elementFromPoint(x,y);
    }

	
	return noder.fromPoint = fromPoint;
});
define('skylark-domx-noder/fullscreen',[
    "skylark-domx-browser",
	"./noder"
],function(browser,noder){

    var fulledEl = null;

    function fullscreen(el) {
        if (el === false) {
            return browser.exitFullscreen.apply(document);
        } else if (el) {
            return el[browser.support.fullscreen.requestFullscreen]();
            fulledEl = el;
        } else {
            return (
                document.fullscreenElement ||
                document.webkitFullscreenElement ||
                document.mozFullScreenElement ||
                document.msFullscreenElement
            )
        }
    }
	
	return noder.fullscreen = fullscreen;
});
define('skylark-domx-noder/html',[
    "skylark-langx-types",
    "skylark-langx-scripter",
	"./noder",
    "./empty"
],function(types,scripter,noder,empty){
 
   var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
       rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );

    /*   
     * Get the HTML contents of the first element in the set of matched elements.
     * @param {HTMLElement} node
     * @param {String} html
     */
    function _html(node, html) {
        if (html === undefined) {
            return node.innerHTML;
        } else {
            empty(node);
            html = html || "";
            if (types.isString(html)) {
                html = html.replace( rxhtmlTag, "<$1></$2>" );
            }
            if (types.isString(html) || types.isNumber(html)) {               
                node.innerHTML = html;
            } else if (types.isArrayLike(html)) {
                for (var i = 0; i < html.length; i++) {
                    node.appendChild(html[i]);
                }
            } else {
                node.appendChild(html);
            }

            return this;
        }
    }


    function html(node,value) {
        var result = _html(node,value);

        if (value !== undefined) {
            var scripts = node.querySelectorAll('script');

            for (var i =0; i<scripts.length; i++) {
                var node1 = scripts[i];
                if (rscriptType.test( node1.type || "" ) ) {
                  scripter.evaluate(node1.textContent,node1);
                }
            }       
            return this;         
        } else {
            return result;
        }
    }


	return noder.html = html;
});
define('skylark-domx-noder/is-active',[
	"./noder"
],function(noder){
    function isActive (elem) {
            return elem === document.activeElement && (elem.type || elem.href);
    }

	
	return noder.isActive = isActive;
});
define('skylark-domx-noder/is-block-node',[
	"./noder"
],function(noder){

    var blockNodes = ["div", "p", "ul", "ol", "li", "blockquote", "hr", "pre", "h1", "h2", "h3", "h4", "h5", "table"];

    function isBlockNode(node) {
        if (!node || node.nodeType === 3) {
          return false;
        }
        return new RegExp("^(" + (blockNodes.join('|')) + ")$").test(node.nodeName.toLowerCase());
    }


	
	return noder.isBlockNode = isBlockNode;
});
define('skylark-domx-noder/is-doc',[
	"./noder"
],function(noder){
    /*   
     * Check to see if a dom node is a document.
     * @param {Node} node
     */
    function isDocument(node) {
        return node != null && node.nodeType == node.DOCUMENT_NODE
    }

	
	return noder.isDoc = isDocument;
});
define('skylark-domx-noder/is-editable',[
	"./noder"
],function(noder){
 
    function isEditable (el) {
      if (!el) { return false; } // no parents were editable
      if (el.contentEditable === 'false') { return false; } // stop the lookup
      if (el.contentEditable === 'true') { return true; } // found a contentEditable element in the chain
      return isEditable(el.parentNode); // contentEditable is set to 'inherit'
    }

	
	return noder.isEditable = isEditable;
});
define('skylark-domx-noder/is-fullscreen',[
	"./noder",
    "./fullscreen"
],function(noder,fullscreen){
 
    function isFullscreen(el) {
        return fullscreen() === el;
    }
	
	return noder.isFullscreen = isFullscreen;
});
define('skylark-domx-noder/is-in-document',[
	"./noder"
],function(noder){
    /*   
     * Check to see if a dom node is in the document
     * @param {Node} node
     */
    function isInDocument(node) {
      return (node === document.body) ? true : document.body.contains(node);
    }     

	
	return noder.isInDocument = isInDocument;
});
define('skylark-domx-noder/is-in-frame',[
	"./noder"
],function(noder){
     function isInFrame() {
        try {
            return window.parent !== window.self;
        } catch (x) {
            return true;
        }
    }
	
	return noder.isInFrame = isInFrame;
});
define('skylark-domx-noder/is-input',[
	"./noder",
    "./is-editable"
],function(noder,isEditable){
 
    function isInput (el) { 
        return el.tagName === 'INPUT' || 
               el.tagName === 'TEXTAREA' || 
               el.tagName === 'SELECT' || 
               isEditable(el); 
    }
	
	return noder.isInput = isInput;
});
define('skylark-domx-noder/is-window',[
    "skylark-langx-types",
    "./noder"
],function(types,noder){
   
    return noder.isWindow = types.isWindow;
	
});
define('skylark-domx-noder/node-name',[
	"./noder"
],function(noder){
 
    function nodeName(elm, chkName) {
        var name = elm.nodeName && elm.nodeName.toLowerCase();
        if (chkName !== undefined) {
            return name === chkName.toLowerCase();
        }
        return name;
    };
	
	return noder.nodeName = nodeName;
});
define('skylark-domx-noder/offset-parent',[
	"./noder"
],function(noder){
 
    var  rootNodeRE = /^(?:body|html)$/i;
    
    /*   
     *
     * @param {Node} elm
     */
    function offsetParent(elm) {
        var parent = elm.offsetParent || document.body;
        while (parent && !rootNodeRE.test(parent.nodeName) && document.defaultView.getComputedStyle(parent).position == "static") {
            parent = parent.offsetParent;
        }
        return parent;
    }
	
	return noder.offsetParent = offsetParent;
});
define('skylark-domx-styler/styler',[
    "skylark-langx/skylark",
    "skylark-langx/langx"
], function(skylark, langx) {
    var every = Array.prototype.every,
        forEach = Array.prototype.forEach,
        camelCase = langx.camelCase,
        dasherize = langx.dasherize;

    function maybeAddPx(name, value) {
        return (typeof value == "number" && !cssNumber[dasherize(name)]) ? value + "px" : value
    }

    var cssNumber = {
            'column-count': 1,
            'columns': 1,
            'font-weight': 1,
            'line-height': 1,
            'opacity': 1,
            'z-index': 1,
            'zoom': 1
        },
        classReCache = {

        };

    function classRE(name) {
        return name in classReCache ?
            classReCache[name] : (classReCache[name] = new RegExp('(^|\\s)' + name + '(\\s|$)'));
    }

    // access className property while respecting SVGAnimatedString
    /*
     * Adds the specified class(es) to each element in the set of matched elements.
     * @param {HTMLElement} node
     * @param {String} value
     */
    function className(node, value) {
        var klass = node.className || '',
            svg = klass && klass.baseVal !== undefined

        if (value === undefined) return svg ? klass.baseVal : klass
        svg ? (klass.baseVal = value) : (node.className = value)
    }

    function disabled(elm, value ) {
        if (arguments.length < 2) {
            return !!this.dom.disabled;
        }

        elm.disabled = value;

        return this;
    }

    var elementDisplay = {};

    function defaultDisplay(nodeName) {
        var element, display
        if (!elementDisplay[nodeName]) {
            element = document.createElement(nodeName)
            document.body.appendChild(element)
            display = getStyles(element).getPropertyValue("display")
            element.parentNode.removeChild(element)
            display == "none" && (display = "block")
            elementDisplay[nodeName] = display
        }
        return elementDisplay[nodeName]
    }
    /*
     * Display the matched elements.
     * @param {HTMLElement} elm
     */
    function show(elm) {
        styler.css(elm, "display", "");
        if (styler.css(elm, "display") == "none") {
            styler.css(elm, "display", defaultDisplay(elm.nodeName));
        }
        return this;
    }

    function isInvisible(elm) {
        return styler.css(elm, "display") == "none" || styler.css(elm, "opacity") == 0 || styler.css(elm,"visibility") == "hidden";
    }

    /*
     * Hide the matched elements.
     * @param {HTMLElement} elm
     */
    function hide(elm) {
        styler.css(elm, "display", "none");
        return this;
    }

    /*
     * Adds the specified class(es) to each element in the set of matched elements.
     * @param {HTMLElement} elm
     * @param {String} name
     */
    function addClass(elm, name) {
        if (!name) return this
        var cls = className(elm),
            names;
        if (langx.isString(name)) {
            names = name.split(/\s+/g);
        } else {
            names = name;
        }
        names.forEach(function(klass) {
            var re = classRE(klass);
            if (!cls.match(re)) {
                cls += (cls ? " " : "") + klass;
            }
        });

        className(elm, cls);

        return this;
    }

    function getStyles( elem ) {

        // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        var view = elem.ownerDocument.defaultView;

        if ( !view || !view.opener ) {
            view = window;
        }

        return view.getComputedStyle( elem);
    }


    /*
     * Get the value of a computed style property for the first element in the set of matched elements or set one or more CSS properties for every matched element.
     * @param {HTMLElement} elm
     * @param {String} property
     * @param {Any} value
     */
    function css(elm, property, value) {
        //if (arguments.length < 3) {
        if (value == void 0) {
            var computedStyle,
                computedStyle = getStyles(elm)
            if (property == void 0) {
                return computedStyle;
            } else if (langx.isString(property)) {
                return elm.style[camelCase(property)] || computedStyle.getPropertyValue(dasherize(property))
            } else if (langx.isArrayLike(property)) {
                var props = {}
                forEach.call(property, function(prop) {
                    props[prop] = (elm.style[camelCase(prop)] || computedStyle.getPropertyValue(dasherize(prop)))
                })
                return props
            }
        }

        var css = '';
        if (typeof(property) == 'string') {
            if (!value && value !== 0) {
                elm.style.removeProperty(dasherize(property));
            } else {
                css = dasherize(property) + ":" + maybeAddPx(property, value)
            }
        } else {
            for (key in property) {
                if (property[key] === undefined) {
                    continue;
                }
                if (!property[key] && property[key] !== 0) {
                    elm.style.removeProperty(dasherize(key));
                } else {
                    css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'
                }
            }
        }

        elm.style.cssText += ';' + css;
        return this;
    }

    /*
     * Determine whether any of the matched elements are assigned the given class.
     * @param {HTMLElement} elm
     * @param {String} name
     */
    function hasClass(elm, name) {
        var re = classRE(name);
        return elm.className && elm.className.match(re);
    }

    /*
     * Remove a single class, multiple classes, or all classes from each element in the set of matched elements.
     * @param {HTMLElement} elm
     * @param {String} name
     */
    function removeClass(elm, name) {
        if (name) {
            var cls = className(elm),
                names;

            if (langx.isString(name)) {
                names = name.split(/\s+/g);
            } else {
                names = name;
            }

            names.forEach(function(klass) {
                var re = classRE(klass);
                if (cls.match(re)) {
                    cls = cls.replace(re, " ");
                }
            });

            className(elm, cls.trim());
        } else {
            className(elm, "");
        }

        return this;
    }

    /*
     * Add or remove one or more classes from the specified element.
     * @param {HTMLElement} elm
     * @param {String} name
     * @param {} when
     */
    function toggleClass(elm, name, when) {
        var self = this;
        name.split(/\s+/g).forEach(function(klass) {
            if (when === undefined) {
                when = !hasClass(elm, klass);
            }
            if (when) {
                addClass(elm, klass);
            } else {
                removeClass(elm, klass)
            }
        });

        return self;
    }

    var styler = function() {
        return styler;
    };

    langx.mixin(styler, {
        autocssfix: false,
        cssHooks: {

        },

        addClass: addClass,
        className: className,
        css: css,
        disabled : disabled,        
        hasClass: hasClass,
        hide: hide,
        isInvisible: isInvisible,
        removeClass: removeClass,
        show: show,
        toggleClass: toggleClass
    });

    return skylark.attach("domx.styler", styler);
});
define('skylark-domx-styler/main',[
	"./styler"
],function(styler,velm,$){
	
	return styler;
});
define('skylark-domx-styler', ['skylark-domx-styler/main'], function (main) { return main; });

define('skylark-domx-noder/overlay',[
	"skylark-domx-styler",
	"./noder"
],function(styler,noder){
    /*   
     *
     * @param {Node} elm
     * @param {Node} params
     */
    function overlay(elm, params) {
        var overlayDiv = noder.createElement("div", params);
        styler.css(overlayDiv, {
            position: "absolute",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            zIndex: 0x7FFFFFFF,
            opacity: 0.7
        });
        elm.appendChild(overlayDiv);
        return overlayDiv;

    }

    return noder.overlay = overlay;
 });
define('skylark-domx-noder/owner-doc',[
	"./noder"
],function(noder){
 
    /*   
     * Get the owner document object for the specified element.
     * @param {Node} elm
     */
    function ownerDoc(elm) {
        if (!elm) {
            return document;
        }

        if (elm.nodeType == 9) {
            return elm;
        }

        return elm.ownerDocument;
    }

	
	return noder.ownerDoc = ownerDoc;
});
define('skylark-domx-noder/owner-window',[
	"./noder",
    "./owner-doc"
],function(noder,ownerDoc){
 
    /*   
     *
     * @param {Node} elm
     */
    function ownerWindow(elm) {
        var doc = ownerDoc(elm);
        return doc.defaultView || doc.parentWindow;
    }

	return noder.ownerWindow = ownerWindow;
});
define('skylark-domx-noder/picture-in-picture',[
    "skylark-domx-browser",
	"./noder"
],function(browser,noder){

    var fulledEl = null;

    function pictureInPicture(el) {
        if (el === false) {
            return   document.exitPictureInPicture();
        } else if (el) {
            if (el !== document.pictureInPictureElement) {
                el.requestPictureInPicture();
                fulledEl = el;
            }          
        } else {
            return document.pictureInPictureElement;
        }
    }
	
	return noder.pictureInPicture = pictureInPicture;
});
define('skylark-domx-noder/prepend',[
    "./noder",
    "./_enhance_place_content",
    "./_ensure_nodes"
],function(noder,enhancePlaceContent,ensureNodes){

    /*   
     * insert one or more nodes as the first children of the specified node.
     * @param {Node} node
     * @param {Node or ArrayLike} placing
     * @param {Boolean Optional} copyByClone
     */
    function prepend(node, placing, copyByClone) {
        var parentNode = node,
            refNode = parentNode.firstChild,
            nodes = ensureNodes(placing, copyByClone);
        for (var i = 0; i < nodes.length; i++) {
            if (refNode) {
                parentNode.insertBefore(nodes[i], refNode);
            } else {
                parentNode.appendChild(nodes[i]);
            }
        }
        return this;
    }

	
	return noder.prepend = prepend;
});
define('skylark-domx-noder/reflow',[
	"./noder"
],function(noder){
 
    function reflow(elm) {
        if (!elm) {
          elm = document;
        }
        elm.offsetHeight;

        return this;      
    }
	
	return noder.reflow = reflow;
});
define('skylark-domx-noder/remove-child',[
    "skylark-langx-types",
	"./noder"
],function(types,noder){
 

    function removeChild(node,children) {
        if (!types.isArrayLike(children)) {
            children = [children];
        }
        for (var i=0;i<children.length;i++) {
            node.removeChild(children[i]);
        }

        return this;
    }

	
	return noder.removeChild = removeChild;
});
define('skylark-domx-noder/remove',[
	"./noder"
],function(noder){
 
    /*   
     * Remove the set of matched elements from the DOM.
     * @param {Node} node
     */
    function remove(node) {
        if (node && node.parentNode) {
            try {
                node.parentNode.removeChild(node);
            } catch (e) {
                console.warn("The node is already removed", e);
            }
        }
        return this;
    }
	
	return noder.remove = remove;
});
define('skylark-domx-noder/replace',[
	"./noder"
],function(noder){
     /*   
     * Replace an old node with the specified node.
     * @param {Node} node
     * @param {Node} oldNode
     */
    function replace(node, oldNode) {
        oldNode.parentNode.replaceChild(node, oldNode);
        return this;
    }

	return noder.replace = replace;
});
define('skylark-domx-noder/reverse',[
	"./noder"
],function(noder){
    /*   
     *
     * @param {Node} node
     */
    function reverse(node) {
        var firstChild = node.firstChild;
        for (var i = node.children.length - 1; i > 0; i--) {
            if (i > 0) {
                var child = node.children[i];
                node.insertBefore(child, firstChild);
            }
        }
    }
	
	return noder.reverse = reverse;
});
define('skylark-domx-noder/root',[
	"./noder"
],function(noder){
	function root() {
		return  document.documentElement;
	}
	
	return noder.root = root;
});
define('skylark-domx-noder/scrolling-element',[
	"./noder"
],function(noder){
	function scrollingElement() {
		return document.scrollingElement || document.documentElement;
	}
	
	return noder.scrollingElement = scrollingElement;
});
define('skylark-domx-noder/selectable',[
	"./noder"
],function(noder){
 

    function selectable(elem, selectable) {
        if (elem === undefined || elem.style === undefined)
            return;
        elem.onselectstart = selectable ? function () {
            return false;
        } : function () {
        };
        elem.style.MozUserSelect = selectable ? 'auto' : 'none';
        elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
        elem.unselectable = selectable ? 'on' : 'off';
    }

	
	return noder.selectable = selectable;
});
define('skylark-domx-noder/throb',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./noder"
],function(langx,styler,noder) {

    
    /*   
     * Replace an old node with the specified node.
     * @param {HTMLElement} elm
     * @param {Node} params
     */
    function throb(elm, params) {
        params = params || {};

        var self = this,
            text = params.text,
            style = params.style,
            time = params.time,
            callback = params.callback,
            timer,

            throbber = noder.createElement("div", {
                "className": params.className || "throbber"
            }),
            //_overlay = overlay(throbber, {
            //    "class": 'overlay fade'
            //}),
            remove = function() {
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
                if (throbber) {
                    noder.remove(throbber);
                    throbber = null;
                }
            },
            update = function(params) {
                if (params && params.text && throbber) {
                    textNode.nodeValue = params.text;
                }
            };

        if (params.style) {
            styler.css(throbber,params.style);
        }

        //throb = noder.createElement("div", {
        //   "class": params.throb && params.throb.className || "throb"
        //}),
        //textNode = noder.createTextNode(text || ""),
 
        var content = params.content ||  '<span class="throb"></span>';

        //throb.appendChild(textNode);
        //throbber.appendChild(throb);

        noder.html(throbber,content);
        
        elm.appendChild(throbber);

        var end = function() {
            remove();
            if (callback) callback();
        };
        if (time) {
            timer = setTimeout(end, time);
        }

        return {
            throbber : throbber,
            remove: remove,
            update: update
        };
    }

    return noder.throb = throb;
});
define('skylark-domx-noder/traverse',[
	"./noder"
],function(noder){
 
    /*   
     * traverse the specified node and its descendants, perform the callback function on each
     * @param {Node} node
     * @param {Function} fn
     */
    function traverse(node, fn) {
        fn(node)
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
            traverse(node.childNodes[i], fn);
        }
        return this;
    }
	
	return noder.traverse = traverse;
});
define('skylark-domx-noder/unwrap',[
	"./noder",
    "./is-doc"
],function(noder,isDoc){

    /*   
     * Remove the parents of the set of matched elements from the DOM, leaving the matched
     * @param {Node} node
     */
    function unwrap(node) {
        var child, parent = node.parentNode;
        if (parent) {
            if (isDoc(parent.parentNode)) return;
            parent.parentNode.insertBefore(node, parent);
        }
    }

	return noder.unwrap = unwrap;
});
define('skylark-domx-noder/wrapper-inner',[
	"./noder"
],function(noder){
    var  slice = Array.prototype.slice;

    /*   
     * Wrap an HTML structure around the content of each element in the set of matched
     * @param {Node} node
     * @param {Node} wrapperNode
     */
    function wrapperInner(node, wrapperNode) {
        var childNodes = slice.call(node.childNodes);
        node.appendChild(wrapperNode);
        for (var i = 0; i < childNodes.length; i++) {
            wrapperNode.appendChild(childNodes[i]);
        }
        return this;
    }

	
	return noder.wrapperInner = wrapperInner;
});
define('skylark-domx-noder/wrapper',[
	"./noder"
],function(noder){
 
    /*   
     * Wrap an HTML structure around each element in the set of matched elements.
     * @param {Node} node
     * @param {Node} wrapperNode
     */
    function wrapper(node, wrapperNode) {
        if (types.isString(wrapperNode)) {
            wrapperNode = this.createFragment(wrapperNode).firstChild;
        }
        node.parentNode.insertBefore(wrapperNode, node);
        wrapperNode.appendChild(node);
    }
	
	return noder.wrapper = wrapper;
});
define('skylark-domx-noder/main',[
	"./noder",
	"./active",
	"./after",
	"./append",
	"./before",
	"./body",
	"./clone",
	"./contains",
	"./create-element",
	"./create-fragment",
	"./create-text-node",
	"./doc",
	"./empty",
	"./focusable",
	"./from-point",
	"./fullscreen",
	"./html",
	"./is-active",
	"./is-block-node",
	"./is-child-of",
	"./is-doc",
	"./is-editable",
	"./is-element",
	"./is-fragment",
	"./is-fullscreen",
	"./is-in-document",
	"./is-in-frame",
	"./is-input",
	"./is-text-node",
	"./is-window",
	"./node-name",
	"./offset-parent",
	"./overlay",
	"./owner-doc",
	"./owner-window",
	"./picture-in-picture",
	"./prepend",
	"./reflow",
	"./remove-child",
	"./remove",
	"./replace",
	"./reverse",
	"./root",
	"./scrolling-element",
	"./selectable",
	"./throb",
	"./traverse",
	"./unwrap",
	"./wrapper-inner",
	"./wrapper",
	"./throb"
],function(noder){
	return noder;
});
define('skylark-domx-noder', ['skylark-domx-noder/main'], function (main) { return main; });

define('skylark-domx-finder/finder',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-noder",
    "skylark-domx-styler"
], function(skylark, langx, browser, noder,styler) {
    var local = {},
        filter = Array.prototype.filter,
        slice = Array.prototype.slice,
        nativeMatchesSelector = browser.matchesSelector;

    /*
    ---
    name: Slick.Parser
    description: Standalone CSS3 Selector parser
    provides: Slick.Parser
    ...
    */
    ;
    (function() {

        var parsed,
            separatorIndex,
            combinatorIndex,
            reversed,
            cache = {},
            reverseCache = {},
            reUnescape = /\\/g;

        var parse = function(expression, isReversed) {
            if (expression == null) return null;
            if (expression.Slick === true) return expression;
            expression = ('' + expression).replace(/^\s+|\s+$/g, '');
            reversed = !!isReversed;
            var currentCache = (reversed) ? reverseCache : cache;
            if (currentCache[expression]) return currentCache[expression];
            parsed = {
                Slick: true,
                expressions: [],
                raw: expression,
                reverse: function() {
                    return parse(this.raw, true);
                }
            };
            separatorIndex = -1;
            while (expression != (expression = expression.replace(regexp, parser)));
            parsed.length = parsed.expressions.length;
            return currentCache[parsed.raw] = (reversed) ? reverse(parsed) : parsed;
        };

        var reverseCombinator = function(combinator) {
            if (combinator === '!') return ' ';
            else if (combinator === ' ') return '!';
            else if ((/^!/).test(combinator)) return combinator.replace(/^!/, '');
            else return '!' + combinator;
        };

        var reverse = function(expression) {
            var expressions = expression.expressions;
            for (var i = 0; i < expressions.length; i++) {
                var exp = expressions[i];
                var last = {
                    parts: [],
                    tag: '*',
                    combinator: reverseCombinator(exp[0].combinator)
                };

                for (var j = 0; j < exp.length; j++) {
                    var cexp = exp[j];
                    if (!cexp.reverseCombinator) cexp.reverseCombinator = ' ';
                    cexp.combinator = cexp.reverseCombinator;
                    delete cexp.reverseCombinator;
                }

                exp.reverse().push(last);
            }
            return expression;
        };

        var escapeRegExp = (function() {
            // Credit: XRegExp 0.6.1 (c) 2007-2008 Steven Levithan <http://stevenlevithan.com/regex/xregexp/> MIT License
            var from = /(?=[\-\[\]{}()*+?.\\\^$|,#\s])/g,
                to = '\\';
            return function(string) {
                return string.replace(from, to)
            }
        }())

        var regexp = new RegExp(
            "^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)"
            .replace(/<combinator>/, '[' + escapeRegExp(">+~`!@$%^&={}\\;</") + ']')
            .replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
            .replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
        );

        function parser(
            rawMatch,

            separator,
            combinator,
            combinatorChildren,

            tagName,
            id,
            className,

            attributeKey,
            attributeOperator,
            attributeQuote,
            attributeValue,

            pseudoMarker,
            pseudoClass,
            pseudoQuote,
            pseudoClassQuotedValue,
            pseudoClassValue
        ) {
            if (separator || separatorIndex === -1) {
                parsed.expressions[++separatorIndex] = [];
                combinatorIndex = -1;
                if (separator) return '';
            }

            if (combinator || combinatorChildren || combinatorIndex === -1) {
                combinator = combinator || ' ';
                var currentSeparator = parsed.expressions[separatorIndex];
                if (reversed && currentSeparator[combinatorIndex])
                    currentSeparator[combinatorIndex].reverseCombinator = reverseCombinator(combinator);
                currentSeparator[++combinatorIndex] = {
                    combinator: combinator,
                    tag: '*'
                };
            }

            var currentParsed = parsed.expressions[separatorIndex][combinatorIndex];

            if (tagName) {
                currentParsed.tag = tagName.replace(reUnescape, '');

            } else if (id) {
                currentParsed.id = id.replace(reUnescape, '');

            } else if (className) {
                className = className.replace(reUnescape, '');

                if (!currentParsed.classList) currentParsed.classList = [];
                if (!currentParsed.classes) currentParsed.classes = [];
                currentParsed.classList.push(className);
                currentParsed.classes.push({
                    value: className,
                    regexp: new RegExp('(^|\\s)' + escapeRegExp(className) + '(\\s|$)')
                });

            } else if (pseudoClass) {
                pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue;
                pseudoClassValue = pseudoClassValue ? pseudoClassValue.replace(reUnescape, '') : null;

                if (!currentParsed.pseudos) currentParsed.pseudos = [];
                currentParsed.pseudos.push({
                    key: pseudoClass.replace(reUnescape, ''),
                    value: pseudoClassValue,
                    type: pseudoMarker.length == 1 ? 'class' : 'element'
                });

            } else if (attributeKey) {
                attributeKey = attributeKey.replace(reUnescape, '');
                attributeValue = (attributeValue || '').replace(reUnescape, '');

                var test, regexp;

                switch (attributeOperator) {
                    case '^=':
                        regexp = new RegExp('^' + escapeRegExp(attributeValue));
                        break;
                    case '$=':
                        regexp = new RegExp(escapeRegExp(attributeValue) + '$');
                        break;
                    case '~=':
                        regexp = new RegExp('(^|\\s)' + escapeRegExp(attributeValue) + '(\\s|$)');
                        break;
                    case '|=':
                        regexp = new RegExp('^' + escapeRegExp(attributeValue) + '(-|$)');
                        break;
                    case '=':
                        test = function(value) {
                            return attributeValue == value;
                        };
                        break;
                    case '*=':
                        test = function(value) {
                            return value && value.indexOf(attributeValue) > -1;
                        };
                        break;
                    case '!=':
                        test = function(value) {
                            return attributeValue != value;
                        };
                        break;
                    default:
                        test = function(value) {
                            return !!value;
                        };
                }

                if (attributeValue == '' && (/^[*$^]=$/).test(attributeOperator)) test = function() {
                    return false;
                };

                if (!test) test = function(value) {
                    return value && regexp.test(value);
                };

                if (!currentParsed.attributes) currentParsed.attributes = [];
                currentParsed.attributes.push({
                    key: attributeKey,
                    operator: attributeOperator,
                    value: attributeValue,
                    test: test
                });

            }

            return '';
        };

        // Slick NS

        var Slick = (this.Slick || {});

        Slick.parse = function(expression) {
            return parse(expression);
        };

        Slick.escapeRegExp = escapeRegExp;

        if (!this.Slick) this.Slick = Slick;

    }).apply(local);


    var simpleClassSelectorRE = /^\.([\w-]*)$/,
        simpleIdSelectorRE = /^#([\w-]*)$/,
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        slice = Array.prototype.slice;


    local.parseSelector = local.Slick.parse;


    var pseudos = local.pseudos = {
        // custom pseudos
        "button": function(elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === "button" || name === "button";
        },

        'checked': function(elm) {
            return !!elm.checked;
        },

        'contains': function(elm, idx, nodes, text) {
            if ($(this).text().indexOf(text) > -1) return this
        },

        'disabled': function(elm) {
            return !!elm.disabled;
        },

        'enabled': function(elm) {
            return !elm.disabled;
        },

        'eq': function(elm, idx, nodes, value) {
            return (idx == value);
        },

        'even': function(elm, idx, nodes, value) {
            return (idx % 2) === 0;
        },

        'focus': function(elm) {
            return document.activeElement === elm && (elm.href || elm.type || elm.tabindex);
        },

        'focusable': function( elm ) {
            return noder.focusable(elm, elm.tabindex != null );
        },

        'first': function(elm, idx) {
            return (idx === 0);
        },

        'gt': function(elm, idx, nodes, value) {
            return (idx > value);
        },

        'has': function(elm, idx, nodes, sel) {
            return find(elm, sel);
        },

        // Element/input types
        "header": function(elem) {
            return rheader.test(elem.nodeName);
        },

        'hidden': function(elm) {
            return !local.pseudos["visible"](elm);
        },

        "input": function(elem) {
            return rinputs.test(elem.nodeName);
        },

        'last': function(elm, idx, nodes) {
            return (idx === nodes.length - 1);
        },

        'lt': function(elm, idx, nodes, value) {
            return (idx < value);
        },

        'not': function(elm, idx, nodes, sel) {
            return !matches(elm, sel);
        },

        'odd': function(elm, idx, nodes, value) {
            return (idx % 2) === 1;
        },

        /*   
         * Get the parent of each element in the current set of matched elements.
         * @param {Object} elm
         */
        'parent': function(elm) {
            return !!elm.parentElement;
        },

        'selected': function(elm) {
            return !!elm.selected;
        },

        'tabbable': function(elm) {
            var tabIndex = elm.tabindex,
                hasTabindex = tabIndex != null;
            return ( !hasTabindex || tabIndex >= 0 ) && noder.focusable( element, hasTabindex );
        },

        'text': function(elm) {
            return elm.type === "text";
        },

        'visible': function(elm) {
            return elm.offsetWidth && elm.offsetWidth
        },
        'empty': function(elm) {
            return !elm.hasChildNodes();
        }
    };

    ["first", "eq", "last"].forEach(function(item) {
        pseudos[item].isArrayFilter = true;
    });



    pseudos["nth"] = pseudos["eq"];

    function createInputPseudo(type) {
        return function(elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === type;
        };
    }

    function createButtonPseudo(type) {
        return function(elem) {
            var name = elem.nodeName.toLowerCase();
            return (name === "input" || name === "button") && elem.type === type;
        };
    }

    // Add button/input type pseudos
    for (i in {
        radio: true,
        checkbox: true,
        file: true,
        password: true,
        image: true
    }) {
        pseudos[i] = createInputPseudo(i);
    }
    for (i in {
        submit: true,
        reset: true
    }) {
        pseudos[i] = createButtonPseudo(i);
    }


    local.divide = function(cond) {
        var nativeSelector = "",
            customPseudos = [],
            tag,
            id,
            classes,
            attributes,
            pseudos;


        if (id = cond.id) {
            nativeSelector += ("#" + id);
        }
        if (classes = cond.classes) {
            for (var i = classes.length; i--;) {
                nativeSelector += ("." + classes[i].value);
            }
        }
        if (attributes = cond.attributes) {
            for (var i = 0; i < attributes.length; i++) {
                if (attributes[i].operator) {
                    nativeSelector += ("[" + attributes[i].key + attributes[i].operator + JSON.stringify(attributes[i].value) + "]");
                } else {
                    nativeSelector += ("[" + attributes[i].key + "]");
                }
            }
        }
        if (pseudos = cond.pseudos) {
            for (i = pseudos.length; i--;) {
                part = pseudos[i];
                if (this.pseudos[part.key]) {
                    customPseudos.push(part);
                } else {
                    if (part.value !== undefined) {
                        nativeSelector += (":" + part.key + "(" + JSON.stringify(part))
                    }
                }
            }
        }

        if (tag = cond.tag) {
            if (tag !== "*") {
                nativeSelector = tag.toUpperCase() + nativeSelector;
            }
        }

        if (!nativeSelector) {
            nativeSelector = "*";
        }

        return {
            nativeSelector: nativeSelector,
            customPseudos: customPseudos
        }

    };

    local.check = function(node, cond, idx, nodes, arrayFilte) {
        var tag,
            id,
            classes,
            attributes,
            pseudos,

            i, part, cls, pseudo;

        if (!arrayFilte) {
            if (tag = cond.tag) {
                var nodeName = node.nodeName.toUpperCase();
                if (tag == '*') {
                    if (nodeName < '@') return false; // Fix for comment nodes and closed nodes
                } else {
                    if (nodeName != (tag || "").toUpperCase()) return false;
                }
            }

            if (id = cond.id) {
                if (node.getAttribute('id') != id) {
                    return false;
                }
            }


            if (classes = cond.classes) {
                for (i = classes.length; i--;) {
                    cls = node.getAttribute('class');
                    if (!(cls && classes[i].regexp.test(cls))) return false;
                }
            }

            if (attributes = cond.attributes) {
                for (i = attributes.length; i--;) {
                    part = attributes[i];
                    if (part.operator ? !part.test(node.getAttribute(part.key)) : !node.hasAttribute(part.key)) return false;
                }
            }

        }
        if (pseudos = cond.pseudos) {
            for (i = pseudos.length; i--;) {
                part = pseudos[i];
                if (pseudo = this.pseudos[part.key]) {
                    if ((arrayFilte && pseudo.isArrayFilter) || (!arrayFilte && !pseudo.isArrayFilter)) {
                        if (!pseudo(node, idx, nodes, part.value)) {
                            return false;
                        }
                    }
                } else {
                    if (!arrayFilte && !nativeMatchesSelector.call(node, part.key)) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    local.match = function(node, selector) {

        var parsed;

        if (langx.isString(selector)) {
            parsed = local.Slick.parse(selector);
        } else {
            parsed = selector;
        }

        if (!parsed) {
            return true;
        }

        // simple (single) selectors
        var expressions = parsed.expressions,
            simpleExpCounter = 0,
            i,
            currentExpression;
        for (i = 0;
            (currentExpression = expressions[i]); i++) {
            if (currentExpression.length == 1) {
                var exp = currentExpression[0];
                if (this.check(node, exp)) {
                    return true;
                }
                simpleExpCounter++;
            }
        }

        if (simpleExpCounter == parsed.length) {
            return false;
        }

        var nodes = this.query(document, parsed),
            item;
        for (i = 0; item = nodes[i++];) {
            if (item === node) {
                return true;
            }
        }
        return false;
    };


    local.filterSingle = function(nodes, exp) {
        var matchs = filter.call(nodes, function(node, idx) {
            return local.check(node, exp, idx, nodes, false);
        });

        matchs = filter.call(matchs, function(node, idx) {
            return local.check(node, exp, idx, matchs, true);
        });
        return matchs;
    };

    local.filter = function(nodes, selector) {
        var parsed;

        if (langx.isString(selector)) {
            parsed = local.Slick.parse(selector);
        } else {
            return local.filterSingle(nodes, selector);
        }

        // simple (single) selectors
        var expressions = parsed.expressions,
            i,
            currentExpression,
            ret = [];
        for (i = 0;
            (currentExpression = expressions[i]); i++) {
            if (currentExpression.length == 1) {
                var exp = currentExpression[0];

                var matchs = local.filterSingle(nodes, exp);

                ret = langx.uniq(ret.concat(matchs));
            } else {
                throw new Error("not supported selector:" + selector);
            }
        }

        return ret;

    };

    local.combine = function(elm, bit) {
        var op = bit.combinator,
            cond = bit,
            node1,
            nodes = [];

        switch (op) {
            case '>': // direct children
                nodes = children(elm, cond);
                break;
            case '+': // next sibling
                node1 = nextSibling(elm, cond, true);
                if (node1) {
                    nodes.push(node1);
                }
                break;
            case '^': // first child
                node1 = firstChild(elm, cond, true);
                if (node1) {
                    nodes.push(node1);
                }
                break;
            case '~': // next siblings
                nodes = nextSiblings(elm, cond);
                break;
            case '++': // next sibling and previous sibling
                var prev = previousSibling(elm, cond, true),
                    next = nextSibling(elm, cond, true);
                if (prev) {
                    nodes.push(prev);
                }
                if (next) {
                    nodes.push(next);
                }
                break;
            case '~~': // next siblings and previous siblings
                nodes = siblings(elm, cond);
                break;
            case '!': // all parent nodes up to document
                nodes = ancestors(elm, cond);
                break;
            case '!>': // direct parent (one level)
                node1 = parent(elm, cond);
                if (node1) {
                    nodes.push(node1);
                }
                break;
            case '!+': // previous sibling
                nodes = previousSibling(elm, cond, true);
                break;
            case '!^': // last child
                node1 = lastChild(elm, cond, true);
                if (node1) {
                    nodes.push(node1);
                }
                break;
            case '!~': // previous siblings
                nodes = previousSiblings(elm, cond);
                break;
            default:
                var divided = this.divide(bit);
                nodes = slice.call(elm.querySelectorAll(divided.nativeSelector));
                if (divided.customPseudos) {
                    for (var i = divided.customPseudos.length - 1; i >= 0; i--) {
                        nodes = filter.call(nodes, function(item, idx) {
                            return local.check(item, {
                                pseudos: [divided.customPseudos[i]]
                            }, idx, nodes, false)
                        });

                        nodes = filter.call(nodes, function(item, idx) {
                            return local.check(item, {
                                pseudos: [divided.customPseudos[i]]
                            }, idx, nodes, true)
                        });
                    }
                }
                break;

        }
        return nodes;
    }

    local.query = function(node, selector, single) {


        var parsed = this.Slick.parse(selector);

        var
            founds = [],
            currentExpression, currentBit,
            expressions = parsed.expressions;

        for (var i = 0;
            (currentExpression = expressions[i]); i++) {
            var currentItems = [node],
                found;
            for (var j = 0;
                (currentBit = currentExpression[j]); j++) {
                found = langx.map(currentItems, function(item, i) {
                    return local.combine(item, currentBit)
                });
                if (found) {
                    currentItems = found;
                }
            }
            if (found) {
                founds = founds.concat(found);
            }
        }

        return founds;
    }

    /*
     * Get the nearest ancestor of the specified element,optional matched by a selector.
     * @param {HTMLElement} node
     * @param {String Optional } selector
     * @param {Object} root
     */
    function ancestor(node, selector, root) {
        var rootIsSelector = root && langx.isString(root);
        while (node = node.parentElement) {
            if (matches(node, selector)) {
                return node;
            }
            if (root) {
                if (rootIsSelector) {
                    if (matches(node, root)) {
                        break;
                    }
                } else if (node == root) {
                    break;
                }
            }
        }
        return null;
    }

    /*
     * Get the ancestors of the specitied element , optionally filtered by a selector.
     * @param {HTMLElement} node
     * @param {String Optional } selector
     * @param {Object} root
     */
    function ancestors(node, selector, root) {
        var ret = [],
            rootIsSelector = root && langx.isString(root);
        while ((node = node.parentElement) && (node.nodeType !== 9)) {
            if (root) {
                if (rootIsSelector) {
                    if (matches(node, root)) {
                        break;
                    }
                } else if (langx.isArrayLike(root)) {
                    if (langx.inArray(node,root)>-1) {
                        break;
                    }
                } else if (node == root) {
                    break;
                }
            }
            if (!selector || matches(node, selector)) {
              ret.push(node); 
            }
        }

        //if (selector) {
        //    ret = local.filter(ret, selector);
        //}
        return ret;
    }


    /*
     * Returns a element by its ID.
     * @param {string} id
     */
    function byId(id, doc) {
        doc = doc || noder.doc();
        return doc.getElementById(id);
    }

    /*
     * Get the children of the specified element , optionally filtered by a selector.
     * @param {string} node
     * @param {String optionlly} selector
     */
    function children(node, selector) {
        var childNodes = node.childNodes,
            ret = [];
        for (var i = 0; i < childNodes.length; i++) {
            var node = childNodes[i];
            if (node.nodeType == 1) {
                ret.push(node);
            }
        }
        if (selector) {
            ret = local.filter(ret, selector);
        }
        return ret;
    }



    /**
     * Gets nth child of elm, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
     * and non-draggable elements
     * @param  {HTMLElement} elm       The parent element
     * @param  {Number} idx      The index of the child
     * @param  {Object} options       Parent's options
     * @return {HTMLElement}          The child at index idx, or null if not found
     */
    function childAt(elm, idx, options) {
        var currentChild = 0,
            children = elm.children;

        options = langx.mixin({
            ignoreHidden : true,
            excluding : null,
            closesting : null
        },options);

        for(var i=0;i < children.length;i++) {
            var child = children[i];
            if (options.ignoreHidden && styler.css(child) === "none") {
                continue;
            }
            if (options.excluding && options.excluding.includes(child)) {
                continue;
            }

            if (options.closesting &&  !closest(child, options.closesting, elm, false)) {
                continue;
            }

            if (currentChild === idx) {
                return child;
            }
            currentChild++;
        }
        return null;
    }



    //function closest(node, selector) {
    //    while (node && !(matches(node, selector))) {
    //        node = node.parentElement;
    //    }
    //   return node;
    //}


    function closest(/**HTMLElement*/elm, /**String*/selector, /**HTMLElement*/ctx, includeCTX) {
        if (elm) {
            ctx = ctx || document;

            do {
                if (
                    selector != null &&
                    (
                        selector[0] === '>' ?
                        elm.parentElement === ctx && matches(elm, selector) :
                        matches(elm, selector)
                    ) ||
                    includeCTX && elm === ctx
                ) {
                    return elm;
                }

                if (elm === ctx) break;
                /* jshint boss:true */
            } while (elm = parent(elm));
        }

        return null;
    }
    /*
     * Get the decendant of the specified element , optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function descendants(elm, selector) {
        // Selector
        try {
            return slice.call(elm.querySelectorAll(selector));
        } catch (matchError) {
            //console.log(matchError);
        }
        return local.query(elm, selector);
    }

    /*
     * Get the nearest decendent of the specified element,optional matched by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function descendant(elm, selector) {
        // Selector
        try {
            return elm.querySelector(selector);
        } catch (matchError) {
            //console.log(matchError);
        }
        var nodes = local.query(elm, selector);
        if (nodes.length > 0) {
            return nodes[0];
        } else {
            return null;
        }
    }

    /*
     * Get the descendants of each element in the current set of matched elements, filtered by a selector, jQuery object, or element.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function find(elm, selector) {
        if (!selector) {
            selector = elm;
            elm = document.body;
        }
        if (matches(elm, selector)) {
            return elm;
        } else {
            return descendant(elm, selector);
        }
    }

    /*
     * Get the findAll of the specified element , optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function findAll(elm, selector) {
        if (!selector) {
            selector = elm;
            elm = document.body;
        }
        return descendants(elm, selector);
    }

    /*
     * Get the first child of the specified element , optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     * @param {String} first
     */
    function firstChild(elm, selector, first) {
        var childNodes = elm.childNodes,
            node = childNodes[0];
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    return node;
                }
                if (first) {
                    break;
                }
            }
            node = node.nextSibling;
        }

        return null;
    }


    /**
     * Returns the index of an element within its parent for a selected set of
     * elements
     * @param  {HTMLElement} el
     * @param  {selector} selector
     * @return {number}
     */
    function index(el, selector) {
        var index = 0;

        if (!el || !el.parentNode) {
            return -1;
        }

        while (el && (el = el.previousElementSibling)) {
            if (langx.isString(selector)) {
                if (matches(el, selector)) {
                    index++;
                }
            } else if (langx.isFunction(selector)) {
                if (selector(el)) {
                    index++;
                }
            }
            index++;
        }

        return index;
    }    

    /*
     * Get the last child of the specified element , optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     * @param {String } last
     */
    function lastChild(elm, selector, last) {
        var childNodes = elm.childNodes,
            node = childNodes[childNodes.length - 1];
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    return node;
                }
                if (last) {
                    break;
                }
            }
            node = node.previousSibling;
        }

        return null;
    }

    /*
     * Check the specified element against a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function matches(elm, selector) {
        if (!selector || !elm || elm.nodeType !== 1) {
            return false
        }

        if (langx.isString(selector)) {
            try {
                return nativeMatchesSelector.call(elm, selector.replace(/\[([^=]+)=\s*([^'"\]]+?)\s*\]/g, '[$1="$2"]'));
            } catch (matchError) {
                //console.log(matchError);
            }
            return local.match(elm, selector);
        } else if (langx.isArrayLike(selector)) {
            return langx.inArray(elm, selector) > -1;
        } else if (langx.isPlainObject(selector)) {
            return local.check(elm, selector);
        } else {
            return elm === selector;
        }

    }

    /*
     * Get the nearest next sibing of the specitied element , optional matched by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     * @param {Boolean Optional} adjacent
     */
    function nextSibling(elm, selector, adjacent) {
        var node = elm.nextSibling;
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    return node;
                }
                if (adjacent) {
                    break;
                }
            }
            node = node.nextSibling;
        }
        return null;
    }

    /*
     * Get the next siblings of the specified element , optional filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function nextSiblings(elm, selector) {
        var node = elm.nextSibling,
            ret = [];
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    ret.push(node);
                }
            }
            node = node.nextSibling;
        }
        return ret;
    }

    /*
     * Get the parent element of the specified element. if a selector is provided, it retrieves the parent element only if it matches that selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function parent(elm, selector) {
        var node = (elm.host && elm !== document && elm.host.nodeType) ? elm.host : elm.parentElement;

        if (node && (!selector || matches(node, selector))) {
            return node;
        }

        return null;
    }

    /*
     * Get hte nearest previous sibling of the specified element ,optional matched by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     * @param {Boolean Optional } adjacent
     */
    function previousSibling(elm, selector, adjacent) {
        var node = elm.previousSibling;
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    return node;
                }
                if (adjacent) {
                    break;
                }
            }
            node = node.previousSibling;
        }
        return null;
    }

    /*
     * Get all preceding siblings of each element in the set of matched elements, optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function previousSiblings(elm, selector) {
        var node = elm.previousSibling,
            ret = [];
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    ret.push(node);
                }
            }
            node = node.previousSibling;
        }
        return ret;
    }

    /*
     * Selects all sibling elements that follow after the “prev” element, have the same parent, and match the filtering “siblings” selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function siblings(elm, selector) {
        var node = elm.parentElement.firstChild,
            ret = [];
        while (node) {
            if (node.nodeType == 1 && node !== elm) {
                if (!selector || matches(node, selector)) {
                    ret.push(node);
                }
            }
            node = node.nextSibling;
        }
        return ret;
    }


    function scrollableParent(el, includeSelf) {
        // skip to window
        if (!el || !el.getBoundingClientRect) {
            return noder.scrollingElement();
        }

        var elem = el;
        var gotSelf = false;
        do {
            // we don't need to get elem css if it isn't even overflowing in the first place (performance)
            if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
                var elemCSS = styler.css(elem);
                if (
                    elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') ||
                    elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')
                ) {
                    if (!elem || !elem.getBoundingClientRect || elem === document.body) {
                        return noder.scrollingElement();
                    } 
                    if (gotSelf || includeSelf) {
                        return elem;
                    }
                    gotSelf = true;
                }
            }
        /* jshint boss:true */
        } while (elem = elem.parentNode);

        return noder.scrollingElement();
    }


    var finder = function() {
        return finder;
    };

    langx.mixin(finder, {

        ancestor: ancestor,

        ancestors: ancestors,

        byId: byId,

        childAt: childAt,

        children: children,

        closest: closest,

        descendant: descendant,

        descendants: descendants,

        find: find,

        findAll: findAll,

        firstChild: firstChild,

        index,

        lastChild: lastChild,

        matches: matches,

        nextSibling: nextSibling,

        nextSiblings: nextSiblings,

        parent: parent,

        previousSibling,

        previousSiblings,

        pseudos: local.pseudos,

        scrollableParent,

        siblings: siblings
    });

    return skylark.attach("domx.finder", finder);
});
define('skylark-domx-finder/main',[
	"./finder"
],function(finder){

	return finder;
});
define('skylark-domx-finder', ['skylark-domx-finder/main'], function (main) { return main; });

define('skylark-domx-data/data',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-finder",
    "skylark-domx-noder"
], function(skylark, langx, finder,noder) {
    var map = Array.prototype.map,
        filter = Array.prototype.filter,
        camelCase = langx.camelCase,
        deserializeValue = langx.deserializeValue,

        capitalRE = /([A-Z])/g,
        propMap = {
            'tabindex': 'tabIndex',
            'readonly': 'readOnly',
            'for': 'htmlFor',
            'class': 'className',
            'maxlength': 'maxLength',
            'cellspacing': 'cellSpacing',
            'cellpadding': 'cellPadding',
            'rowspan': 'rowSpan',
            'colspan': 'colSpan',
            'usemap': 'useMap',
            'frameborder': 'frameBorder',
            'contenteditable': 'contentEditable'
        };

    // Strip and collapse whitespace according to HTML spec
    function stripAndCollapse( value ) {
      var tokens = value.match( /[^\x20\t\r\n\f]+/g ) || [];
      return tokens.join( " " );
    }


    var valHooks = {
      option: {
        get: function( elem ) {
          var val = elem.getAttribute( "value" );
          return val != null ?  val :  stripAndCollapse(text( elem ) );
        }
      },
      select: {
        get: function( elem ) {
          var value, option, i,
            options = elem.options,
            index = elem.selectedIndex,
            one = elem.type === "select-one",
            values = one ? null : [],
            max = one ? index + 1 : options.length;

          if ( index < 0 ) {
            i = max;

          } else {
            i = one ? index : 0;
          }

          // Loop through all the selected options
          for ( ; i < max; i++ ) {
            option = options[ i ];

            if ( option.selected &&

                // Don't return options that are disabled or in a disabled optgroup
                !option.disabled &&
                ( !option.parentNode.disabled ||
                  !noder.nodeName( option.parentNode, "optgroup" ) ) ) {

              // Get the specific value for the option
              value = val(option);

              // We don't need an array for one selects
              if ( one ) {
                return value;
              }

              // Multi-Selects return an array
              values.push( value );
            }
          }

          return values;
        },

        set: function( elem, value ) {
          var optionSet, option,
            options = elem.options,
            values = langx.makeArray( value ),
            i = options.length;

          while ( i-- ) {
            option = options[ i ];

            /* eslint-disable no-cond-assign */

            if ( option.selected =
              langx.inArray( valHooks.option.get( option ), values ) > -1
            ) {
              optionSet = true;
            }

            /* eslint-enable no-cond-assign */
          }

          // Force browsers to behave consistently when non-matching value is set
          if ( !optionSet ) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    };


    // Radios and checkboxes getter/setter
    langx.each( [ "radio", "checkbox" ], function() {
      valHooks[ this ] = {
        set: function( elem, value ) {
          if ( langx.isArray( value ) ) {
            return ( elem.checked = langx.inArray( val(elem), value ) > -1 );
          }
        }
      };
    });



    /*
     * Set property values
     * @param {Object} elm  
     * @param {String} name
     * @param {String} value
     */

    function setAttribute(elm, name, value) {
        if (value == null) {
            elm.removeAttribute(name);
        } else {
            elm.setAttribute(name, value);
        }
    }

    function aria(elm, name, value) {
        return this.attr(elm, "aria-" + name, value);
    }

    /*
     * Set property values
     * @param {Object} elm  
     * @param {String} name
     * @param {String} value
     */

    function attr(elm, name, value) {
        if (value === undefined) {
            if (typeof name === "object") {
                for (var attrName in name) {
                    attr(elm, attrName, name[attrName]);
                }
                return this;
            } else {
                return elm.getAttribute ? elm.getAttribute(name) : elm[name];
            }
        } else {
            elm.setAttribute ? elm.setAttribute(name, value) : elm[name] = value;
            return this;
        }
    }


    /*
     *  Read all "data-*" attributes from a node
     * @param {Object} elm  
     */

    function _attributeData(elm) {
        var store = {}
        langx.each(elm.attributes || [], function(i, attr) {
            if (attr.name.indexOf('data-') == 0) {
                store[camelCase(attr.name.replace('data-', ''))] = deserializeValue(attr.value);
            }
        })
        return store;
    }

    function _store(elm, confirm) {
        var store = elm["_$_store"];
        if (!store && confirm) {
            store = elm["_$_store"] = _attributeData(elm);
        }
        return store;
    }

    function _getData(elm, name) {
        if (name === undefined) {
            return _store(elm, true);
        } else {
            var store = _store(elm);
            if (store) {
                if (name in store) {
                    return store[name];
                }
                var camelName = camelCase(name);
                if (camelName in store) {
                    return store[camelName];
                }
            }
            var attrName = 'data-' + name.replace(capitalRE, "-$1").toLowerCase()
            var value = attr(elm, attrName);
            if (!langx.isString(value)) {
              value = undefined;
            }
            return value;
        }

    }

    function _setData(elm, name, value) {
        var store = _store(elm, true);
        store[camelCase(name)] = value;
    }


    /*
     * xxx
     * @param {Object} elm  
     * @param {String} name
     * @param {String} value
     */
    function data(elm, name, value) {

        if (value === undefined) {
            if (typeof name === "object") {
                for (var dataAttrName in name) {
                    _setData(elm, dataAttrName, name[dataAttrName]);
                }
                return this;
            } else {
                return _getData(elm, name);
            }
        } else {
            _setData(elm, name, value);
            return this;
        }
    } 
    /*
     * Remove from the element all items that have not yet been run. 
     * @param {Object} elm  
     */

    function cleanData(elm) {
        if (elm["_$_store"]) {
            delete elm["_$_store"];
        }
    }

    /*
     * Remove a previously-stored piece of data. 
     * @param {Object} elm  
     * @param {Array} names
     */
    function removeData(elm, names) {
        if (names) {
            if (langx.isString(names)) {
                names = names.split(/\s+/);
            }
            var store = _store(elm, true);
            names.forEach(function(name) {
                delete store[name];
            });            
        } else {
            cleanData(elm);
        }
        return this;
    }

    /*
     * xxx 
     * @param {Object} elm  
     * @param {Array} names
     */
    function pluck(nodes, property) {
        return map.call(nodes, function(elm) {
            return elm[property];
        });
    }

    /*
     * Get or set the value of an property for the specified element.
     * @param {Object} elm  
     * @param {String} name
     * @param {String} value
     */
    function prop(elm, name, value) {
      if (value === undefined) {
          if (typeof name === "object") {
              for (var propName in name) {
                  prop(elm, propName, name[propName]);
              }
              return this;
          } 
      } 


      name = propMap[name] || name;
      if (value === undefined) {
          return elm[name];
      } else {
          elm[name] = value;
          return this;
      }
    }

    /*
     * remove Attributes  
     * @param {Object} elm  
     * @param {String} name
     */
    function removeAttr(elm, name) {
        name.split(' ').forEach(function(attr) {
            setAttribute(elm, attr);
        });
        return this;
    }


    /*
     * Remove the value of a property for the first element in the set of matched elements or set one or more properties for every matched element.
     * @param {Object} elm  
     * @param {String} name
     */
    function removeProp(elm, name) {
        name.split(' ').forEach(function(prop) {
            delete elm[prop];
        });
        return this;
    }

    /*   
     * Get the combined text contents of each element in the set of matched elements, including their descendants, or set the text contents of the matched elements.  
     * @param {Object} elm  
     * @param {String} txt
     */
    function text(elm, txt) {
        if (txt === undefined) {
            return elm.textContent !==undefined  ? elm.textContent : elm.innerText;
        } else {
            txt = txt == null ? '' : '' + txt ;
            if (elm.textContent !==undefined ) {
              elm.textContent = txt ;
            } else {
              elm.innerText = txt ;
            }
            return this;
        }
    }

    /*   
     * Get the current value of the first element in the set of matched elements or set the value of every matched element.
     * @param {Object} elm  
     * @param {String} value
     */
    function val(elm, value) {
        var hooks = valHooks[ elm.type ] || valHooks[ elm.nodeName.toLowerCase() ];
        if (value === undefined) {
/*
            if (elm.multiple) {
                // select multiple values
                var selectedOptions = filter.call(finder.find(elm, "option"), (function(option) {
                    return option.selected;
                }));
                return pluck(selectedOptions, "value");
            } else {
                if (/input|textarea/i.test(elm.tagName)) {
                  return elm.value;
                }
                return text(elm);
            }
*/

          if ( hooks &&  "get" in hooks &&  ( ret = hooks.get( elm, "value" ) ) !== undefined ) {
            return ret;
          }

          ret = elm.value;

          // Handle most common string cases
          if ( typeof ret === "string" ) {
            return ret.replace( /\r/g, "" );
          }

          // Handle cases where value is null/undef or number
          return ret == null ? "" : ret;

        } else {
/*          
            if (/input|textarea/i.test(elm.tagName)) {
              elm.value = value;
            } else {
              text(elm,value);
            }
            return this;
*/
          // Treat null/undefined as ""; convert numbers to string
          if ( value == null ) {
            value = "";

          } else if ( typeof value === "number" ) {
            value += "";

          } else if ( langx.isArray( value ) ) {
            value = langx.map( value, function( value1 ) {
              return value1 == null ? "" : value1 + "";
            } );
          }

          // If set returns undefined, fall back to normal setting
          if ( !hooks || !( "set" in hooks ) || hooks.set( elm, value, "value" ) === undefined ) {
            elm.value = value;
          }
        }      
    }


    finder.pseudos.data = function( elem, i, match,dataName ) {
        return !!data( elem, dataName || match[3]);
    };
   

    function datax() {
        return datax;
    }

    langx.mixin(datax, {
        aria: aria,

        attr: attr,

        cleanData: cleanData,

        data: data,

        pluck: pluck,

        prop: prop,

        removeAttr: removeAttr,

        removeData: removeData,

        removeProp: removeProp,

        text: text,

        val: val,

        valHooks : valHooks
    });

    return skylark.attach("domx.data", datax);
});
define('skylark-domx-query/query',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-finder"
], function(skylark, langx, noder, finder) {
    var some = Array.prototype.some,
        push = Array.prototype.push,
        every = Array.prototype.every,
        concat = Array.prototype.concat,
        slice = Array.prototype.slice,
        map = Array.prototype.map,
        filter = Array.prototype.filter,
        forEach = Array.prototype.forEach,
        indexOf = Array.prototype.indexOf,
        sort = Array.prototype.sort,
        isQ;

    var rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/;

    var funcArg = langx.funcArg,
        isArrayLike = langx.isArrayLike,
        isString = langx.isString,
        uniq = langx.uniq,
        isFunction = langx.isFunction;

    var type = langx.type,
        isArray = langx.isArray,

        isWindow = langx.isWindow,

        isDocument = langx.isDocument,

        isObject = langx.isObject,

        isPlainObject = langx.isPlainObject,

        compact = langx.compact,

        flatten = langx.flatten,

        camelCase = langx.camelCase,

        dasherize = langx.dasherize,
        children = finder.children;

    function wrapper_node_operation(func, context, oldValueFunc) {
        return function(html) {
            var argType, nodes = langx.map(arguments, function(arg) {
                argType = type(arg)
                return argType == "function" || argType == "object" || argType == "array" || arg == null ?
                    arg : noder.createFragment(arg)
            });
            if (nodes.length < 1) {
                return this
            }
            this.each(function(idx) {
                func.apply(context, [this, nodes, idx > 0]);
            });
            return this;
        }
    }

    function wrapper_map(func, context,mapValue) {
        return function() {
            var self = this,
                params = slice.call(arguments);
            var result = langx.map(self, function(elem, idx) {
                return func.apply(context, [elem].concat(params));
            });
            if (mapValue) {
                return result;
            } else {
                    return query(uniq(result));
            }
        }
    }

    function wrapper_selector(func, context, last) {
        return function(selector) {
            var self = this,
                params = slice.call(arguments);
            var result = this.map(function(idx, elem) {
                // if (elem.nodeType == 1) {
                if (elem.querySelector) {
                    return func.apply(context, last ? [elem] : [elem, selector]);
                } else {
                    return [];
                }
            });
            if (last && selector) {
                return result.filter(selector);
            } else {
                return result;
            }
        }
    }

    function wrapper_selector_until(func, context, last) {
        return function(util, selector) {
            var self = this,
                params = slice.call(arguments);
            //if (selector === undefined) { //TODO : needs confirm?
            //    selector = util;
            //    util = undefined;
            //}
            var result = this.map(function(idx, elem) {
                // if (elem.nodeType == 1) { // TODO
                //if (elem.querySelector) {
                    return func.apply(context, last ? [elem, util] : [elem, selector, util]);
                //} else {
                //    return [];
                //}
            });
            if (last && selector) {
                return result.filter(selector);
            } else {
                return result;
            }
        }
    }


    function wrapper_every_act(func, context) {
        return function() {
            var self = this,
                params = slice.call(arguments);
            this.each(function(idx,node) {
                func.apply(context, [this].concat(params));
            });
            return self;
        }
    }

    function wrapper_every_act_firstArgFunc(func, context, oldValueFunc) {
        return function(arg1) {
            var self = this,
                params = slice.call(arguments);
            forEach.call(self, function(elem, idx) {
                var newArg1 = funcArg(elem, arg1, idx, oldValueFunc(elem));
                func.apply(context, [elem, newArg1].concat(params.slice(1)));
            });
            return self;
        }
    }

    function wrapper_some_chk(func, context) {
        return function() {
            var self = this,
                params = slice.call(arguments);
            return some.call(self, function(elem) {
                return func.apply(context, [elem].concat(params));
            });
        }
    }

    function wrapper_name_value(func, context, oldValueFunc) {
        return function(name, value) {
            var self = this;

            if (langx.isPlainObject(name) || langx.isDefined(value)) {
                forEach.call(self, function(elem, idx) {
                    var newValue;
                    if (oldValueFunc) {
                        newValue = funcArg(elem, value, idx, oldValueFunc(elem, name));
                    } else {
                        newValue = value
                    }
                    func.apply(context, [elem,name,newValue]);
                });
                return self;
            } else {
                if (self[0]) {
                    return func.apply(context, [self[0], name]);
                }
            }

        }
    }

    function wrapper_value(func, context, oldValueFunc) {
        return function(value) {
            var self = this;

            if (langx.isDefined(value)) {
                forEach.call(self, function(elem, idx) {
                    var newValue;
                    if (oldValueFunc) {
                        newValue = funcArg(elem, value, idx, oldValueFunc(elem));
                    } else {
                        newValue = value
                    }
                    func.apply(context, [elem, newValue]);
                });
                return self;
            } else {
                if (self[0]) {
                    return func.apply(context, [self[0]]);
                }
            }

        }
    }


    var NodeList = langx.klass({
        klassName: "SkNodeList",
        init: function(selector, context) {
            var self = this,
                match, nodes, node, props;

            if (selector) {
                self.context = context = context || noder.doc();

                if (isString(selector)) {
                    // a html string or a css selector is expected
                    self.selector = selector;

                    if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
                        match = [null, selector, null];
                    } else {
                        match = rquickExpr.exec(selector);
                    }

                    if (match) {
                        if (match[1]) {
                            // if selector is html
                            nodes = noder.createFragment(selector);

                            if (langx.isPlainObject(context)) {
                                props = context;
                            }

                        } else {
                            node = finder.byId(match[2], noder.ownerDoc(context));

                            if (node) {
                                // if selector is id
                                nodes = [node];
                            }

                        }
                    } else {
                        // if selector is css selector
                        if (langx.isString(context)) {
                            context = finder.find(context);
                        }

                        nodes = finder.descendants(context, selector);
                    }
                } else {
                    if (!noder.isWindow(selector) && isArrayLike(selector)) {
                        // a dom node array is expected
                        nodes = selector;
                    } else {
                        // a dom node is expected
                        nodes = [selector];
                    }
                    //self.add(selector, false);
                }
            }


            if (nodes) {

                push.apply(self, nodes);

                if (props) {
                    for ( var name  in props ) {
                        // Properties of context are called as methods if possible
                        if ( langx.isFunction( this[ name ] ) ) {
                            this[ name ]( props[ name ] );
                        } else {
                            this.attr( name, props[ name ] );
                        }
                    }
                }
            }

            return self;
        }
    });

    var query = (function() {
        isQ = function(object) {
            return object instanceof NodeList;
        }
        init = function(selector, context) {
            return new NodeList(selector, context);
        }

        var $ = function(selector, context) {
            if (isFunction(selector)) {
                $.ready(function() {
                    selector($);
                });
                return rootQuery;
            } else if (isQ(selector)) {
                return selector;
            } else {
                if (context && isQ(context) && isString(selector)) {
                    return context.find(selector);
                }
                return init(selector, context);
            }
        },rootQuery = $(document);

        $.fn = NodeList.prototype;
        langx.mixin($.fn, {
            // `map` and `slice` in the jQuery API work differently
            // from their array counterparts
            length : 0,

            map: function(fn) {
                return $(uniq(langx.map(this, function(el, i) {
                    return fn.call(el, i, el)
                })));
            },

            slice: function() {
                return $(slice.apply(this, arguments))
            },

            forEach: function() {
                return forEach.apply(this,arguments);
            },

            get: function(idx) {
                return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]
            },

            indexOf: function() {
                return indexOf.apply(this,arguments);
            },

            sort : function() {
                return sort.apply(this,arguments);
            },

            toArray: function() {
                return slice.call(this);
            },

            size: function() {
                return this.length
            },

            //remove: wrapper_every_act(noder.remove, noder),
            remove : function(selector) {
                if (selector) {
                    return this.find(selector).remove();
                }
                this.each(function(i,node){
                    noder.remove(node);
                });
                return this;
            },

            each: function(callback) {
                langx.each(this, callback);
                return this;
            },

            filter: function(selector) {
                if (isFunction(selector)) return this.not(this.not(selector))
                return $(filter.call(this, function(element) {
                    return finder.matches(element, selector)
                }))
            },

            add: function(selector, context) {
                return $(uniq(this.toArray().concat($(selector, context).toArray())));
            },

            is: function(selector) {
                if (this.length > 0) {
                    var self = this;
                    if (langx.isString(selector)) {
                        return some.call(self,function(elem) {
                            return finder.matches(elem, selector);
                        });
                    } else if (langx.isArrayLike(selector)) {
                       return some.call(self,function(elem) {
                            return langx.inArray(elem, selector) > -1;
                        });
                    } else if (langx.isHtmlNode(selector)) {
                       return some.call(self,function(elem) {
                            return elem ==  selector;
                        });
                    }
                }
                return false;
            },
            
            not: function(selector) {
                var nodes = []
                if (isFunction(selector) && selector.call !== undefined)
                    this.each(function(idx,node) {
                        if (!selector.call(this, idx,node)) nodes.push(this)
                    })
                else {
                    var excludes = typeof selector == 'string' ? this.filter(selector) :
                        (isArrayLike(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)
                    this.forEach(function(el) {
                        if (excludes.indexOf(el) < 0) nodes.push(el)
                    })
                }
                return $(nodes)
            },

            has: function(selector) {
                return this.filter(function() {
                    return isObject(selector) ?
                        noder.contains(this, selector) :
                        $(this).find(selector).size()
                })
            },

            eq: function(idx) {
                return idx === -1 ? this.slice(idx) : this.slice(idx, +idx + 1);
            },

            first: function() {
                return this.eq(0);
            },

            last: function() {
                return this.eq(-1);
            },

            find: wrapper_selector(finder.descendants, finder),

            closest: wrapper_selector(finder.closest, finder),
            /*
                        closest: function(selector, context) {
                            var node = this[0],
                                collection = false
                            if (typeof selector == 'object') collection = $(selector)
                            while (node && !(collection ? collection.indexOf(node) >= 0 : finder.matches(node, selector)))
                                node = node !== context && !isDocument(node) && node.parentNode
                            return $(node)
                        },
            */


            parents: wrapper_selector(finder.ancestors, finder),

            parentsUntil: wrapper_selector_until(finder.ancestors, finder),


            parent: wrapper_selector(finder.parent, finder),

            children: wrapper_selector(finder.children, finder),

            contents: wrapper_map(noder.contents, noder),

            empty: wrapper_every_act(noder.empty, noder),

            html: wrapper_value(noder.html, noder),

            // `pluck` is borrowed from Prototype.js
            pluck: function(property) {
                return langx.map(this, function(el) {
                    return el[property]
                })
            },

            pushStack : function(elms) {
                var ret = $(elms);
                ret.prevObject = this;
                return ret;
            },
            
            replaceWith: function(newContent) {
                return this.before(newContent).remove();
            },

            wrap: function(html) {
                /*
                var func = isFunction(structure)
                if (this[0] && !func)
                    var dom = $(structure).get(0),
                        clone = dom.parentNode || this.length > 1

                return this.each(function(index,node) {
                    $(this).wrapAll(
                        func ? structure.call(this, index,node) :
                        clone ? dom.cloneNode(true) : dom
                    )
                })
                */
                var htmlIsFunction = typeof html === "function";

                return this.each( function( i ) {
                    $( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
                } );                
            },

            wrapAll: function(html) {
                /*
                if (this[0]) {
                    $(this[0]).before(wrappingElement = $(wrappingElement));
                    var children;
                    // drill down to the inmost element
                    while ((children = wrappingElement.children()).length) {
                        wrappingElement = children.first();
                    }
                    $(wrappingElement).append(this);
                }
                return this
                */
                var wrap;

                if ( this[ 0 ] ) {
                    if ( typeof html === "function" ) {
                        html = html.call( this[ 0 ] );
                    }

                    // The elements to wrap the target around
                    wrap = $( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

                    if ( this[ 0 ].parentNode ) {
                        wrap.insertBefore( this[ 0 ] );
                    }

                    wrap.map( function() {
                        var elem = this;

                        while ( elem.firstElementChild ) {
                            elem = elem.firstElementChild;
                        }

                        return elem;
                    } ).append( this );
                }

                return this;

            },

            wrapInner: function(html) {
                /*
                var func = isFunction(wrappingElement)
                return this.each(function(index,node) {
                    var self = $(this),
                        contents = self.contents(),
                        dom = func ? wrappingElement.call(this, index,node) : wrappingElement
                    contents.length ? contents.wrapAll(dom) : self.append(dom)
                })
                */
                if ( typeof html === "function" ) {
                    return this.each( function( i ) {
                        $( this ).wrapInner( html.call( this, i ) );
                    } );
                }

                return this.each( function() {
                    var self = $( this ),
                        contents = self.contents();

                    if ( contents.length ) {
                        contents.wrapAll( html );

                    } else {
                        self.append( html );
                    }
                } );

            },

            unwrap: function(selector) {
                /*
                if (this.parent().children().length === 0) {
                    // remove dom without text
                    this.parent(selector).not("body").each(function() {
                        $(this).replaceWith(document.createTextNode(this.childNodes[0].textContent));
                    });
                } else {
                    this.parent().each(function() {
                        $(this).replaceWith($(this).children())
                    });
                }
                return this
                */
                this.parent(selector).not("body").each( function() {
                    $(this).replaceWith(this.childNodes);
                });
                return this;

            },

            clone: function() {
                return this.map(function() {
                    return this.cloneNode(true)
                })
            },


            toggle: function(setting) {
                return this.each(function() {
                    var el = $(this);
                    (setting === undefined ? el.css("display") == "none" : setting) ? el.show(): el.hide()
                })
            },

            prev: function(selector) {
                return $(this.pluck('previousElementSibling')).filter(selector || '*')
            },

            prevAll: wrapper_selector(finder.previousSiblings, finder),

            next: function(selector) {
                return $(this.pluck('nextElementSibling')).filter(selector || '*')
            },

            nextAll: wrapper_selector(finder.nextSiblings, finder),

            siblings: wrapper_selector(finder.siblings, finder),

            index: function(elem) {
                if (elem) {
                    return this.indexOf($(elem)[0]);
                } else {
                    return this.parent().children().indexOf(this[0]);
                }
            }
        });

        // for now
        $.fn.detach = $.fn.remove;

        $.fn.hover = function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        };


        var traverseNode = noder.traverse;


        $.fn.after = wrapper_node_operation(noder.after, noder);

        $.fn.prepend = wrapper_node_operation(noder.prepend, noder);

        $.fn.before = wrapper_node_operation(noder.before, noder);

        $.fn.append = wrapper_node_operation(noder.append, noder);


        langx.each( {
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
        }, function( name, original ) {
            $.fn[ name ] = function( selector ) {
                var elems,
                    ret = [],
                    insert = $( selector ),
                    last = insert.length - 1,
                    i = 0;

                for ( ; i <= last; i++ ) {
                    elems = i === last ? this : this.clone( true );
                    $( insert[ i ] )[ original ]( elems );

                    // Support: Android <=4.0 only, PhantomJS 1 only
                    // .get() because push.apply(_, arraylike) throws on ancient WebKit
                    push.apply( ret, elems.get() );
                }

                return this.pushStack( ret );
            };
        } );

/*
        $.fn.insertAfter = function(html) {
            $(html).after(this);
            return this;
        };

        $.fn.insertBefore = function(html) {
            $(html).before(this);
            return this;
        };

        $.fn.appendTo = function(html) {
            $(html).append(this);
            return this;
        };

        $.fn.prependTo = function(html) {
            $(html).prepend(this);
            return this;
        };

        $.fn.replaceAll = function(selector) {
            $(selector).replaceWith(this);
            return this;
        };
*/
        return $;
    })();

    (function($) {
        $.fn.scrollParent = function( includeHidden ) {
            var position = this.css( "position" ),
                excludeStaticParent = position === "absolute",
                overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
                scrollParent = this.parents().filter( function() {
                    var parent = $( this );
                    if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
                        return false;
                    }
                    return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) +
                        parent.css( "overflow-x" ) );
                } ).eq( 0 );

            return position === "fixed" || !scrollParent.length ?
                $( this[ 0 ].ownerDocument || document ) :
                scrollParent;
        };

    })(query);


    (function($) {
        $.fn.end = function() {
            return this.prevObject || $()
        }

        $.fn.andSelf = function() {
            return this.add(this.prevObject || $())
        }

        $.fn.addBack = function(selector) {
            if (this.prevObject) {
                if (selector) {
                    return this.add(this.prevObject.filter(selector));
                } else {
                    return this.add(this.prevObject);
                }
            } else {
                return this;
            }
        }

        'filter,add,not,eq,first,last,find,closest,parents,parent,children,siblings,prev,prevAll,next,nextAll'.split(',').forEach(function(property) {
            var fn = $.fn[property]
            $.fn[property] = function() {
                var ret = fn.apply(this, arguments)
                ret.prevObject = this
                return ret
            }
        })
    })(query);


    (function($) {
        $.fn.query = $.fn.find;

        $.fn.place = function(refNode, position) {
            // summary:
            //      places elements of this node list relative to the first element matched
            //      by queryOrNode. Returns the original NodeList. See: `dojo/dom-construct.place`
            // queryOrNode:
            //      may be a string representing any valid CSS3 selector or a DOM node.
            //      In the selector case, only the first matching element will be used
            //      for relative positioning.
            // position:
            //      can be one of:
            //
            //      -   "last" (default)
            //      -   "first"
            //      -   "before"
            //      -   "after"
            //      -   "only"
            //      -   "replace"
            //
            //      or an offset in the childNodes
            if (langx.isString(refNode)) {
                refNode = finder.descendant(refNode);
            } else if (isQ(refNode)) {
                refNode = refNode[0];
            }
            return this.each(function(i, node) {
                switch (position) {
                    case "before":
                        noder.before(refNode, node);
                        break;
                    case "after":
                        noder.after(refNode, node);
                        break;
                    case "replace":
                        noder.replace(refNode, node);
                        break;
                    case "only":
                        noder.empty(refNode);
                        noder.append(refNode, node);
                        break;
                    case "first":
                        noder.prepend(refNode, node);
                        break;
                        // else fallthrough...
                    default: // aka: last
                        noder.append(refNode, node);
                }
            });
        };

        $.fn.addContent = function(content, position) {
            if (content.template) {
                content = langx.substitute(content.template, content);
            }
            return this.append(content);
        };



        $.fn.disableSelection = ( function() {
            var eventType = "onselectstart" in document.createElement( "div" ) ?
                "selectstart" :
                "mousedown";

            return function() {
                return this.on( eventType + ".ui-disableSelection", function( event ) {
                    event.preventDefault();
                } );
            };
        } )();

        $.fn.enableSelection = function() {
            return this.off( ".ui-disableSelection" );
        };

        $.fn.reflow = function() {
            return noder.reflow(this[0]);
        };

        $.fn.isBlockNode = function() {
            return noder.isBlockNode(this[0]);
        };
       

    })(query);

    query.fn.plugin = function(name,options) {
        var args = slice.call( arguments, 1 ),
            self = this,
            returnValue = this;

        this.each(function(){
            returnValue = plugins.instantiate.apply(self,[this,name].concat(args));
        });
        return returnValue;
    };


    query.wraps = {
        wrapper_node_operation,
        wrapper_map,
        wrapper_value,
        wrapper_selector,
        wrapper_some_chk,
        wrapper_selector_until,
        wrapper_every_act_firstArgFunc,
        wrapper_every_act,
        wrapper_name_value

    };

    return skylark.attach("domx.query", query);

});
define('skylark-domx-query/main',[
	"./query",
	"skylark-domx-styler"
],function($,styler){

    $.fn.disabled = $.wraps.wrapper_name_value(styler.disabled, styler);

    $.fn.style = $.wraps.wrapper_name_value(styler.css, styler);

    $.fn.css = $.wraps.wrapper_name_value(styler.css, styler);

    //hasClass(name)
    $.fn.hasClass = $.wraps.wrapper_some_chk(styler.hasClass, styler);

    //addClass(name)
    $.fn.addClass = $.wraps.wrapper_every_act_firstArgFunc(styler.addClass, styler, styler.className);

    //removeClass(name)
    $.fn.removeClass = $.wraps.wrapper_every_act_firstArgFunc(styler.removeClass, styler, styler.className);

    //toogleClass(name,when)
    $.fn.toggleClass = $.wraps.wrapper_every_act_firstArgFunc(styler.toggleClass, styler, styler.className);

    $.fn.replaceClass = function(newClass, oldClass) {
        this.removeClass(oldClass);
        this.addClass(newClass);
        return this;
    };

    $.fn.replaceClass = function(newClass, oldClass) {
        this.removeClass(oldClass);
        this.addClass(newClass);
        return this;
    };
        

	return $;
});
define('skylark-domx-query', ['skylark-domx-query/main'], function (main) { return main; });

define('skylark-domx-velm/velm',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-finder",
    "skylark-domx-query"
], function(skylark, langx, noder, finder, $) {
    var map = Array.prototype.map,
        slice = Array.prototype.slice;
    /*
     * VisualElement is a skylark class type wrapping a visule dom node,
     * provides a number of prototype methods and supports chain calls.
     */
    var VisualElement = langx.klass({
        klassName: "VisualElement",

        "_construct": function(node) {
            if (langx.isString(node)) {
                node = langx.trim(node);
                if (node.charAt(0) === "<") {
                    //html
                    node = noder.createFragment(node)[0];
                } else {
                    // id
                    node = document.getElementById(node);
                }
            }
            this._elm = node;
        }
    });

    VisualElement.prototype.$ = VisualElement.prototype.query = function(selector) {
        return $(selector,this._elm);
    };

    VisualElement.prototype.elm = function() {
        return this._elm;
    };

    /*
     * the VisualElement object wrapping document.body
     */
    var root = new VisualElement(document.body),
        velm = function(node) {
            if (node) {
                if (node instanceof VisualElement) {
                    return node;
                }
                return new VisualElement(node);
            } else {
                return root;
            }
        };
    /*
     * Extend VisualElement prototype with wrapping the specified methods.
     * @param {ArrayLike} fn
     * @param {Object} context
     */
    function _delegator(fn, context) {
        return function() {
            var self = this,
                elem = self._elm,
                ret = fn.apply(context, [elem].concat(slice.call(arguments)));

            if (ret) {
                if (ret === context) {
                    return self;
                } else {
                    if (ret instanceof HTMLElement) {
                        ret = new VisualElement(ret);
                    } else if (langx.isArrayLike(ret)) {
                        ret = map.call(ret, function(el) {
                            if (el instanceof HTMLElement) {
                                return new VisualElement(el);
                            } else {
                                return el;
                            }
                        })
                    }
                }
            }
            return ret;
        };
    }

    langx.mixin(velm, {
        batch: function(nodes, action, args) {
            nodes.forEach(function(node) {
                var elm = (node instanceof VisualElement) ? node : velm(node);
                elm[action].apply(elm, args);
            });

            return this;
        },

        root: new VisualElement(document.body),

        VisualElement: VisualElement,

        partial: function(name, fn) {
            var props = {};

            props[name] = fn;

            VisualElement.partial(props);
        },

        delegate: function(names, context,matching) {
            var props = {};

            names.forEach(function(name) {
                var matchedName = name;
                if (matching && matching[name]) {
                    matchedName = matching[name];
                } 
                props[name] = _delegator(context[matchedName], context);
            });

            VisualElement.partial(props);
        }
    });

    // from ./finder
    velm.delegate([
        "ancestor",
        "ancestors",
        "children",
        "descendant",
        "find",
        "findAll",
        "firstChild",
        "lastChild",
        "matches",
        "nextSibling",
        "nextSiblings",
        "parent",
        "previousSibling",
        "previousSiblings",
        "siblings"
    ], finder);

    /*
     * find a dom element matched by the specified selector.
     * @param {String} selector
     */
    velm.find = function(selector) {
        if (selector === "body") {
            return this.root;
        } else {
            return this.root.descendant(selector);
        }
    };


    // from ./noder
    velm.delegate([
        "after",
        "append",
        "before",
        "clone",
        "contains",
        "contents",
        "empty",
        "fullscreen",
        "html",
        "isChildOf",
        "isDocument",
        "isInDocument",
        "isWindow",
        "ownerDoc",
        "prepend",
        "remove",
        "removeChild",
        "replace",
        "reverse",
        "throb",
        "traverse",
        "wrapper",
        "wrapperInner",
        "unwrap"
    ], noder);


    return skylark.attach("domx.velm", velm);
});
define('skylark-domx-velm/main',[
	"./velm",
	"skylark-domx-styler"
],function(velm,styler){
    // from ./styler
    velm.delegate([
        "addClass",
        "className",
        "css",
        "disabled",
        "hasClass",
        "hide",
        "isInvisible",
        "removeClass",
        "show",
        "toggleClass"
    ], styler);

    // properties

    var properties = [ 'position', 'left', 'top', 'right', 'bottom', 'width', 'height', 'border', 'borderLeft',
    'borderTop', 'borderRight', 'borderBottom', 'borderColor', 'display', 'overflow', 'margin', 'marginLeft', 'marginTop', 'marginRight', 'marginBottom', 'padding', 'paddingLeft', 'paddingTop', 'paddingRight', 'paddingBottom', 'color',
    'background', 'backgroundColor', 'opacity', 'fontSize', 'fontWeight', 'textAlign', 'textDecoration', 'textTransform', 'cursor', 'zIndex' ];

    properties.forEach( function ( property ) {

        var method = property;

        velm.VisualElement.prototype[method ] = function (value) {

            this.css( property, value );

            return this;

        };

    });

	return velm;
});
define('skylark-domx-velm', ['skylark-domx-velm/main'], function (main) { return main; });

define('skylark-domx-data/main',[
    "./data",
    "skylark-domx-velm",
    "skylark-domx-query"    
],function(data,velm,$){
    // from ./data
    velm.delegate([
        "attr",
        "data",
        "prop",
        "removeAttr",
        "removeData",
        "text",
        "val"
    ], data);

    $.fn.text = $.wraps.wrapper_value(data.text, data, data.text);

    $.fn.attr = $.wraps.wrapper_name_value(data.attr, data, data.attr);

    $.fn.removeAttr = $.wraps.wrapper_every_act(data.removeAttr, data);

    $.fn.prop = $.wraps.wrapper_name_value(data.prop, data, data.prop);

    $.fn.removeProp = $.wraps.wrapper_every_act(data.removeProp, data);

    $.fn.data = $.wraps.wrapper_name_value(data.data, data);

    $.fn.removeData = $.wraps.wrapper_every_act(data.removeData);

    $.fn.val = $.wraps.wrapper_value(data.val, data, data.val);


    return data;
});
define('skylark-domx-data', ['skylark-domx-data/main'], function (main) { return main; });

define('skylark-domx-eventer/eventer',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-finder",
    "skylark-domx-noder",
    "skylark-domx-data"
], function(skylark, langx, browser, finder, noder, datax) {
    var mixin = langx.mixin,
        each = langx.each,
        slice = Array.prototype.slice,
        uid = langx.uid,
        ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$)/,
        eventMethods = {
            preventDefault: "isDefaultPrevented",
            stopImmediatePropagation: "isImmediatePropagationStopped",
            stopPropagation: "isPropagationStopped"
        },
        readyRE = /complete|loaded|interactive/;

    function compatible(event, source) {
        if (source || !event.isDefaultPrevented) {
            if (!source) {
                source = event;
            }

            langx.each(eventMethods, function(name, predicate) {
                var sourceMethod = source[name];
                event[name] = function() {
                    this[predicate] = langx.returnTrue;
                    return sourceMethod && sourceMethod.apply(source, arguments);
                }
                event[predicate] = langx.returnFalse;
            });
        }
        return event;
    }

    function parse(event) {
        if (event) {
            var segs = ("" + event).split(".");
            return {
                type: segs[0],
                ns: segs.slice(1).sort().join(" ")
            };
        } else {
            return {
                type : null,
                ns : null
            }
        }
    }

    function isHandler(callback) {
        return callback && (langx.isFunction(callback) || langx.isFunction(callback.handleEvent));
    }

    var NativeEventCtors = [
            window["CustomEvent"], // 0 default
            window["CompositionEvent"], // 1
            window["DragEvent"], // 2
            window["Event"], // 3
            window["FocusEvent"], // 4
            window["KeyboardEvent"], // 5
            window["MessageEvent"], // 6
            window["MouseEvent"], // 7
            window["MouseScrollEvent"], // 8
            window["MouseWheelEvent"], // 9
            window["MutationEvent"], // 10
            window["ProgressEvent"], // 11
            window["TextEvent"], // 12
            window["TouchEvent"], // 13
            window["UIEvent"], // 14
            window["WheelEvent"], // 15
            window["ClipboardEvent"] // 16
        ],
        NativeEvents = {
            "compositionstart": 1, // CompositionEvent
            "compositionend": 1, // CompositionEvent
            "compositionupdate": 1, // CompositionEvent

            "beforecopy": 16, // ClipboardEvent
            "beforecut": 16, // ClipboardEvent
            "beforepaste": 16, // ClipboardEvent
            "copy": 16, // ClipboardEvent
            "cut": 16, // ClipboardEvent
            "paste": 16, // ClipboardEvent

            "drag": 2, // DragEvent
            "dragend": 2, // DragEvent
            "dragenter": 2, // DragEvent
            "dragexit": 2, // DragEvent
            "dragleave": 2, // DragEvent
            "dragover": 2, // DragEvent
            "dragstart": 2, // DragEvent
            "drop": 2, // DragEvent

            "abort": 3, // Event
            "change": 3, // Event
            "error": 3, // Event
            "selectionchange": 3, // Event
            "submit": 3, // Event
            "reset": 3, // Event
            'fullscreenchange':3,
            'fullscreenerror':3,

/*
            'disablepictureinpicturechanged':3,
            'ended':3,
            'enterpictureinpicture':3,
            'durationchange':3,
            'leavepictureinpicture':3,
            'loadstart' : 3,
            'loadedmetadata':3,
            'pause' : 3,
            'play':3,
            'posterchange':3,
            'ratechange':3,
            'seeking' : 3,
            'sourceset':3,
            'suspend':3,
            'textdata':3,
            'texttrackchange':3,
            'timeupdate':3,
            'volumechange':3,
            'waiting' : 3,
*/


            "focus": 4, // FocusEvent
            "blur": 4, // FocusEvent
            "focusin": 4, // FocusEvent
            "focusout": 4, // FocusEvent

            "keydown": 5, // KeyboardEvent
            "keypress": 5, // KeyboardEvent
            "keyup": 5, // KeyboardEvent

            "message": 6, // MessageEvent

            "click": 7, // MouseEvent
            "contextmenu": 7, // MouseEvent
            "dblclick": 7, // MouseEvent
            "mousedown": 7, // MouseEvent
            "mouseup": 7, // MouseEvent
            "mousemove": 7, // MouseEvent
            "mouseover": 7, // MouseEvent
            "mouseout": 7, // MouseEvent
            "mouseenter": 7, // MouseEvent
            "mouseleave": 7, // MouseEvent


            "progress" : 11, //ProgressEvent

            "textInput": 12, // TextEvent

            "tap": 13,
            "touchstart": 13, // TouchEvent
            "touchmove": 13, // TouchEvent
            "touchend": 13, // TouchEvent

            "load": 14, // UIEvent
            "resize": 14, // UIEvent
            "select": 14, // UIEvent
            "scroll": 14, // UIEvent
            "unload": 14, // UIEvent,

            "wheel": 15, // WheelEvent



        };

    //create a custom dom event
    var createEvent = (function() {

        function getEventCtor(type) {
            var idx = NativeEvents[type];
            if (!idx) {
                idx = 0;
            }
            return NativeEventCtors[idx];
        }

        return function(type, props) {
            //create a custom dom event

            if (langx.isString(type)) {
                props = props || {};
            } else {
                props = type || {};
                type = props.type || "";
            }
            var parsed = parse(type);
            type = parsed.type;

            props = langx.mixin({
                bubbles: true,
                cancelable: true
            }, props);

            if (parsed.ns) {
                props.namespace = parsed.ns;
            }

            var ctor = getEventCtor(type),
                e = new ctor(type, props);

            langx.safeMixin(e, props);

            return compatible(e);
        };
    })();

    function createProxy(src, props) {
        var key,
            proxy = {
                originalEvent: src
            };
        for (key in src) {
            if (key !== "keyIdentifier" && !ignoreProperties.test(key) && src[key] !== undefined) {
                proxy[key] = src[key];
            }
        }
        if (props) {
            langx.mixin(proxy, props);
        }
        return compatible(proxy, src);
    }

    var
        specialEvents = {},
        focusinSupported = "onfocusin" in window,
        focus = { focus: "focusin", blur: "focusout" },
        hover = { mouseenter: "mouseover", mouseleave: "mouseout" },
        realEvent = function(type) {
            return hover[type] || (focusinSupported && focus[type]) || type;
        },
        handlers = {},
        EventBindings = langx.klass({
            init: function(target, event) {
                this._target = target;
                this._event = event;
                this._bindings = [];
            },

            add: function(fn, options) {
                var bindings = this._bindings,
                    binding = {
                        fn: fn,
                        options: langx.mixin({}, options)
                    };

                bindings.push(binding);

                var self = this;
                if (!self._listener) {
                    self._listener = function(domEvt) {
                        var elm = this,
                            e = createProxy(domEvt),
                            args = domEvt._args,
                            bindings = self._bindings,
                            ns = e.namespace;

                        if (langx.isDefined(args)) {
                            args = [e].concat(args);
                        } else {
                            args = [e];
                        }

                        e.type = self._event; // convert realEvent to listened event

                        langx.each(bindings, function(idx, binding) {
                            var match = elm;
                            if (e.isImmediatePropagationStopped && e.isImmediatePropagationStopped()) {
                                return false;
                            }
                            var fn = binding.fn,
                                options = binding.options || {},
                                selector = options.selector,
                                one = options.one,
                                data = options.data;

                            if (ns && ns != options.ns && options.ns.indexOf(ns) === -1) {
                                return;
                            }
                            if (selector) {
                                match = finder.closest(e.target, selector);
                                if (match && match !== elm) {
                                    langx.mixin(e, {
                                        currentTarget: match,
                                        liveFired: elm
                                    });
                                } else {
                                    return;
                                }
                            }

                            var originalEvent = self._event;
                            if (originalEvent in hover) {
                                var related = e.relatedTarget;
                                if (related && (related === match || noder.contains(match, related))) {
                                    return;
                                }
                            }

                            if (langx.isDefined(data)) {
                                e.data = data;
                            }

                            if (one) {
                                self.remove(fn, options);
                            }

                            var result ;
                            if (fn.handleEvent) {
                                result = fn.handleEvent.apply(fn,args);
                            } else {
                                if (options.ctx) {
                                    result = fn.apply(options.ctx, args);                                   
                                } else {
                                    result = fn.apply(match, args);                                   
                                }
                            }

                            if (result === false) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                        });;
                    };

                    var event = self._event;
                    /*
                                        if (event in hover) {
                                            var l = self._listener;
                                            self._listener = function(e) {
                                                var related = e.relatedTarget;
                                                if (!related || (related !== this && !noder.contains(this, related))) {
                                                    return l.apply(this, arguments);
                                                }
                                            }
                                        }
                    */

                    if (self._target.addEventListener) {
                        self._target.addEventListener(realEvent(event), self._listener, false);
                    } else {
                        console.warn("invalid eventer object", self._target);
                    }
                }

            },
            remove: function(fn, options) {
                options = langx.mixin({}, options);

                function matcherFor(ns) {
                    return new RegExp("(?:^| )" + ns.replace(" ", " .* ?") + "(?: |$)");
                }
                var matcher;
                if (options.ns) {
                    matcher = matcherFor(options.ns);
                }

                this._bindings = this._bindings.filter(function(binding) {
                    var removing = (!fn || fn === binding.fn) &&
                        (!matcher || matcher.test(binding.options.ns)) &&
                        (!options.selector || options.selector == binding.options.selector);

                    return !removing;
                });
                if (this._bindings.length == 0) {
                    if (this._target.removeEventListener) {
                        this._target.removeEventListener(realEvent(this._event), this._listener, false);
                    }
                    this._listener = null;
                }
            }
        }),
        EventsHandler = langx.klass({
            init: function(elm) {
                this._target = elm;
                this._handler = {};
            },

            // add a event listener
            // selector Optional
            register: function(event, callback, options) {
                // Seperate the event from the namespace
                var parsed = parse(event),
                    event = parsed.type,
                    specialEvent = specialEvents[event],
                    bindingEvent = specialEvent && (specialEvent.bindType || specialEvent.bindEventName);

                var events = this._handler;

                // Check if there is already a handler for this event
                if (events[event] === undefined) {
                    events[event] = new EventBindings(this._target, bindingEvent || event);
                }

                // Register the new callback function
                events[event].add(callback, langx.mixin({
                    ns: parsed.ns
                }, options)); // options:{selector:xxx}
            },

            // remove a event listener
            unregister: function(event, fn, options) {
                // Check for parameter validtiy
                var events = this._handler,
                    parsed = parse(event);
                event = parsed.type;

                if (event) {
                    var listener = events[event];

                    if (listener) {
                        listener.remove(fn, langx.mixin({
                            ns: parsed.ns
                        }, options));
                    }
                } else {
                    //remove all events
                    for (event in events) {
                        var listener = events[event];
                        listener.remove(fn, langx.mixin({
                            ns: parsed.ns
                        }, options));
                    }
                }
            }
        }),

        findHandler = function(elm) {
            var id = uid(elm),
                handler = handlers[id];
            if (!handler) {
                handler = handlers[id] = new EventsHandler(elm);
            }
            return handler;
        };


    /*   
     * Remove all event handlers from the specified element.
     * @param {HTMLElement} elm  
     */
    function clear(elm) {
        var handler = findHandler(elm);

        handler.unregister();

        return this;
    }

    var focusedQueue = [],
        focuser = langx.loop(function(){
            for (var i = 0; i<focusedQueue.length; i++) {
                trigger(focusedQueue[i],"focused");
            }
            focusedQueue = [];
        });

    focuser.start();


    function focused(elm) {
        if (!focusedQueue.includes(elm)) {
            focusedQueue.push(elm)
        }
    }

    /*   
     * Remove an event handler for one or more events from the specified element.
     * @param {HTMLElement} elm  
     * @param {String} events
     * @param {String　Optional } selector
     * @param {Function} callback
     */
    function off(elm, events, selector, callback) {
        var $this = this
        if (langx.isPlainObject(events)) {
            langx.each(events, function(type, fn) {
                off(elm, type, selector, fn);
            })
            return $this;
        }

        if (!langx.isString(selector) && !isHandler(callback) && callback !== false) {
            callback = selector;
            selector = undefined;
        }

        if (callback === false) {
            callback = langx.returnFalse;
        }

        if (typeof events == "string") {
            if (events.indexOf(",") > -1) {
                events = events.split(",");
            } else {
                events = events.split(/\s/);
            }
        }

        var handler = findHandler(elm);

        if (events) events.forEach(function(event) {

            handler.unregister(event, callback, {
                selector: selector,
            });
        });
        return this;
    }

    /*   
     * Attach an event handler function for one or more events to the selected elements.
     * @param {HTMLElement} elm  
     * @param {String} events
     * @param {String　Optional} selector
     * @param {Anything Optional} data
     * @param {Function} callback
     * @param {Boolean　Optional} one
     */
    function on(elm, events, selector, data, callback, ctx,one) {

        var autoRemove, delegator;
        if (langx.isPlainObject(events)) {
            langx.each(events, function(type, fn) {
                on(elm, type, selector, data, fn, one);
            });
            return this;
        }

        if (!langx.isString(selector) && !isHandler(callback)) {
            one = ctx;
            ctx = callback;
            callback = data;
            data = selector;
            selector = undefined;
        }

        if (isHandler(data)) {
            one = ctx;
            ctx = callback;
            callback = data;
            data = undefined;
        }

        if (langx.isBoolean(ctx)) {
            one = ctx;
            ctx = undefined;
        }
        if (callback === false) {
            callback = langx.returnFalse;
        }

        if (typeof events == "string") {
            if (events.indexOf(",") > -1) {
                events = events.split(",");
            } else {
                events = events.split(/\s/);
            }
        }

        var handler = findHandler(elm);

        events.forEach(function(event) {
            if (event == "ready") {
                return ready(callback);
            }
            handler.register(event, callback, {
                data: data,
                selector: selector,
                ctx : ctx,
                one: !!one
            });
        });
        return this;
    }

    /*   
     * Attach a handler to an event for the elements. The handler is executed at most once per 
     * @param {HTMLElement} elm  
     * @param {String} event
     * @param {String　Optional} selector
     * @param {Anything Optional} data
     * @param {Function} callback
     */
    function one(...args) {
        on(...args, true);

        return this;
    }

    /*   
     * Prevents propagation and clobbers the default action of the passed event. The same as calling event.preventDefault() and event.stopPropagation(). 
     * @param {String} event
     */
    function stop(event) {
        if (window.document.all) {
            event.keyCode = 0;
        }
        if (event.preventDefault) {
            event.preventDefault();
            event.stopPropagation();
        }
        return this;
    }
    /*   
     * Execute all handlers and behaviors attached to the matched elements for the given event  
     * @param {String} evented
     * @param {String} type
     * @param {Array or PlainObject } args
     */
    function trigger(evented, type, args) {
        var e;
        if (type instanceof Event) {
            e = type;
        } else {
            e = createEvent(type, args);
        }
        e._args = args;

        var fn = (evented.dispatchEvent || evented.trigger);
        if (fn) {
            fn.call(evented, e);
        } else {
            console.warn("The evented parameter is not a eventable object");
        }

        return this;
    }
    /*   
     * Specify a function to execute when the DOM is fully loaded.  
     * @param {Function} callback
     */
    function ready(callback) {
        // need to check if document.body exists for IE as that browser reports
        // document ready when it hasn't yet created the body elm
        if (readyRE.test(document.readyState) && document.body) {
            langx.defer(callback);
        } else {
            document.addEventListener('DOMContentLoaded', callback, false);
        }

        return this;
    }

    var resizedQueue = [],
        resizer = langx.loop(function(){
            for (var i = 0; i<resizedQueue.length; i++) {
                trigger(resizedQueue[i],"resized");
            }
            resizedQueue = [];
        });

    resizer.start();


    function resized(elm) {
        if (!resizedQueue.includes(elm)) {
            resizedQueue.push(elm)
        }
    }


    var keyCodeLookup = {
        "backspace": 8,
        "comma": 188,
        "delete": 46,
        "down": 40,
        "end": 35,
        "enter": 13,
        "escape": 27,
        "home": 36,
        "left": 37,
        "page_down": 34,
        "page_up": 33,
        "period": 190,
        "right": 39,
        "space": 32,
        "tab": 9,
        "up": 38
    };
    //example:
    //shortcuts(elm).add("CTRL+ALT+SHIFT+X",function(){console.log("test!")});
    function shortcuts(elm) {

        var registry = datax.data(elm, "shortcuts");
        if (!registry) {
            registry = {};
            datax.data(elm, "shortcuts", registry);
            var run = function(shortcut, event) {
                var n = event.metaKey || event.ctrlKey;
                if (shortcut.ctrl == n && shortcut.alt == event.altKey && shortcut.shift == event.shiftKey) {
                    if (event.keyCode == shortcut.keyCode || event.charCode && event.charCode == shortcut.charCode) {
                        event.preventDefault();
                        if ("keydown" == event.type) {
                            shortcut.fn(event);
                        }
                        return true;
                    }
                }
            };
            on(elm, "keyup keypress keydown", function(event) {
                if (!(/INPUT|TEXTAREA/.test(event.target.nodeName))) {
                    for (var key in registry) {
                        run(registry[key], event);
                    }
                }
            });

        }

        return {
            add: function(pattern, fn) {
                var shortcutKeys;
                if (pattern.indexOf(",") > -1) {
                    shortcutKeys = pattern.toLowerCase().split(",");
                } else {
                    shortcutKeys = pattern.toLowerCase().split(" ");
                }
                shortcutKeys.forEach(function(shortcutKey) {
                    var setting = {
                        fn: fn,
                        alt: false,
                        ctrl: false,
                        shift: false
                    };
                    shortcutKey.split("+").forEach(function(key) {
                        switch (key) {
                            case "alt":
                            case "ctrl":
                            case "shift":
                                setting[key] = true;
                                break;
                            default:
                                setting.charCode = key.charCodeAt(0);
                                setting.keyCode = keyCodeLookup[key] || key.toUpperCase().charCodeAt(0);
                        }
                    });
                    var regKey = (setting.ctrl ? "ctrl" : "") + "," + (setting.alt ? "alt" : "") + "," + (setting.shift ? "shift" : "") + "," + setting.keyCode;
                    registry[regKey] = setting;
                })
            }

        };

    }

    if (browser.support.transition) {
        specialEvents.transitionEnd = {
//          handle: function (e) {
//            if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
//          },
          bindType: browser.support.transition.end,
          delegateType: browser.support.transition.end
        }        
    }

    function isNativeEvent(events) {
        if (langx.isString(events)) {
            return !!NativeEvents[events];
        } else if (langx.isArray(events)) {
            for (var i=0; i<events.length; i++) {
                if (NativeEvents[events]) {
                    return false;
                }
            }
            return events.length > 0;
        }
    }


    function eventer() {
        return eventer;
    }

    langx.mixin(eventer, {
        NativeEvents : NativeEvents,
        
        clear,
        
        create: createEvent,

        focused,

        keys: keyCodeLookup,

        isNativeEvent,

        off: off,

        on: on,

        one: one,

        proxy: createProxy,

        ready: ready,

        resized,
        
        shortcuts: shortcuts,

        special: specialEvents,

        stop: stop,

        trigger: trigger

    });

    each(NativeEvents,function(name){
        eventer[name] = function(elm,selector,data,callback) {
            if (arguments.length>1) {
                return this.on(elm,name,selector,data,callback);
            } else {
                if (name == "focus") {
                    if (elm.focus) {
                        elm.focus();
                    }
                } else if (name == "blur") {
                    if (elm.blur) {
                        elm.blur();
                    }
                } else if (name == "click") {
                    if (elm.click) {
                        elm.click();
                    }
                } else {
                    this.trigger(elm,name);
                }

                return this;
            }
        };
    });

    return skylark.attach("domx.eventer",eventer);
});
define('skylark-domx-eventer/main',[
    "skylark-langx/langx",
    "./eventer",
    "skylark-domx-velm",
    "skylark-domx-query"        
],function(langx,eventer,velm,$){

    var delegateMethodNames = [
        "off",
        "on",
        "one",
        "trigger"
    ];

    langx.each(eventer.NativeEvents,function(name){
        delegateMethodNames.push(name);
    });

    // from ./eventer
    velm.delegate(delegateMethodNames, eventer);

    langx.each(delegateMethodNames,function(i,name){
        $.fn[name] = $.wraps.wrapper_every_act(eventer[name],eventer);
    });


    /*
    $.fn.on = $.wraps.wrapper_every_act(eventer.on, eventer);

    $.fn.off = $.wraps.wrapper_every_act(eventer.off, eventer);

    $.fn.trigger = $.wraps.wrapper_every_act(eventer.trigger, eventer);

    ('focusin focusout focus blur load resize scroll unload click dblclick ' +
        'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' +
        'change select keydown keypress keyup error transitionEnd').split(' ').forEach(function(event) {
        $.fn[event] = $.wraps.wrapper_every_act(eventer[event],eventer);
    });

    $.fn.one = function(event, selector, data, callback) {
        if (!langx.isString(selector) && !langx.isFunction(callback)) {
            callback = data;
            data = selector;
            selector = null;
        }

        if (langx.isFunction(data)) {
            callback = data;
            data = null;
        }

        return this.on(event, selector, data, callback, 1)
    }; 
    */

    $.ready = eventer.ready;

    return eventer;
});
define('skylark-domx-eventer', ['skylark-domx-eventer/main'], function (main) { return main; });

define('skylark-domx-forms/forms',[
	"skylark-langx/skylark"
],function(skylark){
	return skylark.attach("domx.forms",{});
});
define('skylark-domx-forms/deserialize',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "./forms"
],function(langx,$,forms){
  /**
   * Updates a key/valueArray with the given property and value. Values will always be stored as arrays.
   *
   * @param prop The property to add the value to.
   * @param value The value to add.
   * @param obj The object to update.
   * @returns {object} Updated object.
   */
  function updateKeyValueArray( prop, value, obj ) {
    var current = obj[ prop ];

    if ( current === undefined ) {
      obj[ prop ] = [ value ];
    } else {
      current.push( value );
    }

    return obj;
  }

  /**
   * Get all of the fields contained within the given elements by name.
   *
   * @param formElm The form element.
   * @param filter Custom filter to apply to the list of fields.
   * @returns {object} All of the fields contained within the given elements, keyed by name.
   */
  function getFieldsByName(formElm, filter ) {
    var elementsByName = {};

    // Extract fields from elements
    var fields = $(formElm)
      .map(function convertFormToElements() {
        return this.elements ? langx.makeArray( this.elements ) : this;
      })
      .filter( filter || ":input:not(:disabled)" )
      .get();

    langx.each( fields, function( index, field ) {
      updateKeyValueArray( field.name, field, elementsByName );
    });

    return elementsByName;
  }

  /**
   * Figure out the type of an element. Input type will be used first, falling back to nodeName.
   *
   * @param element DOM element to check type of.
   * @returns {string} The element's type.
   */
  function getElementType( element ) {
    return ( element.type || element.nodeName ).toLowerCase();
  }

  /**
   * Normalize the provided data into a key/valueArray store.
   *
   * @param data The data provided by the user to the plugin.
   * @returns {object} The data normalized into a key/valueArray store.
   */
  function normalizeData( data ) {
    var normalized = {};
    var rPlus = /\+/g;

    // Convert data from .serializeObject() notation
    if ( langx.isPlainObject( data ) ) {
      langx.extend( normalized, data );

      // Convert non-array values into an array
      langx.each( normalized, function( name, value ) {
        if ( !langx.isArray( value ) ) {
          normalized[ name ] = [ value ];
        }
      });

    // Convert data from .serializeArray() notation
    } else if ( langx.isArray( data ) ) {
      langx.each( data, function( index, field ) {
        updateKeyValueArray( field.name, field.value, normalized );
      });

    // Convert data from .serialize() notation
    } else if ( typeof data === "string" ) {
      langx.each( data.split( "&" ), function( index, field ) {
        var current = field.split( "=" );
        var name = decodeURIComponent( current[ 0 ].replace( rPlus, "%20" ) );
        var value = decodeURIComponent( current[ 1 ].replace( rPlus, "%20" ) );
        updateKeyValueArray( name, value, normalized );
      });
    }

    return normalized;
  }

  /**
   * Map of property name -> element types.
   *
   * @type {object}
   */
  var updateTypes = {
    checked: [
      "radio",
      "checkbox"
    ],
    selected: [
      "option",
      "select-one",
      "select-multiple"
    ],
    value: [
      "button",
      "color",
      "date",
      "datetime",
      "datetime-local",
      "email",
      "hidden",
      "month",
      "number",
      "password",
      "range",
      "reset",
      "search",
      "submit",
      "tel",
      "text",
      "textarea",
      "time",
      "url",
      "week"
    ]
  };

  /**
   * Get the property to update on an element being updated.
   *
   * @param element The DOM element to get the property for.
   * @returns The name of the property to update if element is supported, otherwise `undefined`.
   */
  function getPropertyToUpdate( element ) {
    var type = getElementType( element );
    var elementProperty = undefined;

    langx.each( updateTypes, function( property, types ) {
      if ( langx.inArray( type, types ) > -1 ) {
        elementProperty = property;
        return false;
      }
    });

    return elementProperty;
  }

  /**
   * Update the element based on the provided data.
   *
   * @param element The DOM element to update.
   * @param elementIndex The index of this element in the list of elements with the same name.
   * @param value The serialized element value.
   * @param valueIndex The index of the value in the list of values for elements with the same name.
   * @param callback A function to call if the value of an element was updated.
   */
  function update( element, elementIndex, value, valueIndex, callback ) {
    var property = getPropertyToUpdate( element );

    // Handle value inputs
    // If there are multiple value inputs with the same name, they will be populated by matching indexes.
    if ( property == "value" && elementIndex == valueIndex ) {
      element.value = value;
      callback.call( element, value );

    // Handle select menus, checkboxes and radio buttons
    } else if ( property == "checked" || property == "selected" ) {
      var fields = [];

      // Extract option fields from select menus
      if ( element.options ) {
        langx.each( element.options, function( index, option ) {
          fields.push( option );
        });

      } else {
        fields.push( element );
      }

      // #37: Remove selection from multiple select menus before deserialization
      if ( element.multiple && valueIndex == 0 ) {
        element.selectedIndex = -1;
      }

      langx.each( fields, function( index, field ) {
        if ( field.value == value ) {
          field[ property ] = true;
          callback.call( field, value );
        }
      });
    }
  }

  /**
   * Default plugin options.
   *
   * @type {object}
   */
  var defaultOptions = {
    change: langx.noop,
    complete: langx.noop
  };

  /**
   * The $.deserialize function.
   *
   * @param data The data to deserialize.
   * @param options Additional options.
   * @returns {jQuery} The jQuery object that was provided to the plugin.
   */
  function deserialize(formElm,data, options ) {

    // Backwards compatible with old arguments: data, callback
    if ( langx.isFunction( options ) ) {
      options = { complete: options };
    }

    options = langx.extend( defaultOptions, options || {} );
    data = normalizeData( data );

    var elementsByName = getFieldsByName( formElm, options.filter );

    langx.each( data, function( name, values ) {
      langx.each( elementsByName[ name ], function( elementIndex, element ) {
        langx.each( values, function( valueIndex, value ) {
          update( element, elementIndex, value, valueIndex, options.change );
        });
      });
    });

    options.complete.call( formElm );

    return this;
  };

  return forms.deserialize = deserialize;
});
define('skylark-domx-forms/serialize-array',[
  "skylark-langx/langx",
  "skylark-domx-data",
  "./forms"
],function(langx,datax,forms){
    function serializeArray(formElm) {
        var name, type, result = [],
            add = function(value) {
                if (value.forEach) return value.forEach(add)
                result.push({ name: name, value: value })
            },
            elements;
        if (formElm.elements) {
            elements = formElm.elements;
        } else if (langx.isArrayLike(formElm)) {
            elements = formElm;
        } else {
            elements = [formElm];
        }
        langx.each(elements, function(_, field) {
            type = field.type, name = field.name
            if (name && field.nodeName.toLowerCase() != 'fieldset' &&
                !field.disabled && type != 'submit' && type != 'reset' && type != 'button' && type != 'file' &&
                ((type != 'radio' && type != 'checkbox') || field.checked))
                add(datax.val(field))
        })
        return result
    };

    return forms.serializeArray = serializeArray;
});

define('skylark-domx-forms/serialize-object',[
  "skylark-langx/langx",
  "./forms",
  "./serialize-array"
],function(langx,forms,serializeArray){

  function serializeObject(formElm){
    var obj = {};
    
    langx.each(serializeArray(formElm), function(i,o){
      var n = o.name,
        v = o.value;
        
        obj[n] = obj[n] === undefined ? v
          : langx.isArray( obj[n] ) ? obj[n].concat( v )
          : [ obj[n], v ];
    });
    
    return obj;
  }

  return forms.serializeObject = serializeObject;
});  
define('skylark-domx-forms/serialize',[
  "skylark-langx/langx",
  "./forms",
  "./serialize-array"
],function(langx,forms,serializeArray){
    function serialize(formElm) {
        var result = []
        serializeArray(formElm).forEach(function(elm) {
            result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value))
        })
        return result.join('&')
    }

    return forms.serialize = serialize;
});
define('skylark-domx-forms/main',[
    "skylark-langx",
    "skylark-domx-data",
	"./forms",
    "skylark-domx-velm",
    "skylark-domx-query",
    "./deserialize",
    "./serialize-array",
    "./serialize-object",
    "./serialize"
],function(langx,datax,forms,velm,$){

    // from ./data
    velm.delegate([
        "deserialize",
        "serializeArray",
        "serializeObject",
        "serialize"
    ], forms);

    $.fn.deserialize = $.wraps.wrapper_every_act(forms.deserialize, forms, forms.deserialize);
    $.fn.serializeArray = $.wraps.wrapper_map(forms.serializeArray, forms, forms.serializeArray,true);
    $.fn.serializeObject = $.wraps.wrapper_map(forms.serializeObject, forms, forms.serializeObject,true);
    $.fn.serialize = $.wraps.wrapper_value(forms.serialize, forms, forms.serialize);


/*
    var r20 = /%20/g,
        rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
        rsubmittable = /^(?:input|select|textarea|keygen)/i;
    var rcheckableType = ( /^(?:checkbox|radio)$/i );

    $.fn.serializeArray = function() {
        return this.map( function() {

            // Can add propHook for "elements" to filter or add form elements
            var elements = datax.prop(this, "elements" );
            return elements ? langx.makeArray( elements ) : this;
        } )
        .filter( function() {
            var type = this.type;

            // Use .is( ":disabled" ) so that fieldset[disabled] works
            return this.name && !$(this).is( ":disabled" ) &&
                rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
                ( this.checked || !rcheckableType.test( type ) );
        } )
        .map( function( i, elem ) {
            var val = $(this).val();

            return val == null ?
                null :
                langx.isArray( val ) ?
                    langx.map( val, function( val ) {
                        return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                    } ) :
                    { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
        } ).get();
    };
*/

	return forms;
});
define('skylark-domx-forms', ['skylark-domx-forms/main'], function (main) { return main; });

define('skylark-domx-transits/transits',[
    "skylark-langx/skylark",
    "skylark-langx/langx"
], function(skylark,langx) {

    function transits() {
        return transits;
    }

    langx.mixin(transits, {
        off: false,
        speeds: {
            normal: 400,
            fast: 200,
            slow: 600
        }
    });

    return skylark.attach("domx.transits", transits);
});
define('skylark-domx-geom/geom',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-styler"
], function(skylark, langx, noder, styler) {
  'use strict'

    var rootNodeRE = /^(?:body|html)$/i,
        px = langx.toPixel,
        offsetParent = noder.offsetParent,
        cachedScrollbarWidth;

    function scrollbarWidth() {
        if (cachedScrollbarWidth !== undefined) {
            return cachedScrollbarWidth;
        }
        var w1, w2,
            div = noder.createFragment("<div style=" +
                "'display:block;position:absolute;width:200px;height:200px;overflow:hidden;'>" +
                "<div style='height:300px;width:auto;'></div></div>")[0],
            innerDiv = div.childNodes[0];

        noder.append(document.body, div);

        w1 = innerDiv.offsetWidth;
        styler.css(div, "overflow", "scroll");

        w2 = innerDiv.offsetWidth;

        if (w1 === w2) {
            w2 = div[0].clientWidth;
        }

        noder.remove(div);

        return (cachedScrollbarWidth = w1 - w2);
    }


    function hasScrollbar() {
        return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight);
    }

    /*
     * Get the widths of each border of the specified element.
     * @param {HTMLElement} elm
     */
    function borderExtents(elm) {
        if (noder.isWindow(elm)) {
            return {
                left : 0,
                top : 0,
                right : 0,
                bottom : 0
            }
        }        var s = getComputedStyle(elm);
        return {
            left: px(s.borderLeftWidth, elm),
            top: px(s.borderTopWidth, elm),
            right: px(s.borderRightWidth, elm),
            bottom: px(s.borderBottomWidth, elm)
        }
    }

    //viewport coordinate
    /*
     * Get or set the viewport position of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    function boundingPosition(elm, coords) {
        if (coords === undefined) {
            return rootNodeRE.test(elm.nodeName) ? { top: 0, left: 0 } : elm.getBoundingClientRect();
        } else {
            var // Get *real* offsetParent
                parent = offsetParent(elm),
                // Get correct offsets
                parentOffset = boundingPosition(parent),
                mex = marginExtents(elm),
                pbex = borderExtents(parent);

            relativePosition(elm, {
                top: coords.top - parentOffset.top - mex.top - pbex.top + (scrollTop(parent) || 0),
                left: coords.left - parentOffset.left - mex.left - pbex.left + (scrollLeft(parent) || 0)
            });
            return this;
        }
    }

    /*
     * Get or set the viewport rect of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    function boundingRect(elm, coords) {
        if (coords === undefined) {
            if (elm == window || elm == document.documentElement || elm == document.body){
                return {
                    top : 0,
                    left : 0,
                    bottom : window.innerHeight,
                    right : window.innerWidth,
                    height : window.innerHeight,
                    width : window.innerWidth
                };
            } else if (elm.getBoundingClientRect) {
                return elm.getBoundingClientRect();
            }
        } else {
            boundingPosition(elm, coords);
            size(elm, coords);
            return this;
        }
    }

    /*
     * Get or set the height of the specified element client box.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function clientHeight(elm, value) {
        if (value == undefined) {
            return clientSize(elm).height;
        } else {
            return clientSize(elm, {
                height: value
            });
        }
    }

    /*
     * Get or set the size of the specified element client box.
     * @param {HTMLElement} elm
     * @param {PlainObject} dimension
     */
    function clientSize(elm, dimension) {
        if (dimension == undefined) {
            return {
                width: elm.clientWidth,
                height: elm.clientHeight
            }
        } else {
            var isBorderBox = (styler.css(elm, "box-sizing") === "border-box"),
                props = {
                    width: dimension.width,
                    height: dimension.height
                };
            if (!isBorderBox) {
                var pex = paddingExtents(elm);

                if (props.width !== undefined) {
                    props.width = props.width - pex.left - pex.right;
                }

                if (props.height !== undefined) {
                    props.height = props.height - pex.top - pex.bottom;
                }
            } else {
                var bex = borderExtents(elm);

                if (props.width !== undefined) {
                    props.width = props.width + bex.left + bex.right;
                }

                if (props.height !== undefined) {
                    props.height = props.height + bex.top + bex.bottom;
                }

            }
            styler.css(elm, props);
            return this;
        }
        return {
            width: elm.clientWidth,
            height: elm.clientHeight
        };
    }

    /*
     * Get or set the width of the specified element client box.
     * @param {HTMLElement} elm
     * @param {PlainObject} dimension
     */
    function clientWidth(elm, value) {
        if (value == undefined) {
            return clientSize(elm).width;
        } else {
            clientSize(elm, {
                width: value
            });
            return this;
        }
    }

    /*
     * Get the rect of the specified element content box.
     * @param {HTMLElement} elm
     */
    function contentRect(elm) {
        var cs = clientSize(elm),
            pex = paddingExtents(elm);


        //// On Opera, offsetLeft includes the parent's border
        //if(has("opera")){
        //    pe.l += be.l;
        //    pe.t += be.t;
        //}
        return {
            left: pex.left,
            top: pex.top,
            width: cs.width - pex.left - pex.right,
            height: cs.height - pex.top - pex.bottom
        };
    }

    /*
     * Get the document size.
     * @param {HTMLDocument} doc
     */
    function getDocumentSize(doc) {
        var documentElement = doc.documentElement,
            body = doc.body,
            max = Math.max,
            scrollWidth = max(documentElement.scrollWidth, body.scrollWidth),
            clientWidth = max(documentElement.clientWidth, body.clientWidth),
            offsetWidth = max(documentElement.offsetWidth, body.offsetWidth),
            scrollHeight = max(documentElement.scrollHeight, body.scrollHeight),
            clientHeight = max(documentElement.clientHeight, body.clientHeight),
            offsetHeight = max(documentElement.offsetHeight, body.offsetHeight);

        return {
            width: scrollWidth < offsetWidth ? clientWidth : scrollWidth,
            height: scrollHeight < offsetHeight ? clientHeight : scrollHeight
        };
    }

    /*
     * Get the document size.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function height(elm, value) {
        if (value == undefined) {
            return size(elm).height;
        } else {
            size(elm, {
                height: value
            });
            return this;
        }
    }



    function inview(elm, cushion) {
        function calibrate(coords, cushion) {
            var o = {};
            cushion = +cushion || 0;
            o.width = (o.right = coords.right + cushion) - (o.left = coords.left - cushion);
            o.height = (o.bottom = coords.bottom + cushion) - (o.top = coords.top - cushion);
            return o;
        }

        var r = calibrate(boundingRect(elm), cushion),
            vsize = viewportSize();

        return !!r && r.bottom >= 0 && r.right >= 0 && r.top <= vsize.height && r.left <= vsize.width;
    }


    /*
     * Get the widths of each margin of the specified element.
     * @param {HTMLElement} elm
     */
    function marginExtents(elm) {
        if (noder.isWindow(elm)) {
            return {
                left : 0,
                top : 0,
                right : 0,
                bottom : 0
            }
        }
        var s = getComputedStyle(elm);
        return {
            left: px(s.marginLeft),
            top: px(s.marginTop),
            right: px(s.marginRight),
            bottom: px(s.marginBottom),
        }
    }


    function marginRect(elm) {
        var obj = relativeRect(elm),
            me = marginExtents(elm);

        return {
            left: obj.left,
            top: obj.top,
            width: obj.width + me.left + me.right,
            height: obj.height + me.top + me.bottom
        };
    }


    function marginSize(elm) {
        var obj = size(elm),
            me = marginExtents(elm);

        return {
            width: obj.width + me.left + me.right,
            height: obj.height + me.top + me.bottom
        };
    }

    /*
     * Get the widths of each padding of the specified element.
     * @param {HTMLElement} elm
     */
    function paddingExtents(elm) {
        if (noder.isWindow(elm)) {
            return {
                left : 0,
                top : 0,
                right : 0,
                bottom : 0
            }
        }
        var s = getComputedStyle(elm);
        return {
            left: px(s.paddingLeft),
            top: px(s.paddingTop),
            right: px(s.paddingRight),
            bottom: px(s.paddingBottom),
        }
    }

    /*
     * Get or set the document position of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    //coordinate to the document
    function pagePosition(elm, coords) {
        if (coords === undefined) {
            var obj = elm.getBoundingClientRect(),
                w = elm.ownerDocument.defaultView;
            return {
                left: obj.left + w.pageXOffset,
                top: obj.top + w.pageYOffset
            }
        } else {
            var // Get *real* offsetParent
                parent = offsetParent(elm),
                // Get correct offsets
                parentOffset = pagePosition(parent),
                mex = marginExtents(elm),
                pbex = borderExtents(parent);

            relativePosition(elm, {
                top: coords.top - parentOffset.top - mex.top - pbex.top,
                left: coords.left - parentOffset.left - mex.left - pbex.left
            });
            return this;
        }
    }

    /*
     * Get or set the document rect of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    function pageRect(elm, coords) {
        if (coords === undefined) {
            var obj = elm.getBoundingClientRect(),
                w = elm.ownerDocument.defaultView;
            return {
                left: obj.left + w.pageXOffset,
                top: obj.top + w.pageYOffset,
                width: Math.round(obj.width),
                height: Math.round(obj.height)
            }
        } else {
            pagePosition(elm, coords);
            size(elm, coords);
            return this;
        }
    }

    /*
     * Get or set the position of the specified element border box , relative to parent element.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    // coordinate relative to it's parent
    function relativePosition(elm, coords) {
        if (coords == undefined) {
            var // Get *real* offsetParent
                parent = offsetParent(elm),
                // Get correct offsets
                offset = boundingPosition(elm),
                parentOffset = boundingPosition(parent),
                mex = marginExtents(elm),
                pbex = borderExtents(parent);

            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - pbex.top - mex.top,
                left: offset.left - parentOffset.left - pbex.left - mex.left
            }
        } else {
            var // Get *real* offsetParent
                parent = offsetParent(elm);

            var props = {
                top: coords.top,
                left: coords.left
            };

            /*
            if (langx.isDefined(props.top)) {
                props.top = props.top + (scrollTop(parent) || 0);
            }

            if (langx.isDefined(props.left)) {
                props.left = props.left + (scrollLeft(parent) || 0);
            } 
            */ 

            if (styler.css(elm, "position") == "static") {
                props['position'] = "relative";
            }


            styler.css(elm, props);
            return this;
        }
    }

    /*
     * Get or set the rect of the specified element border box , relatived to parent element.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    function relativeRect(elm, coords) {
        if (coords === undefined) {
            var // Get *real* offsetParent
                parent = offsetParent(elm),
                // Get correct offsets
                offset = boundingRect(elm),
                parentOffset = boundingPosition(parent),
                mex = marginExtents(elm),
                pbex = borderExtents(parent);

            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - pbex.top, // - mex.top,
                left: offset.left - parentOffset.left - pbex.left, // - mex.left,
                width: offset.width,
                height: offset.height
            }
        } else {
            relativePosition(elm, coords);
            size(elm, coords);
            return this;
        }
    }
    /*
     * Scroll the specified element into view.
     * @param {HTMLElement} elm
     * @param {} align
     */
    function scrollIntoView(elm, align) {
        function getOffset(elm, rootElm) {
            var x, y, parent = elm;

            x = y = 0;
            while (parent && parent != rootElm && parent.nodeType) {
                x += parent.offsetLeft || 0;
                y += parent.offsetTop || 0;
                parent = parent.offsetParent;
            }

            return { x: x, y: y };
        }

        var parentElm = elm.parentNode;
        var x, y, width, height, parentWidth, parentHeight;
        var pos = getOffset(elm, parentElm);

        x = pos.x;
        y = pos.y;
        width = elm.offsetWidth;
        height = elm.offsetHeight;
        parentWidth = parentElm.clientWidth;
        parentHeight = parentElm.clientHeight;

        if (align == "end") {
            x -= parentWidth - width;
            y -= parentHeight - height;
        } else if (align == "center") {
            x -= (parentWidth / 2) - (width / 2);
            y -= (parentHeight / 2) - (height / 2);
        }

        parentElm.scrollLeft = x;
        parentElm.scrollTop = y;

        return this;
    }
    /*
     * Get or set the current horizontal position of the scroll bar for the specified element.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function scrollLeft(elm, value) {
        if (elm.nodeType === 9) {
            elm = elm.defaultView;
        } else if (elm == document.body) {
            elm = document.scrollingElement  || document.documentElement;
        }
        var hasScrollLeft = "scrollLeft" in elm;
        if (value === undefined) {
            return hasScrollLeft ? elm.scrollLeft : elm.pageXOffset
        } else {
            if (hasScrollLeft) {
                elm.scrollLeft = value;
            } else {
                elm.scrollTo(value, elm.scrollY);
            }
            return this;
        }
    }
    /*
     * Get or the current vertical position of the scroll bar for the specified element.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function scrollTop(elm, value) {
        if (elm.nodeType === 9) {
            elm = elm.defaultView;
        } else if (elm == document.body) {
            elm = document.scrollingElement  || document.documentElement;
        }

        var hasScrollTop = "scrollTop" in elm;

        if (value === undefined) {
            return hasScrollTop ? elm.scrollTop : elm.pageYOffset
        } else {
            if (hasScrollTop) {
                elm.scrollTop = value;
            } else {
                elm.scrollTo(elm.scrollX, value);
            }
            return this;
        }
    }

    function scrollBy(elm, x, y) {
        elm.scrollLeft += x;
        elm.scrollTop += y;
    }


    /*
     * Get or set the size of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject}dimension
     */
    function size(elm, dimension) {
        if (dimension == undefined) {
            if (langx.isWindow(elm)) {
                return {
                    width: elm.innerWidth,
                    height: elm.innerHeight
                }

            } else if (langx.isDocument(elm)) {
                return getDocumentSize(document);
            } else {
                return {
                    width: elm.offsetWidth,
                    height: elm.offsetHeight
                }
            }
        } else {
            var isBorderBox = (styler.css(elm, "box-sizing") === "border-box"),
                props = {
                    width: dimension.width,
                    height: dimension.height
                };
            if (!isBorderBox) {
                var pex = paddingExtents(elm),
                    bex = borderExtents(elm);

                if (props.width !== undefined && props.width !== "" && props.width !== null) {
                    props.width = props.width - pex.left - pex.right - bex.left - bex.right;
                }

                if (props.height !== undefined && props.height !== "" && props.height !== null) {
                    props.height = props.height - pex.top - pex.bottom - bex.top - bex.bottom;
                }
            }
            styler.css(elm, props);
            return this;
        }
    }


    function viewportSize(win) {
        win = win || window;

        return boundingRect(win);
    }

    /*
     * Get or set the size of the specified element border box.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function width(elm, value) {
        if (value == undefined) {
            return size(elm).width;
        } else {
            size(elm, {
                width: value
            });
            return this;
        }
    }

    function testAxis(elm) {
       
        var top = elm.offsetTop;
        var left = elm.offsetLeft;
        var width = elm.offsetWidth;
        var height = elm.offsetHeight;

        while(elm.offsetParent) {
            elm = elm.offsetParent;
            top += elm.offsetTop;
            left += elm.offsetLeft;
        }

        var result = {x: 0, y: 0};

        //Over the top of the window
        if(top < window.pageYOffset) {
            result.y = top - window.pageYOffset;
        }
        //Bellow the window
        else if((top + height) > (window.pageYOffset + window.innerHeight))
        {
            result.y = (top + height) - (window.pageYOffset + window.innerHeight);
        }

        //Left to the window
        if(left < window.pageXOffset) {
            result.x = left - window.pageXOffset;
        }
        //Right to the window
        else if((left + width) > (window.pageXOffset + window.innerWidth))
        {
            result.x = (left + width) - (window.pageXOffset + window.innerWidth);
        }

        return result;
    };    

    function geom() {
        return geom;
    }

    langx.mixin(geom, {
        borderExtents: borderExtents,
        //viewport coordinate
        boundingPosition: boundingPosition,

        boundingRect: boundingRect,

        clientHeight: clientHeight,

        clientSize: clientSize,

        clientWidth: clientWidth,

        contentRect: contentRect,

        getDocumentSize: getDocumentSize,

        hasScrollbar,

        height: height,

        inview,

        marginExtents: marginExtents,

        marginRect: marginRect,

        marginSize: marginSize,

        offsetParent: offsetParent,

        paddingExtents: paddingExtents,

        //coordinate to the document
        pagePosition: pagePosition,

        pageRect: pageRect,

        // coordinate relative to it's parent
        relativePosition: relativePosition,

        relativeRect: relativeRect,

        scrollbarWidth: scrollbarWidth,

        scrollIntoView: scrollIntoView,

        scrollLeft: scrollLeft,

        scrollTop: scrollTop,

        scrollBy,
            
        size: size,

        testAxis,

        viewportSize,

        width: width
    });



    return skylark.attach("domx.geom", geom);
});
define('skylark-domx-geom/posit',[
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-styler",
    "./geom"
],function(langx,noder,styler,geom){
  'use strict'

    var max = Math.max,
        abs = Math.abs,
        rhorizontal = /left|center|right/,
        rvertical = /top|center|bottom/,
        roffset = /[\+\-]\d+(\.[\d]+)?%?/,
        rposition = /^\w+/,
        rpercent = /%$/;

    function getOffsets( offsets, width, height ) {
        return [
            parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
            parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
        ];
    }

    function parseCss( element, property ) {
        return parseInt( styler.css( element, property ), 10 ) || 0;
    }

    function getDimensions( raw ) {
        if ( raw.nodeType === 9 ) {
            return {
                size: size(raw),
                offset: { top: 0, left: 0 }
            };
        }
        if ( noder.isWindow( raw ) ) {
            return {
                size: geom.size(raw),
                offset: { 
                    top: geom.scrollTop(raw), 
                    left: geom.scrollLeft(raw) 
                }
            };
        }
        if ( raw.preventDefault ) {
            return {
                size : {
                    width: 0,
                    height: 0
                },
                offset: { 
                    top: raw.pageY, 
                    left: raw.pageX 
                }
            };
        }
        return {
            size: geom.size(raw),
            offset: geom.pagePosition(raw)
        };
    }

    function getScrollInfo( within ) {
        var overflowX = within.isWindow || within.isDocument ? "" :
                styler.css(within.element,"overflow-x" ),
            overflowY = within.isWindow || within.isDocument ? "" :
                styler.css(within.element,"overflow-y" ),
            hasOverflowX = overflowX === "scroll" ||
                ( overflowX === "auto" && within.width < geom.scrollWidth(within.element) ),
            hasOverflowY = overflowY === "scroll" ||
                ( overflowY === "auto" && within.height < geom.scrollHeight(within.element));
        return {
            width: hasOverflowY ? geom.scrollbarWidth() : 0,
            height: hasOverflowX ? geom.scrollbarWidth() : 0
        };
    }

    function getWithinInfo( element ) {
        var withinElement = element || window,
            isWindow = noder.isWindow( withinElement),
            isDocument = !!withinElement && withinElement.nodeType === 9,
            hasOffset = !isWindow && !isDocument,
            msize = geom.marginSize(withinElement);
        return {
            element: withinElement,
            isWindow: isWindow,
            isDocument: isDocument,
            offset: hasOffset ? geom.pagePosition(element) : { left: 0, top: 0 },
            scrollLeft: geom.scrollLeft(withinElement),
            scrollTop: geom.scrollTop(withinElement),
            width: msize.width,
            height: msize.height
        };
    }

    function posit(elm,options ) {
        // Make a copy, we don't want to modify arguments
        options = langx.extend( {}, options );

        var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
            target = options.of,
            within = getWithinInfo( options.within ),
            scrollInfo = getScrollInfo( within ),
            collision = ( options.collision || "flip" ).split( " " ),
            offsets = {};

        dimensions = getDimensions( target );
        if ( target.preventDefault ) {

            // Force left top to allow flipping
            options.at = "left top";
        }
        targetWidth = dimensions.size.width;
        targetHeight = dimensions.size.height;
        targetOffset = dimensions.offset;

        // Clone to reuse original targetOffset later
        basePosition = langx.extend( {}, targetOffset );

        // Force my and at to have valid horizontal and vertical positions
        // if a value is missing or invalid, it will be converted to center
        langx.each( [ "my", "at" ], function() {
            var pos = ( options[ this ] || "" ).split( " " ),
                horizontalOffset,
                verticalOffset;

            if ( pos.length === 1 ) {
                pos = rhorizontal.test( pos[ 0 ] ) ?
                    pos.concat( [ "center" ] ) :
                    rvertical.test( pos[ 0 ] ) ?
                        [ "center" ].concat( pos ) :
                        [ "center", "center" ];
            }
            pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
            pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

            // Calculate offsets
            horizontalOffset = roffset.exec( pos[ 0 ] );
            verticalOffset = roffset.exec( pos[ 1 ] );
            offsets[ this ] = [
                horizontalOffset ? horizontalOffset[ 0 ] : 0,
                verticalOffset ? verticalOffset[ 0 ] : 0
            ];

            // Reduce to just the positions without the offsets
            options[ this ] = [
                rposition.exec( pos[ 0 ] )[ 0 ],
                rposition.exec( pos[ 1 ] )[ 0 ]
            ];
        } );

        // Normalize collision option
        if ( collision.length === 1 ) {
            collision[ 1 ] = collision[ 0 ];
        }

        if ( options.at[ 0 ] === "right" ) {
            basePosition.left += targetWidth;
        } else if ( options.at[ 0 ] === "center" ) {
            basePosition.left += targetWidth / 2;
        }

        if ( options.at[ 1 ] === "bottom" ) {
            basePosition.top += targetHeight;
        } else if ( options.at[ 1 ] === "center" ) {
            basePosition.top += targetHeight / 2;
        }

        atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
        basePosition.left += atOffset[ 0 ];
        basePosition.top += atOffset[ 1 ];

        return ( function(elem) {
            var collisionPosition, using,
                msize = geom.marginSize(elem),
                elemWidth = msize.width,
                elemHeight = msize.height,
                marginLeft = parseCss( elem, "marginLeft" ),
                marginTop = parseCss( elem, "marginTop" ),
                collisionWidth = elemWidth + marginLeft + parseCss( elem, "marginRight" ) +
                    scrollInfo.width,
                collisionHeight = elemHeight + marginTop + parseCss( elem, "marginBottom" ) +
                    scrollInfo.height,
                position = langx.extend( {}, basePosition ),
                myOffset = getOffsets( offsets.my, msize.width, msize.height);

            if ( options.my[ 0 ] === "right" ) {
                position.left -= elemWidth;
            } else if ( options.my[ 0 ] === "center" ) {
                position.left -= elemWidth / 2;
            }

            if ( options.my[ 1 ] === "bottom" ) {
                position.top -= elemHeight;
            } else if ( options.my[ 1 ] === "center" ) {
                position.top -= elemHeight / 2;
            }

            position.left += myOffset[ 0 ];
            position.top += myOffset[ 1 ];

            collisionPosition = {
                marginLeft: marginLeft,
                marginTop: marginTop
            };

            langx.each( [ "left", "top" ], function( i, dir ) {
                if ( positions[ collision[ i ] ] ) {
                    positions[ collision[ i ] ][ dir ]( position, {
                        targetWidth: targetWidth,
                        targetHeight: targetHeight,
                        elemWidth: elemWidth,
                        elemHeight: elemHeight,
                        collisionPosition: collisionPosition,
                        collisionWidth: collisionWidth,
                        collisionHeight: collisionHeight,
                        offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
                        my: options.my,
                        at: options.at,
                        within: within,
                        elem: elem
                    } );
                }
            } );

            if ( options.using ) {

                // Adds feedback as second argument to using callback, if present
                using = function( props ) {
                    var left = targetOffset.left - position.left,
                        right = left + targetWidth - elemWidth,
                        top = targetOffset.top - position.top,
                        bottom = top + targetHeight - elemHeight,
                        feedback = {
                            target: {
                                element: target,
                                left: targetOffset.left,
                                top: targetOffset.top,
                                width: targetWidth,
                                height: targetHeight
                            },
                            element: {
                                element: elem,
                                left: position.left,
                                top: position.top,
                                width: elemWidth,
                                height: elemHeight
                            },
                            horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                            vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                        };
                    if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
                        feedback.horizontal = "center";
                    }
                    if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
                        feedback.vertical = "middle";
                    }
                    if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
                        feedback.important = "horizontal";
                    } else {
                        feedback.important = "vertical";
                    }
                    options.using.call( this, props, feedback );
                };
            }

            geom.pagePosition(elem, langx.extend( position, { using: using } ));
        })(elm);
    }

    var positions = {
        fit: {
            left: function( position, data ) {
                var within = data.within,
                    withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
                    outerWidth = within.width,
                    collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                    overLeft = withinOffset - collisionPosLeft,
                    overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
                    newOverRight;

                // Element is wider than within
                if ( data.collisionWidth > outerWidth ) {

                    // Element is initially over the left side of within
                    if ( overLeft > 0 && overRight <= 0 ) {
                        newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -
                            withinOffset;
                        position.left += overLeft - newOverRight;

                    // Element is initially over right side of within
                    } else if ( overRight > 0 && overLeft <= 0 ) {
                        position.left = withinOffset;

                    // Element is initially over both left and right sides of within
                    } else {
                        if ( overLeft > overRight ) {
                            position.left = withinOffset + outerWidth - data.collisionWidth;
                        } else {
                            position.left = withinOffset;
                        }
                    }

                // Too far left -> align with left edge
                } else if ( overLeft > 0 ) {
                    position.left += overLeft;

                // Too far right -> align with right edge
                } else if ( overRight > 0 ) {
                    position.left -= overRight;

                // Adjust based on position and margin
                } else {
                    position.left = max( position.left - collisionPosLeft, position.left );
                }
            },
            top: function( position, data ) {
                var within = data.within,
                    withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
                    outerHeight = data.within.height,
                    collisionPosTop = position.top - data.collisionPosition.marginTop,
                    overTop = withinOffset - collisionPosTop,
                    overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
                    newOverBottom;

                // Element is taller than within
                if ( data.collisionHeight > outerHeight ) {

                    // Element is initially over the top of within
                    if ( overTop > 0 && overBottom <= 0 ) {
                        newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -
                            withinOffset;
                        position.top += overTop - newOverBottom;

                    // Element is initially over bottom of within
                    } else if ( overBottom > 0 && overTop <= 0 ) {
                        position.top = withinOffset;

                    // Element is initially over both top and bottom of within
                    } else {
                        if ( overTop > overBottom ) {
                            position.top = withinOffset + outerHeight - data.collisionHeight;
                        } else {
                            position.top = withinOffset;
                        }
                    }

                // Too far up -> align with top
                } else if ( overTop > 0 ) {
                    position.top += overTop;

                // Too far down -> align with bottom edge
                } else if ( overBottom > 0 ) {
                    position.top -= overBottom;

                // Adjust based on position and margin
                } else {
                    position.top = max( position.top - collisionPosTop, position.top );
                }
            }
        },
        flip: {
            left: function( position, data ) {
                var within = data.within,
                    withinOffset = within.offset.left + within.scrollLeft,
                    outerWidth = within.width,
                    offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
                    collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                    overLeft = collisionPosLeft - offsetLeft,
                    overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
                    myOffset = data.my[ 0 ] === "left" ?
                        -data.elemWidth :
                        data.my[ 0 ] === "right" ?
                            data.elemWidth :
                            0,
                    atOffset = data.at[ 0 ] === "left" ?
                        data.targetWidth :
                        data.at[ 0 ] === "right" ?
                            -data.targetWidth :
                            0,
                    offset = -2 * data.offset[ 0 ],
                    newOverRight,
                    newOverLeft;

                if ( overLeft < 0 ) {
                    newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -
                        outerWidth - withinOffset;
                    if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
                        position.left += myOffset + atOffset + offset;
                    }
                } else if ( overRight > 0 ) {
                    newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +
                        atOffset + offset - offsetLeft;
                    if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
                        position.left += myOffset + atOffset + offset;
                    }
                }
            },
            top: function( position, data ) {
                var within = data.within,
                    withinOffset = within.offset.top + within.scrollTop,
                    outerHeight = within.height,
                    offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
                    collisionPosTop = position.top - data.collisionPosition.marginTop,
                    overTop = collisionPosTop - offsetTop,
                    overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
                    top = data.my[ 1 ] === "top",
                    myOffset = top ?
                        -data.elemHeight :
                        data.my[ 1 ] === "bottom" ?
                            data.elemHeight :
                            0,
                    atOffset = data.at[ 1 ] === "top" ?
                        data.targetHeight :
                        data.at[ 1 ] === "bottom" ?
                            -data.targetHeight :
                            0,
                    offset = -2 * data.offset[ 1 ],
                    newOverTop,
                    newOverBottom;
                if ( overTop < 0 ) {
                    newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -
                        outerHeight - withinOffset;
                    if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
                        position.top += myOffset + atOffset + offset;
                    }
                } else if ( overBottom > 0 ) {
                    newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +
                        offset - offsetTop;
                    if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
                        position.top += myOffset + atOffset + offset;
                    }
                }
            }
        },
        flipfit: {
            left: function() {
                positions.flip.left.apply( this, arguments );
                positions.fit.left.apply( this, arguments );
            },
            top: function() {
                positions.flip.top.apply( this, arguments );
                positions.fit.top.apply( this, arguments );
            }
        }
    };

    return geom.posit = posit;
});
define('skylark-domx-geom/scroll-to-top',[
    "skylark-langx",
    "skylark-domx-styler",
    "./geom"
],function(langx,styler,geom) {
    /*   
     * Set the vertical position of the scroll bar for an element.
     * @param {Object} elm  
     * @param {Number or String} pos
     * @param {Number or String} speed
     * @param {Function} callback
     */
    function scrollToTop(elm, pos, speed, callback) {
        var scrollFrom = parseInt(elm.scrollTop),
            i = 0,
            runEvery = 5, // run every 5ms
            freq = speed * 1000 / runEvery,
            scrollTo = parseInt(pos);

        var interval = setInterval(function() {
            i++;

            if (i <= freq) elm.scrollTop = (scrollTo - scrollFrom) / freq * i + scrollFrom;

            if (i >= freq + 1) {
                clearInterval(interval);
                if (callback) langx.debounce(callback, 1000)();
            }
        }, runEvery);

        return this;
    }

    return geom.scrollToTop = scrollToTop;
});
define('skylark-domx-geom/main',[
    "skylark-langx/langx",
    "./geom",
    "skylark-domx-velm",
    "skylark-domx-query",
    "./posit",
    "./scroll-to-top"
],function(langx,geom,velm,$){
   // from ./geom
    velm.delegate([
        "borderExtents",
        "boundingPosition",
        "boundingRect",
        "clientHeight",
        "clientSize",
        "clientWidth",
        "contentRect",
        "height",
        "marginExtents",
        "marginRect",
        "marginSize",
        "offsetParent",
        "paddingExtents",
        "pagePosition",
        "pageRect",
        "relativePosition",
        "relativeRect",
        "scrollIntoView",
        "scrollLeft",
        "scrollTop",
        "pageSize",
        "width"
    ], geom,{
        "pageSize" : "size"
    });

    $.fn.offset = $.wraps.wrapper_value(geom.pagePosition, geom, geom.pagePosition);

    $.fn.scrollTop = $.wraps.wrapper_value(geom.scrollTop, geom);

    $.fn.scrollLeft = $.wraps.wrapper_value(geom.scrollLeft, geom);

    $.fn.position =  function(options) {
        if (!this.length) {
            return this;
        }

        if (options) {
            if (options.of && options.of.length) {
                options = langx.clone(options);
                options.of = options.of[0];
            }
            return this.each( function() {
                geom.posit(this,options);
            });
        } else {
            var elem = this[0];

            return geom.relativePosition(elem);

        }             
    };

    $.fn.offsetParent = $.wraps.wrapper_map(geom.offsetParent, geom);


    $.fn.pageSize = $.wraps.wrapper_value(geom.size, geom);

    $.fn.width = $.wraps.wrapper_value(geom.width, geom, geom.width);

    $.fn.height = $.wraps.wrapper_value(geom.height, geom, geom.height);

    $.fn.clientSize = $.wraps.wrapper_value(geom.clientSize, geom.clientSize);
    
    ['width', 'height'].forEach(function(dimension) {
        var offset, Dimension = dimension.replace(/./, function(m) {
            return m[0].toUpperCase()
        });

        $.fn['outer' + Dimension] = function(margin, value) {
            if (arguments.length) {
                if (typeof margin !== 'boolean') {
                    value = margin;
                    margin = false;
                }
            } else {
                margin = false;
                value = undefined;
            }

            if (value === undefined) {
                var el = this[0];
                if (!el) {
                    return undefined;
                }
                var cb = geom.size(el);
                if (margin) {
                    var me = geom.marginExtents(el);
                    cb.width = cb.width + me.left + me.right;
                    cb.height = cb.height + me.top + me.bottom;
                }
                return dimension === "width" ? cb.width : cb.height;
            } else {
                return this.each(function(idx, el) {
                    var mb = {};
                    var me = geom.marginExtents(el);
                    if (dimension === "width") {
                        mb.width = value;
                        if (margin) {
                            mb.width = mb.width - me.left - me.right
                        }
                    } else {
                        mb.height = value;
                        if (margin) {
                            mb.height = mb.height - me.top - me.bottom;
                        }
                    }
                    geom.size(el, mb);
                })

            }
        };
    })

    $.fn.innerWidth = $.wraps.wrapper_value(geom.clientWidth, geom, geom.clientWidth);

    $.fn.innerHeight = $.wraps.wrapper_value(geom.clientHeight, geom, geom.clientHeight);

    return geom;
});
define('skylark-domx-geom', ['skylark-domx-geom/main'], function (main) { return main; });

define('skylark-domx-transits/transit',[
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-noder",
    "skylark-domx-geom",
    "skylark-domx-styler",
    "skylark-domx-eventer",
    "./transits"
], function(langx, browser, noder, geom, styler, eventer,transits) {

    var transitionProperty,
        transitionDuration,
        transitionTiming,
        transitionDelay,

        transitionEnd = browser.normalizeCssEvent('TransitionEnd'),

        supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i,
        transform = browser.css3PropPrefix + "transform",
        cssReset = {};

    cssReset[transitionProperty = browser.normalizeCssProperty("transition-property")] =
        cssReset[transitionDuration = browser.normalizeCssProperty("transition-duration")] =
        cssReset[transitionDelay = browser.normalizeCssProperty("transition-delay")] =
        cssReset[transitionTiming = browser.normalizeCssProperty("transition-timing-function")] = "";

    /*   
     * Perform a custom animation of a set of CSS properties.
     * @param {Object} elm  
     * @param {Number or String} properties
     * @param {String} ease
     * @param {Number or String} duration
     * @param {Function} callback
     * @param {Number or String} delay
     */
    function transit(elm, properties, duration, ease, callback, delay) {
        var key,
            cssValues = {},
            cssProperties = [],
            transforms = "",
            that = this,
            endEvent,
            wrappedCallback,
            fired = false,
            hasScrollTop = false,
            resetClipAuto = false;

        if (langx.isPlainObject(duration)) {
            ease = duration.easing;
            callback = duration.complete;
            delay = duration.delay;
            duration = duration.duration;
        }

        if (langx.isString(duration)) {
            duration = transits.speeds[duration];
        }
        if (duration === undefined) {
            duration = transits.speeds.normal;
        }
        duration = duration / 1000;
        if (transits.off) {
            duration = 0;
        }

        if (langx.isFunction(ease)) {
            callback = ease;
            eace = "swing";
        } else {
            ease = ease || "swing";
        }

        if (delay) {
            delay = delay / 1000;
        } else {
            delay = 0;
        }

        // CSS transitions
        for (key in properties) {
            var v = properties[key];
            if (supportedTransforms.test(key)) {
                transforms += key + "(" + v + ") ";
            } else {
                if (key === "scrollTop") {
                    hasScrollTop = true;
                }
                if (key == "clip" && langx.isPlainObject(v)) {
                    cssValues[key] = "rect(" + v.top+"px,"+ v.right +"px,"+ v.bottom +"px,"+ v.left+"px)";
                    if (styler.css(elm,"clip") == "auto") {
                        var size = geom.size(elm);
                        styler.css(elm,"clip","rect("+"0px,"+ size.width +"px,"+ size.height +"px,"+"0px)");  
                        resetClipAuto = true;
                    }

                } else {
                    cssValues[key] = v;
                }
                cssProperties.push(langx.dasherize(key));
            }
        }
        endEvent = transitionEnd;

        if (transforms) {
            cssValues[transform] = transforms;
            cssProperties.push(transform);
        }

        if (duration > 0) {
            cssValues[transitionProperty] = cssProperties.join(", ");
            cssValues[transitionDuration] = duration + "s";
            cssValues[transitionDelay] = delay + "s";
            cssValues[transitionTiming] = ease;
        }

        wrappedCallback = function(event) {
            fired = true;
            if (event) {
                if (event.target !== event.currentTarget) {
                    return // makes sure the event didn't bubble from "below"
                }
                eventer.off(event.target, endEvent, wrappedCallback)
            } else {
                eventer.off(elm, endEvent, wrappedCallback) // triggered by setTimeout
            }
            styler.css(elm, cssReset);
            if (resetClipAuto) {
 //               styler.css(elm,"clip","auto");
            }
            callback && callback.call(this);
        };

        if (duration > 0) {
            eventer.on(elm, endEvent, wrappedCallback);
            // transitionEnd is not always firing on older Android phones
            // so make sure it gets fired
            langx.debounce(function() {
                if (fired) {
                    return;
                }
                wrappedCallback.call(that);
            }, ((duration + delay) * 1000) + 25)();
        }

        // trigger page reflow so new elements can transit
        elm.clientLeft;

        styler.css(elm, cssValues);

        if (duration <= 0) {
            langx.debounce(function() {
                if (fired) {
                    return;
                }
                wrappedCallback.call(that);
            }, 0)();
        }

        if (hasScrollTop) {
            geom.scrollToTop(elm, properties["scrollTop"], duration, callback);
        }

        return this;
    }

    return transits.transit = transit;

});
define('skylark-domx-transits/bounce',[
    "skylark-langx/langx",
    "skylark-domx-geom",
    "skylark-domx-styler",
    "./transits",
    "./transit"
],function(langx,geom,styler,transits,transit) {

    function bounce(elm, options, done ) {
        var upAnim, downAnim, refValue,
            // Defaults:
            mode = options.mode,
            hide = mode === "hide",
            show = mode === "show",
            direction = options.direction || "up",
            start,
            distance = options.distance,
            times = options.times || 5,

            // Number of internal animations
            anims = times * 2 + ( show || hide ? 1 : 0 ),
            speed = options.duration / anims,
            easing = options.easing,

            // Utility:
            ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
            motion = ( direction === "up" || direction === "left" ),
            i = 0;

        //createPlaceholder(elm);

        var Deferred = langx.Deferred;
        var funcs = [];

        refValue = styler.css(elm,ref );

        // Default distance for the BIGGEST bounce is the outer Distance / 3
        if ( !distance ) {
            var msize = geom.size(elm);
            distance = (ref === "top" ? msize.height : msize.width) / 3;
        }

        start = geom.relativePosition(elm)[ref];

        if ( show ) {
            downAnim = { opacity: 1 };
            downAnim[ ref ] = refValue;

            // If we are showing, force opacity 0 and set the initial position
            // then do the "first" animation
            styler.css(elm, "opacity", 0 );
            styler.css(elm, ref, start + (motion ? -distance * 2 : distance * 2 ));

            funcs.push(doAnimate(elm,downAnim, speed, easing));
        }

        // Start at the smallest distance if we are hiding
        if ( hide ) {
            distance = distance / Math.pow( 2, times - 1 );
        }

        downAnim = {};
        downAnim[ ref ] = refValue;


        function doAnimate(elm,properties, duration, easing) {
            return function() {
                var d = new Deferred();

                transit(elm,properties, duration, easing ,function(){
                    d.resolve();
                });
                return d.promise;

            }
        }

        // Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
        for ( ; i < times; i++ ) {
            upAnim = {};
            upAnim[ ref ] = start + ( motion ? -distance : distance) ;

            funcs.push(doAnimate(elm,upAnim, speed, easing));

            funcs.push(doAnimate(elm,downAnim, speed, easing));

            distance = hide ? distance * 2 : distance / 2;
        }

        // Last Bounce when Hiding
        if ( hide ) {
            upAnim = { opacity: 0 };
            upAnim[ ref ] = start + ( motion ? -1 * distance : distance) ;

            funcs.push(doAnimate(elm,upAnim, speed, easing ));
        }

        funcs.push(done);
        funcs.reduce(function(prev, curr, index, array) {
            return prev.then(curr);
        }, Deferred.resolve());

        return this;
    } 

    return transits.bounce = bounce;
});
define('skylark-domx-transits/emulate-transition-end',[
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-eventer",
    "./transits"
],function(langx,browser,eventer,transits) {
    
    function emulateTransitionEnd(elm,duration) {
        var called = false;
        eventer.one(elm,'transitionEnd', function () { 
            called = true;
        })
        var callback = function () { 
            if (!called) {
                eventer.trigger(elm,browser.support.transition.end) 
            }
        };
        setTimeout(callback, duration);
        
        return this;
    } 



    return transits.emulateTransitionEnd = emulateTransitionEnd;
});
define('skylark-domx-transits/show',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./transits",
    "./transit"
],function(langx,styler,transits,transit) {
    /*   
     * Display an element.
     * @param {Object} elm  
     * @param {String} speed
     * @param {Function} callback
     */
    function show(elm, speed, callback) {
        styler.show(elm);
        if (speed) {
            if (!callback && langx.isFunction(speed)) {
                callback = speed;
                speed = "normal";
            }
            styler.css(elm, "opacity", 0)
            transit(elm, { opacity: 1, scale: "1,1" }, speed, callback);
        }
        return this;
    }

    return transits.show = show;
});
define('skylark-domx-transits/hide',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./transits",
    "./transit"
],function(langx,styler,transits,transit) {
    /*   
     * Hide an element.
     * @param {Object} elm  
     * @param {String} speed
     * @param {Function} callback
     */
    function hide(elm, speed, callback) {
        if (speed) {
            if (!callback && langx.isFunction(speed)) {
                callback = speed;
                speed = "normal";
            }
            transit(elm, { opacity: 0, scale: "0,0" }, speed, function() {
                styler.hide(elm);
                if (callback) {
                    callback.call(elm);
                }
            });
        } else {
            styler.hide(elm);
        }
        return this;
    }

    return transits.hide = hide;
});
define('skylark-domx-transits/explode',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "skylark-domx-geom",
    "skylark-domx-noder",
    "skylark-domx-query",
    "./transits",
    "./transit",
    "./show",
    "./hide"
],function(langx,styler,geom,noder,$,transits,transit,show,hide) {

    function explode( elm,options, done ) {

		// Show and then visibility:hidden the element before calculating offset
		styler.show(elm);
		styler.css(elm, "visibility", "hidden" );

		var i, j, left, top, mx, my,
			rows = options.pieces ? Math.round( Math.sqrt( options.pieces ) ) : 3,
			cells = rows,
			mode = options.mode,
			show = mode === "show",
			offset = geom.pagePosition(elm),

			// Width and height of a piece
			size = geom.marginSize(elm),
			width = Math.ceil( size.width / cells ),
			height = Math.ceil( size.height / rows ),
			pieces = [];

		// Children transit complete:
		function childComplete() {
			pieces.push( this );
			if ( pieces.length === rows * cells ) {
				animComplete();
			}
		}

		// Clone the element for each row and cell.
		for ( var i = 0; i < rows; i++ ) { // ===>
			top = offset.top + i * height;
			my = i - ( rows - 1 ) / 2;

			for ( j = 0; j < cells; j++ ) { // |||
				left = offset.left + j * width;
				mx = j - ( cells - 1 ) / 2;

				// Create a clone of the now hidden main element that will be absolute positioned
				// within a wrapper div off the -left and -top equal to size of our pieces
				$(elm)
					.clone()
					.appendTo( "body" )
					.wrap( "<div></div>" )
					.css( {
						position: "absolute",
						visibility: "visible",
						left: -j * width,
						top: -i * height
					} )

					// Select the wrapper - make it overflow: hidden and absolute positioned based on
					// where the original was located +left and +top equal to the size of pieces
					.parent()
						.addClass( options.explodeClass || "ui-effects-explode" )
						.css( {
							position: "absolute",
							overflow: "hidden",
							width: width,
							height: height,
							left: left + ( show ? mx * width : 0 ),
							top: top + ( show ? my * height : 0 ),
							opacity: show ? 0 : 1
						} )
						.transit( {
							left: left + ( show ? 0 : mx * width ),
							top: top + ( show ? 0 : my * height ),
							opacity: show ? 1 : 0
						}, options.duration || 500, options.easing, childComplete );
			}
		}

		function animComplete() {
			styler.css(elm, {
				visibility: "visible"
			} );
			$( pieces ).remove();
			done();
		}

		return this;
	}


	return transits.explode = explode;
});

define('skylark-domx-transits/fade',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./transits",
    "./transit"
],function(langx,styler,transits,transit) {
    /*   
     * Adjust the opacity of an element.
     * @param {Object} elm  
     * @param {Number or String} speed
     * @param {Number or String} opacity
     * @param {String} easing
     * @param {Function} callback
     */
    function fade(elm, opacity,options, callback) {
        if (langx.isFunction(options)) {
            callback = options;
            options = {};
        }
        options = options || {};
        
        transit(elm, { opacity: opacity }, options.duration, options.easing, callback);
        return this;
    }


    return transits.fade = fade;
});
define('skylark-domx-transits/fade-in',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./transits",
    "./fade"
],function(langx,styler,transits,fadeTo) {
    /*   
     * Display an element by fading them to opaque.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {String} easing
     * @param {Function} callback
     */
    function fadeIn(elm, options, callback) {
        var target = styler.css(elm, "opacity");
        if (target > 0) {
            styler.css(elm, "opacity", 0);
        } else {
            target = 1;
        }
        styler.show(elm);

        fadeTo(elm,  target,options, callback);

        return this;
    }


    return transits.fadeIn = fadeIn;
});
define('skylark-domx-transits/fade-out',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./transits",
    "./fade"
],function(langx,styler,transits,fadeTo) {
    /*   
     * Hide an element by fading them to transparent.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {String} easing
     * @param {Function} callback
     */
    function fadeOut(elm, options, callback) {

        function complete() {
            styler.css(elm,"opacity",opacity);
            styler.hide(elm);
            if (callback) {
                callback.call(elm);
            }
        }

        fadeTo(elm, 0,options,callback);

        return this;
    }

    return transits.fadeOut = fadeOut;
});
define('skylark-domx-transits/fade-toggle',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./transits",
    "./fade-in",
    "./fade-out"
],function(langx,styler,transits,fadeIn,fadeOut) {

    /*   
     * Display or hide an element by animating its opacity.
     * @param {Object} elm  
     * @param {Number or String} speed
     * @param {String} ceasing
     * @param {Function} callback
     */
    function fadeToggle(elm, speed, easing, callback) {
        if (styler.isInvisible(elm)) {
            fadeIn(elm, speed, easing, callback);
        } else {
            fadeOut(elm, speed, easing, callback);
        }
        return this;
    }


    return transits.fadeToggle = fadeToggle;
});
define('skylark-domx-transits/pulsate',[
    "skylark-langx/langx",
    "skylark-domx-geom",
    "skylark-domx-styler",
    "./transits",
    "./transit"
],function(langx,geom,styler,transits,transit) {

	function pulsate(elm, options, done ) {
		var 
			mode = options.mode,
			show = mode === "show" || !mode,
			hide = mode === "hide",
			showhide = show || hide,

			// Showing or hiding leaves off the "last" animation
			anims = ( ( options.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
			duration = options.duration / anims,
			animateTo = 0,
			i = 1;

		if ( show || styler.isInvisible(elm) ) {
			styler.css(elm, "opacity", 0 );
			styler.show(elm);
			animateTo = 1;
		}

		// Anims - 1 opacity "toggles"

		var Deferred = langx.Deferred;
		var funcs = [];

		function doAnimate(elm,properties, duration, ease) {
			return function() {
				var d = new Deferred();

				transit( elm,properties, duration, ease ,function(){
					d.resolve();
				});
				return d.promise;

			}
		}


		for ( ; i < anims; i++ ) {
			funcs.push(doAnimate(elm,{ opacity: animateTo }, duration, options.easing ));
			animateTo = 1 - animateTo;
		}

	    funcs.push(doAnimate(elm,{ opacity: animateTo }, duration, options.easing ));

		funcs.push(done);
		funcs.reduce(function(prev, curr, index, array) {
	  		return prev.then(curr);
		}, Deferred.resolve());

		return this;

	}

	return transits.pulsate = pulsate;

});

define('skylark-domx-transits/shake',[
    "skylark-langx/langx",
    "skylark-domx-geom",
    "skylark-domx-styler",
    "./transits",
    "./transit"
],function(langx,geom,styler,transits,transit) {
	function shake(elm, options, done ) {

		var i = 1,
			direction = options.direction || "left",
			distance = options.distance || 20,
			times = options.times || 3,
			anims = times * 2 + 1,
			speed = Math.round( options.duration / anims ),
			ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
			positiveMotion = ( direction === "up" || direction === "left" ),
			animation0 = {},
			animation = {},
			animation1 = {},
			animation2 = {};

		var Deferred = langx.Deferred;
			start = geom.relativePosition(elm)[ref],
			funcs = [];

		function doAnimate(elm,properties, duration, ease) {
			return function() {
				var d = new Deferred();

				transit(elm, properties, duration, ease ,function(){
					d.resolve();
				});
				return d.promise;
			}
		}

		// Animation
		animation0[ ref ] = start;
		animation[ ref ] = start + ( positiveMotion ? -1 : 1 ) * distance;
		animation1[ ref ] = animation[ ref ] + ( positiveMotion ? 1 : -1 ) * distance * 2;
		animation2[ ref ] = animation1[ ref ] + ( positiveMotion ? -1 : 1 ) * distance * 2;

		// Animate
	    funcs.push(doAnimate(elm,animation, speed, options.easing ));

		// Shakes
		for ( ; i < times; i++ ) {
		    funcs.push(doAnimate(elm,animation1, speed, options.easing ));
		    funcs.push(doAnimate(elm,animation2, speed, options.easing ));
		}

	    funcs.push(doAnimate(elm,animation0, speed /2 , options.easing ));

		funcs.push(done);
		funcs.reduce(function(prev, curr, index, array) {
	  		return prev.then(curr);
		}, Deferred.resolve());

		return this;
	}

	return transits.shake = shake;

});

define('skylark-domx-transits/slide',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./transits",
    "./transit"
],function(langx,styler,transits,transit) {

    function slide(elm,options,callback ) {
    	if (langx.isFunction(options)) {
    		callback = options;
    		options = {};
    	}
    	options = options || {};
		var direction = options.direction || "down",
			isHide = ( direction === "up" || direction === "left" ),
			isVert = ( direction === "up" || direction === "down" ),
			duration = options.duration || transits.speeds.normal;


        // get the element position to restore it then
        var position = styler.css(elm, 'position');

        if (isHide) {
            // active the function only if the element is visible
        	if (styler.isInvisible(elm)) {
        		return this;
        	}
        } else {
	        // show element if it is hidden
	        styler.show(elm);        	
	        // place it so it displays as usually but hidden
	        styler.css(elm, {
	            position: 'absolute',
	            visibility: 'hidden'
	        });
        }



        if (isVert) { // up--down
	        // get naturally height, margin, padding
	        var marginTop = styler.css(elm, 'margin-top');
	        var marginBottom = styler.css(elm, 'margin-bottom');
	        var paddingTop = styler.css(elm, 'padding-top');
	        var paddingBottom = styler.css(elm, 'padding-bottom');
	        var height = styler.css(elm, 'height');

	        if (isHide) {  	// slideup
	            // set initial css for animation
	            styler.css(elm, {
	                visibility: 'visible',
	                overflow: 'hidden',
	                height: height,
	                marginTop: marginTop,
	                marginBottom: marginBottom,
	                paddingTop: paddingTop,
	                paddingBottom: paddingBottom
	            });

	            // transit element height, margin and padding to zero
	            transit(elm, {
	                height: 0,
	                marginTop: 0,
	                marginBottom: 0,
	                paddingTop: 0,
	                paddingBottom: 0
	            }, {
	                // callback : restore the element position, height, margin and padding to original values
	                duration: duration,
	                queue: false,
	                complete: function() {
	                    styler.hide(elm);
	                    styler.css(elm, {
	                        visibility: 'visible',
	                        overflow: 'hidden',
	                        height: height,
	                        marginTop: marginTop,
	                        marginBottom: marginBottom,
	                        paddingTop: paddingTop,
	                        paddingBottom: paddingBottom
	                    });
	                    if (callback) {
	                        callback.apply(elm);
	                    }
	                }
	            });
	        } else {     	// slidedown
		        // set initial css for animation
		        styler.css(elm, {
		            position: position,
		            visibility: 'visible',
		            overflow: 'hidden',
		            height: 0,
		            marginTop: 0,
		            marginBottom: 0,
		            paddingTop: 0,
		            paddingBottom: 0
		        });

		        // transit to gotten height, margin and padding
		        transit(elm, {
		            height: height,
		            marginTop: marginTop,
		            marginBottom: marginBottom,
		            paddingTop: paddingTop,
		            paddingBottom: paddingBottom
		        }, {
		            duration: duration,
		            complete: function() {
		                if (callback) {
		                    callback.apply(elm);
		                }
		            }
		        });

	        }

        } else { // left--right
	        // get naturally height, margin, padding
	        var marginLeft = styler.css(elm, 'margin-left');
	        var marginRight = styler.css(elm, 'margin-right');
	        var paddingLeft = styler.css(elm, 'padding-left');
	        var paddingRight = styler.css(elm, 'padding-right');
	        var width = styler.css(elm, 'width');

	        if (isHide) {  	// slideleft
	            // set initial css for animation
	            styler.css(elm, {
	                visibility: 'visible',
	                overflow: 'hidden',
	                width: width,
	                marginLeft: marginLeft,
	                marginRight: marginRight,
	                paddingLeft: paddingLeft,
	                paddingRight: paddingRight
	            });

	            // transit element height, margin and padding to zero
	            transit(elm, {
	                width: 0,
	                marginLeft: 0,
	                marginRight: 0,
	                paddingLeft: 0,
	                paddingRight: 0
	            }, {
	                // callback : restore the element position, height, margin and padding to original values
	                duration: duration,
	                queue: false,
	                complete: function() {
	                    styler.hide(elm);
	                    styler.css(elm, {
	                        visibility: 'visible',
	                        overflow: 'hidden',
	                        width: width,
	                        marginLeft: marginLeft,
	                        marginRight: marginRight,
	                        paddingLeft: paddingLeft,
	                        paddingRight: paddingRight
	                    });
	                    if (callback) {
	                        callback.apply(elm);
	                    }
	                }
	            });
	        } else {     	// slideright
		        // set initial css for animation
		        styler.css(elm, {
		            position: position,
		            visibility: 'visible',
		            overflow: 'hidden',
		            width: 0,
		            marginLeft: 0,
		            marginRight: 0,
		            paddingLeft: 0,
		            paddingRight: 0
		        });

		        // transit to gotten width, margin and padding
		        transit(elm, {
		            width: width,
		            marginLeft: marginLeft,
		            marginRight: marginRight,
		            paddingLeft: paddingLeft,
		            paddingRight: paddingRight
		        }, {
		            duration: duration,
		            complete: function() {
		                if (callback) {
		                    callback.apply(elm);
		                }
		            }
		        });

	        }       	
        }

        return this;
    }

    return transits.slide = slide;

});

define('skylark-domx-transits/slide-down',[
    "./transits",
    "./slide"
],function(transits,slide) {
    /*   
     * Display an element with a sliding motion.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {Function} callback
     */
    function slideDown(elm, duration, callback) {
        return slide(elm,{
            direction : "down",
            duration : duration
        },callback);
    }

    return transits.slideDown = slideDown;
});
define('skylark-domx-transits/slide-up',[
    "./transits",
    "./slide"
],function(transits,slide) {
    /*   
     * Hide an element with a sliding motion.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {Function} callback
     */
    function slideUp(elm, duration, callback) {
        return slide(elm,{
            direction : "up",
            duration : duration
        },callback);
    }



    return transits.slideUp = slideUp;
});
define('skylark-domx-transits/slide-toggle',[
    "skylark-langx/langx",
    "skylark-domx-geom",
    "./transits",
    "./slide-down",
    "./slide-up"
],function(langx,geom,transits,slideDown,slideUp) {

    /*   
     * Display or hide an element with a sliding motion.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {Function} callback
     */
    function slideToggle(elm, duration, callback) {

        // if the element is hidden, slideDown !
        if (geom.height(elm) == 0) {
            slideDown(elm, duration, callback);
        }
        // if the element is visible, slideUp !
        else {
            slideUp(elm, duration, callback);
        }
        return this;
    }

    return transits.slideToggle = slideToggle;
});
define('skylark-domx-transits/throb',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "skylark-domx-noder",
    "./transits",
    "./transit"
],function(langx,styler,noder,transits,transit) {

    
    /*   
     * Replace an old node with the specified node.
     * @param {HTMLElement} elm
     * @param {Node} params
     */
    function throb(elm, params) {
        params = params || {};

        var self = this,
            text = params.text,
            style = params.style,
            time = params.time,
            callback = params.callback,
            timer,

            throbber = noder.createElement("div", {
                "class": params.className || "throbber"
            }),
            //_overlay = overlay(throbber, {
            //    "class": 'overlay fade'
            //}),
            remove = function() {
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
                if (throbber) {
                    noder.remove(throbber);
                    throbber = null;
                }
            },
            update = function(params) {
                if (params && params.text && throbber) {
                    textNode.nodeValue = params.text;
                }
            };

        if (params.style) {
            styler.css(throbber,params.style);
        }

        //throb = noder.createElement("div", {
        //   "class": params.throb && params.throb.className || "throb"
        //}),
        //textNode = noder.createTextNode(text || ""),
 
        var content = params.content ||  '<span class="throb"></span>';

        //throb.appendChild(textNode);
        //throbber.appendChild(throb);

        noder.html(throbber,content);
        
        elm.appendChild(throbber);

        var end = function() {
            remove();
            if (callback) callback();
        };
        if (time) {
            timer = setTimeout(end, time);
        }

        return {
            throbber : throbber,
            remove: remove,
            update: update
        };
    }

    return transits.throb = throb;
});
define('skylark-domx-transits/toggle',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./transits",
    "./show",
    "./hide"
],function(langx,styler,transits,show,hide) {
    /*   
     * Display or hide an element.
     * @param {Object} elm  
     * @param {Number or String} speed
     * @param {Function} callbacke
     */
    function toggle(elm, speed, callback) {
        if (styler.isInvisible(elm)) {
            show(elm, speed, callback);
        } else {
            hide(elm, speed, callback);
        }
        return this;
    }

    return transits.toggle = toggle;
});
define('skylark-domx-transits/main',[
	"./transits",
	"skylark-domx-velm",
	"skylark-domx-query",
    "./transit",
    "./bounce",
    "./emulate-transition-end",
    "./explode",
    "./fade-in",
    "./fade-out",
    "./fade",
    "./fade-toggle",
    "./hide",
    "./pulsate",
    "./shake",
    "./show",
    "./slide",
    "./slide-down",
    "./slide-toggle",
    "./slide-up",
    "./throb",
    "./toggle"
],function(transits,velm,$){
    // from ./transits
    velm.delegate([
        "transit",
        "emulateTransitionEnd",
        "fadeIn",
        "fadeOut",
        "fade",
        "fadeToggle",
        "hide",
        "scrollToTop",
        "slideDown",
        "slideToggle",
        "slideUp",
        "show",
        "toggle"
    ], transits);

    $.fn.hide =  $.wraps.wrapper_every_act(transits.hide, transits);

    $.fn.transit = $.wraps.wrapper_every_act(transits.transit, transits);
    $.fn.emulateTransitionEnd = $.wraps.wrapper_every_act(transits.emulateTransitionEnd, transits);

    $.fn.show = $.wraps.wrapper_every_act(transits.show, transits);
    $.fn.hide = $.wraps.wrapper_every_act(transits.hide, transits);
    $.fn.toogle = $.wraps.wrapper_every_act(transits.toogle, transits);
    $.fn.fadeTo = $.wraps.wrapper_every_act(transits.fadeTo, transits);
    $.fn.fadeIn = $.wraps.wrapper_every_act(transits.fadeIn, transits);
    $.fn.fadeOut = $.wraps.wrapper_every_act(transits.fadeOut, transits);
    $.fn.fadeToggle = $.wraps.wrapper_every_act(transits.fadeToggle, transits);

    $.fn.slideDown = $.wraps.wrapper_every_act(transits.slideDown, transits);
    $.fn.slideToggle = $.wraps.wrapper_every_act(transits.slideToggle, transits);
    $.fn.slideUp = $.wraps.wrapper_every_act(transits.slideUp, transits);

	return transits;
});
define('skylark-domx-transits', ['skylark-domx-transits/main'], function (main) { return main; });

define('skylark-domx-fx/fx',[
    "skylark-langx/skylark",
    "skylark-langx/langx"
], function(skylark,langx) {

    function fx() {
        return fx;
    }

    langx.mixin(fx, {
        off: false,
        speeds: {
            normal: 400,
            fast: 200,
            slow: 600
        }
    });

    return skylark.attach("domx.fx", fx);
});
define('skylark-domx-animates/animates',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser"
], function(skylark,langx,browser) {

    function animates() {
        return animates;
    }

    langx.mixin(animates, {
        off: false,
        speeds: {
            normal: 400,
            fast: 200,
            slow: 600
        },
        animationName : browser.normalizeCssProperty("animation-name"),
        animationDuration : browser.normalizeCssProperty("animation-duration"),
        animationDelay : browser.normalizeCssProperty("animation-delay"),
        animationTiming : browser.normalizeCssProperty("animation-timing-function"),
        animationEnd : browser.normalizeCssEvent('AnimationEnd'),

        animateBaseClass : "animated"
    });

    return skylark.attach("domx.animates", animates);
});
define('skylark-domx-animates/animation',[
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-noder",
    "skylark-domx-geom",
    "skylark-domx-styler",
    "skylark-domx-eventer",
    "./animates"
], function(langx, browser, noder, geom, styler, eventer,animates) {

    var animationName = animates.animationName,
        animationDuration = animates.animationDuration,
        animationTiming = animates.animationTiming,
        animationDelay = animates.animationDelay,

        animationEnd = animates.animationEnd,

        cssReset = {};


    cssReset[animationName] =
        cssReset[animationDuration] =
        cssReset[animationDelay] =
        cssReset[animationTiming] = "";

    /*   
     * Perform a custom animation.
     * @param {Object} elm  
     * @param {String} name
     * @param {String} ease
     * @param {Number or String} duration
     * @param {Function} callback
     * @param {Number or String} delay
     */
    function animation(elm, name, duration, ease, callback, delay) {
        var cssValues = {};
        if (langx.isPlainObject(duration)) {
            ease = duration.easing;
            callback = duration.complete;
            delay = duration.delay;
            duration = duration.duration;
        }

        if (langx.isString(duration)) {
            duration = animates.speeds[duration];
        }
        if (duration === undefined) {
            duration = animates.speeds.normal;
        }
        duration = duration / 1000;

        if (langx.isFunction(ease)) {
            callback = ease;
            eace = "swing";
        } else {
            ease = ease || "swing";
        }

        if (delay) {
            delay = delay / 1000;
        } else {
            delay = 0;
        }
        // keyframe animation
        cssValues[animationName] = name;
        cssValues[animationDuration] = duration + "s";
        cssValues[animationTiming] = ease;


        if (duration > 0) {
            eventer.on(elm, animationEnd, callback);
        }

        // trigger page reflow so new elements can animate
        elm.clientLeft;

        styler.css(elm, cssValues);

        return this;
    }

    return animates.animation = animation;

});
define('skylark-domx-fx/animate',[
    "skylark-langx/langx",
    "skylark-domx-transits/transit",
    "skylark-domx-animates/animation",
    "./fx"
], function(langx, transit,animation,fx) {

    /*   
     * Perform a custom animation of a set of CSS properties.
     * @param {Object} elm  
     * @param {Number or String} properties
     * @param {String} ease
     * @param {Number or String} duration
     * @param {Function} callback
     * @param {Number or String} delay
     */
    function animate(elm, properties, duration, ease, callback, delay) {
        if (langx.isString(properties)) {
            return animation(elm,properties,duration,ease,callback,delay);
        } else {
            return transit(elm,properties,duration,ease,callback,delay);
        }

    }

    return fx.animate = animate;

});
define('skylark-domx-fx/bounce',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {
    return fx.bounce = transits.bounce;
});
define('skylark-domx-fx/emulateTransitionEnd',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {
    return fx.emulateTransitionEnd = transits.emulateTransitionEnd;
});
define('skylark-domx-fx/explode',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {
	return fx.explode = transits.explode;
});

define('skylark-domx-fx/fadeIn',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {

    return fx.fadeIn = transits.fadeIn;
});
define('skylark-domx-fx/fadeOut',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {

    return fx.fadeOut = transits.fadeOut;
});
define('skylark-domx-fx/fade',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {

    return fx.fade = transits.fade;
});
define('skylark-domx-fx/fadeToggle',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {

    return fx.fadeToggle = transits.fadeToggle;
});
define('skylark-domx-fx/hide',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {

    return fx.hide = transits.hide;
});
define('skylark-domx-fx/pulsate',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {

	return fx.pulsate = transits.pulsate;

});

define('skylark-domx-fx/shake',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {

	return fx.shake = transits.shake;

});

define('skylark-domx-fx/show',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {

    return fx.show = transits.show;
});
define('skylark-domx-fx/slide',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {

    function slide(elm,options,callback ) {
    	if (langx.isFunction(options)) {
    		callback = options;
    		options = {};
    	}
    	options = options || {};
		var direction = options.direction || "down",
			isHide = ( direction === "up" || direction === "left" ),
			isVert = ( direction === "up" || direction === "down" ),
			duration = options.duration || fx.speeds.normal;


        // get the element position to restore it then
        var position = styler.css(elm, 'position');

        if (isHide) {
            // active the function only if the element is visible
        	if (styler.isInvisible(elm)) {
        		return this;
        	}
        } else {
	        // show element if it is hidden
	        styler.show(elm);        	
	        // place it so it displays as usually but hidden
	        styler.css(elm, {
	            position: 'absolute',
	            visibility: 'hidden'
	        });
        }



        if (isVert) { // up--down
	        // get naturally height, margin, padding
	        var marginTop = styler.css(elm, 'margin-top');
	        var marginBottom = styler.css(elm, 'margin-bottom');
	        var paddingTop = styler.css(elm, 'padding-top');
	        var paddingBottom = styler.css(elm, 'padding-bottom');
	        var height = styler.css(elm, 'height');

	        if (isHide) {  	// slideup
	            // set initial css for animation
	            styler.css(elm, {
	                visibility: 'visible',
	                overflow: 'hidden',
	                height: height,
	                marginTop: marginTop,
	                marginBottom: marginBottom,
	                paddingTop: paddingTop,
	                paddingBottom: paddingBottom
	            });

	            // animate element height, margin and padding to zero
	            animate(elm, {
	                height: 0,
	                marginTop: 0,
	                marginBottom: 0,
	                paddingTop: 0,
	                paddingBottom: 0
	            }, {
	                // callback : restore the element position, height, margin and padding to original values
	                duration: duration,
	                queue: false,
	                complete: function() {
	                    styler.hide(elm);
	                    styler.css(elm, {
	                        visibility: 'visible',
	                        overflow: 'hidden',
	                        height: height,
	                        marginTop: marginTop,
	                        marginBottom: marginBottom,
	                        paddingTop: paddingTop,
	                        paddingBottom: paddingBottom
	                    });
	                    if (callback) {
	                        callback.apply(elm);
	                    }
	                }
	            });
	        } else {     	// slidedown
		        // set initial css for animation
		        styler.css(elm, {
		            position: position,
		            visibility: 'visible',
		            overflow: 'hidden',
		            height: 0,
		            marginTop: 0,
		            marginBottom: 0,
		            paddingTop: 0,
		            paddingBottom: 0
		        });

		        // animate to gotten height, margin and padding
		        animate(elm, {
		            height: height,
		            marginTop: marginTop,
		            marginBottom: marginBottom,
		            paddingTop: paddingTop,
		            paddingBottom: paddingBottom
		        }, {
		            duration: duration,
		            complete: function() {
		                if (callback) {
		                    callback.apply(elm);
		                }
		            }
		        });

	        }

        } else { // left--right
	        // get naturally height, margin, padding
	        var marginLeft = styler.css(elm, 'margin-left');
	        var marginRight = styler.css(elm, 'margin-right');
	        var paddingLeft = styler.css(elm, 'padding-left');
	        var paddingRight = styler.css(elm, 'padding-right');
	        var width = styler.css(elm, 'width');

	        if (isHide) {  	// slideleft
	            // set initial css for animation
	            styler.css(elm, {
	                visibility: 'visible',
	                overflow: 'hidden',
	                width: width,
	                marginLeft: marginLeft,
	                marginRight: marginRight,
	                paddingLeft: paddingLeft,
	                paddingRight: paddingRight
	            });

	            // animate element height, margin and padding to zero
	            animate(elm, {
	                width: 0,
	                marginLeft: 0,
	                marginRight: 0,
	                paddingLeft: 0,
	                paddingRight: 0
	            }, {
	                // callback : restore the element position, height, margin and padding to original values
	                duration: duration,
	                queue: false,
	                complete: function() {
	                    styler.hide(elm);
	                    styler.css(elm, {
	                        visibility: 'visible',
	                        overflow: 'hidden',
	                        width: width,
	                        marginLeft: marginLeft,
	                        marginRight: marginRight,
	                        paddingLeft: paddingLeft,
	                        paddingRight: paddingRight
	                    });
	                    if (callback) {
	                        callback.apply(elm);
	                    }
	                }
	            });
	        } else {     	// slideright
		        // set initial css for animation
		        styler.css(elm, {
		            position: position,
		            visibility: 'visible',
		            overflow: 'hidden',
		            width: 0,
		            marginLeft: 0,
		            marginRight: 0,
		            paddingLeft: 0,
		            paddingRight: 0
		        });

		        // animate to gotten width, margin and padding
		        animate(elm, {
		            width: width,
		            marginLeft: marginLeft,
		            marginRight: marginRight,
		            paddingLeft: paddingLeft,
		            paddingRight: paddingRight
		        }, {
		            duration: duration,
		            complete: function() {
		                if (callback) {
		                    callback.apply(elm);
		                }
		            }
		        });

	        }       	
        }

        return this;
    }

    return fx.slide = slide;

});

define('skylark-domx-fx/slideDown',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {
    /*   
     * Display an element with a sliding motion.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {Function} callback
     */
    function slideDown(elm, duration, callback) {
        return slide(elm,{
            direction : "down",
            duration : duration
        },callback);
    }

    return fx.slideDown = slideDown;
});
define('skylark-domx-fx/slideToggle',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {

    /*   
     * Display or hide an element with a sliding motion.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {Function} callback
     */
    function slideToggle(elm, duration, callback) {

        // if the element is hidden, slideDown !
        if (geom.height(elm) == 0) {
            slideDown(elm, duration, callback);
        }
        // if the element is visible, slideUp !
        else {
            slideUp(elm, duration, callback);
        }
        return this;
    }

    return fx.slideToggle = slideToggle;
});
define('skylark-domx-fx/slideUp',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {
    /*   
     * Hide an element with a sliding motion.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {Function} callback
     */
    function slideUp(elm, duration, callback) {
        return slide(elm,{
            direction : "up",
            duration : duration
        },callback);
    }



    return fx.slideUp = slideUp;
});
define('skylark-domx-fx/throb',[
    "skylark-domx-noder",
    "./fx"
],function(noder,fx) {
    
    return fx.throb = noder.throb;
});
define('skylark-domx-fx/toggle',[
    "skylark-domx-transits",
    "./fx"
],function(transits,fx) {
    /*   
     * Display or hide an element.
     * @param {Object} elm  
     * @param {Number or String} speed
     * @param {Function} callbacke
     */
    function toggle(elm, speed, callback) {
        if (styler.isInvisible(elm)) {
            show(elm, speed, callback);
        } else {
            hide(elm, speed, callback);
        }
        return this;
    }

    return fx.toggle = toggle;
});
define('skylark-domx-fx/main',[
	"./fx",
    "./animate",
    "./bounce",
    "./emulateTransitionEnd",
    "./explode",
    "./fadeIn",
    "./fadeOut",
    "./fade",
    "./fadeToggle",
    "./hide",
    "./pulsate",
    "./shake",
    "./show",
    "./slide",
    "./slideDown",
    "./slideToggle",
    "./slideUp",
    "./throb",
    "./toggle"
],function(fx){

	return fx;
});
define('skylark-domx-fx', ['skylark-domx-fx/main'], function (main) { return main; });

define('skylark-jquery/core',[
	"skylark-langx/skylark",
	"skylark-langx/langx",
	"skylark-domx-browser",
	"skylark-domx-noder",
	"skylark-domx-data",
	"skylark-domx-eventer",
	"skylark-domx-finder",
	"skylark-domx-forms",
	"skylark-domx-transits",
	"skylark-domx-fx",
	"skylark-domx-styler",
	"skylark-domx-query",
	"skylark-langx-scripter"
],function(skylark,langx,browser,noder,datax,eventer,finder,forms,transites,fx,styler,query,scripter){
	var filter = Array.prototype.filter,
		slice = Array.prototype.slice;

    (function($){
	    $.fn.jquery = '2.2.0';

	    $.browser = browser;
	    
	    $.camelCase = langx.camelCase;

		$.cleanData = function( elems ) {
			var elem,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				datax.cleanData(elem);
			}
		};

		$.removeData = function(elm,name) {
			datax.removeData(elm,name);
		}
	
	    $.each = langx.each;

	    $.extend = langx.extend;

	    $.grep = function(elements, callback) {
	        return filter.call(elements, callback)
	    };

	    $.attr = function(elm,name) {
	    	return datax.attr(elm,name);
	    };

	    $.isArray = langx.isArray;
	    $.isEmptyObject = langx.isEmptyObject;
	    $.isFunction = langx.isFunction;
	    $.isWindow = langx.isWindow;
	    $.isPlainObject = langx.isPlainObject;
        $.isNumeric = langx.isNumber;

	    $.inArray = langx.inArray;

	    $.makeArray = langx.makeArray;
	    $.map = langx.map;  // The behavior is somewhat different from the original jquery.

	    $.noop = function() {
	    };

	    $.parseJSON = window.JSON.parse;

	    $.proxy = langx.proxy;

	    $.trim = langx.trim;
	    $.type = langx.type;

	    $.fn.extend = function(props) {
	        langx.mixin($.fn, props);
	    };


    })(query);

    (function($){
        $.Event = function Event(src, props) {
            if (langx.isString(src)) {
            	var type = src;
            	return eventer.create(type, props);
	        }
            return eventer.proxy(src, props);
        };

        $.event = {};

	    $.event.special = eventer.special;

	    $.fn.submit = function(callback) {
	        if (0 in arguments) this.bind('submit', callback)
	        else if (this.length) {
	            var event = $.Event('submit')
	            this.eq(0).trigger(event)
	            if (!event.isDefaultPrevented()) this.get(0).submit()
	        }
	        return this
	    };

	    // event
	    $.fn.triggerHandler = $.fn.trigger;

	    $.fn.delegate = function(selector, event, callback) {
	        return this.on(event, selector, callback)
	    };

	    $.fn.undelegate = function(selector, event, callback) {
	        return this.off(event, selector, callback)
	    };

	    $.fn.live = function(event, callback) {
	        $(document.body).delegate(this.selector, event, callback)
	        return this
	    };

	    $.fn.die = function(event, callback) {
	        $(document.body).undelegate(this.selector, event, callback)
	        return this
	    };

	    $.fn.bind = function(event, selector, data, callback) {
	        return this.on(event, selector, data, callback)
	    };

	    $.fn.unbind = function(event, callback) {
	        return this.off(event, callback)
	    };

	    $.fn.ready = function(callback) {
	        eventer.ready(callback);
	        return this;
	    };

	    $.fn.stop = function() {
	        // todo
	        return this;
	    };

	    $.fn.moveto = function(x, y) {
	        return this.transit({
	            left: x + "px",
	            top: y + "px"
	        }, 0.4);

	    };

	    $.ready = eventer.ready;

	    $.on = eventer.on;

	    $.off = eventer.off;
    })(query);

    (function($){
	    // plugin compatibility
	    $.uuid = 0;
	    $.support = browser.support;
	    $.expr = {};

	    $.expr[":"] = $.expr.pseudos = $.expr.filters = finder.pseudos;

	    $.expr.createPseudo = function(fn) {
	    	return fn;
	    };

	    $.cssHooks = styler.cssHooks;

	    $.contains = noder.contains;

	    $.css = styler.css;

	    $.data = datax.data;

	    $.fx = fx;
	    $.fx.step = {

        };

        $.speed = function( speed, easing, fn ) {
            var opt = speed && typeof speed === "object" ? $.extend( {}, speed ) : {
                complete: fn || !fn && easing ||
                    $.isFunction( speed ) && speed,
                duration: speed,
                easing: fn && easing || easing && !$.isFunction( easing ) && easing
            };

            // Go to the end state if fx are off
            if ( $.fx.off ) {
                opt.duration = 0;

            } else {
                if ( typeof opt.duration !== "number" ) {
                    if ( opt.duration in $.fx.speeds ) {
                        opt.duration = $.fx.speeds[ opt.duration ];

                    } else {
                        opt.duration = $.fx.speeds._default;
                    }
                }
            }

            // Normalize opt.queue - true/undefined/null -> "fx"
            if ( opt.queue == null || opt.queue === true ) {
                opt.queue = "fx";
            }

            // Queueing
            opt.old = opt.complete;

            opt.complete = function() {
                if ( $.isFunction( opt.old ) ) {
                    opt.old.call( this );
                }

                if ( opt.queue ) {
                    $.dequeue( this, opt.queue );
                }
            };

            return opt;
        };

        $.easing = {};

	    $.offset = {};
	    $.offset.setOffset = function(elem, options, i) {
	        var position = $.css(elem, "position");

	        // set position first, in-case top/left are set even on static elem
	        if (position === "static") {
	            elem.style.position = "relative";
	        }

	        var curElem = $(elem),
	            curOffset = curElem.offset(),
	            curCSSTop = $.css(elem, "top"),
	            curCSSLeft = $.css(elem, "left"),
	            calculatePosition = (position === "absolute" || position === "fixed") && $.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
	            props = {},
	            curPosition = {},
	            curTop, curLeft;

	        // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
	        if (calculatePosition) {
	            curPosition = curElem.position();
	            curTop = curPosition.top;
	            curLeft = curPosition.left;
	        } else {
	            curTop = parseFloat(curCSSTop) || 0;
	            curLeft = parseFloat(curCSSLeft) || 0;
	        }

	        if ($.isFunction(options)) {
	            options = options.call(elem, i, curOffset);
	        }

	        if (options.top != null) {
	            props.top = (options.top - curOffset.top) + curTop;
	        }
	        if (options.left != null) {
	            props.left = (options.left - curOffset.left) + curLeft;
	        }

	        if ("using" in options) {
	            options.using.call(elem, props);
	        } else {
	            curElem.css(props);
	        }
	    };

        $._data = function(elm,propName) {
            if (elm.hasAttribute) {
                return datax.data(elm,propName);
            } else {
                return {};
            }
        };

     	var t = $.fn.text;  
	    $.fn.text = function(v) {
	        var r = t.apply(this,arguments);
	        if (r === undefined) {
	            r = "";
	        }  
	        return r;
	    };       

	    $.fn.pos = $.fn.position;
        	    
    })(query);

    query.parseHTML = function(html) {
        return  noder.createFragment(html);
    };

    query.uniqueSort = query.unique = langx.uniq;

    query.skylark = skylark;

    return window.jQuery = window.$ = query;
});

define('skylark-langx-emitter/emitter',[
    "skylark-langx-events"
],function(events){
    return events.Emitter;
});
define('skylark-langx-emitter/evented',[
	"./emitter"
],function(Emitter){
	return Emitter;
});
define('skylark-net-http/http',[
  "skylark-langx-ns/ns",
],function(skylark){
	return skylark.attach("net.http",{});
});
define('skylark-net-http/xhr',[
  "skylark-langx-ns/ns",
  "skylark-langx-types",
  "skylark-langx-objects",
  "skylark-langx-arrays",
  "skylark-langx-funcs",
  "skylark-langx-async/deferred",
  "skylark-langx-emitter/evented",
  "skylark-langx-urls/is-cross-origin",
  "./http"
],function(skylark,types,objects,arrays,funcs,Deferred,Evented,isCrossOrigin,http){

    var each = objects.each,
        mixin = objects.mixin,
        noop = funcs.noop,
        isArray = types.isArray,
        isFunction = types.isFunction,
        isPlainObject = types.isPlainObject,
        type = types.type;
 
     var getAbsoluteUrl = (function() {
        var a;

        return function(url) {
            if (!a) a = document.createElement('a');
            a.href = url;

            return a.href;
        };
    })();
   
    var Xhr = (function(){
        var jsonpID = 0,
            key,
            name,
            rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
            scriptTypeRE = /^(?:text|application)\/javascript/i,
            xmlTypeRE = /^(?:text|application)\/xml/i,
            jsonType = 'application/json',
            htmlType = 'text/html',
            blankRE = /^\s*$/;

        var XhrDefaultOptions = {
            async: true,

            // Default type of request
            type: 'GET',
            // Callback that is executed before request
            beforeSend: noop,
            // Callback that is executed if the request succeeds
            success: noop,
            // Callback that is executed the the server drops error
            error: noop,
            // Callback that is executed on request complete (both: error and success)
            complete: noop,
            // The context for the callbacks
            context: null,
            // Whether to trigger "global" Ajax events
            global: true,

            // MIME types mapping
            // IIS returns Javascript as "application/x-javascript"
            accepts: {
                script: 'text/javascript, application/javascript, application/x-javascript',
                json: 'application/json',
                xml: 'application/xml, text/xml',
                html: 'text/html',
                text: 'text/plain'
            },
            // Whether the request is to another domain
            crossDomain: false,
            // Default timeout
            timeout: 0,
            // Whether data should be serialized to string
            processData: false,
            // Whether the browser should be allowed to cache GET responses
            cache: true,

            traditional : false,
            
            xhrFields : {
                ///withCredentials : false
            }
        };

        function mimeToDataType(mime) {
            if (mime) {
                mime = mime.split(';', 2)[0];
            }
            if (mime) {
                if (mime == htmlType) {
                    return "html";
                } else if (mime == jsonType) {
                    return "json";
                } else if (scriptTypeRE.test(mime)) {
                    return "script";
                } else if (xmlTypeRE.test(mime)) {
                    return "xml";
                }
            }
            return "text";
        }

        function appendQuery(url, query) {
            if (query == '') return url
            return (url + '&' + query).replace(/[&?]{1,2}/, '?')
        }

        // serialize payload and append it to the URL for GET requests
        function serializeData(options) {
            options.data = options.data || options.query;
            if (options.processData && options.data && type(options.data) != "string") {
                options.data = param(options.data, options.traditional);
            }
            if (options.data && (!options.type || options.type.toUpperCase() == 'GET')) {
                if (type(options.data) != "string") {
                    options.data = param(options.data, options.traditional);
                }
                options.url = appendQuery(options.url, options.data);
                options.data = undefined;
            }
        }
        
        function serialize(params, obj, traditional, scope) {
            var t, array = isArray(obj),
                hash = isPlainObject(obj)
            each(obj, function(key, value) {
                t =type(value);
                if (scope) key = traditional ? scope :
                    scope + '[' + (hash || t == 'object' || t == 'array' ? key : '') + ']'
                // handle data in serializeArray() format
                if (!scope && array) params.add(value.name, value.value)
                // recurse into nested objects
                else if (t == "array" || (!traditional && t == "object"))
                    serialize(params, value, traditional, key)
                else params.add(key, value)
            })
        }

        var param = function(obj, traditional) {
            var params = []
            params.add = function(key, value) {
                if (isFunction(value)) {
                  value = value();
                }
                if (value == null) {
                  value = "";
                }
                this.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
            };
            serialize(params, obj, traditional)
            return params.join('&').replace(/%20/g, '+')
        };

        var Xhr = Evented.inherit({
            klassName : "Xhr",

            _request  : function(args) {
                var _ = this._,
                    self = this,
                    options = mixin({},XhrDefaultOptions,_.options,args),
                    xhr = _.xhr = new XMLHttpRequest();

                serializeData(options)

                if (options.beforeSend) {
                    options.beforeSend.call(this, xhr, options);
                }                

                var dataType = options.dataType || options.handleAs,
                    mime = options.mimeType || options.accepts[dataType],
                    headers = options.headers,
                    xhrFields = options.xhrFields,
                    isFormData = options.data && options.data instanceof FormData,
                    basicAuthorizationToken = options.basicAuthorizationToken,
                    type = options.type,
                    url = options.url,
                    async = options.async,
                    user = options.user , 
                    password = options.password,
                    deferred = new Deferred(),
                    contentType = options.contentType || (isFormData ? false : 'application/x-www-form-urlencoded');

                if (xhrFields) {
                    for (name in xhrFields) {
                        xhr[name] = xhrFields[name];
                    }
                }

                if (mime && mime.indexOf(',') > -1) {
                    mime = mime.split(',', 2)[0];
                }
                if (mime && xhr.overrideMimeType) {
                    xhr.overrideMimeType(mime);
                }

                if (dataType == "blob" || dataType == "arraybuffer") {
                    xhr.responseType = dataType;
                }

                var finish = function() {
                    xhr.onloadend = noop;
                    xhr.onabort = noop;
                    xhr.onprogress = noop;
                    xhr.ontimeout = noop;
                    xhr = null;
                }
                var onloadend = function() {
                    var result, error = false
                    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && getAbsoluteUrl(url).startsWith('file:'))) {
                        dataType = dataType || mimeToDataType(options.mimeType || xhr.getResponseHeader('content-type'));

                        //result = xhr.responseText;
                        try {
                            if (dataType == 'script') {
                                eval(xhr.responseText);
                            } else if (dataType == 'xml') {
                                result = xhr.responseXML;
                            } else if (dataType == 'json') {
                                result = blankRE.test(xhr.responseText) ? null : JSON.parse(xhr.responseText);
                            } else if (dataType == "blob") {
                                result = xhr.response; // new Blob([xhr.response]);
                            } else if (dataType == "arraybuffer") {
                                result = xhr.response;
                            } else {
                                //if (dataType == "text" || dataType=="html")
                                result = xhr.responseText;
                            }
                        } catch (e) { 
                            error = e;
                        }

                        if (error) {
                            deferred.reject(error,xhr.status,xhr);
                        } else {
                            deferred.resolve(result,xhr.status,xhr);
                        }
                    } else {
                        deferred.reject(new Error(xhr.statusText),xhr.status,xhr);
                    }
                    finish();
                };
                
                var onabort = function() {
                    if (deferred) {
                        deferred.reject(new Error("abort"),xhr.status,xhr);
                    }
                    finish();                 
                }
 
                var ontimeout = function() {
                    if (deferred) {
                        deferred.reject(new Error("timeout"),xhr.status,xhr);
                    }
                    finish();                 
                }

                var onprogress = function(evt) {
                    if (deferred) {
                        deferred.notify(evt,xhr.status,xhr);
                    }
                }

                xhr.onloadend = onloadend;
                xhr.onabort = onabort;
                xhr.ontimeout = ontimeout;
                xhr.onprogress = onprogress;

                xhr.open(type, url, async, user, password);
               
                if (headers) {
                    for ( var key in headers) {
                        var value = headers[key];
 
                        if(key.toLowerCase() === 'content-type'){
                            contentType = value;
                        } else {
                           xhr.setRequestHeader(key, value);
                        }
                    }
                }   

                if  (contentType && contentType !== false){
                    xhr.setRequestHeader('Content-Type', contentType);
                }

                if(!headers || !('X-Requested-With' in headers)){
                    if (!isCrossOrigin(url)) {// for s02
                      xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest'); 
                    }
                }


                //If basicAuthorizationToken is defined set its value into "Authorization" header
                if (basicAuthorizationToken) {
                    xhr.setRequestHeader("Authorization", basicAuthorizationToken);
                }

                xhr.send(options.data ? options.data : null);

                return deferred.promise;

            },

            "abort": function() {
                var _ = this._,
                    xhr = _.xhr;

                if (xhr) {
                    xhr.abort();
                }    
            },


            "request": function(args) {
                return this._request(args);
            },

            get : function(args) {
                args = args || {};
                args.type = "GET";
                return this._request(args);
            },

            post : function(args) {
                args = args || {};
                args.type = "POST";
                return this._request(args);
            },

            patch : function(args) {
                args = args || {};
                args.type = "PATCH";
                return this._request(args);
            },

            put : function(args) {
                args = args || {};
                args.type = "PUT";
                return this._request(args);
            },

            del : function(args) {
                args = args || {};
                args.type = "DELETE";
                return this._request(args);
            },

            "init": function(options) {
                this._ = {
                    options : options || {}
                };
            }
        });

        ["request","get","post","put","del","patch"].forEach(function(name){
            Xhr[name] = function(url,args) {
                var xhr = new Xhr({"url" : url});
                return xhr[name](args);
            };
        });

        Xhr.defaultOptions = XhrDefaultOptions;
        Xhr.param = param;

        return Xhr;
    })();

    return http.Xhr = Xhr;  
});
define('skylark-jquery/ajax',[
    "skylark-langx/langx",
    "skylark-net-http/xhr",
    "./core",
], function(langx,Xhr,$) {
    var jsonpID = 0;

     // Attach a bunch of functions for handling common AJAX events
    $.each( [
        "ajaxStart",
        "ajaxStop",
        "ajaxComplete",
        "ajaxError",
        "ajaxSuccess",
        "ajaxSend"
    ], function( i, type ) {
        $.fn[ type ] = function( fn ) {
            return this.on( type, fn );
        };
    } );
   

    function appendQuery(url, query) {
        if (query == '') return url
        return (url + '&' + query).replace(/[&?]{1,2}/, '?')
    }
    
    $.ajaxJSONP = function(options) {
        var deferred = new langx.Deferred();
        var _callbackName = options.jsonpCallback,
            callbackName = ($.isFunction(_callbackName) ?
                _callbackName() : _callbackName) || ('jsonp' + (++jsonpID)),
            script = document.createElement('script'),
            originalCallback = window[callbackName],
            responseData,
            abort = function(errorType) {
                $(script).triggerHandler('error', errorType || 'abort')
            },
            xhr = { abort: abort },
            abortTimeout;

        for (var key in options.data) {
            options.url = appendQuery(options.url, key + "=" + options.data[key]);
        }
         
//        if (deferred) deferred.promise(xhr)

        $(script).on('load error', function(e, errorType) {
            clearTimeout(abortTimeout)
            $(script).off().remove()

            if (e.type == 'error' || !responseData) {
                deferred.reject(e);
            } else {
                deferred.resolve(responseData[0],200,xhr);
            }

            window[callbackName] = originalCallback
            if (responseData && $.isFunction(originalCallback))
                originalCallback(responseData[0])

            originalCallback = responseData = undefined
        })

        window[callbackName] = function() {
            responseData = arguments
        }

        script.src = options.url.replace(/\?(.+)=\?/, '?$1=' + callbackName)
        document.head.appendChild(script)

        if (options.timeout > 0) abortTimeout = setTimeout(function() {
            abort('timeout')
        }, options.timeout)

        return deferred;
    }

    //$.ajaxSettings = Xhr.defaultOptions;
    //$.ajaxSettings.xhr = function() {
    //    return new window.XMLHttpRequest()
    //};

    $.ajaxSettings = {
        processData : true
    };


    $.ajax = function(url,options) {
        if (!url) {
            options = {
                url :  "./"
            };
        } else if (!options) {
            if (langx.isString(url)) {
                options = {
                    url :  url
                };
            } else {
                options = url;
            }
        } else {
            options.url = url;
        }

        options = langx.mixin({},$.ajaxSettings,options);

        if ('jsonp' == options.dataType) {
            var hasPlaceholder = /\?.+=\?/.test(options.url);

            if (!hasPlaceholder)
                options.url = appendQuery(options.url,
                    options.jsonp ? (options.jsonp + '=?') : options.jsonp === false ? '' : 'callback=?')
            return $.ajaxJSONP(options);
        }

        function ajaxSuccess(data,status,xhr) {
            $(document).trigger("ajaxSucess");
            if (options.success) {
                options.success.apply(this,arguments);
            }
            if (options.complete) {
                options.complete.apply(this,arguments);
            }
            return data;
        }

        function ajaxError() {
            $(document).trigger("ajaxError");
            if (options.error) {
                options.error.apply(this,arguments);
            }
        }

        var p = Xhr.request(options.url,options);
        p = p.then(ajaxSuccess,ajaxError);
        p.success = p.done;
        p.error = p.fail;
        p.complete = p.always;
        
        return p;
    };

    // handle optional data/success arguments
    function parseArguments(url, data, success, dataType) {
        if ($.isFunction(url)) {
            dataType = data, success = url, data = undefined,url = undefined;
        } else if ($.isFunction(data)) {
            dataType = success, success = data, data = undefined;
        } 
        if (!$.isFunction(success)) dataType = success, success = undefined
        return {
            url: url,
            data: data,
            success: success,
            dataType: dataType
        }
    }

    $.get = function( /* url, data, success, dataType */ ) {
        return $.ajax(parseArguments.apply(null, arguments))
    }

    $.post = function( /* url, data, success, dataType */ ) {
        var options = parseArguments.apply(null, arguments)
        options.type = 'POST'
        return $.ajax(options)
    }

    $.getJSON = function( /* url, data, success */ ) {
        var options = parseArguments.apply(null, arguments)
        options.dataType = 'json'
        return $.ajax(options)
    }

    var originalLoad = $.fn.load;

    $.fn.load = function(url, data, success) {
        if ("string" != typeof url && originalLoad) {
            return originalLoad.apply(this, arguments);
        }
        if (!this.length) return this
        var self = this,
            options = parseArguments(url, data, success),
            parts = options.url && options.url.split(/\s/),
            selector,
            callback = options.success
        if (parts && parts.length > 1) options.url = parts[0], selector = parts[1]

        if (options.data && typeof options.data === "object") {
            options.type = "POST";
        }
        options.success = function(response) {
            self.html(selector ?
                $('<div>').html(response.replace(rscript, "")).find(selector) : response)
            callback && callback.apply(self, arguments)
        }
        $.ajax(options)
        return this
    }

    $.param = Xhr.param;


    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {

        // dataTypeExpression is optional and defaults to "*"
        return function(dataTypeExpression, func) {

            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            var dataType,
                i = 0,
                dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

            if (jQuery.isFunction(func)) {

                // For each dataType in the dataTypeExpression
                while ((dataType = dataTypes[i++])) {

                    // Prepend if requested
                    if (dataType[0] === "+") {
                        dataType = dataType.slice(1) || "*";
                        (structure[dataType] = structure[dataType] || []).unshift(func);

                        // Otherwise append
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }

    var
        prefilters = {},
        transports = {},
        rnotwhite = (/\S+/g);

    $.ajaxPrefilter = addToPrefiltersOrTransports(prefilters);
    $.ajaxTransport = addToPrefiltersOrTransports(transports);
    $.ajaxSetup = function(target, settings) {
        langx.mixin(Xhr.defaultOptions,target,settings);
    };

    $.getScript = function( url, callback ) {
        return $.get( url, undefined, callback, "script" );
    };

    return $;

});

define('skylark-jquery/callbacks',[
    "./core"
], function($) {

    //     This module is borrow from zepto.callback.js
    //     (c) 2010-2014 Thomas Fuchs
    //     Zepto.js may be freely distributed under the MIT license.

    // Create a collection of callbacks to be fired in a sequence, with configurable behaviour
    // Option flags:
    //   - once: Callbacks fired at most one time.
    //   - memory: Remember the most recent context and arguments
    //   - stopOnFalse: Cease iterating over callback list
    //   - unique: Permit adding at most one instance of the same callback
    $.Callbacks = function(options) {
        options = $.extend({}, options)

        var memory, // Last fire value (for non-forgettable lists)
            fired, // Flag to know if list was already fired
            firing, // Flag to know if list is currently firing
            firingStart, // First callback to fire (used internally by add and fireWith)
            firingLength, // End of the loop when firing
            firingIndex, // Index of currently firing callback (modified by remove if needed)
            list = [], // Actual callback list
            stack = !options.once && [], // Stack of fire calls for repeatable lists
            fire = function(data) {
                memory = options.memory && data
                fired = true
                firingIndex = firingStart || 0
                firingStart = 0
                firingLength = list.length
                firing = true
                for (; list && firingIndex < firingLength; ++firingIndex) {
                    if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                        memory = false
                        break
                    }
                }
                firing = false
                if (list) {
                    if (stack) stack.length && fire(stack.shift())
                    else if (memory) list.length = 0
                    else Callbacks.disable()
                }
            },

            Callbacks = {
                add: function() {
                    if (list) {
                        var start = list.length,
                            add = function(args) {
                                $.each(args, function(_, arg) {
                                    if (typeof arg === "function") {
                                        if (!options.unique || !Callbacks.has(arg)) list.push(arg)
                                    } else if (arg && arg.length && typeof arg !== 'string') add(arg)
                                })
                            }
                        add(arguments)
                        if (firing) firingLength = list.length
                        else if (memory) {
                            firingStart = start
                            fire(memory)
                        }
                    }
                    return this
                },
                remove: function() {
                    if (list) {
                        $.each(arguments, function(_, arg) {
                            var index
                            while ((index = $.inArray(arg, list, index)) > -1) {
                                list.splice(index, 1)
                                // Handle firing indexes
                                if (firing) {
                                    if (index <= firingLength) --firingLength
                                    if (index <= firingIndex) --firingIndex
                                }
                            }
                        })
                    }
                    return this
                },
                has: function(fn) {
                    return !!(list && (fn ? $.inArray(fn, list) > -1 : list.length))
                },
                empty: function() {
                    firingLength = list.length = 0
                    return this
                },
                disable: function() {
                    list = stack = memory = undefined
                    return this
                },
                disabled: function() {
                    return !list
                },
                lock: function() {
                    stack = undefined;
                    if (!memory) Callbacks.disable()
                    return this
                },
                locked: function() {
                    return !stack
                },
                fireWith: function(context, args) {
                    if (list && (!fired || stack)) {
                        args = args || []
                        args = [context, args.slice ? args.slice() : args]
                        if (firing) stack.push(args)
                        else fire(args)
                    }
                    return this
                },
                fire: function() {
                    return Callbacks.fireWith(this, arguments)
                },
                fired: function() {
                    return !!fired
                }
            }

        return Callbacks
    };

    return $;

});

define('skylark-jquery/deferred',[
    "./core",
    "skylark-langx/langx"
], function($,langx) {

    $.Deferred = function() {
        var d = new langx.Deferred(),
            ret = {
                promise : function() {
                    return d.promise;
                }
            };

        ["resolve","resolveWith","reject","rejectWith","notify","then","done","fail","progress","always","state"].forEach(function(name){
            ret[name] = function() {
              var ret2 =   d[name].apply(d,arguments);
              if (ret2 == d) {
                ret2 = ret;
              }
              return ret2;
            }
        });

        return ret;
    };
    
    $.when = function(){
        var p = langx.Deferred.all(langx.makeArray(arguments)),
            originThen = p.then;
        p.then = function(onResolved,onRejected) {
            var handler = function(results) {
                //results = results.map(function(result){
                //    return [result];
                //});
                return onResolved && onResolved.apply(null,results);
            };
            return originThen.call(p,handler,onRejected);
        };
        return p;
    };

    return $;

});

define('skylark-jquery/queue',[
    "skylark-langx/langx",
    "./core",
    "./callbacks"
], function(langx, $) {

 // jQuery Data object
  var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
      rmultiDash = /([A-Z])/g,
      expando = "Sky" + ( '1.0' + Math.random() ).replace( /\D/g, ""),
      optionsCache = {},
      core_rnotwhite = /\S+/g,
      core_deletedIds = [],
      core_push = core_deletedIds.push;

// Convert String-formatted options into Object-formatted ones and store in cache
  function createOptions( options ) {
    var object = optionsCache[ options ] = {};
    $.each( options.match( core_rnotwhite ) || [], function( _, flag ) {
      object[ flag ] = true;
    });
    return object;
  }

  function isArraylike( obj ) {
    var length = obj.length,
        type = $.type( obj );

    if ( $.isWindow( obj ) ) {
      return false;
    }

    if ( obj.nodeType === 1 && length ) {
      return true;
    }

    return type === "array" || type !== "function" &&
        ( length === 0 ||
            typeof length === "number" && length > 0 && ( length - 1 ) in obj );
  }

  

  function Data() {
    // Support: Android < 4,
    // Old WebKit does not have Object.preventExtensions/freeze method,
    // return new empty object instead with no [[set]] accessor
    Object.defineProperty( this.cache = {}, 0, {
      get: function() {
        return {};
      }
    });

    this.expando = expando + Math.random();
  }

  Data.uid = 1;

  Data.accepts = function( owner ) {
    // Accepts only:
    //  - Node
    //    - Node.ELEMENT_NODE
    //    - Node.DOCUMENT_NODE
    //  - Object
    //    - Any
    return owner.nodeType ?
        owner.nodeType === 1 || owner.nodeType === 9 : true;
  };

  Data.prototype = {
    key: function( owner ) {
      // We can accept data for non-element nodes in modern browsers,
      // but we should not, see #8335.
      // Always return the key for a frozen object.
      if ( !Data.accepts( owner ) ) {
        return 0;
      }

      var descriptor = {},
      // Check if the owner object already has a cache key
          unlock = owner[ this.expando ];

      // If not, create one
      if ( !unlock ) {
        unlock = Data.uid++;

        // Secure it in a non-enumerable, non-writable property
        try {
          descriptor[ this.expando ] = { value: unlock };
          Object.defineProperties( owner, descriptor );

          // Support: Android < 4
          // Fallback to a less secure definition
        } catch ( e ) {
          descriptor[ this.expando ] = unlock;
          $.extend( owner, descriptor );
        }
      }

      // Ensure the cache object
      if ( !this.cache[ unlock ] ) {
        this.cache[ unlock ] = {};
      }

      return unlock;
    },
    set: function( owner, data, value ) {
      var prop,
      // There may be an unlock assigned to this node,
      // if there is no entry for this "owner", create one inline
      // and set the unlock as though an owner entry had always existed
          unlock = this.key( owner ),
          cache = this.cache[ unlock ];

      // Handle: [ owner, key, value ] args
      if ( typeof data === "string" ) {
        cache[ data ] = value;

        // Handle: [ owner, { properties } ] args
      } else {
        // Fresh assignments by object are shallow copied
        if ( $.isEmptyObject( cache ) ) {
          $.extend( this.cache[ unlock ], data );
          // Otherwise, copy the properties one-by-one to the cache object
        } else {
          for ( prop in data ) {
            cache[ prop ] = data[ prop ];
          }
        }
      }
      return cache;
    },
    get: function( owner, key ) {
      // Either a valid cache is found, or will be created.
      // New caches will be created and the unlock returned,
      // allowing direct access to the newly created
      // empty data object. A valid owner object must be provided.
      var cache = this.cache[ this.key( owner ) ];

      return key === undefined ?
          cache : cache[ key ];
    },
    access: function( owner, key, value ) {
      var stored;
      // In cases where either:
      //
      //   1. No key was specified
      //   2. A string key was specified, but no value provided
      //
      // Take the "read" path and allow the get method to determine
      // which value to return, respectively either:
      //
      //   1. The entire cache object
      //   2. The data stored at the key
      //
      if ( key === undefined ||
          ((key && typeof key === "string") && value === undefined) ) {

        stored = this.get( owner, key );

        return stored !== undefined ?
            stored : this.get( owner, $.camelCase(key) );
      }

      // [*]When the key is not a string, or both a key and value
      // are specified, set or extend (existing objects) with either:
      //
      //   1. An object of properties
      //   2. A key and value
      //
      this.set( owner, key, value );

      // Since the "set" path can have two possible entry points
      // return the expected data based on which path was taken[*]
      return value !== undefined ? value : key;
    },
    remove: function( owner, key ) {
      var i, name, camel,
          unlock = this.key( owner ),
          cache = this.cache[ unlock ];

      if ( key === undefined ) {
        this.cache[ unlock ] = {};

      } else {
        // Support array or space separated string of keys
        if ( $.isArray( key ) ) {
          // If "name" is an array of keys...
          // When data is initially created, via ("key", "val") signature,
          // keys will be converted to camelCase.
          // Since there is no way to tell _how_ a key was added, remove
          // both plain key and camelCase key. #12786
          // This will only penalize the array argument path.
          name = key.concat( key.map( $.camelCase ) );
        } else {
          camel = $.camelCase( key );
          // Try the string as a key before any manipulation
          if ( key in cache ) {
            name = [ key, camel ];
          } else {
            // If a key with the spaces exists, use it.
            // Otherwise, create an array by matching non-whitespace
            name = camel;
            name = name in cache ?
                [ name ] : ( name.match( core_rnotwhite ) || [] );
          }
        }

        i = name.length;
        while ( i-- ) {
          delete cache[ name[ i ] ];
        }
      }
    },
    hasData: function( owner ) {
      return !$.isEmptyObject(
          this.cache[ owner[ this.expando ] ] || {}
      );
    },
    discard: function( owner ) {
      if ( owner[ this.expando ] ) {
        delete this.cache[ owner[ this.expando ] ];
      }
    }
  };

  var data_priv = new Data();

  $.extend($, {
    queue: function( elem, type, data ) {
      var queue;

      if ( elem ) {
        type = ( type || "fx" ) + "queue";
        queue = data_priv.get( elem, type );

        // Speed up dequeue by getting out quickly if this is just a lookup
        if ( data ) {
          if ( !queue || $.isArray( data ) ) {
            queue = data_priv.access( elem, type, $.makeArray(data) );
          } else {
            queue.push( data );
          }
        }
        return queue || [];
      }
    },

    dequeue: function( elem, type ) {
      type = type || "fx";

      var queue = $.queue( elem, type ),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = $._queueHooks( elem, type ),
          next = function() {
            $.dequeue( elem, type );
          };

      // If the fx queue is dequeued, always remove the progress sentinel
      if ( fn === "inprogress" ) {
        fn = queue.shift();
        startLength--;
      }

      if ( fn ) {

        // Add a progress sentinel to prevent the fx queue from being
        // automatically dequeued
        if ( type === "fx" ) {
          queue.unshift( "inprogress" );
        }

        // clear up the last queue stop function
        delete hooks.stop;
        fn.call( elem, next, hooks );
      }

      if ( !startLength && hooks ) {
        hooks.empty.fire();
      }
    },

    // not intended for public consumption - generates a queueHooks object, or returns the current one
    _queueHooks: function( elem, type ) {
      var key = type + "queueHooks";
      return data_priv.get( elem, key ) || data_priv.access( elem, key, {
        empty: $.Callbacks("once memory").add(function() {
          data_priv.remove( elem, [ type + "queue", key ] );
        })
      });
    },

    // array operations
    makeArray: function( arr, results ) {
      var ret = results || [];

      if ( arr != null ) {
        if ( isArraylike( Object(arr) ) ) {
          $.merge( ret,
              typeof arr === "string" ?
                  [ arr ] : arr
          );
        } else {
          core_push.call( ret, arr );
        }
      }

      return ret;
    },
    merge: function( first, second ) {
      var l = second.length,
          i = first.length,
          j = 0;

      if ( typeof l === "number" ) {
        for ( ; j < l; j++ ) {
          first[ i++ ] = second[ j ];
        }
      } else {
        while ( second[j] !== undefined ) {
          first[ i++ ] = second[ j++ ];
        }
      }

      first.length = i;

      return first;
    }
  });

  $.extend($.fn, {
    queue: function( type, data ) {
      var setter = 2;

      if ( typeof type !== "string" ) {
        data = type;
        type = "fx";
        setter--;
      }

      if ( arguments.length < setter ) {
        return $.queue( this[0], type );
      }

      return data === undefined ?
          this :
          this.each(function() {
            var queue = $.queue( this, type, data );

            // ensure a hooks for this queue
            $._queueHooks( this, type );

            if ( type === "fx" && queue[0] !== "inprogress" ) {
              $.dequeue( this, type );
            }
          });
    },
    dequeue: function( type ) {
      return this.each(function() {
        $.dequeue( this, type );
      });
    },
    // Based off of the plugin by Clint Helfers, with permission.
    // http://blindsignals.com/index.php/2009/07/jquery-delay/
    delay: function( time, type ) {
      time = $.fx ? $.fx.speeds[ time ] || time : time;
      type = type || "fx";

      return this.queue( type, function( next, hooks ) {
        var timeout = setTimeout( next, time );
        hooks.stop = function() {
          clearTimeout( timeout );
        };
      });
    },
    clearQueue: function( type ) {
      return this.queue( type || "fx", [] );
    },
    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function( type, obj ) {
      var tmp,
          count = 1,
          defer = $.Deferred(),
          elements = this,
          i = this.length,
          resolve = function() {
            if ( !( --count ) ) {
              defer.resolveWith( elements, [ elements ] );
            }
          };

      if ( typeof type !== "string" ) {
        obj = type;
        type = undefined;
      }
      type = type || "fx";

      while( i-- ) {
        tmp = data_priv.get( elements[ i ], type + "queueHooks" );
        if ( tmp && tmp.empty ) {
          count++;
          tmp.empty.add( resolve );
        }
      }
      resolve();
      return defer.promise( obj );
    }
  });

  return $;

});

define('skylark-domx-plugins-base/plugins',[
    "skylark-langx-ns"
], function(skylark) {
    "use strict";

    var pluginKlasses = {},
        shortcuts = {};


    return  skylark.attach("domx.plugins",{
        pluginKlasses,
        shortcuts
    });
});
define('skylark-langx-events/Emitter',[
  "skylark-langx-types",
  "skylark-langx-objects",
  "skylark-langx-arrays",
  "skylark-langx-klass",
  "./events",
  "./event",
  "./listener"
],function(types,objects,arrays,klass,events,Event,Listener){
    var slice = Array.prototype.slice,
        compact = arrays.compact,
        isDefined = types.isDefined,
        isPlainObject = types.isPlainObject,
        isFunction = types.isFunction,
        isString = types.isString,
        isEmptyObject = types.isEmptyObject,
        mixin = objects.mixin,
        safeMixin = objects.safeMixin;

    function parse(event) {
        var segs = ("" + event).split(".");
        return {
            name: segs[0],
            ns: segs.slice(1).join(" ")
        };
    }

    
    var queues  = new Map();


    var Emitter = Listener.inherit({
        _prepareArgs : function(e,args) {
            if (isDefined(args)) {
                args = [e].concat(args);
            } else {
                args = [e];
            }
            return args;
        },

        on: function(events, selector, data, callback, ctx, /*used internally*/ one) {
            var self = this,
                _hub = this._hub || (this._hub = {});

            if (isPlainObject(events)) {
                ctx = callback;
                each(events, function(type, fn) {
                    self.on(type, selector, data, fn, ctx, one);
                });
                return this;
            }

            if (!isString(selector) && !isFunction(callback)) {
                ctx = callback;
                callback = data;
                data = selector;
                selector = undefined;
            }

            if (isFunction(data)) {
                ctx = callback;
                callback = data;
                data = null;
            }

            if (!callback ) {
                throw new Error("No callback function");
            } else if (!isFunction(callback)) {
                throw new Error("The callback  is not afunction");
            }

            if (isString(events)) {
                events = events.split(/\s/)
            }

            events.forEach(function(event) {
                var parsed = parse(event),
                    name = parsed.name,
                    ns = parsed.ns;

                (_hub[name] || (_hub[name] = [])).push({
                    fn: callback,
                    selector: selector,
                    data: data,
                    ctx: ctx,
                    ns : ns,
                    one: one
                });
            });

            return this;
        },

        one: function(events, selector, data, callback, ctx) {
            return this.on(events, selector, data, callback, ctx, 1);
        },

        emit: function(e /*,argument list*/ ) {
            if (!this._hub) {
                return this;
            }

            var self = this;

            if (isString(e)) {
                e = new Event(e); //new CustomEvent(e);
            }

            Object.defineProperty(e,"target",{
                value : this
            });

            var args = slice.call(arguments, 1);

            args = this._prepareArgs(e,args);

            [e.type || e.name, "all"].forEach(function(eventName) {
                var parsed = parse(eventName),
                    name = parsed.name,
                    ns = parsed.ns;

                var listeners = self._hub[name];
                if (!listeners) {
                    return;
                }

                var len = listeners.length,
                    reCompact = false;

                for (var i = 0; i < len; i++) {
                    if (e.isImmediatePropagationStopped && e.isImmediatePropagationStopped()) {
                        return this;
                    }
                    var listener = listeners[i];
                    if (ns && (!listener.ns ||  !listener.ns.startsWith(ns))) {
                        continue;
                    }

                    if (listener.data) {
                        e.data = mixin({}, listener.data, e.data);
                    }
                    if (args.length == 2 && isPlainObject(args[1])) {
                        e.data = e.data || {};
                        mixin(e.data,args[1]);
                    }

                    listener.fn.apply(listener.ctx, args);
                    if (listener.one) {
                        listeners[i] = null;
                        reCompact = true;
                    }
                }

                if (reCompact) {
                    self._hub[eventName] = compact(listeners);
                }

            });
            return this;
        },

        queueEmit : function (event) {
            const type = event.type || event;
            let map = queues.get(this);
            if (!map) {
                map = new Map();
                queues.set(this, map);
            }
            const oldTimeout = map.get(type);
            map.delete(type);
            window.clearTimeout(oldTimeout);
            const timeout = window.setTimeout(() => {
                if (map.size === 0) {
                    map = null;
                    queues.delete(this);
                }
                this.trigger(event);
            }, 0);
            map.set(type, timeout);
        },

        listened: function(event) {
            var evtArr = ((this._hub || (this._events = {}))[event] || []);
            return evtArr.length > 0;
        },

        off: function(events, callback) {
            if (!events) {
              this._hub = null;
              return;
            }
            var _hub = this._hub || (this._hub = {});
            if (isString(events)) {
                events = events.split(/\s/)
            }

            events.forEach(function(event) {
                var parsed = parse(event),
                    name = parsed.name,
                    ns = parsed.ns;

                var evts = _hub[name];

                if (evts) {
                    var liveEvents = [];

                    if (callback || ns) {
                        for (var i = 0, len = evts.length; i < len; i++) {
                            
                            if (callback && evts[i].fn !== callback && evts[i].fn._ !== callback) {
                                liveEvents.push(evts[i]);
                                continue;
                            } 

                            if (ns && (!evts[i].ns || evts[i].ns.indexOf(ns)!=0)) {
                                liveEvents.push(evts[i]);
                                continue;
                            }
                        }
                    }

                    if (liveEvents.length) {
                        _hub[name] = liveEvents;
                    } else {
                        delete _hub[name];
                    }

                }
            });

            return this;
        },

        trigger  : function() {
            return this.emit.apply(this,arguments);
        },

        queueTrigger : function (event) {
            return this.queueEmit.apply(this,arguments);
        }

    });


    return events.Emitter = Emitter;

});
define('skylark-domx-animates/animate',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "skylark-domx-eventer",
    "./animates"
], function(langx, styler, eventer,animates) {


    function animate(elm,keyframes/*className*/,options) {
        if (langx.isString(keyframes)) {
            let className = keyframes;
            if (animates.animateBaseClass) {
              className = animates.animateBaseClass + " " + className;
            }
            styler.addClass(elm,className);
            eventer.one(elm,animates.animationEnd, function() {
                styler.removeClass(elm,className);
            });
            return this;
        } else {
            return elm.animate(keyframes,options);
        }

    }
    
    return animates.animate = animate;
 });
define('skylark-domx-animates/main',[
	"./animates",
 	"skylark-domx-velm",
	"skylark-domx-query",
   "./animation",
    "./animate"
],function(animates,velm,$){
    // from ./aanimates
    velm.delegate([
        "animate"
    ], animates);

    $.fn.animate =  $.wraps.wrapper_every_act(animates.animate, animates);

	return animates;
});
define('skylark-domx-animates', ['skylark-domx-animates/main'], function (main) { return main; });

define('skylark-domx/animates',[
    "skylark-domx-animates"
], function( animates) {
    return animates;
});
define('skylark-domx/browser',[
    "skylark-domx-browser"
], function(browser) {
    "use strict";

    return browser;
});

define('skylark-domx-css/css',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder"
], function(skylark, langx, noder) {
    "use strict";

    var head = document.getElementsByTagName("head")[0],
        count = 0,
        sheetsByUrl = {},
        sheetsById = {},
        defaultSheetId = _createStyleSheet(),
        defaultSheet = sheetsById[defaultSheetId],
        rulesPropName = ("cssRules" in defaultSheet) ? "cssRules" : "rules",
        insertRuleFunc,
        deleteRuleFunc = defaultSheet.deleteRule || defaultSheet.removeRule;

    if (defaultSheet.insertRule) {
        var _insertRule = defaultSheet.insertRule;
        insertRuleFunc = function(selector, css, index) {
            _insertRule.call(this, selector + "{" + css + "}", index);
        };
    } else {
        insertRuleFunc = defaultSheet.addRule;
    }

    function normalizeSelector(selectorText) {
        var selector = [],
            last, len;
        last = defaultSheet[rulesPropName].length;
        insertRuleFunc.call(defaultSheet, selectorText, ';');
        len = defaultSheet[rulesPropName].length;
        for (var i = len - 1; i >= last; i--) {
            selector.push(_sheet[_rules][i].selectorText);
            deleteRuleFunc.call(defaultSheet, i);
        }
        return selector.reverse().join(', ');
    }

    /*
     * create a stylesheet element.
     * @param {Boolean} external
     * @param {Object} options
     * @param {String} [options.media = null]
     */
    function _createStyleSheet(external,options ) {
        var node,
            props = {
                type : "text/css"
            },
            id = (count++);

        options = options || {};
        if (options.media) {
            props.media = options.media;
        }

        if (external) {
            node = noder.create("link",langx.mixin(props,{
                rel  : "stylesheet",
                async : false
            }));
        } else {
            node = noder.createElement("style",props);
        }

        noder.append(head,node);
        sheetsById[id] = {
            id : id,
            node :node
        };

        return id;
    }

    function createStyleSheet(css,options) {
        if (!options) {
            options = {};
        }
        var sheetId = _createStyleSheet(false,options);
        if (css) {
            addSheetRules(sheetId,css);
        }

        return sheetId;
    }

    function loadStyleSheet(url, options,loadedCallback, errorCallback) {
        if (langx.isFunction(options)) {
            errorCallback = loadedCallback;
            loadedCallback = options;
            options = {};
        }
        var sheet = sheetsByUrl[url];
        if (!sheet) {
            var sheetId = _createStyleSheet(true,options);

            sheet = sheetsByUrl[url] = sheetsById[sheetId];
            langx.mixin(sheet,{
                state: 0, //0:unload,1:loaded,-1:loaderror
                url : url,
                deferred : new langx.Deferred()
            });

            var node = sheet.node;

            startTime = new Date().getTime();

            node.onload = function() {
                sheet.state = 1;
                sheet.deferred.resolve(sheet.id);
            },
            node.onerror = function(e) {
                sheet.state = -1;
                sheet.deferred.reject(e);
            };

            node.href = sheet.url;
        }
        if (loadedCallback || errorCallback) {
            sheet.deferred.promise.then(loadedCallback,errorCallback);
        }
        return sheet.id;
    }

    function deleteSheetRule(sheetId, rule) {
        var sheet = sheetsById[sheetId];
        if (langx.isNumber(rule)) {
            deleteRuleFunc.call(sheet, rule);
        } else {
            langx.each(sheet[rulesPropName], function(i, _rule) {
                if (rule === _rule) {
                    deleteRuleFunc.call(sheet, i);
                    return false;
                }
            });
        }
        return this;
    }

    function deleteRule(rule) {
        deleteSheetRule(defaultSheetId, rule);
        return this;
    }

    function removeStyleSheet(sheetId) {
        if (sheetId === defaultSheetId) {
            throw new Error("The default stylesheet can not be deleted");
        }
        var sheet = sheetsById[sheetId];
        delete sheetsById[sheetId];

        noder.remove(sheet.node);
        return this;
    }

    /*
     * insert a rule to the default stylesheet.
     * @param {String} selector
     * @param {String} css
     * @param {Number} index 
     */
    function insertRule(selector, css, index) {
        return this.insertSheetRule(defaultSheetId, selector, css, index);
    }

    /*
     * Add rules to the default stylesheet.
     * @param {Object} rules
     */
    function addRules(rules) {
        return this.addRules(defaultSheetId,rules);
    }

    /*
     * insert a rule to the stylesheet specified by sheetId.
     * @param {Number} sheetId  
     * @param {String} selector
     * @param {String} css
     * @param {Number} index 
     */
    function insertSheetRule(sheetId, selector, css, index) {
        if (!selector || !css) {
            return -1;
        }

        var sheet = sheetsById[sheetId];
        index = index || sheet[rulesPropName].length;

        return insertRuleFunc.call(sheet, selector, css, index);
    }

    /*
     * Add  rules to stylesheet.
     * @param {Number} sheetId  
     * @param {Object|String} rules
     * @return this
     * @example insertSheetRules(sheetId,{
     * 
     * });
     */
    function addSheetRules(sheetId,rules) {
        var sheet = sheetsById[sheetId],
            css;
        if (langx.isString(rules)) {
            css = rules;
        } else {
            css = toString(rules);
        }

        noder.append(sheet.node,noder.createTextNode(css));
        
        return this;
    }

    function isAtRule(str) {
        return str.startsWith("@");
    }

    function toString(json){
        var adjust = function(parentName,name,depth) {
            if (parentName) {
                if (isAtRule(parentName)) {
                    depth += 1;
                } else {
                    name =  parentName + " " + name;
                }                
            }
            return {
                name : name,
                depth : depth
            }
        };

        var strNode = function (name, values, depth) {
            var str = "",
                atFlg = isAtRule(name);


            if (isAtRule(name)) {
                // at rule
                if (langx.isString(values)) {
                    // an at rule without block
                    // ex: (1) @charset 'utf8';
                    str = css.SPACE.repeat(depth) + name.trim() + " \"" + values.trim() + " \";\n";
                } else {
                    // an at rule with block, ex :
                    //  @media 'screen' {
                    //  }
                    str += css.SPACE.repeat(depth) + name.trim() + " {\n";
                    str += strNode("",values,depth+1);
                    str += css.SPACE.repeat(depth) + " }\n";
                }
            } else {
                // a selector or a property
                if (langx.isString(values)) {
                    // a css property 
                    // ex : (1) font-color : red;
                    str = css.SPACE.repeat(depth) + name.trim() ;
                    if (atFlg) {
                        str = str +  " \"" + values.trim() + " \";\n";
                    } else {
                        str = str + ': ' + values.trim() + ";\n";
                    }

                } else {
                    // a selector rule 
                    // ex : (1) .class1 : {
                    //            font-color : red;
                    //          }
                    if (langx.isArray(values)) {
                        // array for ordering
                        for (var n =0; n<values.length; n ++) {
                           str +=  strNode(name,values[n],depth);
                        }
                    } else {
                        // plain object

                        if (name) {
                            str += css.SPACE.repeat(depth) + name.trim() + " {\n";

                            for (var n in values) {
                                var value =values[n];
                                if (langx.isString(value)) {
                                    // css property
                                    str += strNode(n,value,depth+1)
                                }
                            }

                            str += css.SPACE.repeat(depth) + "}\n";
                        }

                        for (var n in values) {
                            var value =values[n];
                            if (!langx.isString(value)) {
                                var adjusted = adjust(name,n,depth);
                                str +=  strNode(adjusted.name,value,adjusted.depth);
                            } 
                        }

                    }
                }
            }   

            return str;
        };


        return strNode("",json,0);
    }
 

    function css() {
        return css;
    }

    langx.mixin(css, {
        SPACE : "\t",

        addRules : addRules,

        addSheetRules : addSheetRules,

        createStyleSheet: createStyleSheet,

        deleteSheetRule : deleteSheetRule,

        deleteRule : deleteRule,

        insertRule : insertRule,

        insertSheetRule : insertSheetRule,

        loadStyleSheet : loadStyleSheet,

        removeStyleSheet : removeStyleSheet,

        toString : toString
    });

    return skylark.attach("domx.css", css);
});

define('skylark-domx-css/main',[
	"./css"
],function(css){
	return css;
});
define('skylark-domx-css', ['skylark-domx-css/main'], function (main) { return main; });

define('skylark-domx/css',[
    "skylark-domx-css"
], function( css) {
    "use strict";

     return css;
});

define('skylark-domx/data',[
    "skylark-domx-data"
], function( data) {
 
    return data;
});
define('skylark-domx/eventer',[
    "skylark-domx-eventer"
], function( eventer) {
 
    return eventer;
});
define('skylark-domx/finder',[
    "skylark-domx-finder"
], function( finder) {

    return finder;
});
define('skylark-domx/fx',[
    "skylark-domx-fx"
], function( fx) {
    return fx;
});
define('skylark-domx/geom',[
    "skylark-domx-geom"
], function( geom) {

    return geom;
});
define('skylark-domx-iframes/iframes',[
	"skylark-langx-ns"
],function(skylark){
	return skylark.attach("domx.iframes");
});
define('skylark-domx-iframes/create',[
  "skylark-domx-noder",
  "./iframes"
],function(noder,iframes){
  'use strict';

  function create(options,parentElm) {
  	  options = options || {
  	  };

  	  let props = {},
  	  	  attrs = {};

  	  if (options.id) {
  	  	props.id = options.id;
  	  };

  	  if (options.url) {
  	  	props.src = options.url;
  	  };

  	  if (options.style) {
  	  	props.style = options.style;
  	  }

  	  if (options.onload) {
  	  	props.onload = options.onload;
  	  }

  	  if (options.onerror) {
  	  	props.onload = options.onerror;
  	  }

  	  if (options.className) {
  	  	props.className = options.className;
  	  }

  	  if (options.sandbox) {
  	  	attrs.sandbox = options.sandbox;
  	  }

  	  if (options.frameBorder) {
  	  	attrs.frameBorder = options.frameBorder;  	  	
  	  }

  	  if (options.name) {
  	  	attrs.name = options.name;
  	  }

  	  /*
      // Basic mode
      // This adds the runner iframe to the page. It's only run once.
      //if (!$live.find('iframe').length) {
        iframe = noder.create("iframe",{
          ///iframe.src = jsbin.runner;
          src : this.options.runnerUrl
        },{
          "class" : "stretch",
          "sandbox", "allow-modals allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts",
          "frameBorder": '0',
          "name", "<proxy>",
        },this._elm);

        try {
          ///iframe.contentWindow.name = '/' + jsbin.state.code + '/' + jsbin.state.revision;
          iframe.contentWindow.name  = this.options.runnerName;
        } catch (e) {
          // ^- this shouldn't really fail, but if we're honest, it's a fucking mystery as to why it even works.
          // problem is: if this throws (because iframe.contentWindow is undefined), then the execution exits
          // and `var renderLivePreview` is set to undefined. The knock on effect is that the calls to renderLivePreview
          // then fail, and jsbin doesn't boot up. Tears all round, so we catch.
        }
      //}

      iframe.onload = () => {
        if (window.postMessage) {
          // setup postMessage listening to the runner
          $window.on('message', (event) => {
            this.handleMessage(event.originalEvent)
          });
          this.setup(iframe);
          this._inited.resolve();
        }
      };

      iframe.onerror = err => {
        this._inited.reject(err);
      };

      */

      let iframe = noder.create("iframe",props,attrs,parentElm);

      if (options.contentWindowName) {
      	iframe.contentWindow.name = options.contentWindowName;
      }

      return iframe;
  }

  return iframes.create = create;
});
define('skylark-domx-iframes/hook-sizing',[
  "skylark-domx-eventer",
  "./iframes"
],function(eventer,iframes){
  'use strict';

  function hookSizing(iframe) {
    var onmessage = function (event) {
      if (!event) { event = window.event; }
      ///TODO : how check message source
      // * 1 to coerse to number, and + 2 to compensate for border
      iframe.style.height = (event.data.height * 1 + 2) + 'px';
    };

    eventer.on(window,'message', onmessage);
  }

  return iframes.hookSizing = hookSizing;

});
define('skylark-domx-iframes/load-real',[
  "skylark-domx-noder",
  "skylark-domx-data",
  "./iframes",
  "./hook-sizing"
],function(noder,datax,iframes,hookSizing){

  function loadReal(iframe,options) {
    options = options || {};
    var clone = noder.clone(iframe);
    var url = options.url;
    if (!url) {
      url = datax.attr(clone,options.urlAttrName || 'data-url');
    }
    url = url.split('&')[0];
    datax.prop(clone,"src",url);
    datax.prop(clone,"_src",url); // support for google slide embed
    noder.replace(clone,ifame);
    ///hookSizing(clone);
  }

  return iframes.loadReal = loadReal;  
});
define('skylark-domx-iframes/lazy-load',[
	"skylark-domx-eventer",
	"skylark-domx-data",
	"skylark-domx-geom",
	"./iframes",
	"./load-real"
],function(eventer,datax,geom,iframes,loadReal){
	var pending;


  	function check() {
	    var i = 0;
	    var todo = [];
	    for (i = 0; i < pending.length; i++) {
	      if (geom.inview(pending[i], 400)) {
	        todo.unshift({ iframe: pending[i], i: i });
	      }
	    }

	    for (i = todo.length -1 ; i >=0 ; i--) {
	      pending.splice(todo[i].i, 1);
	      loadReal(todo[i].iframe);
	    }
  	}

	function init() {
		if (pending) {
			return
		}

		pending = [];

		eventer.on(window,"scroll",function(){
			check();
		});
	}

	function lazyLoad(iframe,options) {
		init();

		options = options || {};
	
      	///iframe.setAttribute('data-url', url);
      	///iframe.src = 'https://jsbin.com/embed-holding';
      	if (options.url) {
      		datax.attr(iframe,(options.urlAttrName || "data-url"),options.url)
      	}

      	if (options.holdingUrl) {
      		datax.prop(iframe,"src",options.holdingUrl)      		
      	}

		pending.push(iframe);
	}

	return iframes.lazyLoad = lazyLoad
});
define('skylark-domx-iframes/replace',[
  "skylark-langx-urls/get-query",
  "skylark-domx-noder",
  "skylark-domx-geom",
  "skylark-domx-styler",
  "./iframes",
  "./create",
  "./load-real",
  "./lazy-load"
],function(getQuery,noder,geom,styler,iframes,create,loadReal,lazyLoad){
  'use strict';
  
  function replace(link,options) {
    options = options || {};

    /*
    var iframe = noder.createElement('iframe',{
      "className" : link.className, // inherit all the classes from the link
      "id" : link.id, // also inherit, giving more style control to the user
      "style" : { "border" : '1px solid #aaa'}
    });
    */

    var ifarme =create({
      "className" : link.className, // inherit all the classes from the link
      "id" : link.id, // also inherit, giving more style control to the user
      "style" : { 
        "border" : '1px solid #aaa'
      }
    });
    ///var url = link.href.replace(/edit/, 'embed');
    var url = options.url || link.href,
        size = options.size || getQuery(link.search),
        holdingUrl = options.holdingUrl;

    styler.css(iframe,"width", size.width || '100%');
    styler.css(iframe,"minHeight", size.height || '300px');
    if (size.height) {
      styler.css(iframe,"maxHeight", size.height);
    }

    // track when it comes into view and reload
    if (geom.inview(link, 100)) {
      // the iframe is full view, let's render it
      ///iframe.src = url.split('&')[0];
      ///iframe._src = url.split('&')[0]; // support for google slide embed
      ///hookMessaging(iframe);
      loadReal(iframe,{url})
    } else {
      ///iframe.setAttribute('data-url', url);
      ///iframe.src = 'https://jsbin.com/embed-holding';
      ///pending.push(iframe);
      lazyLoad(iframe,{
        url,
        holdingUrl
      });

    }

    noder.replace(iframe, link);
  }

  return iframes.replace = replace;
});
define('skylark-domx-iframes/main',[
	"./iframes",
	"./create",
	"./lazy-load",
	"./load-real",
	"./replace"
],function(){
	
});
define('skylark-domx-iframes', ['skylark-domx-iframes/main'], function (main) { return main; });

define('skylark-domx/iframes',[
    "skylark-domx-iframes"
], function( iframes) {
    return iframes;
});
define('skylark-domx-lists/lists',[
	"skylark-langx-ns",
	"skylark-domx-query",
	"skylark-domx-data",
	"skylark-domx-geom",
	"skylark-domx-finder",
	"skylark-domx-noder",
	"skylark-domx-styler"
],function(skylark){
	return skylark.attach("domx.lists");
});
define('skylark-domx-lists/multitier',[
	"skylark-langx",
	"skylark-domx-query",
	"./lists"
],function(langx,$,lists){
  'use strict'

	function multitier(elm,options) {
		options = langx.mixin({

			classes : {
				active : "active",
				collapse : "collapse",
				in : "in",
			},

			selectors : {
				item : "li",                   // ".list-group-item"
				sublist : "ul",  // "> .list-group"
				hasSublist : ":has(ul)",
				handler : " > a"
			},


			mode   : "",  // "tree" or "accordion" or "popover"

			levels : 2,

			togglable : false,
			multiExpand : false,

			/*
			show : function($el) {
				$el.show();
			},

			hide : function($el) {
				//$el.hide();
				$el.add
			},

			toggle : function($el) {
				$el.toggle();
			}
			*/
		},options,true);

    var itemSelector = options.selectors.item,
        $items = $(itemSelector,elm),

        activeClass = options.classes.active,
        activeSelector = "." + activeClass,

		multitierMode = options.mode,

        sublistSelector = options.selectors.sublist,  
        togglable = options.togglable,   
        multiExpand = options.multiExpand,
        handlerSelector = options.selectors.handler,

        collapseClass = options.classes.collapse,
        inClass = options.classes.in,
        inSelector = "." + inClass,

        show = options.show || function($el) {
        	$el.addClass(inClass);
        },
        hide = options.hide || function($el) {
        	$el.addClass(collapseClass).removeClass(inClass);

        },
        toggle = options.toggle || function($el) {
			if ($el.hasClass(inClass)) {
				hide($el);
			} else {
				show($el);
			}
        };

     $items.find(handlerSelector).on("click.multitier", function(e) {
          e.preventDefault();

          let $children,
          	  $clickedItem =  $(this).closest(itemSelector);

          if (!multiExpand) {
              ///langx.scall($(this).closest(itemSelector).siblings().removeClass("active").children(sublistSelector+".in").plugin("domx.toggles.collapse"),"hide");
              //$clildren = $(this).closest(itemSelector).siblings().removeClass(activeClass).children(sublistSelector+"."+options.classes.in);
              $children = $clickedItem.siblings().removeClass(activeClass).children(sublistSelector);
              if ($children) {
	              hide($children);
              }
          }
          //$(this).closest(itemSelector).toggleClass(activeClass).children(sublistSelector).plugin("domx.toggles.collapse").toggle();
          let isActiveItem = $clickedItem.hasClass(activeClass);
          if (!isActiveItem || togglable) {
	          $children = $clickedItem.children(options.selectors.sublist);
	          if (isActiveItem) {
				$clickedItem.removeClass(activeClass);
				hide($children)  	
	          } else {
				$clickedItem.addClass(activeClass);
				show($children)  	
	          }

          }
      });

      hide($items.has(sublistSelector).children(sublistSelector));

      show($items.filter(activeSelector).has(sublistSelector).children(sublistSelector))


	}

	return lists.multitier = multitier
});
define('skylark-domx-lists/main',[
	"./lists",
	"./multitier"
],function(lists){
	return lists;
});
define('skylark-domx-lists', ['skylark-domx-lists/main'], function (main) { return main; });

define('skylark-domx/lists',[
    "skylark-domx-lists"
], function( lists) {

    return lists;
});
define('skylark-domx/noder',[
    "skylark-domx-noder"
], function( noder) {

    return noder;
});
define('skylark-domx/styler',[
    "skylark-domx-styler"
], function( styler) {

    return styler;
});
define('skylark-domx/query',[
    "skylark-domx-query",
    "./data",
    "./eventer",
    "./fx",
    "./geom",
    "./styler"
], function( query) {

    return query;

});
define('skylark-domx-transforms/transforms',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-data",
    "skylark-domx-styler"
], function(skylark,langx,browser,datax,styler) {
  var css3Transform = browser.normalizeCssProperty("transform");

  function getMatrix(radian, x, y) {
    var Cos = Math.cos(radian), Sin = Math.sin(radian);
    return {
      M11: Cos * x, 
      M12: -Sin * y,
      M21: Sin * x, 
      M22: Cos * y
    };
  }

  function getZoom(scale, zoom) {
      return scale > 0 && scale > -zoom ? zoom :
        scale < 0 && scale < zoom ? -zoom : 0;
  }

  function change(el,d) {
      var matrix = getMatrix(d.radian, d.y, d.x);
      styler.css(el,css3Transform, "matrix("
        + matrix.M11.toFixed(16) + "," + matrix.M21.toFixed(16) + ","
        + matrix.M12.toFixed(16) + "," + matrix.M22.toFixed(16) + ", 0, 0)"
      );      
  }

  function transformData(el,d) {
    if (d) {
      datax.data(el,"transform",d);
    } else {
      d = datax.data(el,"transform") || {};
      d.radian = d.radian || 0;
      d.x = d.x || 1;
      d.y = d.y || 1;
      d.zoom = d.zoom || 1;
      return d;     
    }
  }

  var calcs = {
    //Vertical flip
    vertical : function (d) {
        d.radian = Math.PI - d.radian; 
        d.y *= -1;
    },

   //Horizontal flip
    horizontal : function (d) {
        d.radian = Math.PI - d.radian; 
        d.x *= -1;
    },

    //Rotate according to angle
    rotate : function (d,degress) {
        d.radian = degress * Math.PI / 180;; 
    },

    //Turn left 90 degrees
    left : function (d) {
        d.radian -= Math.PI / 2; 
    },

    //Turn right 90 degrees
    right : function (d) {
        d.radian += Math.PI / 2; 
    },
 
    //zoom
    scale: function (d,zoom) {
        var hZoom = getZoom(d.y, zoom), vZoom = getZoom(d.x, zoom);
        if (hZoom && vZoom) {
          d.y += hZoom; 
          d.x += vZoom;
        }
    }, 

    //zoom in
    zoomin: function (d) { 
      calcs.scale(d,0.1); 
    },
    
    //zoom out
    zoomout: function (d) { 
      calcs.scale(d,-0.1); 
    }

  };
  
  
  function _createApiMethod(calcFunc) {
    return function() {
      var args = langx.makeArray(arguments),
        el = args.shift(),
          d = transformData(el);
        args.unshift(d);
        calcFunc.apply(this,args)
        change(el,d);
        transformData(el,d);
    }
  }
  

  function matrix(el) {
    var appliedTransforms = '';
    do {
      var transform = styler.css(el, 'transform');

      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */
    } while (el = el.parentElement);

    if (window.DOMMatrix) {
      return new DOMMatrix(appliedTransforms);
    } else if (window.WebKitCSSMatrix) {
      return new WebKitCSSMatrix(appliedTransforms);
    } else if (window.CSSMatrix) {
      return new CSSMatrix(appliedTransforms);
    }
  }
   
  function transforms() {
    return transforms;
  }

  ["vertical","horizontal","rotate","left","right","scale","zoom","zoomin","zoomout"].forEach(function(name){
    transforms[name] = _createApiMethod(calcs[name]);
  });

  langx.mixin(transforms, {
    reset : function(el) {
      var d = {
        x : 1,
        y : 1,
        radian : 0,
      }
      change(el,d);
      transformData(el,d);
    },
    matrix
  });


  return skylark.attach("domx.transforms", transforms);
});

define('skylark-domx-transforms/main',[
	"./transforms"
],function(transforms){
	return transforms;
});
define('skylark-domx-transforms', ['skylark-domx-transforms/main'], function (main) { return main; });

define('skylark-domx/transforms',[
    "skylark-domx-transforms"
], function(transforms) {
  return transforms;
});

define('skylark-domx/transits',[
    "skylark-domx-transits"
], function( transits) {
    return transits;
});
define('skylark-domx/velm',[
    "skylark-domx-velm",
    "./data",
    "./eventer",
    "./fx",
    "./geom",
    "./styler"
], function( velm) {
     return velm;
});
define('skylark-domx/main',[
    "./animates",
    "./browser",
    "./css",
    "./data",
    "./eventer",
    "./finder",
    "./fx",
    "./geom",
    "./iframes",
    "./lists",
    "./noder",
    "./query",
    "./styler",
    "./transforms",
    "./transits",
    "./velm"
], function(animates,browser,css,data,eventer,finder,fx,geom,iframes,lists,noder,query,styler,transforms,transits,velm) {
    return {
        animates,
        browser,
        css,
        data,
        eventer,
        finder,
        geom,
        lists,
        noder,
        iframes,
        query,
        styler,
        transforms,
        transits,
        velm
    };
})
;
define('skylark-domx', ['skylark-domx/main'], function (main) { return main; });

define('skylark-domx-plugins-base/plugin',[
    "skylark-langx-ns",
    "skylark-langx-types",
    "skylark-langx-objects",
    "skylark-langx-funcs",
    "skylark-langx-events/Emitter",
    "skylark-domx-noder",
    "skylark-domx-data",
    "skylark-domx-eventer",
    "skylark-domx-finder",
    "skylark-domx-geom",
    "skylark-domx-styler",
    "skylark-domx-fx",
    "skylark-domx-query",
    "skylark-domx-velm",
    "skylark-domx",
    "./plugins"
], function(
    skylark,
    types,
    objects,
    funcs,
    Emitter, 
    noder, 
    datax, 
    eventer, 
    finder, 
    geom, 
    styler, 
    fx, 
    $, 
    elmx,
    domx,
    plugins
) {
    "use strict";

    var slice = Array.prototype.slice,
        concat = Array.prototype.concat;

    function parentClass(ctor){
        if (ctor.hasOwnProperty("superclass")) {
            return ctor.superclass;
        }

        return Object.getPrototypeOf(ctor);
    }

 
    var Plugin =   Emitter.inherit({
        klassName: "Plugin",

        _domx : domx,

        _construct : function(elm,options) {
           this._elm = elm;
           this._initOptions(options);
        },

        _initOptions : function(options) {
          var ctor = this.constructor,
              cache = ctor.cache = (ctor.hasOwnProperty("cache") ? ctor.cache : {}),
              defaults = cache.defaults;
          if (!defaults) {
            var  ctors = [];
            do {
              ctors.unshift(ctor);
              if (ctor === Plugin) {
                break;
              }
              ctor = parentClass(ctor);
            } while (ctor);

            defaults = cache.defaults = {};
            for (var i=0;i<ctors.length;i++) {
              ctor = ctors[i];
              if (ctor.prototype.hasOwnProperty("options")) {
                objects.mixin(defaults,ctor.prototype.options,true);
              }
              if (ctor.hasOwnProperty("options")) {
                objects.mixin(defaults,ctor.options,true);
              }
            }
          }
          Object.defineProperty(this,"options",{
            value :objects.mixin({},defaults,options,true)
          });

          //return this.options = langx.mixin({},defaults,options);
          return this.options;
        },


        destroy: function() {

            this._destroy();

            // remove all event lisener
            this.unlistenTo();
            // remove data 
            datax.removeData(this._elm,this.pluginName );
        },

        _destroy: funcs.noop,

        _delay: function( handler, delay ) {
            function handlerProxy() {
                return ( typeof handler === "string" ? instance[ handler ] : handler )
                    .apply( instance, arguments );
            }
            var instance = this;
            return setTimeout( handlerProxy, delay || 0 );
        },

        elmx : function(elm) {
            if (elm) {
                return elmx(elm);
            }
            if (!this._velm) {
                this._velm = elmx(this._elm);
            }
            return this._velm;
        },

        $ : function(elm) {
            if (elm) {
                return $(elm,this._elm);
            }
            if (!this._$elm) {
                this._$elm = $(this._elm);
            }            
            return this._$elm;
        },

        option: function( key, value ) {
            var options = key;
            var parts;
            var curOption;
            var i;

            if ( arguments.length === 0 ) {

                // Don't return a reference to the internal hash
                return objects.mixin( {}, this.options );
            }

            if ( typeof key === "string" ) {

                // Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
                options = {};
                parts = key.split( "." );
                key = parts.shift();
                if ( parts.length ) {
                    curOption = options[ key ] = objects.mixin( {}, this.options[ key ] );
                    for ( i = 0; i < parts.length - 1; i++ ) {
                        curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
                        curOption = curOption[ parts[ i ] ];
                    }
                    key = parts.pop();
                    if ( arguments.length === 1 ) {
                        return curOption[ key ] === undefined ? null : curOption[ key ];
                    }
                    curOption[ key ] = value;
                } else {
                    if ( arguments.length === 1 ) {
                        return this.options[ key ] === undefined ? null : this.options[ key ];
                    }
                    options[ key ] = value;
                }
            }

            this._setOptions( options );

            return this;
        },

        _setOptions: function( options ) {
            var key;

            for ( key in options ) {
                this._setOption( key, options[ key ] );
            }

            return this;
        },

        _setOption: function( key, value ) {

            this.options[ key ] = value;

            return this;
        },

        getUID : function (prefix) {
            prefix = prefix || "plugin";
            do prefix += ~~(Math.random() * 1000000)
            while (document.getElementById(prefix))
            return prefix;
        },

        elm : function() {
            return this._elm;
        }

    });


    return  plugins.Plugin = Plugin;
});
define('skylark-domx-plugins-base/instantiate',[
    "skylark-domx-data",
    "./plugins",
    "./plugin"
], function(
    datax, 
    plugins,
    Plugin
) {
    "use strict";

    var pluginKlasses = plugins.pluginKlasses;

    /*
     * Create or get or destory a plugin instance assocated with the element.
     */
    function instantiate(elm,pluginName,options) {
        var pair = pluginName.split(":"),
            instanceDataName = pair[1];
        pluginName = pair[0];

        if (!instanceDataName) {
            instanceDataName = pluginName;
        }

        var pluginInstance = datax.data( elm, instanceDataName );

        if (options === "instance") {
            return pluginInstance;
        } else if (options === "destroy") {
            if (!pluginInstance) {
                throw new Error ("The plugin instance is not existed");
            }
            pluginInstance.destroy();
            //datax.removeData( elm, pluginName);
            pluginInstance = undefined;
        } else {
            if (!pluginInstance) {
                if (options !== undefined && typeof options !== "object") {
                    throw new Error ("The options must be a plain object");
                }
                var pluginKlass = pluginKlasses[pluginName]; 
                pluginInstance = new pluginKlass(elm,options);
                datax.data( elm, instanceDataName,pluginInstance );
            } else if (options) {
                pluginInstance.reset(options);
            }
        }

        return pluginInstance;
    }

    Plugin.instantiate = function(elm,options) {
        return instantiate(elm,this.prototype.pluginName,options);
    };

    return  plugins.instantiate = instantiate;
});
define('skylark-domx-plugins-base/shortcutter',[
    "skylark-langx-types",
    "./plugins",
    "./instantiate"
], function(
    types,
    plugins,
    instantiate
) {
    "use strict";

    var slice = Array.prototype.slice;

    function shortcutter(pluginName,extfn) {
       /*
        * Create or get or destory a plugin instance assocated with the element,
        * and also you can execute the plugin method directory;
        */
        return function (elm,options) {
            var  plugin = instantiate(elm, pluginName,"instance");
            if ( options === "instance" ) {
              return plugin || null;
            }

            if (!plugin) {
                plugin = instantiate(elm, pluginName,typeof options == 'object' && options || {});
                if (typeof options != "string") {
                  return this;
                }
            } 
            if (options) {
                var args = slice.call(arguments,1); //2
                if (extfn) {
                    return extfn.apply(plugin,args);
                } else {
                    if (typeof options == 'string') {
                        var methodName = options;

                        if ( !plugin ) {
                            throw new Error( "cannot call methods on " + pluginName +
                                " prior to initialization; " +
                                "attempted to call method '" + methodName + "'" );
                        }

                        if ( !types.isFunction( plugin[ methodName ] ) || methodName.charAt( 0 ) === "_" ) {
                            throw new Error( "no such method '" + methodName + "' for " + pluginName +
                                " plugin instance" );
                        }

                        args = slice.call(args,1); //remove method name

                        var ret = plugin[methodName].apply(plugin,args);
                        if (ret == plugin) {
                          ret = undefined;
                        }

                        return ret;
                    }                
                }                
            }

        }

    }


    return  plugins.shortcutter = shortcutter;
});
define('skylark-domx-plugins-base/register',[
    "skylark-langx-types",
    "skylark-domx-query",
    "skylark-domx-velm",
    "./plugins",
    "./shortcutter"
], function(
    types,
    $, 
    elmx,
    plugins,
    shortcutter
) {
    "use strict";

    var slice = Array.prototype.slice,
        pluginKlasses = plugins.pluginKlasses,
        shortcuts = plugins.shortcuts;

    /*
     * Register a plugin type
     */
    function register( pluginKlass,shortcutName,instanceDataName,extfn) {
        var pluginName = pluginKlass.prototype.pluginName;
        
        pluginKlasses[pluginName] = pluginKlass;

        if (shortcutName) {
            if (instanceDataName && types.isFunction(instanceDataName)) {
                extfn = instanceDataName;
                instanceDataName = null;
            } 
            if (instanceDataName) {
                pluginName = pluginName + ":" + instanceDataName;
            }

            var shortcut = shortcuts[shortcutName] = shortcutter(pluginName,extfn);
                
            $.fn[shortcutName] = function(options) {
                var returnValue = this;

                if ( !this.length && options === "instance" ) {
                  returnValue = undefined;
                } else {
                  var args = slice.call(arguments);
                  this.each(function () {
                    var args2 = slice.call(args);
                    args2.unshift(this);
                    var  ret  = shortcut.apply(undefined,args2);
                    if (ret !== undefined) {
                        returnValue = ret;
                    }
                  });
                }

                return returnValue;
            };

            elmx.partial(shortcutName,function(options) {
                var  ret  = shortcut(this._elm,options);
                if (ret === undefined) {
                    ret = this;
                }
                return ret;
            });

        }
    }

    return  plugins.register = register;
});
define('skylark-domx-plugins-base/main',[
    "skylark-domx-query",
    "skylark-domx-velm",
	"./plugins",
	"./instantiate",
	"./plugin",
	"./register",
	"./shortcutter"
],function($,elmx,plugins,instantiate,Plugin,register,shortcutter){
    "use strict";

    var slice = Array.prototype.slice;

    $.fn.plugin = function(name,options) {
        var args = slice.call( arguments, 1 ),
            self = this,
            returnValue ;

        this.each(function(){
            returnValue = instantiate.apply(self,[this,name].concat(args));
        });
        return returnValue;
    };

    elmx.partial("plugin",function(name,options) {
        var args = slice.call( arguments, 1 );
        return instantiate.apply(this,[this._elm,name].concat(args));
    }); 

	return plugins;
});
define('skylark-domx-plugins-base', ['skylark-domx-plugins-base/main'], function (main) { return main; });

define('skylark-jquery/jquery-plugin',[
	"skylark-langx-types",
	"skylark-langx-objects",
	"skylark-langx-arrays",
	"skylark-langx/langx",
	"skylark-domx-data",
	"skylark-domx-eventer",
	"skylark-domx-plugins-base",
	"skylark-domx-query",
],function(types, objects, arrays, langx, datax, eventer, plugins, $){

    var pluginUuid = 0;

	var JqPlugin = plugins.Plugin.inherit({
		klassName : "JqPlugin",

        pluginEventPrefix: "",

        options: {
            // Callbacks
            create: null
        },

        destroy: function() {
            this.overrided();

            // We can probably remove the unbind calls in 2.0
            // all event bindings should go through this._on()
            this.element
                .off( this.eventNamespace );

            // Clean up events and states
            this.bindings.off( this.eventNamespace );
        },

        _construct : function(element,options) {
            //this.options = langx.mixin( {}, this.options );

            element = $( element || this.defaultElement || this )[ 0 ];
            this.element = $( element );
            this.uuid = pluginUuid++;
            this.eventNamespace = "." + this.pluginName + this.uuid;

            this.bindings = $();
            this.classesElementLookup = {};

			this.hoverable = $();
			this.focusable = $();

            if ( element !== this ) {
                datax.data( element, this.pluginName, this );
                this._on( true, this.element, {
                    remove: function( event ) {
                        if ( event.target === element ) {
                            this.destroy();
                        }
                    }
                } );
                this.document = $( element.style ?

                    // Element within the document
                    element.ownerDocument :

                    // Element is window or document
                    element.document || element );
                this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
            }

            this.overrided(element,options);

//            this.options = langx.mixin( {},
//                this.options,
//                this._getCreateOptions(),
//                options );

            this._create();

            this._trigger( "create", null, this._getCreateEventData() );

            this._init();
        },


	     _initOptions : function(options) {
	     	options = langx.mixin(this._getCreateOptions(),options);

			this.overrided(options);
		},

        _getCreateOptions: function() {
            return {};
        },

        _getCreateEventData: langx.noop,

		_super : function() {
			if (this.overrided) {
				return this.overrided.apply(this,arguments);
			}
		},

		_superApply : function ( args ) {
			if (this.overrided) {
				return this.overrided.apply(this,args);
			}
		},

        _create: langx.noop,

        _init: langx.noop,

		_classes: function( options ) {
			var full = [];
			var that = this;

			options = objects.mixin( {
				element: this.element,
				classes: this.options.classes || {}
			}, options );


			function bindRemoveEvent() {
				options.element.each( function( _, element ) {
					var isTracked = langx.map( that.classesElementLookup, function( elements ) {
						return elements;
					} )
						.some( function(elements ) {
							return $(elements).is( element );
						} );

					if ( !isTracked ) {
						that._on( $( element ), {
							remove: "_untrackClassesElement"
						} );
					}
				} );
			}

			function processClassString( classes, checkOption ) {
				var current, i;
				for ( i = 0; i < classes.length; i++ ) {
					current = that.classesElementLookup[ classes[ i ] ] || $();
					if ( options.add ) {
						bindRemoveEvent();
						current = $( langx.uniq( current.get().concat( options.element.get() ) ) );
					} else {
						current = $( current.not( options.element ).get() );
					}
					that.classesElementLookup[ classes[ i ] ] = current;
					full.push( classes[ i ] );
					if ( checkOption && options.classes[ classes[ i ] ] ) {
						full.push( options.classes[ classes[ i ] ] );
					}
				}
			}

			if ( options.keys ) {
				processClassString( options.keys.match( /\S+/g ) || [], true );
			}
			if ( options.extra ) {
				processClassString( options.extra.match( /\S+/g ) || [] );
			}

			return full.join( " " );
		},

		_untrackClassesElement: function( event ) {
			var that = this;
			langx.each( that.classesElementLookup, function( key, value ) {
				if ( arrays.inArray( event.target, value ) !== -1 ) {
					that.classesElementLookup[ key ] = $( value.not( event.target ).get() );
				}
			} );

			this._off( $( event.target ) );
		},

		_removeClass: function( element, keys, extra ) {
			return this._toggleClass( element, keys, extra, false );
		},

		_addClass: function( element, keys, extra ) {
			return this._toggleClass( element, keys, extra, true );
		},

		_toggleClass: function( element, keys, extra, add ) {
			add = ( typeof add === "boolean" ) ? add : extra;
			var shift = ( typeof element === "string" || element === null ),
				options = {
					extra: shift ? keys : extra,
					keys: shift ? element : keys,
					element: shift ? this.element : element,
					add: add
				};
			options.element.toggleClass( this._classes( options ), add );
			return this;
		},

		_on: function( suppressDisabledCheck, element, handlers ) {
			var delegateElement;
			var instance = this;

			// No suppressDisabledCheck flag, shuffle arguments
			if ( typeof suppressDisabledCheck !== "boolean" ) {
				handlers = element;
				element = suppressDisabledCheck;
				suppressDisabledCheck = false;
			}

			// No element argument, shuffle and use this.element
			if ( !handlers ) {
				handlers = element;
				element = this.element;
				delegateElement = this.widget();
			} else {
				element = delegateElement = $( element );
				this.bindings = this.bindings.add( element );
			}

			objects.each( handlers, function( event, handler ) {
				function handlerProxy() {

					// Allow widgets to customize the disabled handling
					// - disabled as an array instead of boolean
					// - disabled class as method for disabling individual parts
					if ( !suppressDisabledCheck &&
							( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
						return;
					}
					return ( typeof handler === "string" ? instance[ handler ] : handler )
						.apply( instance, arguments );
				}

				// Copy the guid so direct unbinding works
				if ( typeof handler !== "string" ) {
					handlerProxy.guid = handler.guid =
						handler.guid || handlerProxy.guid || $.guid++;
				}

				var match = event.match( /^([\w:-]*)\s*(.*)$/ );
				var eventName = match[ 1 ] + instance.eventNamespace;
				var selector = match[ 2 ];

				if ( selector ) {
					delegateElement.on( eventName, selector, handlerProxy );
				} else {
					element.on( eventName, handlerProxy );
				}
			} );
		},

		_off: function( element, eventName ) {
			eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
				this.eventNamespace;
			element.off( eventName );

			// Clear the stack to avoid memory leaks (#10056)
			this.bindings = $( this.bindings.not( element ).get() );
			this.focusable = $( this.focusable.not( element ).get() );
			this.hoverable = $( this.hoverable.not( element ).get() );
		},

		_trigger: function( type, event, data ) {
			var prop, orig;
			var callback = this.options[ type ];

			data = data || {};
			event = eventer.proxy( event );
			event.type = ( type === this.widgetEventPrefix ?
				type :
				this.widgetEventPrefix + type ).toLowerCase();

			// The original event may come from any element
			// so we need to reset the target on the new event
			event.target = this.element[ 0 ];

			// Copy original event properties over to the new event
			orig = event.originalEvent;
			if ( orig ) {
				for ( prop in orig ) {
					if ( !( prop in event ) ) {
						event[ prop ] = orig[ prop ];
					}
				}
			}

			this.element.trigger( event, data );
			return !( types.isFunction( callback ) &&
				callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
				event.isDefaultPrevented() );
		},
		_hoverable: function( element ) {
			this.hoverable = this.hoverable.add( element );
			this._on( element, {
				mouseenter: function( event ) {
					this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
				},
				mouseleave: function( event ) {
					this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
				}
			} );
		},

		_focusable: function( element ) {
			this.focusable = this.focusable.add( element );
			this._on( element, {
				focusin: function( event ) {
					this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
				},
				focusout: function( event ) {
					this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
				}
			} );
		},


	    enable: function() {
	      return this._setOptions( { disabled: false } );
	    },

	    disable: function() {
	      return this._setOptions( { disabled: true } );
	    }


	});

	return JqPlugin;
});
/*!
 * jQuery UI Widget @VERSION
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Widget
//>>group: Core
//>>description: Provides a factory for creating stateful widgets with a common API.
//>>docs: http://api.jqueryui.com/jQuery.widget/
//>>demos: http://jqueryui.com/widget/

define( 'skylark-jquery/widget',[ 
	"skylark-langx/langx",
	"skylark-domx-plugins-base",
	"./core",
	"./jquery-plugin"
],  function(langx,splugins, $,JqPlugin ) {

	var widgetUuid = 0;
	var widgetHasOwnProperty = Array.prototype.hasOwnProperty;
	var widgetSlice = Array.prototype.slice;

	$.cleanData = ( function( orig ) {
		return function( elems ) {
			var events, elem, i;
			for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {

				// Only trigger remove when necessary to save time
				events = $._data( elem, "events" );
				if ( events && events.remove ) {
					$( elem ).triggerHandler( "remove" );
				}
			}
			orig( elems );
		};
	} )( $.cleanData );
	
	$.widget = function( name, base, prototype ) {
		var existingConstructor, constructor, basePrototype;

		// ProxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		var proxiedPrototype = {};

		var namespace = name.split( "." )[ 0 ];
		name = name.split( "." )[ 1 ];
		var fullName = namespace + "-" + name;

		if ( !prototype ) {
			prototype = base;
			base = $.Widget;
		}

		if ( $.isArray( prototype ) ) {
			prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
		}

		// Create selector for plugin
		$.expr.pseudos[ fullName.toLowerCase() ] = function( elem ) {
			return !!$.data( elem, fullName );
		};

		$[ namespace ] = $[ namespace ] || {};

		existingConstructor = $[ namespace ][ name ];

		var basePrototype = base.prototype,
			newPrototype = {};

		for (var key in prototype) {
			var value = prototype[key];

			if ( $.isPlainObject( value ) ) {
				newPrototype[ key ] = $.isPlainObject( basePrototype[ key ] ) ?
					$.widget.extend( {}, basePrototype[ key ], value ) :

					// Don't extend strings, arrays, etc. with objects
					$.widget.extend( {}, value );
			} else {
				newPrototype[key] = value;
			}
		}

		var _proto = $.widget.extend({

			// TODO: remove support for widgetEventPrefix
			// always use the name + a colon as the prefix, e.g., draggable:start
			// don't prefix for widgets that aren't DOM-based
			widgetEventPrefix: existingConstructor ? ( base.prototype.widgetEventPrefix || name ) : name
		}, {
			options : base.prototype.options
		},newPrototype, {
			name : fullName,
			namespace: namespace,
			widgetName: name,
			pluginName : "jqueryui." + (namespace ? namespace + "." : "") + name,
			widgetFullName: fullName
		} );

		constructor = $[ namespace ][ name ] = base.inherit(_proto);
		/*

		constructor = $[ namespace ][ name ] = function( options, element ) {

			// Allow instantiation without "new" keyword
			if ( !this._createWidget ) {
				return new constructor( options, element );
			}

			// Allow instantiation without initializing for simple inheritance
			// must use "new" keyword (the code above always passes args)
			if ( arguments.length ) {
				this._createWidget( options, element );
			}
		};
		*/
		// Extend with the existing constructor to carry over any static properties
		$.extend( constructor, existingConstructor, {
			version: prototype.version,

			// Copy the object used to create the prototype in case we need to
			// redefine the widget later
			_proto: _proto,

			// Track widgets that inherit from this widget in case this widget is
			// redefined after a widget inherits from it
			_childConstructors: []
		} );

		/*
		basePrototype = new base();

		// We need to make the options hash a property directly on the new instance
		// otherwise we'll modify the options hash on the prototype that we're
		// inheriting from
		basePrototype.options = $.widget.extend( {}, basePrototype.options );
		$.each( prototype, function( prop, value ) {
			if ( !$.isFunction( value ) ) {
				proxiedPrototype[ prop ] = value;
				return;
			}
			proxiedPrototype[ prop ] = ( function() {
				function _super() {
					return base.prototype[ prop ].apply( this, arguments );
				}

				function _superApply( args ) {
					return base.prototype[ prop ].apply( this, args );
				}

				return function() {
					var __super = this._super;
					var __superApply = this._superApply;
					var returnValue;

					this._super = _super;
					this._superApply = _superApply;

					returnValue = value.apply( this, arguments );

					this._super = __super;
					this._superApply = __superApply;

					return returnValue;
				};
			} )();
		} );
		constructor.prototype = $.widget.extend( basePrototype, {

			// TODO: remove support for widgetEventPrefix
			// always use the name + a colon as the prefix, e.g., draggable:start
			// don't prefix for widgets that aren't DOM-based
			widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
		}, proxiedPrototype, {
			constructor: constructor,
			namespace: namespace,
			widgetName: name,
			widgetFullName: fullName
		} );
		*/
		// If this widget is being redefined then we need to find all widgets that
		// are inheriting from it and redefine all of them so that they inherit from
		// the new version of this widget. We're essentially trying to replace one
		// level in the prototype chain.
		if ( existingConstructor ) {
			$.each( existingConstructor._childConstructors, function( i, child ) {
				var childPrototype = child.prototype;

				// Redefine the child widget using the same prototype that was
				// originally used, but inherit from the new version of the base
				$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
					child._proto );
			} );

			// Remove the list of existing child constructors from the old constructor
			// so the old child constructors can be garbage collected
			delete existingConstructor._childConstructors;
		} else {
			if (base._childConstructors) {
				base._childConstructors.push( constructor );
			}
		}

		//$.widget.bridge( name, constructor );

		splugins.register(constructor,name,fullName);

		return constructor;
	};

	$.widget.extend = function( target ) {
		var input = widgetSlice.call( arguments, 1 );
		var inputIndex = 0;
		var inputLength = input.length;
		var key;
		var value;

		for ( ; inputIndex < inputLength; inputIndex++ ) {
			for ( key in input[ inputIndex ] ) {
				value = input[ inputIndex ][ key ];
				if ( widgetHasOwnProperty.call( input[ inputIndex ], key ) && value !== undefined ) {

					// Clone objects
					if ( $.isPlainObject( value ) ) {
						target[ key ] = $.isPlainObject( target[ key ] ) ?
							$.widget.extend( {}, target[ key ], value ) :

							// Don't extend strings, arrays, etc. with objects
							$.widget.extend( {}, value );

					// Copy everything else by reference
					} else {
						target[ key ] = value;
					}
				}
			}
		}
		return target;
	};


	$.Widget = 	 JqPlugin.inherit({
		widgetName: "widget",
		widgetEventPrefix: "",
		defaultElement: "<div>",

		options: {
			classes: {},
			disabled: false,

			// Callbacks
			create: null
		},

		widget: function() {
			return this.element;
		},

		_setOption: function( key, value ) {
			if ( key === "classes" ) {
				this._setOptionClasses( value );
			}

			this.options[ key ] = value;

			if ( key === "disabled" ) {
				this._setOptionDisabled( value );
			}

			return this;
		},

		_setOptionClasses: function( value ) {
			var classKey, elements, currentElements;

			for ( classKey in value ) {
				currentElements = this.classesElementLookup[ classKey ];
				if ( value[ classKey ] === this.options.classes[ classKey ] ||
						!currentElements ||
						!currentElements.length ) {
					continue;
				}

				// We are doing this to create a new jQuery object because the _removeClass() call
				// on the next line is going to destroy the reference to the current elements being
				// tracked. We need to save a copy of this collection so that we can add the new classes
				// below.
				elements = $( currentElements.get() );
				this._removeClass( currentElements, classKey );

				// We don't use _addClass() here, because that uses this.options.classes
				// for generating the string of classes. We want to use the value passed in from
				// _setOption(), this is the new value of the classes option which was passed to
				// _setOption(). We pass this value directly to _classes().
				elements.addClass( this._classes( {
					element: elements,
					keys: classKey,
					classes: value,
					add: true
				} ));
			}
		},

		_setOptionDisabled: function( value ) {
			this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );

			// If the widget is becoming disabled, then nothing is interactive
			if ( value ) {
				this._removeClass( this.hoverable, null, "ui-state-hover" );
				this._removeClass( this.focusable, null, "ui-state-focus" );
			}
		},

		enable: function() {
			return this._setOptions( { disabled: false } );
		},

		disable: function() {
			return this._setOptions( { disabled: true } );
		},


		_delay: function( handler, delay ) {
			function handlerProxy() {
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}
			var instance = this;
			return setTimeout( handlerProxy, delay || 0 );
		},

		_hoverable: function( element ) {
			this.hoverable = this.hoverable.add( element );
			this._on( element, {
				mouseenter: function( event ) {
					this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
				},
				mouseleave: function( event ) {
					this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
				}
			} );
		},

		_focusable: function( element ) {
			this.focusable = this.focusable.add( element );
			this._on( element, {
				focusin: function( event ) {
					this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
				},
				focusout: function( event ) {
					this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
				}
			} );
		}

	});

	$.Widget._childConstructors = [];

	$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
		$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
			if ( typeof options === "string" ) {
				options = { effect: options };
			}

			var hasOptions;
			var effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;

			options = options || {};
			if ( typeof options === "number" ) {
				options = { duration: options };
			}

			hasOptions = !$.isEmptyObject( options );
			options.complete = callback;

			if ( options.delay ) {
				element.delay( options.delay );
			}

			if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
				element[ method ]( options );
			} else if ( effectName !== method && element[ effectName ] ) {
				element[ effectName ]( options.duration, options.easing, callback );
			} else {
				element.queue( function( next ) {
					$( this )[ method ]();
					if ( callback ) {
						callback.call( element[ 0 ] );
					}
					next();
				} );
			}
		};
	} );

	return $.widget;

});

define('skylark-jquery/main',[
    "./core",
    "./ajax",
    "./callbacks",
    "./deferred",
    "./queue",
    "./jquery-plugin",
    "./widget"
], function($) {
    return $;
});

define('skylark-jquery', ['skylark-jquery/main'], function (main) { return main; });

define('skylark-98js/win98',[
	"skylark-langx-ns",
	"skylark-jquery"
],function(skylark,$){
	window.$ = $;
	return skylark.attach("intg.win98js");
});
define('skylark-browserfs/libs/process',[],function(){
    // shim for using process in browser
    var process = {};

    // cached from whatever global is present so that test runners that stub it
    // don't break things.  But we need to wrap it in a try catch in case it is
    // wrapped in strict mode code which doesn't define any globals.  It's inside a
    // function because try/catches deoptimize in certain engines.

    var cachedSetTimeout;
    var cachedClearTimeout;

    function defaultSetTimeout() {
        throw new Error('setTimeout has not been defined');
    }

    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }

    (function () {
        try {
            if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
            } else {
                cachedSetTimeout = defaultSetTimeout;
            }
        } catch (e) {
            cachedSetTimeout = defaultSetTimeout;
        }
        try {
            if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
            } else {
                cachedClearTimeout = defaultClearTimeout;
            }
        } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
        }
    } ())

    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimeout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }
    }

    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }
    }
    
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }

    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    };

    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;

    process.listeners = function (name) { return [] }

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

    process.cwd = function () { return '/' };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function() { return 0; };

    return process;

});
define('skylark-browserfs/libs/base64',[],function(){
  'use strict'
  var exports = {};

  exports.byteLength = byteLength
  exports.toByteArray = toByteArray
  exports.fromByteArray = fromByteArray

  var lookup = []
  var revLookup = []
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i]
    revLookup[code.charCodeAt(i)] = i
  }

  // Support decoding URL-safe base64 strings, as Node.js does.
  // See: https://en.wikipedia.org/wiki/Base64#URL_applications
  revLookup['-'.charCodeAt(0)] = 62
  revLookup['_'.charCodeAt(0)] = 63

  function getLens (b64) {
    var len = b64.length

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }

    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=')
    if (validLen === -1) validLen = len

    var placeHoldersLen = validLen === len
      ? 0
      : 4 - (validLen % 4)

    return [validLen, placeHoldersLen]
  }

  // base64 is 4/3 + up to two characters of the original data
  function byteLength (b64) {
    var lens = getLens(b64)
    var validLen = lens[0]
    var placeHoldersLen = lens[1]
    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
  }

  function _byteLength (b64, validLen, placeHoldersLen) {
    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
  }

  function toByteArray (b64) {
    var tmp
    var lens = getLens(b64)
    var validLen = lens[0]
    var placeHoldersLen = lens[1]

    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

    var curByte = 0

    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0
      ? validLen - 4
      : validLen

    var i
    for (i = 0; i < len; i += 4) {
      tmp =
        (revLookup[b64.charCodeAt(i)] << 18) |
        (revLookup[b64.charCodeAt(i + 1)] << 12) |
        (revLookup[b64.charCodeAt(i + 2)] << 6) |
        revLookup[b64.charCodeAt(i + 3)]
      arr[curByte++] = (tmp >> 16) & 0xFF
      arr[curByte++] = (tmp >> 8) & 0xFF
      arr[curByte++] = tmp & 0xFF
    }

    if (placeHoldersLen === 2) {
      tmp =
        (revLookup[b64.charCodeAt(i)] << 2) |
        (revLookup[b64.charCodeAt(i + 1)] >> 4)
      arr[curByte++] = tmp & 0xFF
    }

    if (placeHoldersLen === 1) {
      tmp =
        (revLookup[b64.charCodeAt(i)] << 10) |
        (revLookup[b64.charCodeAt(i + 1)] << 4) |
        (revLookup[b64.charCodeAt(i + 2)] >> 2)
      arr[curByte++] = (tmp >> 8) & 0xFF
      arr[curByte++] = tmp & 0xFF
    }

    return arr
  }

  function tripletToBase64 (num) {
    return lookup[num >> 18 & 0x3F] +
      lookup[num >> 12 & 0x3F] +
      lookup[num >> 6 & 0x3F] +
      lookup[num & 0x3F]
  }

  function encodeChunk (uint8, start, end) {
    var tmp
    var output = []
    for (var i = start; i < end; i += 3) {
      tmp =
        ((uint8[i] << 16) & 0xFF0000) +
        ((uint8[i + 1] << 8) & 0xFF00) +
        (uint8[i + 2] & 0xFF)
      output.push(tripletToBase64(tmp))
    }
    return output.join('')
  }

  function fromByteArray (uint8) {
    var tmp
    var len = uint8.length
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    var parts = []
    var maxChunkLength = 16383 // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(
        uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
      ))
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1]
      parts.push(
        lookup[tmp >> 2] +
        lookup[(tmp << 4) & 0x3F] +
        '=='
      )
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1]
      parts.push(
        lookup[tmp >> 10] +
        lookup[(tmp >> 4) & 0x3F] +
        lookup[(tmp << 2) & 0x3F] +
        '='
      )
    }

    return parts.join('')
  }

  return exports;
});
define('skylark-browserfs/libs/ieee754',[],function(){
  'use strict'
  var exports = {};

  exports.read = function (buffer, offset, isLE, mLen, nBytes) {
    var e, m
    var eLen = (nBytes * 8) - mLen - 1
    var eMax = (1 << eLen) - 1
    var eBias = eMax >> 1
    var nBits = -7
    var i = isLE ? (nBytes - 1) : 0
    var d = isLE ? -1 : 1
    var s = buffer[offset + i]

    i += d

    e = s & ((1 << (-nBits)) - 1)
    s >>= (-nBits)
    nBits += eLen
    for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & ((1 << (-nBits)) - 1)
    e >>= (-nBits)
    nBits += mLen
    for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity)
    } else {
      m = m + Math.pow(2, mLen)
      e = e - eBias
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  }

  exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c
    var eLen = (nBytes * 8) - mLen - 1
    var eMax = (1 << eLen) - 1
    var eBias = eMax >> 1
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
    var i = isLE ? 0 : (nBytes - 1)
    var d = isLE ? 1 : -1
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

    value = Math.abs(value)

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0
      e = eMax
    } else {
      e = Math.floor(Math.log(value) / Math.LN2)
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--
        c *= 2
      }
      if (e + eBias >= 1) {
        value += rt / c
      } else {
        value += rt * Math.pow(2, 1 - eBias)
      }
      if (value * c >= 2) {
        e++
        c /= 2
      }

      if (e + eBias >= eMax) {
        m = 0
        e = eMax
      } else if (e + eBias >= 1) {
        m = ((value * c) - 1) * Math.pow(2, mLen)
        e = e + eBias
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
        e = 0
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = (e << mLen) | m
    eLen += mLen
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128
  }

  return exports;
});

define('skylark-browserfs/libs/buffers',[
  "./base64",
  "./ieee754"
],function(base64,ieee754){
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /* eslint-disable no-proto */

  'use strict'

  var exports = {};

  ///var base64 = require('base64-js')
  ///var ieee754 = require('ieee754')

  exports.Buffer = Buffer
  exports.SlowBuffer = SlowBuffer
  exports.INSPECT_MAX_BYTES = 50

  var K_MAX_LENGTH = 0x7fffffff
  exports.kMaxLength = K_MAX_LENGTH

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Print warning and recommend using `buffer` v4.x which has an Object
   *               implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * We report that the browser does not support typed arrays if the are not subclassable
   * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
   * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
   * for __proto__ and has a buggy typed array implementation.
   */
  Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

  if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
      typeof console.error === 'function') {
    console.error(
      'This browser lacks typed array (Uint8Array) support which is required by ' +
      '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
    )
  }

  function typedArraySupport () {
    // Can typed array instances can be augmented?
    try {
      var arr = new Uint8Array(1)
      arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
      return arr.foo() === 42
    } catch (e) {
      return false
    }
  }

  Object.defineProperty(Buffer.prototype, 'parent', {
    get: function () {
      if (!(this instanceof Buffer)) {
        return undefined
      }
      return this.buffer
    }
  })

  Object.defineProperty(Buffer.prototype, 'offset', {
    get: function () {
      if (!(this instanceof Buffer)) {
        return undefined
      }
      return this.byteOffset
    }
  })

  function createBuffer (length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('Invalid typed array length')
    }
    // Return an augmented `Uint8Array` instance
    var buf = new Uint8Array(length)
    buf.__proto__ = Buffer.prototype
    return buf
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer (arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error(
          'If encoding is specified then the first argument must be a string'
        )
      }
      return allocUnsafe(arg)
    }
    return from(arg, encodingOrOffset, length)
  }

  // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true,
      enumerable: false,
      writable: false
    })
  }

  Buffer.poolSize = 8192 // not used by this implementation

  function from (value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number')
    }

    if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length)
    }

    if (typeof value === 'string') {
      return fromString(value, encodingOrOffset)
    }

    return fromObject(value)
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer.from = function (value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length)
  }

  // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
  // https://github.com/feross/buffer/pull/148
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array

  function assertSize (size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be of type number')
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative')
    }
  }

  function alloc (size, fill, encoding) {
    assertSize(size)
    if (size <= 0) {
      return createBuffer(size)
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string'
        ? createBuffer(size).fill(fill, encoding)
        : createBuffer(size).fill(fill)
    }
    return createBuffer(size)
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer.alloc = function (size, fill, encoding) {
    return alloc(size, fill, encoding)
  }

  function allocUnsafe (size) {
    assertSize(size)
    return createBuffer(size < 0 ? 0 : checked(size) | 0)
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(size)
  }
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(size)
  }

  function fromString (string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8'
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }

    var length = byteLength(string, encoding) | 0
    var buf = createBuffer(length)

    var actual = buf.write(string, encoding)

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      buf = buf.slice(0, actual)
    }

    return buf
  }

  function fromArrayLike (array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0
    var buf = createBuffer(length)
    for (var i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255
    }
    return buf
  }

  function fromArrayBuffer (array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds')
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds')
    }

    var buf
    if (byteOffset === undefined && length === undefined) {
      buf = new Uint8Array(array)
    } else if (length === undefined) {
      buf = new Uint8Array(array, byteOffset)
    } else {
      buf = new Uint8Array(array, byteOffset, length)
    }

    // Return an augmented `Uint8Array` instance
    buf.__proto__ = Buffer.prototype
    return buf
  }

  function fromObject (obj) {
    if (Buffer.isBuffer(obj)) {
      var len = checked(obj.length) | 0
      var buf = createBuffer(len)

      if (buf.length === 0) {
        return buf
      }

      obj.copy(buf, 0, 0, len)
      return buf
    }

    if (obj) {
      if (ArrayBuffer.isView(obj) || 'length' in obj) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
          return createBuffer(0)
        }
        return fromArrayLike(obj)
      }

      if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data)
      }
    }

    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.')
  }

  function checked (length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                           'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
    }
    return length | 0
  }

  function SlowBuffer (length) {
    if (+length != length) { // eslint-disable-line eqeqeq
      length = 0
    }
    return Buffer.alloc(+length)
  }

  Buffer.isBuffer = function isBuffer (b) {
    return b != null && b._isBuffer === true
  }

  Buffer.compare = function compare (a, b) {
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('Arguments must be Buffers')
    }

    if (a === b) return 0

    var x = a.length
    var y = b.length

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i]
        y = b[i]
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  }

  Buffer.isEncoding = function isEncoding (encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true
      default:
        return false
    }
  }

  Buffer.concat = function concat (list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }

    if (list.length === 0) {
      return Buffer.alloc(0)
    }

    var i
    if (length === undefined) {
      length = 0
      for (i = 0; i < list.length; ++i) {
        length += list[i].length
      }
    }

    var buffer = Buffer.allocUnsafe(length)
    var pos = 0
    for (i = 0; i < list.length; ++i) {
      var buf = list[i]
      if (ArrayBuffer.isView(buf)) {
        buf = Buffer.from(buf)
      }
      if (!Buffer.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
      buf.copy(buffer, pos)
      pos += buf.length
    }
    return buffer
  }

  function byteLength (string, encoding) {
    if (Buffer.isBuffer(string)) {
      return string.length
    }
    if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {
      return string.byteLength
    }
    if (typeof string !== 'string') {
      string = '' + string
    }

    var len = string.length
    if (len === 0) return 0

    // Use a for loop to avoid recursion
    var loweredCase = false
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len
        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes(string).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2
        case 'hex':
          return len >>> 1
        case 'base64':
          return base64ToBytes(string).length
        default:
          if (loweredCase) return utf8ToBytes(string).length // assume utf8
          encoding = ('' + encoding).toLowerCase()
          loweredCase = true
      }
    }
  }
  Buffer.byteLength = byteLength

  function slowToString (encoding, start, end) {
    var loweredCase = false

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return ''
    }

    if (end === undefined || end > this.length) {
      end = this.length
    }

    if (end <= 0) {
      return ''
    }

    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0
    start >>>= 0

    if (end <= start) {
      return ''
    }

    if (!encoding) encoding = 'utf8'

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end)

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end)

        case 'ascii':
          return asciiSlice(this, start, end)

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end)

        case 'base64':
          return base64Slice(this, start, end)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = (encoding + '').toLowerCase()
          loweredCase = true
      }
    }
  }

  // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
  // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
  // reliably in a browserify context because there could be multiple different
  // copies of the 'buffer' package in use. This method works even for Buffer
  // instances that were created from another copy of the `buffer` package.
  // See: https://github.com/feross/buffer/issues/154
  Buffer.prototype._isBuffer = true

  function swap (b, n, m) {
    var i = b[n]
    b[n] = b[m]
    b[m] = i
  }

  Buffer.prototype.swap16 = function swap16 () {
    var len = this.length
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits')
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1)
    }
    return this
  }

  Buffer.prototype.swap32 = function swap32 () {
    var len = this.length
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits')
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3)
      swap(this, i + 1, i + 2)
    }
    return this
  }

  Buffer.prototype.swap64 = function swap64 () {
    var len = this.length
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits')
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7)
      swap(this, i + 1, i + 6)
      swap(this, i + 2, i + 5)
      swap(this, i + 3, i + 4)
    }
    return this
  }

  Buffer.prototype.toString = function toString () {
    var length = this.length
    if (length === 0) return ''
    if (arguments.length === 0) return utf8Slice(this, 0, length)
    return slowToString.apply(this, arguments)
  }

  Buffer.prototype.toLocaleString = Buffer.prototype.toString

  Buffer.prototype.equals = function equals (b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
    if (this === b) return true
    return Buffer.compare(this, b) === 0
  }

  Buffer.prototype.inspect = function inspect () {
    var str = ''
    var max = exports.INSPECT_MAX_BYTES
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
      if (this.length > max) str += ' ... '
    }
    return '<Buffer ' + str + '>'
  }

  Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    if (!Buffer.isBuffer(target)) {
      throw new TypeError('Argument must be a Buffer')
    }

    if (start === undefined) {
      start = 0
    }
    if (end === undefined) {
      end = target ? target.length : 0
    }
    if (thisStart === undefined) {
      thisStart = 0
    }
    if (thisEnd === undefined) {
      thisEnd = this.length
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index')
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0
    }
    if (thisStart >= thisEnd) {
      return -1
    }
    if (start >= end) {
      return 1
    }

    start >>>= 0
    end >>>= 0
    thisStart >>>= 0
    thisEnd >>>= 0

    if (this === target) return 0

    var x = thisEnd - thisStart
    var y = end - start
    var len = Math.min(x, y)

    var thisCopy = this.slice(thisStart, thisEnd)
    var targetCopy = target.slice(start, end)

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i]
        y = targetCopy[i]
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  }

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset
      byteOffset = 0
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000
    }
    byteOffset = +byteOffset  // Coerce to Number.
    if (numberIsNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : (buffer.length - 1)
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset
    if (byteOffset >= buffer.length) {
      if (dir) return -1
      else byteOffset = buffer.length - 1
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0
      else return -1
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer.from(val, encoding)
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    } else if (typeof val === 'number') {
      val = val & 0xFF // Search for a byte value [0-255]
      if (typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
        }
      }
      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
    }

    throw new TypeError('val must be string, number or Buffer')
  }

  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    var indexSize = 1
    var arrLength = arr.length
    var valLength = val.length

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase()
      if (encoding === 'ucs2' || encoding === 'ucs-2' ||
          encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1
        }
        indexSize = 2
        arrLength /= 2
        valLength /= 2
        byteOffset /= 2
      }
    }

    function read (buf, i) {
      if (indexSize === 1) {
        return buf[i]
      } else {
        return buf.readUInt16BE(i * indexSize)
      }
    }

    var i
    if (dir) {
      var foundIndex = -1
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
        } else {
          if (foundIndex !== -1) i -= i - foundIndex
          foundIndex = -1
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
      for (i = byteOffset; i >= 0; i--) {
        var found = true
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false
            break
          }
        }
        if (found) return i
      }
    }

    return -1
  }

  Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1
  }

  Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  }

  Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  }

  function hexWrite (buf, string, offset, length) {
    offset = Number(offset) || 0
    var remaining = buf.length - offset
    if (!length) {
      length = remaining
    } else {
      length = Number(length)
      if (length > remaining) {
        length = remaining
      }
    }

    var strLen = string.length

    if (length > strLen / 2) {
      length = strLen / 2
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16)
      if (numberIsNaN(parsed)) return i
      buf[offset + i] = parsed
    }
    return i
  }

  function utf8Write (buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  }

  function asciiWrite (buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length)
  }

  function latin1Write (buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length)
  }

  function base64Write (buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length)
  }

  function ucs2Write (buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  }

  Buffer.prototype.write = function write (string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8'
      length = this.length
      offset = 0
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset
      length = this.length
      offset = 0
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset >>> 0
      if (isFinite(length)) {
        length = length >>> 0
        if (encoding === undefined) encoding = 'utf8'
      } else {
        encoding = length
        length = undefined
      }
    } else {
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
      )
    }

    var remaining = this.length - offset
    if (length === undefined || length > remaining) length = remaining

    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds')
    }

    if (!encoding) encoding = 'utf8'

    var loweredCase = false
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length)

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length)

        case 'ascii':
          return asciiWrite(this, string, offset, length)

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length)

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = ('' + encoding).toLowerCase()
          loweredCase = true
      }
    }
  }

  Buffer.prototype.toJSON = function toJSON () {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    }
  }

  function base64Slice (buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf)
    } else {
      return base64.fromByteArray(buf.slice(start, end))
    }
  }

  function utf8Slice (buf, start, end) {
    end = Math.min(buf.length, end)
    var res = []

    var i = start
    while (i < end) {
      var firstByte = buf[i]
      var codePoint = null
      var bytesPerSequence = (firstByte > 0xEF) ? 4
        : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
        : 1

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte
            }
            break
          case 2:
            secondByte = buf[i + 1]
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint
              }
            }
            break
          case 3:
            secondByte = buf[i + 1]
            thirdByte = buf[i + 2]
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint
              }
            }
            break
          case 4:
            secondByte = buf[i + 1]
            thirdByte = buf[i + 2]
            fourthByte = buf[i + 3]
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD
        bytesPerSequence = 1
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000
        res.push(codePoint >>> 10 & 0x3FF | 0xD800)
        codePoint = 0xDC00 | codePoint & 0x3FF
      }

      res.push(codePoint)
      i += bytesPerSequence
    }

    return decodeCodePointsArray(res)
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000

  function decodeCodePointsArray (codePoints) {
    var len = codePoints.length
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = ''
    var i = 0
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      )
    }
    return res
  }

  function asciiSlice (buf, start, end) {
    var ret = ''
    end = Math.min(buf.length, end)

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F)
    }
    return ret
  }

  function latin1Slice (buf, start, end) {
    var ret = ''
    end = Math.min(buf.length, end)

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i])
    }
    return ret
  }

  function hexSlice (buf, start, end) {
    var len = buf.length

    if (!start || start < 0) start = 0
    if (!end || end < 0 || end > len) end = len

    var out = ''
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i])
    }
    return out
  }

  function utf16leSlice (buf, start, end) {
    var bytes = buf.slice(start, end)
    var res = ''
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
    }
    return res
  }

  Buffer.prototype.slice = function slice (start, end) {
    var len = this.length
    start = ~~start
    end = end === undefined ? len : ~~end

    if (start < 0) {
      start += len
      if (start < 0) start = 0
    } else if (start > len) {
      start = len
    }

    if (end < 0) {
      end += len
      if (end < 0) end = 0
    } else if (end > len) {
      end = len
    }

    if (end < start) end = start

    var newBuf = this.subarray(start, end)
    // Return an augmented `Uint8Array` instance
    newBuf.__proto__ = Buffer.prototype
    return newBuf
  }

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset (offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
  }

  Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    offset = offset >>> 0
    byteLength = byteLength >>> 0
    if (!noAssert) checkOffset(offset, byteLength, this.length)

    var val = this[offset]
    var mul = 1
    var i = 0
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul
    }

    return val
  }

  Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    offset = offset >>> 0
    byteLength = byteLength >>> 0
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length)
    }

    var val = this[offset + --byteLength]
    var mul = 1
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul
    }

    return val
  }

  Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 1, this.length)
    return this[offset]
  }

  Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 2, this.length)
    return this[offset] | (this[offset + 1] << 8)
  }

  Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 2, this.length)
    return (this[offset] << 8) | this[offset + 1]
  }

  Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)

    return ((this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16)) +
        (this[offset + 3] * 0x1000000)
  }

  Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)

    return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
  }

  Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    offset = offset >>> 0
    byteLength = byteLength >>> 0
    if (!noAssert) checkOffset(offset, byteLength, this.length)

    var val = this[offset]
    var mul = 1
    var i = 0
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul
    }
    mul *= 0x80

    if (val >= mul) val -= Math.pow(2, 8 * byteLength)

    return val
  }

  Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    offset = offset >>> 0
    byteLength = byteLength >>> 0
    if (!noAssert) checkOffset(offset, byteLength, this.length)

    var i = byteLength
    var mul = 1
    var val = this[offset + --i]
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul
    }
    mul *= 0x80

    if (val >= mul) val -= Math.pow(2, 8 * byteLength)

    return val
  }

  Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 1, this.length)
    if (!(this[offset] & 0x80)) return (this[offset])
    return ((0xff - this[offset] + 1) * -1)
  }

  Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 2, this.length)
    var val = this[offset] | (this[offset + 1] << 8)
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  }

  Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 2, this.length)
    var val = this[offset + 1] | (this[offset] << 8)
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  }

  Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)

    return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
  }

  Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)

    return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
  }

  Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)
    return ieee754.read(this, offset, true, 23, 4)
  }

  Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)
    return ieee754.read(this, offset, false, 23, 4)
  }

  Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 8, this.length)
    return ieee754.read(this, offset, true, 52, 8)
  }

  Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 8, this.length)
    return ieee754.read(this, offset, false, 52, 8)
  }

  function checkInt (buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    value = +value
    offset = offset >>> 0
    byteLength = byteLength >>> 0
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1
      checkInt(this, value, offset, byteLength, maxBytes, 0)
    }

    var mul = 1
    var i = 0
    this[offset] = value & 0xFF
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF
    }

    return offset + byteLength
  }

  Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    value = +value
    offset = offset >>> 0
    byteLength = byteLength >>> 0
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1
      checkInt(this, value, offset, byteLength, maxBytes, 0)
    }

    var i = byteLength - 1
    var mul = 1
    this[offset + i] = value & 0xFF
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF
    }

    return offset + byteLength
  }

  Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
    this[offset] = (value & 0xff)
    return offset + 1
  }

  Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    return offset + 2
  }

  Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
    return offset + 2
  }

  Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
    return offset + 4
  }

  Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
    return offset + 4
  }

  Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) {
      var limit = Math.pow(2, (8 * byteLength) - 1)

      checkInt(this, value, offset, byteLength, limit - 1, -limit)
    }

    var i = 0
    var mul = 1
    var sub = 0
    this[offset] = value & 0xFF
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
    }

    return offset + byteLength
  }

  Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) {
      var limit = Math.pow(2, (8 * byteLength) - 1)

      checkInt(this, value, offset, byteLength, limit - 1, -limit)
    }

    var i = byteLength - 1
    var mul = 1
    var sub = 0
    this[offset + i] = value & 0xFF
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
    }

    return offset + byteLength
  }

  Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
    if (value < 0) value = 0xff + value + 1
    this[offset] = (value & 0xff)
    return offset + 1
  }

  Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    return offset + 2
  }

  Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
    return offset + 2
  }

  Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
    return offset + 4
  }

  Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
    if (value < 0) value = 0xffffffff + value + 1
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
    return offset + 4
  }

  function checkIEEE754 (buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
    if (offset < 0) throw new RangeError('Index out of range')
  }

  function writeFloat (buf, value, offset, littleEndian, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4)
    return offset + 4
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert)
  }

  Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert)
  }

  function writeDouble (buf, value, offset, littleEndian, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8)
    return offset + 8
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert)
  }

  Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert)
  }

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy (target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
    if (!start) start = 0
    if (!end && end !== 0) end = this.length
    if (targetStart >= target.length) targetStart = target.length
    if (!targetStart) targetStart = 0
    if (end > 0 && end < start) end = start

    // Copy 0 bytes; we're done
    if (end === start) return 0
    if (target.length === 0 || this.length === 0) return 0

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds')
    }
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
    if (end < 0) throw new RangeError('sourceEnd out of bounds')

    // Are we oob?
    if (end > this.length) end = this.length
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start
    }

    var len = end - start

    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
      // Use built-in when available, missing from IE11
      this.copyWithin(targetStart, start, end)
    } else if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (var i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start]
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      )
    }

    return len
  }

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer.prototype.fill = function fill (val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start
        start = 0
        end = this.length
      } else if (typeof end === 'string') {
        encoding = end
        end = this.length
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string')
      }
      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0)
        if ((encoding === 'utf8' && code < 128) ||
            encoding === 'latin1') {
          // Fast path: If `val` fits into a single byte, use that numeric value.
          val = code
        }
      }
    } else if (typeof val === 'number') {
      val = val & 255
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index')
    }

    if (end <= start) {
      return this
    }

    start = start >>> 0
    end = end === undefined ? this.length : end >>> 0

    if (!val) val = 0

    var i
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val
      }
    } else {
      var bytes = Buffer.isBuffer(val)
        ? val
        : new Buffer(val, encoding)
      var len = bytes.length
      if (len === 0) {
        throw new TypeError('The value "' + val +
          '" is invalid for argument "value"')
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len]
      }
    }

    return this
  }

  // HELPER FUNCTIONS
  // ================

  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

  function base64clean (str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0]
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '')
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return ''
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '='
    }
    return str
  }

  function toHex (n) {
    if (n < 16) return '0' + n.toString(16)
    return n.toString(16)
  }

  function utf8ToBytes (string, units) {
    units = units || Infinity
    var codePoint
    var length = string.length
    var leadSurrogate = null
    var bytes = []

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i)

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
            continue
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
            continue
          }

          // valid lead
          leadSurrogate = codePoint

          continue
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          leadSurrogate = codePoint
          continue
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
      }

      leadSurrogate = null

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break
        bytes.push(codePoint)
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break
        bytes.push(
          codePoint >> 0x6 | 0xC0,
          codePoint & 0x3F | 0x80
        )
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break
        bytes.push(
          codePoint >> 0xC | 0xE0,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        )
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break
        bytes.push(
          codePoint >> 0x12 | 0xF0,
          codePoint >> 0xC & 0x3F | 0x80,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        )
      } else {
        throw new Error('Invalid code point')
      }
    }

    return bytes
  }

  function asciiToBytes (str) {
    var byteArray = []
    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF)
    }
    return byteArray
  }

  function utf16leToBytes (str, units) {
    var c, hi, lo
    var byteArray = []
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break

      c = str.charCodeAt(i)
      hi = c >> 8
      lo = c % 256
      byteArray.push(lo)
      byteArray.push(hi)
    }

    return byteArray
  }

  function base64ToBytes (str) {
    return base64.toByteArray(base64clean(str))
  }

  function blitBuffer (src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if ((i + offset >= dst.length) || (i >= src.length)) break
      dst[i + offset] = src[i]
    }
    return i
  }

  // ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
  // but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
  function isArrayBuffer (obj) {
    return obj instanceof ArrayBuffer ||
      (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
        typeof obj.byteLength === 'number')
  }

  function numberIsNaN (obj) {
    return obj !== obj // eslint-disable-line no-self-compare
  }

  return exports;

});
define('skylark-browserfs/core/api_error',[
  '../libs/buffers'
],function (buffers) {
    const { Buffer } = buffers;

    /**
     * Standard libc error codes. Add more to this enum and ErrorStrings as they are
     * needed.
     * @url http://www.gnu.org/software/libc/manual/html_node/Error-Codes.html
     */
    var ErrorCode;
    (function (ErrorCode) {
        ErrorCode[ErrorCode["EPERM"] = 1] = "EPERM";
        ErrorCode[ErrorCode["ENOENT"] = 2] = "ENOENT";
        ErrorCode[ErrorCode["EIO"] = 5] = "EIO";
        ErrorCode[ErrorCode["EBADF"] = 9] = "EBADF";
        ErrorCode[ErrorCode["EACCES"] = 13] = "EACCES";
        ErrorCode[ErrorCode["EBUSY"] = 16] = "EBUSY";
        ErrorCode[ErrorCode["EEXIST"] = 17] = "EEXIST";
        ErrorCode[ErrorCode["ENOTDIR"] = 20] = "ENOTDIR";
        ErrorCode[ErrorCode["EISDIR"] = 21] = "EISDIR";
        ErrorCode[ErrorCode["EINVAL"] = 22] = "EINVAL";
        ErrorCode[ErrorCode["EFBIG"] = 27] = "EFBIG";
        ErrorCode[ErrorCode["ENOSPC"] = 28] = "ENOSPC";
        ErrorCode[ErrorCode["EROFS"] = 30] = "EROFS";
        ErrorCode[ErrorCode["ENOTEMPTY"] = 39] = "ENOTEMPTY";
        ErrorCode[ErrorCode["ENOTSUP"] = 95] = "ENOTSUP";
    })(ErrorCode || (ErrorCode = {}));

    /* tslint:disable:variable-name */
    /**
     * Strings associated with each error code.
     * @hidden
     */
    const ErrorStrings = {};
    ErrorStrings[ErrorCode.EPERM] = 'Operation not permitted.';
    ErrorStrings[ErrorCode.ENOENT] = 'No such file or directory.';
    ErrorStrings[ErrorCode.EIO] = 'Input/output error.';
    ErrorStrings[ErrorCode.EBADF] = 'Bad file descriptor.';
    ErrorStrings[ErrorCode.EACCES] = 'Permission denied.';
    ErrorStrings[ErrorCode.EBUSY] = 'Resource busy or locked.';
    ErrorStrings[ErrorCode.EEXIST] = 'File exists.';
    ErrorStrings[ErrorCode.ENOTDIR] = 'File is not a directory.';
    ErrorStrings[ErrorCode.EISDIR] = 'File is a directory.';
    ErrorStrings[ErrorCode.EINVAL] = 'Invalid argument.';
    ErrorStrings[ErrorCode.EFBIG] = 'File is too big.';
    ErrorStrings[ErrorCode.ENOSPC] = 'No space left on disk.';
    ErrorStrings[ErrorCode.EROFS] = 'Cannot modify a read-only file system.';
    ErrorStrings[ErrorCode.ENOTEMPTY] = 'Directory is not empty.';
    ErrorStrings[ErrorCode.ENOTSUP] = 'Operation is not supported.';

    /* tslint:enable:variable-name */
    /**
     * Represents a BrowserFS error. Passed back to applications after a failed
     * call to the BrowserFS API.
     */
    class ApiError extends Error {
        /**
         * Represents a BrowserFS error. Passed back to applications after a failed
         * call to the BrowserFS API.
         *
         * Error codes mirror those returned by regular Unix file operations, which is
         * what Node returns.
         * @constructor ApiError
         * @param type The type of the error.
         * @param [message] A descriptive error message.
         */
        constructor(type, message = ErrorStrings[type], path) {
            super(message);
            // Unsupported.
            this.syscall = "";
            this.errno = type;
            this.code = ErrorCode[type];
            this.path = path;
            this.stack = new Error().stack;
            this.message = `Error: ${this.code}: ${message}${this.path ? `, '${this.path}'` : ''}`;
        }
        static fromJSON(json) {
            const err = new ApiError(0);
            err.errno = json.errno;
            err.code = json.code;
            err.path = json.path;
            err.stack = json.stack;
            err.message = json.message;
            return err;
        }
        /**
         * Creates an ApiError object from a buffer.
         */
        static fromBuffer(buffer, i = 0) {
            return ApiError.fromJSON(JSON.parse(buffer.toString('utf8', i + 4, i + 4 + buffer.readUInt32LE(i))));
        }
        static FileError(code, p) {
            return new ApiError(code, ErrorStrings[code], p);
        }
        static ENOENT(path) {
            return this.FileError(ErrorCode.ENOENT, path);
        }
        static EEXIST(path) {
            return this.FileError(ErrorCode.EEXIST, path);
        }
        static EISDIR(path) {
            return this.FileError(ErrorCode.EISDIR, path);
        }
        static ENOTDIR(path) {
            return this.FileError(ErrorCode.ENOTDIR, path);
        }
        static EPERM(path) {
            return this.FileError(ErrorCode.EPERM, path);
        }
        static ENOTEMPTY(path) {
            return this.FileError(ErrorCode.ENOTEMPTY, path);
        }
        /**
         * @return A friendly error message.
         */
        toString() {
            return this.message;
        }
        toJSON() {
            return {
                errno: this.errno,
                code: this.code,
                path: this.path,
                stack: this.stack,
                message: this.message
            };
        }
        /**
         * Writes the API error into a buffer.
         */
        writeToBuffer(buffer = Buffer.alloc(this.bufferSize()), i = 0) {
            const bytesWritten = buffer.write(JSON.stringify(this.toJSON()), i + 4);
            buffer.writeUInt32LE(bytesWritten, i);
            return buffer;
        }
        /**
         * The size of the API error in buffer-form in bytes.
         */
        bufferSize() {
            // 4 bytes for string length.
            return 4 + Buffer.byteLength(JSON.stringify(this.toJSON()));
        }
    }

    return {
        ApiError,
        ErrorCode,
        ErrorStrings
    };
});
define('skylark-browserfs/core/file_flag',['./api_error'], function (api_error) {
    'use strict';

  const { ErrorCode, ApiError } = api_error;

  var ActionType;
  (function (ActionType) {
      // Indicates that the code should not do anything.
      ActionType[ActionType["NOP"] = 0] = "NOP";
      // Indicates that the code should throw an exception.
      ActionType[ActionType["THROW_EXCEPTION"] = 1] = "THROW_EXCEPTION";
      // Indicates that the code should truncate the file, but only if it is a file.
      ActionType[ActionType["TRUNCATE_FILE"] = 2] = "TRUNCATE_FILE";
      // Indicates that the code should create the file.
      ActionType[ActionType["CREATE_FILE"] = 3] = "CREATE_FILE";
  })(ActionType || (ActionType = {}));
  /**
   * Represents one of the following file flags. A convenience object.
   *
   * * `'r'` - Open file for reading. An exception occurs if the file does not exist.
   * * `'r+'` - Open file for reading and writing. An exception occurs if the file does not exist.
   * * `'rs'` - Open file for reading in synchronous mode. Instructs the filesystem to not cache writes.
   * * `'rs+'` - Open file for reading and writing, and opens the file in synchronous mode.
   * * `'w'` - Open file for writing. The file is created (if it does not exist) or truncated (if it exists).
   * * `'wx'` - Like 'w' but opens the file in exclusive mode.
   * * `'w+'` - Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).
   * * `'wx+'` - Like 'w+' but opens the file in exclusive mode.
   * * `'a'` - Open file for appending. The file is created if it does not exist.
   * * `'ax'` - Like 'a' but opens the file in exclusive mode.
   * * `'a+'` - Open file for reading and appending. The file is created if it does not exist.
   * * `'ax+'` - Like 'a+' but opens the file in exclusive mode.
   *
   * Exclusive mode ensures that the file path is newly created.
   */
  class FileFlag {
      /**
       * This should never be called directly.
       * @param modeStr The string representing the mode
       * @throw when the mode string is invalid
       */
      constructor(flagStr) {
          this.flagStr = flagStr;
          if (FileFlag.validFlagStrs.indexOf(flagStr) < 0) {
              throw new ApiError(ErrorCode.EINVAL, "Invalid flag: " + flagStr);
          }
      }
      /**
       * Get an object representing the given file flag.
       * @param modeStr The string representing the flag
       * @return The FileFlag object representing the flag
       * @throw when the flag string is invalid
       */
      static getFileFlag(flagStr) {
          // Check cache first.
          if (FileFlag.flagCache.hasOwnProperty(flagStr)) {
              return FileFlag.flagCache[flagStr];
          }
          return FileFlag.flagCache[flagStr] = new FileFlag(flagStr);
      }
      /**
       * Get the underlying flag string for this flag.
       */
      getFlagString() {
          return this.flagStr;
      }
      /**
       * Returns true if the file is readable.
       */
      isReadable() {
          return this.flagStr.indexOf('r') !== -1 || this.flagStr.indexOf('+') !== -1;
      }
      /**
       * Returns true if the file is writeable.
       */
      isWriteable() {
          return this.flagStr.indexOf('w') !== -1 || this.flagStr.indexOf('a') !== -1 || this.flagStr.indexOf('+') !== -1;
      }
      /**
       * Returns true if the file mode should truncate.
       */
      isTruncating() {
          return this.flagStr.indexOf('w') !== -1;
      }
      /**
       * Returns true if the file is appendable.
       */
      isAppendable() {
          return this.flagStr.indexOf('a') !== -1;
      }
      /**
       * Returns true if the file is open in synchronous mode.
       */
      isSynchronous() {
          return this.flagStr.indexOf('s') !== -1;
      }
      /**
       * Returns true if the file is open in exclusive mode.
       */
      isExclusive() {
          return this.flagStr.indexOf('x') !== -1;
      }
      /**
       * Returns one of the static fields on this object that indicates the
       * appropriate response to the path existing.
       */
      pathExistsAction() {
          if (this.isExclusive()) {
              return ActionType.THROW_EXCEPTION;
          }
          else if (this.isTruncating()) {
              return ActionType.TRUNCATE_FILE;
          }
          else {
              return ActionType.NOP;
          }
      }
      /**
       * Returns one of the static fields on this object that indicates the
       * appropriate response to the path not existing.
       */
      pathNotExistsAction() {
          if ((this.isWriteable() || this.isAppendable()) && this.flagStr !== 'r+') {
              return ActionType.CREATE_FILE;
          }
          else {
              return ActionType.THROW_EXCEPTION;
          }
      }
  }
  // Contains cached FileMode instances.
  FileFlag.flagCache = {};
  // Array of valid mode strings.
  FileFlag.validFlagStrs = ['r', 'r+', 'rs', 'rs+', 'w', 'wx', 'w+', 'wx+', 'a', 'ax', 'a+', 'ax+'];



    return {
        ActionType: ActionType,
        FileFlag: FileFlag
    };
});
define('skylark-browserfs/libs/path',[],function(){
	var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;

	function posixSplitPath(filename) {
	    var out = splitPathRe.exec(filename);
	    out.shift();
	    return out;
	}
	/**
	 * Emulates Node's `path` module. This module contains utilities for handling and
	 * transforming file paths. **All** of these methods perform only string
	 * transformations. The file system is not consulted to check whether paths are
	 * valid.
	 * @see http://nodejs.org/api/path.html
	 * @class
	 */
	var path = (function () {
	    function path() {
	    }
	    /**
	     * Normalize a string path, taking care of '..' and '.' parts.
	     *
	     * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.
	     * @example Usage example
	     *   path.normalize('/foo/bar//baz/asdf/quux/..')
	     *   // returns
	     *   '/foo/bar/baz/asdf'
	     * @param [String] p The path to normalize.
	     * @return [String]
	     */
	    path.normalize = function (p) {
	        // Special case: '' -> '.'
	        if (p === '') {
	            p = '.';
	        }
	        // It's very important to know if the path is relative or not, since it
	        // changes how we process .. and reconstruct the split string.
	        var absolute = p.charAt(0) === path.sep;
	        // Remove repeated //s
	        p = path._removeDuplicateSeps(p);
	        // Try to remove as many '../' as possible, and remove '.' completely.
	        var components = p.split(path.sep);
	        var goodComponents = [];
	        for (var idx = 0; idx < components.length; idx++) {
	            var c = components[idx];
	            if (c === '.') {
	                continue;
	            }
	            else if (c === '..' && (absolute || (!absolute && goodComponents.length > 0 && goodComponents[0] !== '..'))) {
	                // In the absolute case: Path is relative to root, so we may pop even if
	                // goodComponents is empty (e.g. /../ => /)
	                // In the relative case: We're getting rid of a directory that preceded
	                // it (e.g. /foo/../bar -> /bar)
	                goodComponents.pop();
	            }
	            else {
	                goodComponents.push(c);
	            }
	        }
	        // Add in '.' when it's a relative path with no other nonempty components.
	        // Possible results: '.' and './' (input: [''] or [])
	        // @todo Can probably simplify this logic.
	        if (!absolute && goodComponents.length < 2) {
	            switch (goodComponents.length) {
	                case 1:
	                    if (goodComponents[0] === '') {
	                        goodComponents.unshift('.');
	                    }
	                    break;
	                default:
	                    goodComponents.push('.');
	            }
	        }
	        p = goodComponents.join(path.sep);
	        if (absolute && p.charAt(0) !== path.sep) {
	            p = path.sep + p;
	        }
	        return p;
	    };
	    /**
	     * Join all arguments together and normalize the resulting path.
	     *
	     * Arguments must be strings.
	     * @example Usage
	     *   path.join('/foo', 'bar', 'baz/asdf', 'quux', '..')
	     *   // returns
	     *   '/foo/bar/baz/asdf'
	     *
	     *   path.join('foo', {}, 'bar')
	     *   // throws exception
	     *   TypeError: Arguments to path.join must be strings
	     * @param [String,...] paths Each component of the path
	     * @return [String]
	     */
	    path.join = function () {
	        var paths = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            paths[_i - 0] = arguments[_i];
	        }
	        // Required: Prune any non-strings from the path. I also prune empty segments
	        // so we can do a simple join of the array.
	        var processed = [];
	        for (var i = 0; i < paths.length; i++) {
	            var segment = paths[i];
	            if (typeof segment !== 'string') {
	                throw new TypeError("Invalid argument type to path.join: " + (typeof segment));
	            }
	            else if (segment !== '') {
	                processed.push(segment);
	            }
	        }
	        return path.normalize(processed.join(path.sep));
	    };
	    /**
	     * Resolves to to an absolute path.
	     *
	     * If to isn't already absolute from arguments are prepended in right to left
	     * order, until an absolute path is found. If after using all from paths still
	     * no absolute path is found, the current working directory is used as well.
	     * The resulting path is normalized, and trailing slashes are removed unless
	     * the path gets resolved to the root directory. Non-string arguments are
	     * ignored.
	     *
	     * Another way to think of it is as a sequence of cd commands in a shell.
	     *
	     *     path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile')
	     *
	     * Is similar to:
	     *
	     *     cd foo/bar
	     *     cd /tmp/file/
	     *     cd ..
	     *     cd a/../subfile
	     *     pwd
	     *
	     * The difference is that the different paths don't need to exist and may also
	     * be files.
	     * @example Usage example
	     *   path.resolve('/foo/bar', './baz')
	     *   // returns
	     *   '/foo/bar/baz'
	     *
	     *   path.resolve('/foo/bar', '/tmp/file/')
	     *   // returns
	     *   '/tmp/file'
	     *
	     *   path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')
	     *   // if currently in /home/myself/node, it returns
	     *   '/home/myself/node/wwwroot/static_files/gif/image.gif'
	     * @param [String,...] paths
	     * @return [String]
	     */
	    path.resolve = function () {
	        var paths = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            paths[_i - 0] = arguments[_i];
	        }
	        // Monitor for invalid paths, throw out empty paths, and look for the *last*
	        // absolute path that we see.
	        var processed = [];
	        for (var i = 0; i < paths.length; i++) {
	            var p = paths[i];
	            if (typeof p !== 'string') {
	                throw new TypeError("Invalid argument type to path.join: " + (typeof p));
	            }
	            else if (p !== '') {
	                // Remove anything that has occurred before this absolute path, as it
	                // doesn't matter.
	                if (p.charAt(0) === path.sep) {
	                    processed = [];
	                }
	                processed.push(p);
	            }
	        }
	        // Special: Remove trailing slash unless it's the root
	        var resolved = path.normalize(processed.join(path.sep));
	        if (resolved.length > 1 && resolved.charAt(resolved.length - 1) === path.sep) {
	            return resolved.substr(0, resolved.length - 1);
	        }
	        // Special: If it doesn't start with '/', it's relative and we need to append
	        // the current directory.
	        if (resolved.charAt(0) !== path.sep) {
	            // Remove ./, since we're going to append the current directory.
	            if (resolved.charAt(0) === '.' && (resolved.length === 1 || resolved.charAt(1) === path.sep)) {
	                resolved = resolved.length === 1 ? '' : resolved.substr(2);
	            }
	            // Append the current directory, which *must* be an absolute path.
	            var cwd = process.cwd();
	            if (resolved !== '') {
	                // cwd will never end in a /... unless it's the root.
	                resolved = this.normalize(cwd + (cwd !== '/' ? path.sep : '') + resolved);
	            }
	            else {
	                resolved = cwd;
	            }
	        }
	        return resolved;
	    };
	    /**
	     * Solve the relative path from from to to.
	     *
	     * At times we have two absolute paths, and we need to derive the relative path
	     * from one to the other. This is actually the reverse transform of
	     * path.resolve, which means we see that:
	     *
	     *    path.resolve(from, path.relative(from, to)) == path.resolve(to)
	     *
	     * @example Usage example
	     *   path.relative('C:\\orandea\\test\\aaa', 'C:\\orandea\\impl\\bbb')
	     *   // returns
	     *   '..\\..\\impl\\bbb'
	     *
	     *   path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')
	     *   // returns
	     *   '../../impl/bbb'
	     * @param [String] from
	     * @param [String] to
	     * @return [String]
	     */
	    path.relative = function (from, to) {
	        var i;
	        // Alright. Let's resolve these two to absolute paths and remove any
	        // weirdness.
	        from = path.resolve(from);
	        to = path.resolve(to);
	        var fromSegs = from.split(path.sep);
	        var toSegs = to.split(path.sep);
	        // Remove the first segment on both, as it's '' (both are absolute paths)
	        toSegs.shift();
	        fromSegs.shift();
	        // There are two segments to this path:
	        // * Going *up* the directory hierarchy with '..'
	        // * Going *down* the directory hierarchy with foo/baz/bat.
	        var upCount = 0;
	        var downSegs = [];
	        // Figure out how many things in 'from' are shared with 'to'.
	        for (i = 0; i < fromSegs.length; i++) {
	            var seg = fromSegs[i];
	            if (seg === toSegs[i]) {
	                continue;
	            }
	            // The rest of 'from', including the current element, indicates how many
	            // directories we need to go up.
	            upCount = fromSegs.length - i;
	            break;
	        }
	        // The rest of 'to' indicates where we need to change to. We place this
	        // outside of the loop, as toSegs.length may be greater than fromSegs.length.
	        downSegs = toSegs.slice(i);
	        // Special case: If 'from' is '/'
	        if (fromSegs.length === 1 && fromSegs[0] === '') {
	            upCount = 0;
	        }
	        // upCount can't be greater than the number of fromSegs
	        // (cd .. from / is still /)
	        if (upCount > fromSegs.length) {
	            upCount = fromSegs.length;
	        }
	        // Create the final string!
	        var rv = '';
	        for (i = 0; i < upCount; i++) {
	            rv += '../';
	        }
	        rv += downSegs.join(path.sep);
	        // Special case: Remove trailing '/'. Happens if it's all up and no down.
	        if (rv.length > 1 && rv.charAt(rv.length - 1) === path.sep) {
	            rv = rv.substr(0, rv.length - 1);
	        }
	        return rv;
	    };
	    /**
	     * Return the directory name of a path. Similar to the Unix `dirname` command.
	     *
	     * Note that BrowserFS does not validate if the path is actually a valid
	     * directory.
	     * @example Usage example
	     *   path.dirname('/foo/bar/baz/asdf/quux')
	     *   // returns
	     *   '/foo/bar/baz/asdf'
	     * @param [String] p The path to get the directory name of.
	     * @return [String]
	     */
	    path.dirname = function (p) {
	        // We get rid of //, but we don't modify anything else (e.g. any extraneous .
	        // and ../ are kept intact)
	        p = path._removeDuplicateSeps(p);
	        var absolute = p.charAt(0) === path.sep;
	        var sections = p.split(path.sep);
	        // Do 1 if it's /foo/bar, 2 if it's /foo/bar/
	        if (sections.pop() === '' && sections.length > 0) {
	            sections.pop();
	        }
	        // # of sections needs to be > 1 if absolute, since the first section is '' for '/'.
	        // If not absolute, the first section is the first part of the path, and is OK
	        // to return.
	        if (sections.length > 1 || (sections.length === 1 && !absolute)) {
	            return sections.join(path.sep);
	        }
	        else if (absolute) {
	            return path.sep;
	        }
	        else {
	            return '.';
	        }
	    };
	    /**
	     * Return the last portion of a path. Similar to the Unix basename command.
	     * @example Usage example
	     *   path.basename('/foo/bar/baz/asdf/quux.html')
	     *   // returns
	     *   'quux.html'
	     *
	     *   path.basename('/foo/bar/baz/asdf/quux.html', '.html')
	     *   // returns
	     *   'quux'
	     * @param [String] p
	     * @param [String?] ext
	     * @return [String]
	     */
	    path.basename = function (p, ext) {
	        if (ext === void 0) { ext = ""; }
	        // Special case: Normalize will modify this to '.'
	        if (p === '') {
	            return p;
	        }
	        // Normalize the string first to remove any weirdness.
	        p = path.normalize(p);
	        // Get the last part of the string.
	        var sections = p.split(path.sep);
	        var lastPart = sections[sections.length - 1];
	        // Special case: If it's empty, then we have a string like so: foo/
	        // Meaning, 'foo' is guaranteed to be a directory.
	        if (lastPart === '' && sections.length > 1) {
	            return sections[sections.length - 2];
	        }
	        // Remove the extension, if need be.
	        if (ext.length > 0) {
	            var lastPartExt = lastPart.substr(lastPart.length - ext.length);
	            if (lastPartExt === ext) {
	                return lastPart.substr(0, lastPart.length - ext.length);
	            }
	        }
	        return lastPart;
	    };
	    /**
	     * Return the extension of the path, from the last '.' to end of string in the
	     * last portion of the path. If there is no '.' in the last portion of the path
	     * or the first character of it is '.', then it returns an empty string.
	     * @example Usage example
	     *   path.extname('index.html')
	     *   // returns
	     *   '.html'
	     *
	     *   path.extname('index.')
	     *   // returns
	     *   '.'
	     *
	     *   path.extname('index')
	     *   // returns
	     *   ''
	     * @param [String] p
	     * @return [String]
	     */
	    path.extname = function (p) {
	        p = path.normalize(p);
	        var sections = p.split(path.sep);
	        p = sections.pop();
	        // Special case: foo/file.ext/ should return '.ext'
	        if (p === '' && sections.length > 0) {
	            p = sections.pop();
	        }
	        if (p === '..') {
	            return '';
	        }
	        var i = p.lastIndexOf('.');
	        if (i === -1 || i === 0) {
	            return '';
	        }
	        return p.substr(i);
	    };
	    /**
	     * Checks if the given path is an absolute path.
	     *
	     * Despite not being documented, this is a tested part of Node's path API.
	     * @param [String] p
	     * @return [Boolean] True if the path appears to be an absolute path.
	     */
	    path.isAbsolute = function (p) {
	        return p.length > 0 && p.charAt(0) === path.sep;
	    };
	    /**
	     * Unknown. Undocumented.
	     */
	    path._makeLong = function (p) {
	        return p;
	    };
	    /**
	     * Returns an object from a path string.
	     */
	    path.parse = function (p) {
	        var allParts = posixSplitPath(p);
	        return {
	            root: allParts[0],
	            dir: allParts[0] + allParts[1].slice(0, -1),
	            base: allParts[2],
	            ext: allParts[3],
	            name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
	        };
	    };
	    path.format = function (pathObject) {
	        if (pathObject === null || typeof pathObject !== 'object') {
	            throw new TypeError("Parameter 'pathObject' must be an object, not " + typeof pathObject);
	        }
	        var root = pathObject.root || '';
	        if (typeof root !== 'string') {
	            throw new TypeError("'pathObject.root' must be a string or undefined, not " +
	                typeof pathObject.root);
	        }
	        var dir = pathObject.dir ? pathObject.dir + path.sep : '';
	        var base = pathObject.base || '';
	        return dir + base;
	    };
	    path._removeDuplicateSeps = function (p) {
	        p = p.replace(this._replaceRegex, this.sep);
	        return p;
	    };
	    // The platform-specific file separator. BrowserFS uses `/`.
	    path.sep = '/';
	    path._replaceRegex = new RegExp("//+", 'g');
	    // The platform-specific path delimiter. BrowserFS uses `:`.
	    path.delimiter = ':';
	    path.posix = path;
	    // XXX: Typing hack. We don't actually support win32.
	    path.win32 = path;
	    return path;
	}());


	return path;
});
define('skylark-browserfs/core/node_fs_stats',[
    '../libs/buffers'
],function (buffers) {
    'use strict';
    const { Buffer } = buffers;

    /**
     * Indicates the type of the given file. Applied to 'mode'.
     */
    var FileType;
    (function (FileType) {
        FileType[FileType["FILE"] = 32768] = "FILE";
        FileType[FileType["DIRECTORY"] = 16384] = "DIRECTORY";
        FileType[FileType["SYMLINK"] = 40960] = "SYMLINK";
    })(FileType || (FileType = {}));

    /**
     * Emulation of Node's `fs.Stats` object.
     *
     * Attribute descriptions are from `man 2 stat'
     * @see http://nodejs.org/api/fs.html#fs_class_fs_stats
     * @see http://man7.org/linux/man-pages/man2/stat.2.html
     */
    class Stats {
        /**
         * Provides information about a particular entry in the file system.
         * @param itemType Type of the item (FILE, DIRECTORY, SYMLINK, or SOCKET)
         * @param size Size of the item in bytes. For directories/symlinks,
         *   this is normally the size of the struct that represents the item.
         * @param mode Unix-style file mode (e.g. 0o644)
         * @param atimeMs time of last access, in milliseconds since epoch
         * @param mtimeMs time of last modification, in milliseconds since epoch
         * @param ctimeMs time of last time file status was changed, in milliseconds since epoch
         * @param birthtimeMs time of file creation, in milliseconds since epoch
         */
        constructor(itemType, size, mode, atimeMs, mtimeMs, ctimeMs, birthtimeMs) {
            /**
             * UNSUPPORTED ATTRIBUTES
             * I assume no one is going to need these details, although we could fake
             * appropriate values if need be.
             */
            // ID of device containing file
            this.dev = 0;
            // inode number
            this.ino = 0;
            // device ID (if special file)
            this.rdev = 0;
            // number of hard links
            this.nlink = 1;
            // blocksize for file system I/O
            this.blksize = 4096;
            // @todo Maybe support these? atm, it's a one-user filesystem.
            // user ID of owner
            this.uid = 0;
            // group ID of owner
            this.gid = 0;
            // XXX: Some file systems stash data on stats objects.
            this.fileData = null;
            this.size = size;
            let currentTime = 0;
            if (typeof (atimeMs) !== 'number') {
                currentTime = Date.now();
                atimeMs = currentTime;
            }
            if (typeof (mtimeMs) !== 'number') {
                if (!currentTime) {
                    currentTime = Date.now();
                }
                mtimeMs = currentTime;
            }
            if (typeof (ctimeMs) !== 'number') {
                if (!currentTime) {
                    currentTime = Date.now();
                }
                ctimeMs = currentTime;
            }
            if (typeof (birthtimeMs) !== 'number') {
                if (!currentTime) {
                    currentTime = Date.now();
                }
                birthtimeMs = currentTime;
            }
            this.atimeMs = atimeMs;
            this.ctimeMs = ctimeMs;
            this.mtimeMs = mtimeMs;
            this.birthtimeMs = birthtimeMs;
            if (!mode) {
                switch (itemType) {
                    case FileType.FILE:
                        this.mode = 0x1a4;
                        break;
                    case FileType.DIRECTORY:
                    default:
                        this.mode = 0x1ff;
                }
            }
            else {
                this.mode = mode;
            }
            // number of 512B blocks allocated
            this.blocks = Math.ceil(size / 512);
            // Check if mode also includes top-most bits, which indicate the file's
            // type.
            if (this.mode < 0x1000) {
                this.mode |= itemType;
            }
        }
        static fromBuffer(buffer) {
            const size = buffer.readUInt32LE(0), mode = buffer.readUInt32LE(4), atime = buffer.readDoubleLE(8), mtime = buffer.readDoubleLE(16), ctime = buffer.readDoubleLE(24);
            return new Stats(mode & 0xF000, size, mode & 0xFFF, atime, mtime, ctime);
        }
        /**
         * Clones the stats object.
         */
        static clone(s) {
            return new Stats(s.mode & 0xF000, s.size, s.mode & 0xFFF, s.atimeMs, s.mtimeMs, s.ctimeMs, s.birthtimeMs);
        }
        get atime() {
            return new Date(this.atimeMs);
        }
        get mtime() {
            return new Date(this.mtimeMs);
        }
        get ctime() {
            return new Date(this.ctimeMs);
        }
        get birthtime() {
            return new Date(this.birthtimeMs);
        }
        toBuffer() {
            const buffer = Buffer.alloc(32);
            buffer.writeUInt32LE(this.size, 0);
            buffer.writeUInt32LE(this.mode, 4);
            buffer.writeDoubleLE(this.atime.getTime(), 8);
            buffer.writeDoubleLE(this.mtime.getTime(), 16);
            buffer.writeDoubleLE(this.ctime.getTime(), 24);
            return buffer;
        }
        /**
         * @return [Boolean] True if this item is a file.
         */
        isFile() {
            return (this.mode & 0xF000) === FileType.FILE;
        }
        /**
         * @return [Boolean] True if this item is a directory.
         */
        isDirectory() {
            return (this.mode & 0xF000) === FileType.DIRECTORY;
        }
        /**
         * @return [Boolean] True if this item is a symbolic link (only valid through lstat)
         */
        isSymbolicLink() {
            return (this.mode & 0xF000) === FileType.SYMLINK;
        }
        /**
         * Change the mode of the file. We use this helper function to prevent messing
         * up the type of the file, which is encoded in mode.
         */
        chmod(mode) {
            this.mode = (this.mode & 0xF000) | mode;
        }
        // We don't support the following types of files.
        isSocket() {
            return false;
        }
        isBlockDevice() {
            return false;
        }
        isCharacterDevice() {
            return false;
        }
        isFIFO() {
            return false;
        }
    }


    return {
        FileType,
        Stats
    }
});
define('skylark-browserfs/core/global',[],function () {
    'use strict';
    const toExport = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : global;
    return toExport;
});
define('skylark-browserfs/generic/setImmediate',['../core/global'], function (global) {
    'use strict';
    /**
     * @hidden
     */
    let bfsSetImmediate;
    if (typeof (setImmediate) !== "undefined") {
        bfsSetImmediate = setImmediate;
    }
    else {
        const gScope = global;
        const timeouts = [];
        const messageName = "zero-timeout-message";
        const canUsePostMessage = function () {
            if (typeof gScope.importScripts !== 'undefined' || !gScope.postMessage) {
                return false;
            }
            let postMessageIsAsync = true;
            const oldOnMessage = gScope.onmessage;
            gScope.onmessage = function () {
                postMessageIsAsync = false;
            };
            gScope.postMessage('', '*');
            gScope.onmessage = oldOnMessage;
            return postMessageIsAsync;
        };
        if (canUsePostMessage()) {
            bfsSetImmediate = function (fn) {
                timeouts.push(fn);
                gScope.postMessage(messageName, "*");
            };
            const handleMessage = function (event) {
                if (event.source === self && event.data === messageName) {
                    if (event.stopPropagation) {
                        event.stopPropagation();
                    }
                    else {
                        event.cancelBubble = true;
                    }
                    if (timeouts.length > 0) {
                        const fn = timeouts.shift();
                        return fn();
                    }
                }
            };
            if (gScope.addEventListener) {
                gScope.addEventListener('message', handleMessage, true);
            }
            else {
                gScope.attachEvent('onmessage', handleMessage);
            }
        }
        else if (gScope.MessageChannel) {
            // WebWorker MessageChannel
            const channel = new gScope.MessageChannel();
            channel.port1.onmessage = (event) => {
                if (timeouts.length > 0) {
                    return timeouts.shift()();
                }
            };
            bfsSetImmediate = (fn) => {
                timeouts.push(fn);
                channel.port2.postMessage('');
            };
        }
        else {
            bfsSetImmediate = function (fn) {
                return setTimeout(fn, 0);
            };
        }
    }

    return bfsSetImmediate;
});
define('skylark-browserfs/core/FS',[
    '../libs/buffers',
    './api_error',
    './file_flag',
    '../libs/path',
    './node_fs_stats',
    '../generic/setImmediate'
], function (buffers,api_error, file_flag, path, node_fs_stats, setImmediate) {
    'use strict';

    const { ApiError, ErrorCode } = api_error;
    const { FileFlag } = file_flag;
    const {Stats} = node_fs_stats;
    const { Buffer } = buffers;

    /** Used for unit testing. Defaults to a NOP. */
    let wrapCbHook = function (cb, numArgs) {
        return cb;
    };
    /**
     * Wraps a callback function, ensuring it is invoked through setImmediate.
     * @hidden
     */
    function wrapCb(cb, numArgs) {
        if (typeof cb !== 'function') {
            throw new Error('Callback must be a function.');
        }
        const hookedCb = wrapCbHook(cb, numArgs);
        // We could use `arguments`, but Function.call/apply is expensive. And we only
        // need to handle 1-3 arguments
        switch (numArgs) {
            case 1:
                return function (arg1) {
                    setImmediate(function () {
                        return hookedCb(arg1);
                    });
                };
            case 2:
                return function (arg1, arg2) {
                    setImmediate(function () {
                        return hookedCb(arg1, arg2);
                    });
                };
            case 3:
                return function (arg1, arg2, arg3) {
                    setImmediate(function () {
                        return hookedCb(arg1, arg2, arg3);
                    });
                };
            default:
                throw new Error('Invalid invocation of wrapCb.');
        }
    }
    /**
     * @hidden
     */
    function assertRoot(fs) {
        if (fs) {
            return fs;
        }
        throw new ApiError(ErrorCode.EIO, `Initialize BrowserFS with a file system using BrowserFS.initialize(filesystem)`);
    }
    /**
     * @hidden
     */
    function normalizeMode(mode, def) {
        switch (typeof mode) {
            case 'number':
                // (path, flag, mode, cb?)
                return mode;
            case 'string':
                // (path, flag, modeString, cb?)
                const trueMode = parseInt(mode, 8);
                if (!isNaN(trueMode)) {
                    return trueMode;
                }
                // Invalid string.
                return def;
            default:
                return def;
        }
    }
    /**
     * @hidden
     */
    function normalizeTime(time) {
        if (time instanceof Date) {
            return time;
        }
        else if (typeof time === 'number') {
            return new Date(time * 1000);
        }
        else {
            throw new ApiError(ErrorCode.EINVAL, `Invalid time.`);
        }
    }
    /**
     * @hidden
     */
    function normalizePath(p) {
        // Node doesn't allow null characters in paths.
        if (p.indexOf('\u0000') >= 0) {
            throw new ApiError(ErrorCode.EINVAL, 'Path must be a string without null bytes.');
        }
        else if (p === '') {
            throw new ApiError(ErrorCode.EINVAL, 'Path must not be empty.');
        }
        return path.resolve(p);
    }
    /**
     * @hidden
     */
    function normalizeOptions(options, defEnc, defFlag, defMode) {
        // typeof null === 'object' so special-case handing is needed.
        switch (options === null ? 'null' : typeof options) {
            case 'object':
                return {
                    encoding: typeof options['encoding'] !== 'undefined' ? options['encoding'] : defEnc,
                    flag: typeof options['flag'] !== 'undefined' ? options['flag'] : defFlag,
                    mode: normalizeMode(options['mode'], defMode)
                };
            case 'string':
                return {
                    encoding: options,
                    flag: defFlag,
                    mode: defMode
                };
            case 'null':
            case 'undefined':
            case 'function':
                return {
                    encoding: defEnc,
                    flag: defFlag,
                    mode: defMode
                };
            default:
                throw new TypeError(`"options" must be a string or an object, got ${typeof options} instead.`);
        }
    }
    /**
     * The default callback is a NOP.
     * @hidden
     * @private
     */
    function nopCb() {
        // NOP.
    }
    /**
     * The node frontend to all filesystems.
     * This layer handles:
     *
     * * Sanity checking inputs.
     * * Normalizing paths.
     * * Resetting stack depth for asynchronous operations which may not go through
     *   the browser by wrapping all input callbacks using `setImmediate`.
     * * Performing the requested operation through the filesystem or the file
     *   descriptor, as appropriate.
     * * Handling optional arguments and setting default arguments.
     * @see http://nodejs.org/api/fs.html
     */
    class FS {
        constructor() {
            /* tslint:enable:variable-name */
            this.F_OK = 0;
            this.R_OK = 4;
            this.W_OK = 2;
            this.X_OK = 1;
            this.root = null;
            this.fdMap = {};
            this.nextFd = 100;
        }
        initialize(rootFS) {
            if (!rootFS.constructor.isAvailable()) {
                throw new ApiError(ErrorCode.EINVAL, 'Tried to instantiate BrowserFS with an unavailable file system.');
            }
            return this.root = rootFS;
        }
        /**
         * converts Date or number to a fractional UNIX timestamp
         * Grabbed from NodeJS sources (lib/fs.js)
         */
        _toUnixTimestamp(time) {
            if (typeof time === 'number') {
                return time;
            }
            else if (time instanceof Date) {
                return time.getTime() / 1000;
            }
            throw new Error("Cannot parse time: " + time);
        }
        /**
         * **NONSTANDARD**: Grab the FileSystem instance that backs this API.
         * @return [BrowserFS.FileSystem | null] Returns null if the file system has
         *   not been initialized.
         */
        getRootFS() {
            if (this.root) {
                return this.root;
            }
            else {
                return null;
            }
        }
        // FILE OR DIRECTORY METHODS
        /**
         * Asynchronous rename. No arguments other than a possible exception are given
         * to the completion callback.
         * @param oldPath
         * @param newPath
         * @param callback
         */
        rename(oldPath, newPath, cb = nopCb) {
            const newCb = wrapCb(cb, 1);
            try {
                assertRoot(this.root).rename(normalizePath(oldPath), normalizePath(newPath), newCb);
            }
            catch (e) {
                newCb(e);
            }
        }
        /**
         * Synchronous rename.
         * @param oldPath
         * @param newPath
         */
        renameSync(oldPath, newPath) {
            assertRoot(this.root).renameSync(normalizePath(oldPath), normalizePath(newPath));
        }
        /**
         * Test whether or not the given path exists by checking with the file system.
         * Then call the callback argument with either true or false.
         * @example Sample invocation
         *   fs.exists('/etc/passwd', function (exists) {
         *     util.debug(exists ? "it's there" : "no passwd!");
         *   });
         * @param path
         * @param callback
         */
        exists(path, cb = nopCb) {
            const newCb = wrapCb(cb, 1);
            try {
                return assertRoot(this.root).exists(normalizePath(path), newCb);
            }
            catch (e) {
                // Doesn't return an error. If something bad happens, we assume it just
                // doesn't exist.
                return newCb(false);
            }
        }
        /**
         * Test whether or not the given path exists by checking with the file system.
         * @param path
         * @return [boolean]
         */
        existsSync(path) {
            try {
                return assertRoot(this.root).existsSync(normalizePath(path));
            }
            catch (e) {
                // Doesn't return an error. If something bad happens, we assume it just
                // doesn't exist.
                return false;
            }
        }
        /**
         * Asynchronous `stat`.
         * @param path
         * @param callback
         */
        stat(path, cb = nopCb) {
            const newCb = wrapCb(cb, 2);
            try {
                return assertRoot(this.root).stat(normalizePath(path), false, newCb);
            }
            catch (e) {
                return newCb(e);
            }
        }
        /**
         * Synchronous `stat`.
         * @param path
         * @return [BrowserFS.node.fs.Stats]
         */
        statSync(path) {
            return assertRoot(this.root).statSync(normalizePath(path), false);
        }
        /**
         * Asynchronous `lstat`.
         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,
         * then the link itself is stat-ed, not the file that it refers to.
         * @param path
         * @param callback
         */
        lstat(path, cb = nopCb) {
            const newCb = wrapCb(cb, 2);
            try {
                return assertRoot(this.root).stat(normalizePath(path), true, newCb);
            }
            catch (e) {
                return newCb(e);
            }
        }
        /**
         * Synchronous `lstat`.
         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,
         * then the link itself is stat-ed, not the file that it refers to.
         * @param path
         * @return [BrowserFS.node.fs.Stats]
         */
        lstatSync(path) {
            return assertRoot(this.root).statSync(normalizePath(path), true);
        }
        truncate(path, arg2 = 0, cb = nopCb) {
            let len = 0;
            if (typeof arg2 === 'function') {
                cb = arg2;
            }
            else if (typeof arg2 === 'number') {
                len = arg2;
            }
            const newCb = wrapCb(cb, 1);
            try {
                if (len < 0) {
                    throw new ApiError(ErrorCode.EINVAL);
                }
                return assertRoot(this.root).truncate(normalizePath(path), len, newCb);
            }
            catch (e) {
                return newCb(e);
            }
        }
        /**
         * Synchronous `truncate`.
         * @param path
         * @param len
         */
        truncateSync(path, len = 0) {
            if (len < 0) {
                throw new ApiError(ErrorCode.EINVAL);
            }
            return assertRoot(this.root).truncateSync(normalizePath(path), len);
        }
        /**
         * Asynchronous `unlink`.
         * @param path
         * @param callback
         */
        unlink(path, cb = nopCb) {
            const newCb = wrapCb(cb, 1);
            try {
                return assertRoot(this.root).unlink(normalizePath(path), newCb);
            }
            catch (e) {
                return newCb(e);
            }
        }
        /**
         * Synchronous `unlink`.
         * @param path
         */
        unlinkSync(path) {
            return assertRoot(this.root).unlinkSync(normalizePath(path));
        }
        open(path, flag, arg2, cb = nopCb) {
            const mode = normalizeMode(arg2, 0x1a4);
            cb = typeof arg2 === 'function' ? arg2 : cb;
            const newCb = wrapCb(cb, 2);
            try {
                assertRoot(this.root).open(normalizePath(path), FileFlag.getFileFlag(flag), mode, (e, file) => {
                    if (file) {
                        newCb(e, this.getFdForFile(file));
                    }
                    else {
                        newCb(e);
                    }
                });
            }
            catch (e) {
                newCb(e);
            }
        }
        /**
         * Synchronous file open.
         * @see http://www.manpagez.com/man/2/open/
         * @param path
         * @param flags
         * @param mode defaults to `0644`
         * @return [BrowserFS.File]
         */
        openSync(path, flag, mode = 0x1a4) {
            return this.getFdForFile(assertRoot(this.root).openSync(normalizePath(path), FileFlag.getFileFlag(flag), normalizeMode(mode, 0x1a4)));
        }
        readFile(filename, arg2 = {}, cb = nopCb) {
            const options = normalizeOptions(arg2, null, 'r', null);
            cb = typeof arg2 === 'function' ? arg2 : cb;
            const newCb = wrapCb(cb, 2);
            try {
                const flag = FileFlag.getFileFlag(options['flag']);
                if (!flag.isReadable()) {
                    return newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to readFile must allow for reading.'));
                }
                return assertRoot(this.root).readFile(normalizePath(filename), options.encoding, flag, newCb);
            }
            catch (e) {
                return newCb(e);
            }
        }
        readFileSync(filename, arg2 = {}) {
            const options = normalizeOptions(arg2, null, 'r', null);
            const flag = FileFlag.getFileFlag(options.flag);
            if (!flag.isReadable()) {
                throw new ApiError(ErrorCode.EINVAL, 'Flag passed to readFile must allow for reading.');
            }
            return assertRoot(this.root).readFileSync(normalizePath(filename), options.encoding, flag);
        }
        writeFile(filename, data, arg3 = {}, cb = nopCb) {
            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);
            cb = typeof arg3 === 'function' ? arg3 : cb;
            const newCb = wrapCb(cb, 1);
            try {
                const flag = FileFlag.getFileFlag(options.flag);
                if (!flag.isWriteable()) {
                    return newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to writeFile must allow for writing.'));
                }
                return assertRoot(this.root).writeFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);
            }
            catch (e) {
                return newCb(e);
            }
        }
        writeFileSync(filename, data, arg3) {
            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);
            const flag = FileFlag.getFileFlag(options.flag);
            if (!flag.isWriteable()) {
                throw new ApiError(ErrorCode.EINVAL, 'Flag passed to writeFile must allow for writing.');
            }
            return assertRoot(this.root).writeFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);
        }
        appendFile(filename, data, arg3, cb = nopCb) {
            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);
            cb = typeof arg3 === 'function' ? arg3 : cb;
            const newCb = wrapCb(cb, 1);
            try {
                const flag = FileFlag.getFileFlag(options.flag);
                if (!flag.isAppendable()) {
                    return newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to appendFile must allow for appending.'));
                }
                assertRoot(this.root).appendFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);
            }
            catch (e) {
                newCb(e);
            }
        }
        appendFileSync(filename, data, arg3) {
            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);
            const flag = FileFlag.getFileFlag(options.flag);
            if (!flag.isAppendable()) {
                throw new ApiError(ErrorCode.EINVAL, 'Flag passed to appendFile must allow for appending.');
            }
            return assertRoot(this.root).appendFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);
        }
        // FILE DESCRIPTOR METHODS
        /**
         * Asynchronous `fstat`.
         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is
         * specified by the file descriptor `fd`.
         * @param fd
         * @param callback
         */
        fstat(fd, cb = nopCb) {
            const newCb = wrapCb(cb, 2);
            try {
                const file = this.fd2file(fd);
                file.stat(newCb);
            }
            catch (e) {
                newCb(e);
            }
        }
        /**
         * Synchronous `fstat`.
         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is
         * specified by the file descriptor `fd`.
         * @param fd
         * @return [BrowserFS.node.fs.Stats]
         */
        fstatSync(fd) {
            return this.fd2file(fd).statSync();
        }
        /**
         * Asynchronous close.
         * @param fd
         * @param callback
         */
        close(fd, cb = nopCb) {
            const newCb = wrapCb(cb, 1);
            try {
                this.fd2file(fd).close((e) => {
                    if (!e) {
                        this.closeFd(fd);
                    }
                    newCb(e);
                });
            }
            catch (e) {
                newCb(e);
            }
        }
        /**
         * Synchronous close.
         * @param fd
         */
        closeSync(fd) {
            this.fd2file(fd).closeSync();
            this.closeFd(fd);
        }
        ftruncate(fd, arg2, cb = nopCb) {
            const length = typeof arg2 === 'number' ? arg2 : 0;
            cb = typeof arg2 === 'function' ? arg2 : cb;
            const newCb = wrapCb(cb, 1);
            try {
                const file = this.fd2file(fd);
                if (length < 0) {
                    throw new ApiError(ErrorCode.EINVAL);
                }
                file.truncate(length, newCb);
            }
            catch (e) {
                newCb(e);
            }
        }
        /**
         * Synchronous ftruncate.
         * @param fd
         * @param len
         */
        ftruncateSync(fd, len = 0) {
            const file = this.fd2file(fd);
            if (len < 0) {
                throw new ApiError(ErrorCode.EINVAL);
            }
            file.truncateSync(len);
        }
        /**
         * Asynchronous fsync.
         * @param fd
         * @param callback
         */
        fsync(fd, cb = nopCb) {
            const newCb = wrapCb(cb, 1);
            try {
                this.fd2file(fd).sync(newCb);
            }
            catch (e) {
                newCb(e);
            }
        }
        /**
         * Synchronous fsync.
         * @param fd
         */
        fsyncSync(fd) {
            this.fd2file(fd).syncSync();
        }
        /**
         * Asynchronous fdatasync.
         * @param fd
         * @param callback
         */
        fdatasync(fd, cb = nopCb) {
            const newCb = wrapCb(cb, 1);
            try {
                this.fd2file(fd).datasync(newCb);
            }
            catch (e) {
                newCb(e);
            }
        }
        /**
         * Synchronous fdatasync.
         * @param fd
         */
        fdatasyncSync(fd) {
            this.fd2file(fd).datasyncSync();
        }
        write(fd, arg2, arg3, arg4, arg5, cb = nopCb) {
            let buffer, offset, length, position = null;
            if (typeof arg2 === 'string') {
                // Signature 1: (fd, string, [position?, [encoding?]], cb?)
                let encoding = 'utf8';
                switch (typeof arg3) {
                    case 'function':
                        // (fd, string, cb)
                        cb = arg3;
                        break;
                    case 'number':
                        // (fd, string, position, encoding?, cb?)
                        position = arg3;
                        encoding = typeof arg4 === 'string' ? arg4 : 'utf8';
                        cb = typeof arg5 === 'function' ? arg5 : cb;
                        break;
                    default:
                        // ...try to find the callback and get out of here!
                        cb = typeof arg4 === 'function' ? arg4 : typeof arg5 === 'function' ? arg5 : cb;
                        return cb(new ApiError(ErrorCode.EINVAL, 'Invalid arguments.'));
                }
                buffer = Buffer.from(arg2, encoding);
                offset = 0;
                length = buffer.length;
            }
            else {
                // Signature 2: (fd, buffer, offset, length, position?, cb?)
                buffer = arg2;
                offset = arg3;
                length = arg4;
                position = typeof arg5 === 'number' ? arg5 : null;
                cb = typeof arg5 === 'function' ? arg5 : cb;
            }
            const newCb = wrapCb(cb, 3);
            try {
                const file = this.fd2file(fd);
                if (position === undefined || position === null) {
                    position = file.getPos();
                }
                file.write(buffer, offset, length, position, newCb);
            }
            catch (e) {
                newCb(e);
            }
        }
        writeSync(fd, arg2, arg3, arg4, arg5) {
            let buffer, offset = 0, length, position;
            if (typeof arg2 === 'string') {
                // Signature 1: (fd, string, [position?, [encoding?]])
                position = typeof arg3 === 'number' ? arg3 : null;
                const encoding = typeof arg4 === 'string' ? arg4 : 'utf8';
                offset = 0;
                buffer = Buffer.from(arg2, encoding);
                length = buffer.length;
            }
            else {
                // Signature 2: (fd, buffer, offset, length, position?)
                buffer = arg2;
                offset = arg3;
                length = arg4;
                position = typeof arg5 === 'number' ? arg5 : null;
            }
            const file = this.fd2file(fd);
            if (position === undefined || position === null) {
                position = file.getPos();
            }
            return file.writeSync(buffer, offset, length, position);
        }
        read(fd, arg2, arg3, arg4, arg5, cb = nopCb) {
            let position, offset, length, buffer, newCb;
            if (typeof arg2 === 'number') {
                // legacy interface
                // (fd, length, position, encoding, callback)
                length = arg2;
                position = arg3;
                const encoding = arg4;
                cb = typeof arg5 === 'function' ? arg5 : cb;
                offset = 0;
                buffer = Buffer.alloc(length);
                // XXX: Inefficient.
                // Wrap the cb so we shelter upper layers of the API from these
                // shenanigans.
                newCb = wrapCb((err, bytesRead, buf) => {
                    if (err) {
                        return cb(err);
                    }
                    cb(err, buf.toString(encoding), bytesRead);
                }, 3);
            }
            else {
                buffer = arg2;
                offset = arg3;
                length = arg4;
                position = arg5;
                newCb = wrapCb(cb, 3);
            }
            try {
                const file = this.fd2file(fd);
                if (position === undefined || position === null) {
                    position = file.getPos();
                }
                file.read(buffer, offset, length, position, newCb);
            }
            catch (e) {
                newCb(e);
            }
        }
        readSync(fd, arg2, arg3, arg4, arg5) {
            let shenanigans = false;
            let buffer, offset, length, position, encoding = 'utf8';
            if (typeof arg2 === 'number') {
                length = arg2;
                position = arg3;
                encoding = arg4;
                offset = 0;
                buffer = Buffer.alloc(length);
                shenanigans = true;
            }
            else {
                buffer = arg2;
                offset = arg3;
                length = arg4;
                position = arg5;
            }
            const file = this.fd2file(fd);
            if (position === undefined || position === null) {
                position = file.getPos();
            }
            const rv = file.readSync(buffer, offset, length, position);
            if (!shenanigans) {
                return rv;
            }
            else {
                return [buffer.toString(encoding), rv];
            }
        }
        /**
         * Asynchronous `fchown`.
         * @param fd
         * @param uid
         * @param gid
         * @param callback
         */
        fchown(fd, uid, gid, callback = nopCb) {
            const newCb = wrapCb(callback, 1);
            try {
                this.fd2file(fd).chown(uid, gid, newCb);
            }
            catch (e) {
                newCb(e);
            }
        }
        /**
         * Synchronous `fchown`.
         * @param fd
         * @param uid
         * @param gid
         */
        fchownSync(fd, uid, gid) {
            this.fd2file(fd).chownSync(uid, gid);
        }
        /**
         * Asynchronous `fchmod`.
         * @param fd
         * @param mode
         * @param callback
         */
        fchmod(fd, mode, cb) {
            const newCb = wrapCb(cb, 1);
            try {
                const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;
                this.fd2file(fd).chmod(numMode, newCb);
            }
            catch (e) {
                newCb(e);
            }
        }
        /**
         * Synchronous `fchmod`.
         * @param fd
         * @param mode
         */
        fchmodSync(fd, mode) {
            const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;
            this.fd2file(fd).chmodSync(numMode);
        }
        /**
         * Change the file timestamps of a file referenced by the supplied file
         * descriptor.
         * @param fd
         * @param atime
         * @param mtime
         * @param callback
         */
        futimes(fd, atime, mtime, cb = nopCb) {
            const newCb = wrapCb(cb, 1);
            try {
                const file = this.fd2file(fd);
                if (typeof atime === 'number') {
                    atime = new Date(atime * 1000);
                }
                if (typeof mtime === 'number') {
                    mtime = new Date(mtime * 1000);
                }
                file.utimes(atime, mtime, newCb);
            }
            catch (e) {
                newCb(e);
            }
        }
        /**
         * Change the file timestamps of a file referenced by the supplied file
         * descriptor.
         * @param fd
         * @param atime
         * @param mtime
         */
        futimesSync(fd, atime, mtime) {
            this.fd2file(fd).utimesSync(normalizeTime(atime), normalizeTime(mtime));
        }
        // DIRECTORY-ONLY METHODS
        /**
         * Asynchronous `rmdir`.
         * @param path
         * @param callback
         */
        rmdir(path, cb = nopCb) {
            const newCb = wrapCb(cb, 1);
            try {
                path = normalizePath(path);
                assertRoot(this.root).rmdir(path, newCb);
            }
            catch (e) {
                newCb(e);
            }
        }
        /**
         * Synchronous `rmdir`.
         * @param path
         */
        rmdirSync(path) {
            path = normalizePath(path);
            return assertRoot(this.root).rmdirSync(path);
        }
        /**
         * Asynchronous `mkdir`.
         * @param path
         * @param mode defaults to `0777`
         * @param callback
         */
        mkdir(path, mode, cb = nopCb) {
            if (typeof mode === 'function') {
                cb = mode;
                mode = 0x1ff;
            }
            const newCb = wrapCb(cb, 1);
            try {
                path = normalizePath(path);
                assertRoot(this.root).mkdir(path, mode, newCb);
            }
            catch (e) {
                newCb(e);
            }
        }
        /**
         * Synchronous `mkdir`.
         * @param path
         * @param mode defaults to `0777`
         */
        mkdirSync(path, mode) {
            assertRoot(this.root).mkdirSync(normalizePath(path), normalizeMode(mode, 0x1ff));
        }
        /**
         * Asynchronous `readdir`. Reads the contents of a directory.
         * The callback gets two arguments `(err, files)` where `files` is an array of
         * the names of the files in the directory excluding `'.'` and `'..'`.
         * @param path
         * @param callback
         */
        readdir(path, cb = nopCb) {
            const newCb = wrapCb(cb, 2);
            try {
                path = normalizePath(path);
                assertRoot(this.root).readdir(path, newCb);
            }
            catch (e) {
                newCb(e);
            }
        }
        /**
         * Synchronous `readdir`. Reads the contents of a directory.
         * @param path
         * @return [String[]]
         */
        readdirSync(path) {
            path = normalizePath(path);
            return assertRoot(this.root).readdirSync(path);
        }
        // SYMLINK METHODS
        /**
         * Asynchronous `link`.
         * @param srcpath
         * @param dstpath
         * @param callback
         */
        link(srcpath, dstpath, cb = nopCb) {
            const newCb = wrapCb(cb, 1);
            try {
                srcpath = normalizePath(srcpath);
                dstpath = normalizePath(dstpath);
                assertRoot(this.root).link(srcpath, dstpath, newCb);
            }
            catch (e) {
                newCb(e);
            }
        }
        /**
         * Synchronous `link`.
         * @param srcpath
         * @param dstpath
         */
        linkSync(srcpath, dstpath) {
            srcpath = normalizePath(srcpath);
            dstpath = normalizePath(dstpath);
            return assertRoot(this.root).linkSync(srcpath, dstpath);
        }
        symlink(srcpath, dstpath, arg3, cb = nopCb) {
            const type = typeof arg3 === 'string' ? arg3 : 'file';
            cb = typeof arg3 === 'function' ? arg3 : cb;
            const newCb = wrapCb(cb, 1);
            try {
                if (type !== 'file' && type !== 'dir') {
                    return newCb(new ApiError(ErrorCode.EINVAL, "Invalid type: " + type));
                }
                srcpath = normalizePath(srcpath);
                dstpath = normalizePath(dstpath);
                assertRoot(this.root).symlink(srcpath, dstpath, type, newCb);
            }
            catch (e) {
                newCb(e);
            }
        }
        /**
         * Synchronous `symlink`.
         * @param srcpath
         * @param dstpath
         * @param type can be either `'dir'` or `'file'` (default is `'file'`)
         */
        symlinkSync(srcpath, dstpath, type) {
            if (!type) {
                type = 'file';
            }
            else if (type !== 'file' && type !== 'dir') {
                throw new ApiError(ErrorCode.EINVAL, "Invalid type: " + type);
            }
            srcpath = normalizePath(srcpath);
            dstpath = normalizePath(dstpath);
            return assertRoot(this.root).symlinkSync(srcpath, dstpath, type);
        }
        /**
         * Asynchronous readlink.
         * @param path
         * @param callback
         */
        readlink(path, cb = nopCb) {
            const newCb = wrapCb(cb, 2);
            try {
                path = normalizePath(path);
                assertRoot(this.root).readlink(path, newCb);
            }
            catch (e) {
                newCb(e);
            }
        }
        /**
         * Synchronous readlink.
         * @param path
         * @return [String]
         */
        readlinkSync(path) {
            path = normalizePath(path);
            return assertRoot(this.root).readlinkSync(path);
        }
        // PROPERTY OPERATIONS
        /**
         * Asynchronous `chown`.
         * @param path
         * @param uid
         * @param gid
         * @param callback
         */
        chown(path, uid, gid, cb = nopCb) {
            const newCb = wrapCb(cb, 1);
            try {
                path = normalizePath(path);
                assertRoot(this.root).chown(path, false, uid, gid, newCb);
            }
            catch (e) {
                newCb(e);
            }
        }
        /**
         * Synchronous `chown`.
         * @param path
         * @param uid
         * @param gid
         */
        chownSync(path, uid, gid) {
            path = normalizePath(path);
            assertRoot(this.root).chownSync(path, false, uid, gid);
        }
        /**
         * Asynchronous `lchown`.
         * @param path
         * @param uid
         * @param gid
         * @param callback
         */
        lchown(path, uid, gid, cb = nopCb) {
            const newCb = wrapCb(cb, 1);
            try {
                path = normalizePath(path);
                assertRoot(this.root).chown(path, true, uid, gid, newCb);
            }
            catch (e) {
                newCb(e);
            }
        }
        /**
         * Synchronous `lchown`.
         * @param path
         * @param uid
         * @param gid
         */
        lchownSync(path, uid, gid) {
            path = normalizePath(path);
            assertRoot(this.root).chownSync(path, true, uid, gid);
        }
        /**
         * Asynchronous `chmod`.
         * @param path
         * @param mode
         * @param callback
         */
        chmod(path, mode, cb = nopCb) {
            const newCb = wrapCb(cb, 1);
            try {
                const numMode = normalizeMode(mode, -1);
                if (numMode < 0) {
                    throw new ApiError(ErrorCode.EINVAL, `Invalid mode.`);
                }
                assertRoot(this.root).chmod(normalizePath(path), false, numMode, newCb);
            }
            catch (e) {
                newCb(e);
            }
        }
        /**
         * Synchronous `chmod`.
         * @param path
         * @param mode
         */
        chmodSync(path, mode) {
            const numMode = normalizeMode(mode, -1);
            if (numMode < 0) {
                throw new ApiError(ErrorCode.EINVAL, `Invalid mode.`);
            }
            path = normalizePath(path);
            assertRoot(this.root).chmodSync(path, false, numMode);
        }
        /**
         * Asynchronous `lchmod`.
         * @param path
         * @param mode
         * @param callback
         */
        lchmod(path, mode, cb = nopCb) {
            const newCb = wrapCb(cb, 1);
            try {
                const numMode = normalizeMode(mode, -1);
                if (numMode < 0) {
                    throw new ApiError(ErrorCode.EINVAL, `Invalid mode.`);
                }
                assertRoot(this.root).chmod(normalizePath(path), true, numMode, newCb);
            }
            catch (e) {
                newCb(e);
            }
        }
        /**
         * Synchronous `lchmod`.
         * @param path
         * @param mode
         */
        lchmodSync(path, mode) {
            const numMode = normalizeMode(mode, -1);
            if (numMode < 1) {
                throw new ApiError(ErrorCode.EINVAL, `Invalid mode.`);
            }
            assertRoot(this.root).chmodSync(normalizePath(path), true, numMode);
        }
        /**
         * Change file timestamps of the file referenced by the supplied path.
         * @param path
         * @param atime
         * @param mtime
         * @param callback
         */
        utimes(path, atime, mtime, cb = nopCb) {
            const newCb = wrapCb(cb, 1);
            try {
                assertRoot(this.root).utimes(normalizePath(path), normalizeTime(atime), normalizeTime(mtime), newCb);
            }
            catch (e) {
                newCb(e);
            }
        }
        /**
         * Change file timestamps of the file referenced by the supplied path.
         * @param path
         * @param atime
         * @param mtime
         */
        utimesSync(path, atime, mtime) {
            assertRoot(this.root).utimesSync(normalizePath(path), normalizeTime(atime), normalizeTime(mtime));
        }
        realpath(path, arg2, cb = nopCb) {
            const cache = typeof (arg2) === 'object' ? arg2 : {};
            cb = typeof (arg2) === 'function' ? arg2 : nopCb;
            const newCb = wrapCb(cb, 2);
            try {
                path = normalizePath(path);
                assertRoot(this.root).realpath(path, cache, newCb);
            }
            catch (e) {
                newCb(e);
            }
        }
        /**
         * Synchronous `realpath`.
         * @param path
         * @param cache An object literal of mapped paths that can be used to
         *   force a specific path resolution or avoid additional `fs.stat` calls for
         *   known real paths.
         * @return [String]
         */
        realpathSync(path, cache = {}) {
            path = normalizePath(path);
            return assertRoot(this.root).realpathSync(path, cache);
        }
        watchFile(filename, arg2, listener = nopCb) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        unwatchFile(filename, listener = nopCb) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        watch(filename, arg2, listener = nopCb) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        access(path, arg2, cb = nopCb) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        accessSync(path, mode) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        createReadStream(path, options) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        createWriteStream(path, options) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        /**
         * For unit testing. Passes all incoming callbacks to cbWrapper for wrapping.
         */
        wrapCallbacks(cbWrapper) {
            wrapCbHook = cbWrapper;
        }
        getFdForFile(file) {
            const fd = this.nextFd++;
            this.fdMap[fd] = file;
            return fd;
        }
        fd2file(fd) {
            const rv = this.fdMap[fd];
            if (rv) {
                return rv;
            }
            else {
                throw new ApiError(ErrorCode.EBADF, 'Invalid file descriptor.');
            }
        }
        closeFd(fd) {
            delete this.fdMap[fd];
        }
    }
    /* tslint:disable:variable-name */
    // Exported fs.Stats.
    FS.Stats = Stats;
    //# sourceMappingURL=FS.js.map

    return FS;
});
define('skylark-browserfs/core/node_fs',['./FS'], function (FS) {
    'use strict';
    let fs = new FS();
    const _fsMock = {};
    const fsProto = FS.prototype;
    const keys = Object.getOwnPropertyNames(fsProto);
    keys.forEach(key => {
        if (typeof fs[key] === 'function') {
            _fsMock[key] = function () {
                return fs[key].apply(fs, arguments);
            };
        } else {
            _fsMock[key] = fs[key];
        }
    });
    _fsMock['changeFSModule'] = function (newFs) {
        fs = newFs;
    };
    _fsMock['getFSModule'] = function () {
        return fs;
    };
    _fsMock['FS'] = FS;
    _fsMock['Stats'] = FS.Stats;

    return _fsMock;
});
define('skylark-browserfs/core/levenshtein',[],function () {
    'use strict';
   
    /*
     * Levenshtein distance, from the `js-levenshtein` NPM module.
     * Copied here to avoid complexity of adding another CommonJS module dependency.
     */
    function _min(d0, d1, d2, bx, ay) {
        return d0 < d1 || d2 < d1 ? d0 > d2 ? d2 + 1 : d0 + 1 : bx === ay ? d1 : d1 + 1;
    }

    /**
     * Calculates levenshtein distance.
     * @param a
     * @param b
     */    
     function levenshtein(a, b) {
        if (a === b) {
            return 0;
        }
        if (a.length > b.length) {
            const tmp = a;
            a = b;
            b = tmp;
        }
        let la = a.length;
        let lb = b.length;
        while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {
            la--;
            lb--;
        }
        let offset = 0;
        while (offset < la && a.charCodeAt(offset) === b.charCodeAt(offset)) {
            offset++;
        }
        la -= offset;
        lb -= offset;
        if (la === 0 || lb === 1) {
            return lb;
        }
        const vector = new Array(la << 1);
        for (let y = 0; y < la;) {
            vector[la + y] = a.charCodeAt(offset + y);
            vector[y] = ++y;
        }
        let x;
        let d0;
        let d1;
        let d2;
        let d3;
        for (x = 0; x + 3 < lb;) {
            const bx0 = b.charCodeAt(offset + (d0 = x));
            const bx1 = b.charCodeAt(offset + (d1 = x + 1));
            const bx2 = b.charCodeAt(offset + (d2 = x + 2));
            const bx3 = b.charCodeAt(offset + (d3 = x + 3));
            let dd = x += 4;
            for (let y = 0; y < la;) {
                const ay = vector[la + y];
                const dy = vector[y];
                d0 = _min(dy, d0, d1, bx0, ay);
                d1 = _min(d0, d1, d2, bx1, ay);
                d2 = _min(d1, d2, d3, bx2, ay);
                dd = _min(d2, d3, dd, bx3, ay);
                vector[y++] = dd;
                d3 = d2;
                d2 = d1;
                d1 = d0;
                d0 = dy;
            }
        }
        let dd = 0;
        for (; x < lb;) {
            const bx0 = b.charCodeAt(offset + (d0 = x));
            dd = ++x;
            for (let y = 0; y < la; y++) {
                const dy = vector[y];
                vector[y] = dd = dy < d0 || dd < d0 ? dy > dd ? dd + 1 : dy + 1 : bx0 === vector[la + y] ? d0 : d0 + 1;
                d0 = dy;
            }
        }
        return dd;
    }

    return levenshtein;
});
define('skylark-browserfs/core/util',[
    '../libs/buffers',
    './api_error',
    './levenshtein',
    '../libs/path'
], function (buffers,api_error, levenshtein, path) {
    'use strict';

    const { ErrorCode, ApiError } = api_error;
    const {Buffer} = buffers;

    function deprecationMessage(print, fsName, opts) {
        if (print) {
            // tslint:disable-next-line:no-console
            console.warn(`[${fsName}] Direct file system constructor usage is deprecated for this file system, and will be removed in the next major version. Please use the '${fsName}.Create(${JSON.stringify(opts)}, callback)' method instead. See https://github.com/jvilk/BrowserFS/issues/176 for more details.`);
            // tslint:enable-next-line:no-console
        }
    }
    /**
     * Checks for any IE version, including IE11 which removed MSIE from the
     * userAgent string.
     * @hidden
     */
    const isIE = typeof navigator !== "undefined" && !!(/(msie) ([\w.]+)/.exec(navigator.userAgent.toLowerCase()) || navigator.userAgent.indexOf('Trident') !== -1);
    /**
     * Check if we're in a web worker.
     * @hidden
     */
    const isWebWorker = typeof window === "undefined";
    /**
     * Throws an exception. Called on code paths that should be impossible.
     * @hidden
     */
    function fail() {
        throw new Error("BFS has reached an impossible code path; please file a bug.");
    }
    /**
     * Synchronous recursive makedir.
     * @hidden
     */
    function mkdirpSync(p, mode, fs) {
        if (!fs.existsSync(p)) {
            mkdirpSync(path.dirname(p), mode, fs);
            fs.mkdirSync(p, mode);
        }
    }
    /**
     * Converts a buffer into an array buffer. Attempts to do so in a
     * zero-copy manner, e.g. the array references the same memory.
     * @hidden
     */
    function buffer2ArrayBuffer(buff) {
        const u8 = buffer2Uint8array(buff), u8offset = u8.byteOffset, u8Len = u8.byteLength;
        if (u8offset === 0 && u8Len === u8.buffer.byteLength) {
            return u8.buffer;
        }
        else {
            return u8.buffer.slice(u8offset, u8offset + u8Len);
        }
    }
    /**
     * Converts a buffer into a Uint8Array. Attempts to do so in a
     * zero-copy manner, e.g. the array references the same memory.
     * @hidden
     */
    function buffer2Uint8array(buff) {
        if (buff instanceof Uint8Array) {
            // BFS & Node v4.0 buffers *are* Uint8Arrays.
            return buff;
        }
        else {
            // Uint8Arrays can be constructed from arrayish numbers.
            // At this point, we assume this isn't a BFS array.
            return new Uint8Array(buff);
        }
    }
    /**
     * Converts the given arrayish object into a Buffer. Attempts to
     * be zero-copy.
     * @hidden
     */
    function arrayish2Buffer(arr) {
        if (arr instanceof Buffer) {
            return arr;
        }
        else if (arr instanceof Uint8Array) {
            return uint8Array2Buffer(arr);
        }
        else {
            return Buffer.from(arr);
        }
    }
    /**
     * Converts the given Uint8Array into a Buffer. Attempts to be zero-copy.
     * @hidden
     */
    function uint8Array2Buffer(u8) {
        if (u8 instanceof Buffer) {
            return u8;
        }
        else if (u8.byteOffset === 0 && u8.byteLength === u8.buffer.byteLength) {
            return arrayBuffer2Buffer(u8.buffer);
        }
        else {
            return Buffer.from(u8.buffer, u8.byteOffset, u8.byteLength);
        }
    }
    /**
     * Converts the given array buffer into a Buffer. Attempts to be
     * zero-copy.
     * @hidden
     */
    function arrayBuffer2Buffer(ab) {
        return Buffer.from(ab);
    }
    /**
     * Copies a slice of the given buffer
     * @hidden
     */
    function copyingSlice(buff, start = 0, end = buff.length) {
        if (start < 0 || end < 0 || end > buff.length || start > end) {
            throw new TypeError(`Invalid slice bounds on buffer of length ${buff.length}: [${start}, ${end}]`);
        }
        if (buff.length === 0) {
            // Avoid s0 corner case in ArrayBuffer case.
            return emptyBuffer();
        }
        else {
            const u8 = buffer2Uint8array(buff), s0 = buff[0], newS0 = (s0 + 1) % 0xFF;
            buff[0] = newS0;
            if (u8[0] === newS0) {
                // Same memory. Revert & copy.
                u8[0] = s0;
                return uint8Array2Buffer(u8.slice(start, end));
            }
            else {
                // Revert.
                buff[0] = s0;
                return uint8Array2Buffer(u8.subarray(start, end));
            }
        }
    }
    /**
     * @hidden
     */
    let emptyBuff = null;
    /**
     * Returns an empty buffer.
     * @hidden
     */
    function emptyBuffer() {
        if (emptyBuff) {
            return emptyBuff;
        }
        return emptyBuff = Buffer.alloc(0);
    }
    /**
     * Option validator for a Buffer file system option.
     * @hidden
     */
    function bufferValidator(v, cb) {
        if (Buffer.isBuffer(v)) {
            cb();
        }
        else {
            cb(new ApiError(ErrorCode.EINVAL, `option must be a Buffer.`));
        }
    }
    /**
     * Checks that the given options object is valid for the file system options.
     * @hidden
     */
    function checkOptions(fsType, opts, cb) {
        const optsInfo = fsType.Options;
        const fsName = fsType.Name;
        let pendingValidators = 0;
        let callbackCalled = false;
        let loopEnded = false;
        function validatorCallback(e) {
            if (!callbackCalled) {
                if (e) {
                    callbackCalled = true;
                    cb(e);
                }
                pendingValidators--;
                if (pendingValidators === 0 && loopEnded) {
                    cb();
                }
            }
        }
        // Check for required options.
        for (const optName in optsInfo) {
            if (optsInfo.hasOwnProperty(optName)) {
                const opt = optsInfo[optName];
                const providedValue = opts[optName];
                if (providedValue === undefined || providedValue === null) {
                    if (!opt.optional) {
                        // Required option, not provided.
                        // Any incorrect options provided? Which ones are close to the provided one?
                        // (edit distance 5 === close)
                        const incorrectOptions = Object.keys(opts).filter((o) => !(o in optsInfo)).map((a) => {
                            return { str: a, distance: levenshtein(optName, a) };
                        }).filter((o) => o.distance < 5).sort((a, b) => a.distance - b.distance);
                        // Validators may be synchronous.
                        if (callbackCalled) {
                            return;
                        }
                        callbackCalled = true;
                        return cb(new ApiError(ErrorCode.EINVAL, `[${fsName}] Required option '${optName}' not provided.${incorrectOptions.length > 0 ? ` You provided unrecognized option '${incorrectOptions[0].str}'; perhaps you meant to type '${optName}'.` : ''}\nOption description: ${opt.description}`));
                    }
                    // Else: Optional option, not provided. That is OK.
                }
                else {
                    // Option provided! Check type.
                    let typeMatches = false;
                    if (Array.isArray(opt.type)) {
                        typeMatches = opt.type.indexOf(typeof (providedValue)) !== -1;
                    }
                    else {
                        typeMatches = typeof (providedValue) === opt.type;
                    }
                    if (!typeMatches) {
                        // Validators may be synchronous.
                        if (callbackCalled) {
                            return;
                        }
                        callbackCalled = true;
                        return cb(new ApiError(ErrorCode.EINVAL, `[${fsName}] Value provided for option ${optName} is not the proper type. Expected ${Array.isArray(opt.type) ? `one of {${opt.type.join(", ")}}` : opt.type}, but received ${typeof (providedValue)}\nOption description: ${opt.description}`));
                    }
                    else if (opt.validator) {
                        pendingValidators++;
                        opt.validator(providedValue, validatorCallback);
                    }
                    // Otherwise: All good!
                }
            }
        }
        loopEnded = true;
        if (pendingValidators === 0 && !callbackCalled) {
            cb();
        }
    }

    return {
        deprecationMessage: deprecationMessage,
        isIE: isIE,
        isWebWorker: isWebWorker,
        fail: fail,
        mkdirpSync: mkdirpSync,
        buffer2ArrayBuffer: buffer2ArrayBuffer,
        buffer2Uint8array: buffer2Uint8array,
        arrayish2Buffer: arrayish2Buffer,
        uint8Array2Buffer: uint8Array2Buffer,
        arrayBuffer2Buffer: arrayBuffer2Buffer,
        copyingSlice: copyingSlice,
        emptyBuffer: emptyBuffer,
        bufferValidator: bufferValidator,
        checkOptions: checkOptions
    };
});
define('skylark-browserfs/generic/emscripten_fs',[
    '../core/node_fs',
    '../core/util'
], function (fs, util) {
    'use strict';
    const { uint8Array2Buffer } = util;

    class BFSEmscriptenStreamOps {
        constructor(fs) {
            this.fs = fs;
            this.nodefs = fs.getNodeFS();
            this.FS = fs.getFS();
            this.PATH = fs.getPATH();
            this.ERRNO_CODES = fs.getERRNO_CODES();
        }
        open(stream) {
            const path = this.fs.realPath(stream.node);
            const FS = this.FS;
            try {
                if (FS.isFile(stream.node.mode)) {
                    stream.nfd = this.nodefs.openSync(path, this.fs.flagsToPermissionString(stream.flags));
                }
            }
            catch (e) {
                if (!e.code) {
                    throw e;
                }
                throw new FS.ErrnoError(this.ERRNO_CODES[e.code]);
            }
        }
        close(stream) {
            const FS = this.FS;
            try {
                if (FS.isFile(stream.node.mode) && stream.nfd) {
                    this.nodefs.closeSync(stream.nfd);
                }
            }
            catch (e) {
                if (!e.code) {
                    throw e;
                }
                throw new FS.ErrnoError(this.ERRNO_CODES[e.code]);
            }
        }
        read(stream, buffer, offset, length, position) {
            // Avoid copying overhead by reading directly into buffer.
            try {
                return this.nodefs.readSync(stream.nfd, uint8Array2Buffer(buffer), offset, length, position);
            }
            catch (e) {
                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
            }
        }
        write(stream, buffer, offset, length, position) {
            // Avoid copying overhead.
            try {
                return this.nodefs.writeSync(stream.nfd, uint8Array2Buffer(buffer), offset, length, position);
            }
            catch (e) {
                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
            }
        }
        llseek(stream, offset, whence) {
            let position = offset;
            if (whence === 1) { // SEEK_CUR.
                position += stream.position;
            }
            else if (whence === 2) { // SEEK_END.
                if (this.FS.isFile(stream.node.mode)) {
                    try {
                        const stat = this.nodefs.fstatSync(stream.nfd);
                        position += stat.size;
                    }
                    catch (e) {
                        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
                    }
                }
            }
            if (position < 0) {
                throw new this.FS.ErrnoError(this.ERRNO_CODES.EINVAL);
            }
            stream.position = position;
            return position;
        }
    }
    class BFSEmscriptenNodeOps {
        constructor(fs) {
            this.fs = fs;
            this.nodefs = fs.getNodeFS();
            this.FS = fs.getFS();
            this.PATH = fs.getPATH();
            this.ERRNO_CODES = fs.getERRNO_CODES();
        }
        getattr(node) {
            const path = this.fs.realPath(node);
            let stat;
            try {
                stat = this.nodefs.lstatSync(path);
            }
            catch (e) {
                if (!e.code) {
                    throw e;
                }
                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
            }
            return {
                dev: stat.dev,
                ino: stat.ino,
                mode: stat.mode,
                nlink: stat.nlink,
                uid: stat.uid,
                gid: stat.gid,
                rdev: stat.rdev,
                size: stat.size,
                atime: stat.atime,
                mtime: stat.mtime,
                ctime: stat.ctime,
                blksize: stat.blksize,
                blocks: stat.blocks
            };
        }
        setattr(node, attr) {
            const path = this.fs.realPath(node);
            try {
                if (attr.mode !== undefined) {
                    this.nodefs.chmodSync(path, attr.mode);
                    // update the common node structure mode as well
                    node.mode = attr.mode;
                }
                if (attr.timestamp !== undefined) {
                    const date = new Date(attr.timestamp);
                    this.nodefs.utimesSync(path, date, date);
                }
            }
            catch (e) {
                if (!e.code) {
                    throw e;
                }
                // Ignore not supported errors. Emscripten does utimesSync when it
                // writes files, but never really requires the value to be set.
                if (e.code !== "ENOTSUP") {
                    throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
                }
            }
            if (attr.size !== undefined) {
                try {
                    this.nodefs.truncateSync(path, attr.size);
                }
                catch (e) {
                    if (!e.code) {
                        throw e;
                    }
                    throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
                }
            }
        }
        lookup(parent, name) {
            const path = this.PATH.join2(this.fs.realPath(parent), name);
            const mode = this.fs.getMode(path);
            return this.fs.createNode(parent, name, mode);
        }
        mknod(parent, name, mode, dev) {
            const node = this.fs.createNode(parent, name, mode, dev);
            // create the backing node for this in the fs root as well
            const path = this.fs.realPath(node);
            try {
                if (this.FS.isDir(node.mode)) {
                    this.nodefs.mkdirSync(path, node.mode);
                }
                else {
                    this.nodefs.writeFileSync(path, '', { mode: node.mode });
                }
            }
            catch (e) {
                if (!e.code) {
                    throw e;
                }
                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
            }
            return node;
        }
        rename(oldNode, newDir, newName) {
            const oldPath = this.fs.realPath(oldNode);
            const newPath = this.PATH.join2(this.fs.realPath(newDir), newName);
            try {
                this.nodefs.renameSync(oldPath, newPath);
                // This logic is missing from the original NodeFS,
                // causing Emscripten's filesystem to think that the old file still exists.
                oldNode.name = newName;
                oldNode.parent = newDir;
            }
            catch (e) {
                if (!e.code) {
                    throw e;
                }
                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
            }
        }
        unlink(parent, name) {
            const path = this.PATH.join2(this.fs.realPath(parent), name);
            try {
                this.nodefs.unlinkSync(path);
            }
            catch (e) {
                if (!e.code) {
                    throw e;
                }
                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
            }
        }
        rmdir(parent, name) {
            const path = this.PATH.join2(this.fs.realPath(parent), name);
            try {
                this.nodefs.rmdirSync(path);
            }
            catch (e) {
                if (!e.code) {
                    throw e;
                }
                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
            }
        }
        readdir(node) {
            const path = this.fs.realPath(node);
            try {
                // Node does not list . and .. in directory listings,
                // but Emscripten expects it.
                const contents = this.nodefs.readdirSync(path);
                contents.push('.', '..');
                return contents;
            }
            catch (e) {
                if (!e.code) {
                    throw e;
                }
                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
            }
        }
        symlink(parent, newName, oldPath) {
            const newPath = this.PATH.join2(this.fs.realPath(parent), newName);
            try {
                this.nodefs.symlinkSync(oldPath, newPath);
            }
            catch (e) {
                if (!e.code) {
                    throw e;
                }
                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
            }
        }
        readlink(node) {
            const path = this.fs.realPath(node);
            try {
                return this.nodefs.readlinkSync(path);
            }
            catch (e) {
                if (!e.code) {
                    throw e;
                }
                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
            }
        }
    }
    class BFSEmscriptenFS {
        constructor(_FS = self['FS'], _PATH = self['PATH'], _ERRNO_CODES = self['ERRNO_CODES'], nodefs = fs) {
            // This maps the integer permission modes from http://linux.die.net/man/3/open
            // to node.js-specific file open permission strings at http://nodejs.org/api/fs.html#fs_fs_open_path_flags_mode_callback
            this.flagsToPermissionStringMap = {
                0 /*O_RDONLY*/: 'r',
                1 /*O_WRONLY*/: 'r+',
                2 /*O_RDWR*/: 'r+',
                64 /*O_CREAT*/: 'r',
                65 /*O_WRONLY|O_CREAT*/: 'r+',
                66 /*O_RDWR|O_CREAT*/: 'r+',
                129 /*O_WRONLY|O_EXCL*/: 'rx+',
                193 /*O_WRONLY|O_CREAT|O_EXCL*/: 'rx+',
                514 /*O_RDWR|O_TRUNC*/: 'w+',
                577 /*O_WRONLY|O_CREAT|O_TRUNC*/: 'w',
                578 /*O_CREAT|O_RDWR|O_TRUNC*/: 'w+',
                705 /*O_WRONLY|O_CREAT|O_EXCL|O_TRUNC*/: 'wx',
                706 /*O_RDWR|O_CREAT|O_EXCL|O_TRUNC*/: 'wx+',
                1024 /*O_APPEND*/: 'a',
                1025 /*O_WRONLY|O_APPEND*/: 'a',
                1026 /*O_RDWR|O_APPEND*/: 'a+',
                1089 /*O_WRONLY|O_CREAT|O_APPEND*/: 'a',
                1090 /*O_RDWR|O_CREAT|O_APPEND*/: 'a+',
                1153 /*O_WRONLY|O_EXCL|O_APPEND*/: 'ax',
                1154 /*O_RDWR|O_EXCL|O_APPEND*/: 'ax+',
                1217 /*O_WRONLY|O_CREAT|O_EXCL|O_APPEND*/: 'ax',
                1218 /*O_RDWR|O_CREAT|O_EXCL|O_APPEND*/: 'ax+',
                4096 /*O_RDONLY|O_DSYNC*/: 'rs',
                4098 /*O_RDWR|O_DSYNC*/: 'rs+'
            };
            this.nodefs = nodefs;
            this.FS = _FS;
            this.PATH = _PATH;
            this.ERRNO_CODES = _ERRNO_CODES;
            this.node_ops = new BFSEmscriptenNodeOps(this);
            this.stream_ops = new BFSEmscriptenStreamOps(this);
        }
        mount(m) {
            return this.createNode(null, '/', this.getMode(m.opts.root), 0);
        }
        createNode(parent, name, mode, dev) {
            const FS = this.FS;
            if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
                throw new FS.ErrnoError(this.ERRNO_CODES.EINVAL);
            }
            const node = FS.createNode(parent, name, mode);
            node.node_ops = this.node_ops;
            node.stream_ops = this.stream_ops;
            return node;
        }
        getMode(path) {
            let stat;
            try {
                stat = this.nodefs.lstatSync(path);
            }
            catch (e) {
                if (!e.code) {
                    throw e;
                }
                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
            }
            return stat.mode;
        }
        realPath(node) {
            const parts = [];
            while (node.parent !== node) {
                parts.push(node.name);
                node = node.parent;
            }
            parts.push(node.mount.opts.root);
            parts.reverse();
            return this.PATH.join.apply(null, parts);
        }
        flagsToPermissionString(flags) {
            let parsedFlags = (typeof flags === "string") ? parseInt(flags, 10) : flags;
            parsedFlags &= 0x1FFF;
            if (parsedFlags in this.flagsToPermissionStringMap) {
                return this.flagsToPermissionStringMap[parsedFlags];
            }
            else {
                return flags;
            }
        }
        getNodeFS() {
            return this.nodefs;
        }
        getFS() {
            return this.FS;
        }
        getPATH() {
            return this.PATH;
        }
        getERRNO_CODES() {
            return this.ERRNO_CODES;
        }
    }

    return BFSEmscriptenFS;
});
define('skylark-browserfs/core/file_system',[
    '../libs/buffers',
    './api_error',
    './file_flag',
    '../libs/path',
    './util'
], function (buffers,api_error, file_flag, path, util) {
    'use strict';

    const { ApiError, ErrorCode } = api_error;
    const { FileFlag, ActionType } = file_flag;
    const { fail } = util;

    /**
     * Basic filesystem class. Most filesystems should extend this class, as it
     * provides default implementations for a handful of methods.
     */
    class BaseFileSystem {
        supportsLinks() {
            return false;
        }
        diskSpace(p, cb) {
            cb(0, 0);
        }
        /**
         * Opens the file at path p with the given flag. The file must exist.
         * @param p The path to open.
         * @param flag The flag to use when opening the file.
         */
        openFile(p, flag, cb) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        /**
         * Create the file at path p with the given mode. Then, open it with the given
         * flag.
         */
        createFile(p, flag, mode, cb) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        open(p, flag, mode, cb) {
            const mustBeFile = (e, stats) => {
                if (e) {
                    // File does not exist.
                    switch (flag.pathNotExistsAction()) {
                        case ActionType.CREATE_FILE:
                            // Ensure parent exists.
                            return this.stat(path.dirname(p), false, (e, parentStats) => {
                                if (e) {
                                    cb(e);
                                }
                                else if (parentStats && !parentStats.isDirectory()) {
                                    cb(ApiError.ENOTDIR(path.dirname(p)));
                                }
                                else {
                                    this.createFile(p, flag, mode, cb);
                                }
                            });
                        case ActionType.THROW_EXCEPTION:
                            return cb(ApiError.ENOENT(p));
                        default:
                            return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.'));
                    }
                }
                else {
                    // File exists.
                    if (stats && stats.isDirectory()) {
                        return cb(ApiError.EISDIR(p));
                    }
                    switch (flag.pathExistsAction()) {
                        case ActionType.THROW_EXCEPTION:
                            return cb(ApiError.EEXIST(p));
                        case ActionType.TRUNCATE_FILE:
                            // NOTE: In a previous implementation, we deleted the file and
                            // re-created it. However, this created a race condition if another
                            // asynchronous request was trying to read the file, as the file
                            // would not exist for a small period of time.
                            return this.openFile(p, flag, (e, fd) => {
                                if (e) {
                                    cb(e);
                                }
                                else if (fd) {
                                    fd.truncate(0, () => {
                                        fd.sync(() => {
                                            cb(null, fd);
                                        });
                                    });
                                }
                                else {
                                    fail();
                                }
                            });
                        case ActionType.NOP:
                            return this.openFile(p, flag, cb);
                        default:
                            return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.'));
                    }
                }
            };
            this.stat(p, false, mustBeFile);
        }
        rename(oldPath, newPath, cb) {
            cb(new ApiError(ErrorCode.ENOTSUP));
        }
        renameSync(oldPath, newPath) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        stat(p, isLstat, cb) {
            cb(new ApiError(ErrorCode.ENOTSUP));
        }
        statSync(p, isLstat) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        /**
         * Opens the file at path p with the given flag. The file must exist.
         * @param p The path to open.
         * @param flag The flag to use when opening the file.
         * @return A File object corresponding to the opened file.
         */
        openFileSync(p, flag, mode) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        /**
         * Create the file at path p with the given mode. Then, open it with the given
         * flag.
         */
        createFileSync(p, flag, mode) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        openSync(p, flag, mode) {
            // Check if the path exists, and is a file.
            let stats;
            try {
                stats = this.statSync(p, false);
            }
            catch (e) {
                // File does not exist.
                switch (flag.pathNotExistsAction()) {
                    case ActionType.CREATE_FILE:
                        // Ensure parent exists.
                        const parentStats = this.statSync(path.dirname(p), false);
                        if (!parentStats.isDirectory()) {
                            throw ApiError.ENOTDIR(path.dirname(p));
                        }
                        return this.createFileSync(p, flag, mode);
                    case ActionType.THROW_EXCEPTION:
                        throw ApiError.ENOENT(p);
                    default:
                        throw new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.');
                }
            }
            // File exists.
            if (stats.isDirectory()) {
                throw ApiError.EISDIR(p);
            }
            switch (flag.pathExistsAction()) {
                case ActionType.THROW_EXCEPTION:
                    throw ApiError.EEXIST(p);
                case ActionType.TRUNCATE_FILE:
                    // Delete file.
                    this.unlinkSync(p);
                    // Create file. Use the same mode as the old file.
                    // Node itself modifies the ctime when this occurs, so this action
                    // will preserve that behavior if the underlying file system
                    // supports those properties.
                    return this.createFileSync(p, flag, stats.mode);
                case ActionType.NOP:
                    return this.openFileSync(p, flag, mode);
                default:
                    throw new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.');
            }
        }
        unlink(p, cb) {
            cb(new ApiError(ErrorCode.ENOTSUP));
        }
        unlinkSync(p) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        rmdir(p, cb) {
            cb(new ApiError(ErrorCode.ENOTSUP));
        }
        rmdirSync(p) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        mkdir(p, mode, cb) {
            cb(new ApiError(ErrorCode.ENOTSUP));
        }
        mkdirSync(p, mode) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        readdir(p, cb) {
            cb(new ApiError(ErrorCode.ENOTSUP));
        }
        readdirSync(p) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        exists(p, cb) {
            this.stat(p, null, function (err) {
                cb(!err);
            });
        }
        existsSync(p) {
            try {
                this.statSync(p, true);
                return true;
            }
            catch (e) {
                return false;
            }
        }
        realpath(p, cache, cb) {
            if (this.supportsLinks()) {
                // The path could contain symlinks. Split up the path,
                // resolve any symlinks, return the resolved string.
                const splitPath = p.split(path.sep);
                // TODO: Simpler to just pass through file, find sep and such.
                for (let i = 0; i < splitPath.length; i++) {
                    const addPaths = splitPath.slice(0, i + 1);
                    splitPath[i] = path.join.apply(null, addPaths);
                }
            }
            else {
                // No symlinks. We just need to verify that it exists.
                this.exists(p, function (doesExist) {
                    if (doesExist) {
                        cb(null, p);
                    }
                    else {
                        cb(ApiError.ENOENT(p));
                    }
                });
            }
        }
        realpathSync(p, cache) {
            if (this.supportsLinks()) {
                // The path could contain symlinks. Split up the path,
                // resolve any symlinks, return the resolved string.
                const splitPath = p.split(path.sep);
                // TODO: Simpler to just pass through file, find sep and such.
                for (let i = 0; i < splitPath.length; i++) {
                    const addPaths = splitPath.slice(0, i + 1);
                    splitPath[i] = path.join.apply(path, addPaths);
                }
                return splitPath.join(path.sep);
            }
            else {
                // No symlinks. We just need to verify that it exists.
                if (this.existsSync(p)) {
                    return p;
                }
                else {
                    throw ApiError.ENOENT(p);
                }
            }
        }
        truncate(p, len, cb) {
            this.open(p, FileFlag.getFileFlag('r+'), 0x1a4, (function (er, fd) {
                if (er) {
                    return cb(er);
                }
                fd.truncate(len, (function (er) {
                    fd.close((function (er2) {
                        cb(er || er2);
                    }));
                }));
            }));
        }
        truncateSync(p, len) {
            const fd = this.openSync(p, FileFlag.getFileFlag('r+'), 0x1a4);
            // Need to safely close FD, regardless of whether or not truncate succeeds.
            try {
                fd.truncateSync(len);
            }
            catch (e) {
                throw e;
            }
            finally {
                fd.closeSync();
            }
        }
        readFile(fname, encoding, flag, cb) {
            // Wrap cb in file closing code.
            const oldCb = cb;
            // Get file.
            this.open(fname, flag, 0x1a4, (err, fd) => {
                if (err) {
                    return cb(err);
                }
                cb = function (err, arg) {
                    fd.close(function (err2) {
                        if (!err) {
                            err = err2;
                        }
                        return oldCb(err, arg);
                    });
                };
                fd.stat((err, stat) => {
                    if (err) {
                        return cb(err);
                    }
                    // Allocate buffer.
                    const buf = Buffer.alloc(stat.size);
                    fd.read(buf, 0, stat.size, 0, (err) => {
                        if (err) {
                            return cb(err);
                        }
                        else if (encoding === null) {
                            return cb(err, buf);
                        }
                        try {
                            cb(null, buf.toString(encoding));
                        }
                        catch (e) {
                            cb(e);
                        }
                    });
                });
            });
        }
        readFileSync(fname, encoding, flag) {
            // Get file.
            const fd = this.openSync(fname, flag, 0x1a4);
            try {
                const stat = fd.statSync();
                // Allocate buffer.
                const buf = Buffer.alloc(stat.size);
                fd.readSync(buf, 0, stat.size, 0);
                fd.closeSync();
                if (encoding === null) {
                    return buf;
                }
                return buf.toString(encoding);
            }
            finally {
                fd.closeSync();
            }
        }
        writeFile(fname, data, encoding, flag, mode, cb) {
            // Wrap cb in file closing code.
            const oldCb = cb;
            // Get file.
            this.open(fname, flag, 0x1a4, function (err, fd) {
                if (err) {
                    return cb(err);
                }
                cb = function (err) {
                    fd.close(function (err2) {
                        oldCb(err ? err : err2);
                    });
                };
                try {
                    if (typeof data === 'string') {
                        data = Buffer.from(data, encoding);
                    }
                }
                catch (e) {
                    return cb(e);
                }
                // Write into file.
                fd.write(data, 0, data.length, 0, cb);
            });
        }
        writeFileSync(fname, data, encoding, flag, mode) {
            // Get file.
            const fd = this.openSync(fname, flag, mode);
            try {
                if (typeof data === 'string') {
                    data = Buffer.from(data, encoding);
                }
                // Write into file.
                fd.writeSync(data, 0, data.length, 0);
            }
            finally {
                fd.closeSync();
            }
        }
        appendFile(fname, data, encoding, flag, mode, cb) {
            // Wrap cb in file closing code.
            const oldCb = cb;
            this.open(fname, flag, mode, function (err, fd) {
                if (err) {
                    return cb(err);
                }
                cb = function (err) {
                    fd.close(function (err2) {
                        oldCb(err ? err : err2);
                    });
                };
                if (typeof data === 'string') {
                    data = Buffer.from(data, encoding);
                }
                fd.write(data, 0, data.length, null, cb);
            });
        }
        appendFileSync(fname, data, encoding, flag, mode) {
            const fd = this.openSync(fname, flag, mode);
            try {
                if (typeof data === 'string') {
                    data = Buffer.from(data, encoding);
                }
                fd.writeSync(data, 0, data.length, null);
            }
            finally {
                fd.closeSync();
            }
        }
        chmod(p, isLchmod, mode, cb) {
            cb(new ApiError(ErrorCode.ENOTSUP));
        }
        chmodSync(p, isLchmod, mode) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        chown(p, isLchown, uid, gid, cb) {
            cb(new ApiError(ErrorCode.ENOTSUP));
        }
        chownSync(p, isLchown, uid, gid) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        utimes(p, atime, mtime, cb) {
            cb(new ApiError(ErrorCode.ENOTSUP));
        }
        utimesSync(p, atime, mtime) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        link(srcpath, dstpath, cb) {
            cb(new ApiError(ErrorCode.ENOTSUP));
        }
        linkSync(srcpath, dstpath) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        symlink(srcpath, dstpath, type, cb) {
            cb(new ApiError(ErrorCode.ENOTSUP));
        }
        symlinkSync(srcpath, dstpath, type) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        readlink(p, cb) {
            cb(new ApiError(ErrorCode.ENOTSUP));
        }
        readlinkSync(p) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
    }
    /**
     * Implements the asynchronous API in terms of the synchronous API.
     * @class SynchronousFileSystem
     */
    class SynchronousFileSystem extends BaseFileSystem {
        supportsSynch() {
            return true;
        }
        rename(oldPath, newPath, cb) {
            try {
                this.renameSync(oldPath, newPath);
                cb();
            }
            catch (e) {
                cb(e);
            }
        }
        stat(p, isLstat, cb) {
            try {
                cb(null, this.statSync(p, isLstat));
            }
            catch (e) {
                cb(e);
            }
        }
        open(p, flags, mode, cb) {
            try {
                cb(null, this.openSync(p, flags, mode));
            }
            catch (e) {
                cb(e);
            }
        }
        unlink(p, cb) {
            try {
                this.unlinkSync(p);
                cb();
            }
            catch (e) {
                cb(e);
            }
        }
        rmdir(p, cb) {
            try {
                this.rmdirSync(p);
                cb();
            }
            catch (e) {
                cb(e);
            }
        }
        mkdir(p, mode, cb) {
            try {
                this.mkdirSync(p, mode);
                cb();
            }
            catch (e) {
                cb(e);
            }
        }
        readdir(p, cb) {
            try {
                cb(null, this.readdirSync(p));
            }
            catch (e) {
                cb(e);
            }
        }
        chmod(p, isLchmod, mode, cb) {
            try {
                this.chmodSync(p, isLchmod, mode);
                cb();
            }
            catch (e) {
                cb(e);
            }
        }
        chown(p, isLchown, uid, gid, cb) {
            try {
                this.chownSync(p, isLchown, uid, gid);
                cb();
            }
            catch (e) {
                cb(e);
            }
        }
        utimes(p, atime, mtime, cb) {
            try {
                this.utimesSync(p, atime, mtime);
                cb();
            }
            catch (e) {
                cb(e);
            }
        }
        link(srcpath, dstpath, cb) {
            try {
                this.linkSync(srcpath, dstpath);
                cb();
            }
            catch (e) {
                cb(e);
            }
        }
        symlink(srcpath, dstpath, type, cb) {
            try {
                this.symlinkSync(srcpath, dstpath, type);
                cb();
            }
            catch (e) {
                cb(e);
            }
        }
        readlink(p, cb) {
            try {
                cb(null, this.readlinkSync(p));
            }
            catch (e) {
                cb(e);
            }
        }
    }


    return {
        BaseFileSystem: BaseFileSystem,
        SynchronousFileSystem: SynchronousFileSystem
    };
});
define('skylark-browserfs/core/file',['./api_error'], function (api_error) {
    'use strict';

    const { ApiError, ErrorCode } = api_error;
    /**
     * Base class that contains shared implementations of functions for the file
     * object.
     */
    class BaseFile {
        sync(cb) {
            cb(new ApiError(ErrorCode.ENOTSUP));
        }
        syncSync() {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        datasync(cb) {
            this.sync(cb);
        }
        datasyncSync() {
            return this.syncSync();
        }
        chown(uid, gid, cb) {
            cb(new ApiError(ErrorCode.ENOTSUP));
        }
        chownSync(uid, gid) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        chmod(mode, cb) {
            cb(new ApiError(ErrorCode.ENOTSUP));
        }
        chmodSync(mode) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        utimes(atime, mtime, cb) {
            cb(new ApiError(ErrorCode.ENOTSUP));
        }
        utimesSync(atime, mtime) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
    }
    return { BaseFile: BaseFile };
});
define('skylark-browserfs/generic/preload_file',[
    '../libs/buffers',
    '../core/file',
    '../core/node_fs_stats',
    '../core/api_error',
    '../core/node_fs',
    '../core/util'
], function (buffers,file, Stats, api_error, fs, util) {
    'use strict';

    const { BaseFile } = file;
    const { ApiError, ErrorCode } = api_error;
    const { emptyBuffer } = util;
    const { Buffer } = buffers;

    /**
     * An implementation of the File interface that operates on a file that is
     * completely in-memory. PreloadFiles are backed by a Buffer.
     *
     * This is also an abstract class, as it lacks an implementation of 'sync' and
     * 'close'. Each filesystem that wishes to use this file representation must
     * extend this class and implement those two methods.
     * @todo 'close' lever that disables functionality once closed.
     */
    class PreloadFile extends BaseFile {
        /**
         * Creates a file with the given path and, optionally, the given contents. Note
         * that, if contents is specified, it will be mutated by the file!
         * @param _fs The file system that created the file.
         * @param _path
         * @param _mode The mode that the file was opened using.
         *   Dictates permissions and where the file pointer starts.
         * @param _stat The stats object for the given file.
         *   PreloadFile will mutate this object. Note that this object must contain
         *   the appropriate mode that the file was opened as.
         * @param contents A buffer containing the entire
         *   contents of the file. PreloadFile will mutate this buffer. If not
         *   specified, we assume it is a new file.
         */
        constructor(_fs, _path, _flag, _stat, contents) {
            super();
            this._pos = 0;
            this._dirty = false;
            this._fs = _fs;
            this._path = _path;
            this._flag = _flag;
            this._stat = _stat;
            this._buffer = contents ? contents : emptyBuffer();
            // Note: This invariant is *not* maintained once the file starts getting
            // modified.
            // Note: Only actually matters if file is readable, as writeable modes may
            // truncate/append to file.
            if (this._stat.size !== this._buffer.length && this._flag.isReadable()) {
                throw new Error(`Invalid buffer: Buffer is ${this._buffer.length} long, yet Stats object specifies that file is ${this._stat.size} long.`);
            }
        }
        /**
         * NONSTANDARD: Get the underlying buffer for this file. !!DO NOT MUTATE!! Will mess up dirty tracking.
         */
        getBuffer() {
            return this._buffer;
        }
        /**
         * NONSTANDARD: Get underlying stats for this file. !!DO NOT MUTATE!!
         */
        getStats() {
            return this._stat;
        }
        getFlag() {
            return this._flag;
        }
        /**
         * Get the path to this file.
         * @return [String] The path to the file.
         */
        getPath() {
            return this._path;
        }
        /**
         * Get the current file position.
         *
         * We emulate the following bug mentioned in the Node documentation:
         * > On Linux, positional writes don't work when the file is opened in append
         *   mode. The kernel ignores the position argument and always appends the data
         *   to the end of the file.
         * @return [Number] The current file position.
         */
        getPos() {
            if (this._flag.isAppendable()) {
                return this._stat.size;
            }
            return this._pos;
        }
        /**
         * Advance the current file position by the indicated number of positions.
         * @param [Number] delta
         */
        advancePos(delta) {
            return this._pos += delta;
        }
        /**
         * Set the file position.
         * @param [Number] newPos
         */
        setPos(newPos) {
            return this._pos = newPos;
        }
        /**
         * **Core**: Asynchronous sync. Must be implemented by subclasses of this
         * class.
         * @param [Function(BrowserFS.ApiError)] cb
         */
        sync(cb) {
            try {
                this.syncSync();
                cb();
            }
            catch (e) {
                cb(e);
            }
        }
        /**
         * **Core**: Synchronous sync.
         */
        syncSync() {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        /**
         * **Core**: Asynchronous close. Must be implemented by subclasses of this
         * class.
         * @param [Function(BrowserFS.ApiError)] cb
         */
        close(cb) {
            try {
                this.closeSync();
                cb();
            }
            catch (e) {
                cb(e);
            }
        }
        /**
         * **Core**: Synchronous close.
         */
        closeSync() {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        /**
         * Asynchronous `stat`.
         * @param [Function(BrowserFS.ApiError, BrowserFS.node.fs.Stats)] cb
         */
        stat(cb) {
            try {
                cb(null, Stats.clone(this._stat));
            }
            catch (e) {
                cb(e);
            }
        }
        /**
         * Synchronous `stat`.
         */
        statSync() {
            return Stats.clone(this._stat);
        }
        /**
         * Asynchronous truncate.
         * @param [Number] len
         * @param [Function(BrowserFS.ApiError)] cb
         */
        truncate(len, cb) {
            try {
                this.truncateSync(len);
                if (this._flag.isSynchronous() && !fs.getRootFS().supportsSynch()) {
                    this.sync(cb);
                }
                cb();
            }
            catch (e) {
                return cb(e);
            }
        }
        /**
         * Synchronous truncate.
         * @param [Number] len
         */
        truncateSync(len) {
            this._dirty = true;
            if (!this._flag.isWriteable()) {
                throw new ApiError(ErrorCode.EPERM, 'File not opened with a writeable mode.');
            }
            this._stat.mtimeMs = Date.now();
            if (len > this._buffer.length) {
                const buf = Buffer.alloc(len - this._buffer.length, 0);
                // Write will set @_stat.size for us.
                this.writeSync(buf, 0, buf.length, this._buffer.length);
                if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {
                    this.syncSync();
                }
                return;
            }
            this._stat.size = len;
            // Truncate buffer to 'len'.
            const newBuff = Buffer.alloc(len);
            this._buffer.copy(newBuff, 0, 0, len);
            this._buffer = newBuff;
            if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {
                this.syncSync();
            }
        }
        /**
         * Write buffer to the file.
         * Note that it is unsafe to use fs.write multiple times on the same file
         * without waiting for the callback.
         * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to
         *  the file.
         * @param [Number] offset Offset in the buffer to start reading data from.
         * @param [Number] length The amount of bytes to write to the file.
         * @param [Number] position Offset from the beginning of the file where this
         *   data should be written. If position is null, the data will be written at
         *   the current position.
         * @param [Function(BrowserFS.ApiError, Number, BrowserFS.node.Buffer)]
         *   cb The number specifies the number of bytes written into the file.
         */
        write(buffer, offset, length, position, cb) {
            try {
                cb(null, this.writeSync(buffer, offset, length, position), buffer);
            }
            catch (e) {
                cb(e);
            }
        }
        /**
         * Write buffer to the file.
         * Note that it is unsafe to use fs.writeSync multiple times on the same file
         * without waiting for the callback.
         * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to
         *  the file.
         * @param [Number] offset Offset in the buffer to start reading data from.
         * @param [Number] length The amount of bytes to write to the file.
         * @param [Number] position Offset from the beginning of the file where this
         *   data should be written. If position is null, the data will be written at
         *   the current position.
         * @return [Number]
         */
        writeSync(buffer, offset, length, position) {
            this._dirty = true;
            if (position === undefined || position === null) {
                position = this.getPos();
            }
            if (!this._flag.isWriteable()) {
                throw new ApiError(ErrorCode.EPERM, 'File not opened with a writeable mode.');
            }
            const endFp = position + length;
            if (endFp > this._stat.size) {
                this._stat.size = endFp;
                if (endFp > this._buffer.length) {
                    // Extend the buffer!
                    const newBuff = Buffer.alloc(endFp);
                    this._buffer.copy(newBuff);
                    this._buffer = newBuff;
                }
            }
            const len = buffer.copy(this._buffer, position, offset, offset + length);
            this._stat.mtimeMs = Date.now();
            if (this._flag.isSynchronous()) {
                this.syncSync();
                return len;
            }
            this.setPos(position + len);
            return len;
        }
        /**
         * Read data from the file.
         * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be
         *   written to.
         * @param [Number] offset The offset within the buffer where writing will
         *   start.
         * @param [Number] length An integer specifying the number of bytes to read.
         * @param [Number] position An integer specifying where to begin reading from
         *   in the file. If position is null, data will be read from the current file
         *   position.
         * @param [Function(BrowserFS.ApiError, Number, BrowserFS.node.Buffer)] cb The
         *   number is the number of bytes read
         */
        read(buffer, offset, length, position, cb) {
            try {
                cb(null, this.readSync(buffer, offset, length, position), buffer);
            }
            catch (e) {
                cb(e);
            }
        }
        /**
         * Read data from the file.
         * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be
         *   written to.
         * @param [Number] offset The offset within the buffer where writing will
         *   start.
         * @param [Number] length An integer specifying the number of bytes to read.
         * @param [Number] position An integer specifying where to begin reading from
         *   in the file. If position is null, data will be read from the current file
         *   position.
         * @return [Number]
         */
        readSync(buffer, offset, length, position) {
            if (!this._flag.isReadable()) {
                throw new ApiError(ErrorCode.EPERM, 'File not opened with a readable mode.');
            }
            if (position === undefined || position === null) {
                position = this.getPos();
            }
            const endRead = position + length;
            if (endRead > this._stat.size) {
                length = this._stat.size - position;
            }
            const rv = this._buffer.copy(buffer, offset, position, position + length);
            this._stat.atimeMs = Date.now();
            this._pos = position + length;
            return rv;
        }
        /**
         * Asynchronous `fchmod`.
         * @param [Number|String] mode
         * @param [Function(BrowserFS.ApiError)] cb
         */
        chmod(mode, cb) {
            try {
                this.chmodSync(mode);
                cb();
            }
            catch (e) {
                cb(e);
            }
        }
        /**
         * Asynchronous `fchmod`.
         * @param [Number] mode
         */
        chmodSync(mode) {
            if (!this._fs.supportsProps()) {
                throw new ApiError(ErrorCode.ENOTSUP);
            }
            this._dirty = true;
            this._stat.chmod(mode);
            this.syncSync();
        }
        isDirty() {
            return this._dirty;
        }
        /**
         * Resets the dirty bit. Should only be called after a sync has completed successfully.
         */
        resetDirty() {
            this._dirty = false;
        }
    }
    /**
     * File class for the InMemory and XHR file systems.
     * Doesn't sync to anything, so it works nicely for memory-only files.
     */
    class NoSyncFile extends PreloadFile {
        constructor(_fs, _path, _flag, _stat, contents) {
            super(_fs, _path, _flag, _stat, contents);
        }
        /**
         * Asynchronous sync. Doesn't do anything, simply calls the cb.
         * @param [Function(BrowserFS.ApiError)] cb
         */
        sync(cb) {
            cb();
        }
        /**
         * Synchronous sync. Doesn't do anything.
         */
        syncSync() {
            // NOP.
        }
        /**
         * Asynchronous close. Doesn't do anything, simply calls the cb.
         * @param [Function(BrowserFS.ApiError)] cb
         */
        close(cb) {
            cb();
        }
        /**
         * Synchronous close. Doesn't do anything.
         */
        closeSync() {
            // NOP.
        }
    }

    return {
        PreloadFile,
        NoSyncFile
    }
});
define('skylark-browserfs/backend/AsyncMirror',[
    '../core/file_system',
    '../core/api_error',
    '../core/file_flag',
    '../generic/preload_file',
    '../libs/path'
], function (file_system, api_error, file_flag, preload_file, path) {
    'use strict';


    const  { SynchronousFileSystem } = file_system;
    const { ApiError, ErrorCode } = api_error;
    const { FileFlag } = file_flag;
    const { PreloadFile} = preload_file;

    /**
     * We define our own file to interpose on syncSync() for mirroring purposes.
     */
    class MirrorFile extends PreloadFile {
        constructor(fs, path, flag, stat, data) {
            super(fs, path, flag, stat, data);
        }
        syncSync() {
            if (this.isDirty()) {
                this._fs._syncSync(this);
                this.resetDirty();
            }
        }
        closeSync() {
            this.syncSync();
        }
    }
    /**
     * AsyncMirrorFS mirrors a synchronous filesystem into an asynchronous filesystem
     * by:
     *
     * * Performing operations over the in-memory copy, while asynchronously pipelining them
     *   to the backing store.
     * * During application loading, the contents of the async file system can be reloaded into
     *   the synchronous store, if desired.
     *
     * The two stores will be kept in sync. The most common use-case is to pair a synchronous
     * in-memory filesystem with an asynchronous backing store.
     *
     * Example: Mirroring an IndexedDB file system to an in memory file system. Now, you can use
     * IndexedDB synchronously.
     *
     * ```javascript
     * BrowserFS.configure({
     *   fs: "AsyncMirror",
     *   options: {
     *     sync: { fs: "InMemory" },
     *     async: { fs: "IndexedDB" }
     *   }
     * }, function(e) {
     *   // BrowserFS is initialized and ready-to-use!
     * });
     * ```
     *
     * Or, alternatively:
     *
     * ```javascript
     * BrowserFS.FileSystem.IndexedDB.Create(function(e, idbfs) {
     *   BrowserFS.FileSystem.InMemory.Create(function(e, inMemory) {
     *     BrowserFS.FileSystem.AsyncMirror({
     *       sync: inMemory, async: idbfs
     *     }, function(e, mirrored) {
     *       BrowserFS.initialize(mirrored);
     *     });
     *   });
     * });
     * ```
     */
    class AsyncMirror extends SynchronousFileSystem {
        /**
         * **Deprecated; use AsyncMirror.Create() method instead.**
         *
         * Mirrors the synchronous file system into the asynchronous file system.
         *
         * **IMPORTANT**: You must call `initialize` on the file system before it can be used.
         * @param sync The synchronous file system to mirror the asynchronous file system to.
         * @param async The asynchronous file system to mirror.
         */
        constructor(sync, async) {
            super();
            /**
             * Queue of pending asynchronous operations.
             */
            this._queue = [];
            this._queueRunning = false;
            this._isInitialized = false;
            this._initializeCallbacks = [];
            this._sync = sync;
            this._async = async;
        }
        /**
         * Constructs and initializes an AsyncMirror file system with the given options.
         */
        static Create(opts, cb) {
            try {
                const fs = new AsyncMirror(opts.sync, opts.async);
                fs._initialize((e) => {
                    if (e) {
                        cb(e);
                    }
                    else {
                        cb(null, fs);
                    }
                });
            }
            catch (e) {
                cb(e);
            }
        }
        static isAvailable() {
            return true;
        }
        getName() {
            return AsyncMirror.Name;
        }
        _syncSync(fd) {
            this._sync.writeFileSync(fd.getPath(), fd.getBuffer(), null, FileFlag.getFileFlag('w'), fd.getStats().mode);
            this.enqueueOp({
                apiMethod: 'writeFile',
                arguments: [fd.getPath(), fd.getBuffer(), null, fd.getFlag(), fd.getStats().mode]
            });
        }
        isReadOnly() { return false; }
        supportsSynch() { return true; }
        supportsLinks() { return false; }
        supportsProps() { return this._sync.supportsProps() && this._async.supportsProps(); }
        renameSync(oldPath, newPath) {
            this._sync.renameSync(oldPath, newPath);
            this.enqueueOp({
                apiMethod: 'rename',
                arguments: [oldPath, newPath]
            });
        }
        statSync(p, isLstat) {
            return this._sync.statSync(p, isLstat);
        }
        openSync(p, flag, mode) {
            // Sanity check: Is this open/close permitted?
            const fd = this._sync.openSync(p, flag, mode);
            fd.closeSync();
            return new MirrorFile(this, p, flag, this._sync.statSync(p, false), this._sync.readFileSync(p, null, FileFlag.getFileFlag('r')));
        }
        unlinkSync(p) {
            this._sync.unlinkSync(p);
            this.enqueueOp({
                apiMethod: 'unlink',
                arguments: [p]
            });
        }
        rmdirSync(p) {
            this._sync.rmdirSync(p);
            this.enqueueOp({
                apiMethod: 'rmdir',
                arguments: [p]
            });
        }
        mkdirSync(p, mode) {
            this._sync.mkdirSync(p, mode);
            this.enqueueOp({
                apiMethod: 'mkdir',
                arguments: [p, mode]
            });
        }
        readdirSync(p) {
            return this._sync.readdirSync(p);
        }
        existsSync(p) {
            return this._sync.existsSync(p);
        }
        chmodSync(p, isLchmod, mode) {
            this._sync.chmodSync(p, isLchmod, mode);
            this.enqueueOp({
                apiMethod: 'chmod',
                arguments: [p, isLchmod, mode]
            });
        }
        chownSync(p, isLchown, uid, gid) {
            this._sync.chownSync(p, isLchown, uid, gid);
            this.enqueueOp({
                apiMethod: 'chown',
                arguments: [p, isLchown, uid, gid]
            });
        }
        utimesSync(p, atime, mtime) {
            this._sync.utimesSync(p, atime, mtime);
            this.enqueueOp({
                apiMethod: 'utimes',
                arguments: [p, atime, mtime]
            });
        }
        /**
         * Called once to load up files from async storage into sync storage.
         */
        _initialize(userCb) {
            const callbacks = this._initializeCallbacks;
            const end = (e) => {
                this._isInitialized = !e;
                this._initializeCallbacks = [];
                callbacks.forEach((cb) => cb(e));
            };
            if (!this._isInitialized) {
                // First call triggers initialization, the rest wait.
                if (callbacks.push(userCb) === 1) {
                    const copyDirectory = (p, mode, cb) => {
                        if (p !== '/') {
                            this._sync.mkdirSync(p, mode);
                        }
                        this._async.readdir(p, (err, files) => {
                            let i = 0;
                            // NOTE: This function must not be in a lexically nested statement,
                            // such as an if or while statement. Safari refuses to run the
                            // script since it is undefined behavior.
                            function copyNextFile(err) {
                                if (err) {
                                    cb(err);
                                }
                                else if (i < files.length) {
                                    copyItem(path.join(p, files[i]), copyNextFile);
                                    i++;
                                }
                                else {
                                    cb();
                                }
                            }
                            if (err) {
                                cb(err);
                            }
                            else {
                                copyNextFile();
                            }
                        });
                    }, copyFile = (p, mode, cb) => {
                        this._async.readFile(p, null, FileFlag.getFileFlag('r'), (err, data) => {
                            if (err) {
                                cb(err);
                            }
                            else {
                                try {
                                    this._sync.writeFileSync(p, data, null, FileFlag.getFileFlag('w'), mode);
                                }
                                catch (e) {
                                    err = e;
                                }
                                finally {
                                    cb(err);
                                }
                            }
                        });
                    }, copyItem = (p, cb) => {
                        this._async.stat(p, false, (err, stats) => {
                            if (err) {
                                cb(err);
                            }
                            else if (stats.isDirectory()) {
                                copyDirectory(p, stats.mode, cb);
                            }
                            else {
                                copyFile(p, stats.mode, cb);
                            }
                        });
                    };
                    copyDirectory('/', 0, end);
                }
            }
            else {
                userCb();
            }
        }
        enqueueOp(op) {
            this._queue.push(op);
            if (!this._queueRunning) {
                this._queueRunning = true;
                const doNextOp = (err) => {
                    if (err) {
                        throw new Error(`WARNING: File system has desynchronized. Received following error: ${err}\n$`);
                    }
                    if (this._queue.length > 0) {
                        const op = this._queue.shift(), args = op.arguments;
                        args.push(doNextOp);
                        this._async[op.apiMethod].apply(this._async, args);
                    }
                    else {
                        this._queueRunning = false;
                    }
                };
                doNextOp();
            }
        }
    }
    AsyncMirror.Name = "AsyncMirror";
    AsyncMirror.Options = {
        sync: {
            type: "object",
            description: "The synchronous file system to mirror the asynchronous file system to.",
            validator: (v, cb) => {
                if (v && typeof (v['supportsSynch']) === "function" && v.supportsSynch()) {
                    cb();
                }
                else {
                    cb(new ApiError(ErrorCode.EINVAL, `'sync' option must be a file system that supports synchronous operations`));
                }
            }
        },
        async: {
            type: "object",
            description: "The asynchronous file system to mirror."
        }
    };

    return AsyncMirror;
});
define('skylark-browserfs/backend/Dropbox',[
    '../libs/buffers',
    '../generic/preload_file',
    '../core/file_system',
    '../core/node_fs_stats',
    '../core/api_error',
    '../core/util',
///    'dropbox_bridge',
    '../generic/setImmediate',
    '../libs/path'
], function (buffers,preload_file, file_system, node_fs_stats, api_error, util,  setImmediate, path) {
    'use strict';

    const { BaseFileSystem } = file_system;
    const { Stats, FileType } = node_fs_stats;
    const { ApiError, ErrorCode } = api_error;
    const { arrayBuffer2Buffer, buffer2ArrayBuffer } =  util;
///    const { Dropbox } =  dropbox_bridge;
    const { dirname } =  path;

    const { PreloadFile} = preload_file;

    const {Buffer} = buffers;


    /**
     * Dropbox paths do not begin with a /, they just begin with a folder at the root node.
     * Here, we strip the `/`.
     * @param p An absolute path
     */
    function FixPath(p) {
        if (p === '/') {
            return '';
        }
        else {
            return p;
        }
    }
    /**
     * HACK: Dropbox errors are FUBAR'd sometimes.
     * @url https://github.com/dropbox/dropbox-sdk-js/issues/146
     * @param e
     */
    function ExtractTheFuckingError(e) {
        const obj = e.error;
        if (obj['.tag']) {
            // Everything is OK.
            return obj;
        }
        else if (obj['error']) {
            // Terrible nested object bug.
            const obj2 = obj.error;
            if (obj2['.tag']) {
                return obj2;
            }
            else if (obj2['reason'] && obj2['reason']['.tag']) {
                return obj2.reason;
            }
            else {
                return obj2;
            }
        }
        else if (typeof (obj) === 'string') {
            // Might be a fucking JSON object error.
            try {
                const obj2 = JSON.parse(obj);
                if (obj2['error'] && obj2['error']['reason'] && obj2['error']['reason']['.tag']) {
                    return obj2.error.reason;
                }
            }
            catch (e) {
                // Nope. Give up.
            }
        }
        return obj;
    }
    /**
     * Returns a user-facing error message given an error.
     *
     * HACK: Dropbox error messages sometimes lack a `user_message` field.
     * Sometimes, they are even strings. Ugh.
     * @url https://github.com/dropbox/dropbox-sdk-js/issues/146
     * @url https://github.com/dropbox/dropbox-sdk-js/issues/145
     * @url https://github.com/dropbox/dropbox-sdk-js/issues/144
     * @param err An error.
     */
    function GetErrorMessage(err) {
        if (err['user_message']) {
            return err.user_message.text;
        }
        else if (err['error_summary']) {
            return err.error_summary;
        }
        else if (typeof (err.error) === "string") {
            return err.error;
        }
        else if (typeof (err.error) === "object") {
            // DROPBOX BUG: Sometimes, error is a nested error.
            return GetErrorMessage(err.error);
        }
        else {
            throw new Error(`Dropbox's servers gave us a garbage error message: ${JSON.stringify(err)}`);
        }
    }
    function LookupErrorToError(err, p, msg) {
        switch (err['.tag']) {
            case 'malformed_path':
                return new ApiError(ErrorCode.EBADF, msg, p);
            case 'not_found':
                return ApiError.ENOENT(p);
            case 'not_file':
                return ApiError.EISDIR(p);
            case 'not_folder':
                return ApiError.ENOTDIR(p);
            case 'restricted_content':
                return ApiError.EPERM(p);
            case 'other':
            default:
                return new ApiError(ErrorCode.EIO, msg, p);
        }
    }
    function WriteErrorToError(err, p, msg) {
        switch (err['.tag']) {
            case 'malformed_path':
            case 'disallowed_name':
                return new ApiError(ErrorCode.EBADF, msg, p);
            case 'conflict':
            case 'no_write_permission':
            case 'team_folder':
                return ApiError.EPERM(p);
            case 'insufficient_space':
                return new ApiError(ErrorCode.ENOSPC, msg);
            case 'other':
            default:
                return new ApiError(ErrorCode.EIO, msg, p);
        }
    }
    function FilesDeleteWrapped(client, p, cb) {
        const arg = {
            path: FixPath(p)
        };
        client.filesDeleteV2(arg)
            .then(() => {
            cb();
        }).catch((e) => {
            const err = ExtractTheFuckingError(e);
            switch (err['.tag']) {
                case 'path_lookup':
                    cb(LookupErrorToError(err.path_lookup, p, GetErrorMessage(e)));
                    break;
                case 'path_write':
                    cb(WriteErrorToError(err.path_write, p, GetErrorMessage(e)));
                    break;
                case 'too_many_write_operations':
                    setTimeout(() => FilesDeleteWrapped(client, p, cb), 500 + (300 * (Math.random())));
                    break;
                case 'other':
                default:
                    cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), p));
                    break;
            }
        });
    }
    class DropboxFile extends PreloadFile {
        constructor(_fs, _path, _flag, _stat, contents) {
            super(_fs, _path, _flag, _stat, contents);
        }
        sync(cb) {
            this._fs._syncFile(this.getPath(), this.getBuffer(), cb);
        }
        close(cb) {
            this.sync(cb);
        }
    }
    /**
     * A read/write file system backed by Dropbox cloud storage.
     *
     * Uses the Dropbox V2 API, and the 2.x JS SDK.
     */
    class DropboxFileSystem extends BaseFileSystem {
        constructor(client) {
            super();
            this._client = client;
        }
        /**
         * Creates a new DropboxFileSystem instance with the given options.
         * Must be given an *authenticated* Dropbox client from 2.x JS SDK.
         */
        static Create(opts, cb) {
            cb(null, new DropboxFileSystem(opts.client));
        }
        static isAvailable() {
            // Checks if the Dropbox library is loaded.
            return typeof Dropbox !== 'undefined';
        }
        getName() {
            return DropboxFileSystem.Name;
        }
        isReadOnly() {
            return false;
        }
        // Dropbox doesn't support symlinks, properties, or synchronous calls
        // TODO: does it???
        supportsSymlinks() {
            return false;
        }
        supportsProps() {
            return false;
        }
        supportsSynch() {
            return false;
        }
        /**
         * Deletes *everything* in the file system. Mainly intended for unit testing!
         * @param mainCb Called when operation completes.
         */
        empty(mainCb) {
            this.readdir('/', (e, paths) => {
                if (paths) {
                    const next = (e) => {
                        if (paths.length === 0) {
                            mainCb();
                        }
                        else {
                            FilesDeleteWrapped(this._client, paths.shift(), next);
                        }
                    };
                    next();
                }
                else {
                    mainCb(e);
                }
            });
        }
        rename(oldPath, newPath, cb) {
            // Dropbox doesn't let you rename things over existing things, but POSIX does.
            // So, we need to see if newPath exists...
            this.stat(newPath, false, (e, stats) => {
                const rename = () => {
                    const relocationArg = {
                        from_path: FixPath(oldPath),
                        to_path: FixPath(newPath)
                    };
                    this._client.filesMoveV2(relocationArg)
                        .then(() => cb())
                        .catch(function (e) {
                        const err = ExtractTheFuckingError(e);
                        switch (err['.tag']) {
                            case 'from_lookup':
                                cb(LookupErrorToError(err.from_lookup, oldPath, GetErrorMessage(e)));
                                break;
                            case 'from_write':
                                cb(WriteErrorToError(err.from_write, oldPath, GetErrorMessage(e)));
                                break;
                            case 'to':
                                cb(WriteErrorToError(err.to, newPath, GetErrorMessage(e)));
                                break;
                            case 'cant_copy_shared_folder':
                            case 'cant_nest_shared_folder':
                                cb(new ApiError(ErrorCode.EPERM, GetErrorMessage(e), oldPath));
                                break;
                            case 'cant_move_folder_into_itself':
                            case 'duplicated_or_nested_paths':
                                cb(new ApiError(ErrorCode.EBADF, GetErrorMessage(e), oldPath));
                                break;
                            case 'too_many_files':
                                cb(new ApiError(ErrorCode.ENOSPC, GetErrorMessage(e), oldPath));
                                break;
                            case 'other':
                            default:
                                cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), oldPath));
                                break;
                        }
                    });
                };
                if (e) {
                    // Doesn't exist. Proceed!
                    rename();
                }
                else if (oldPath === newPath) {
                    // NOP if the path exists. Error if it doesn't exist.
                    if (e) {
                        cb(ApiError.ENOENT(newPath));
                    }
                    else {
                        cb();
                    }
                }
                else if (stats && stats.isDirectory()) {
                    // Exists, is a directory. Cannot rename over an existing directory.
                    cb(ApiError.EISDIR(newPath));
                }
                else {
                    // Exists, is a file, and differs from oldPath. Delete and rename.
                    this.unlink(newPath, (e) => {
                        if (e) {
                            cb(e);
                        }
                        else {
                            rename();
                        }
                    });
                }
            });
        }
        stat(path, isLstat, cb) {
            if (path === '/') {
                // Dropbox doesn't support querying the root directory.
                setImmediate(function () {
                    cb(null, new Stats(FileType.DIRECTORY, 4096));
                });
                return;
            }
            const arg = {
                path: FixPath(path)
            };
            this._client.filesGetMetadata(arg).then((ref) => {
                switch (ref['.tag']) {
                    case 'file':
                        const fileMetadata = ref;
                        // TODO: Parse time fields.
                        cb(null, new Stats(FileType.FILE, fileMetadata.size));
                        break;
                    case 'folder':
                        cb(null, new Stats(FileType.DIRECTORY, 4096));
                        break;
                    case 'deleted':
                        cb(ApiError.ENOENT(path));
                        break;
                    default:
                        // Unknown.
                        break;
                }
            }).catch((e) => {
                const err = ExtractTheFuckingError(e);
                switch (err['.tag']) {
                    case 'path':
                        cb(LookupErrorToError(err.path, path, GetErrorMessage(e)));
                        break;
                    default:
                        cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), path));
                        break;
                }
            });
        }
        openFile(path, flags, cb) {
            const downloadArg = {
                path: FixPath(path)
            };
            this._client.filesDownload(downloadArg).then((res) => {
                const b = res.fileBlob;
                const fr = new FileReader();
                fr.onload = () => {
                    const ab = fr.result;
                    cb(null, new DropboxFile(this, path, flags, new Stats(FileType.FILE, ab.byteLength), arrayBuffer2Buffer(ab)));
                };
                fr.readAsArrayBuffer(b);
            }).catch((e) => {
                const err = ExtractTheFuckingError(e);
                switch (err['.tag']) {
                    case 'path':
                        const dpError = err;
                        cb(LookupErrorToError(dpError.path, path, GetErrorMessage(e)));
                        break;
                    case 'other':
                    default:
                        cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), path));
                        break;
                }
            });
        }
        createFile(p, flags, mode, cb) {
            const fileData = Buffer.alloc(0);
            const blob = new Blob([buffer2ArrayBuffer(fileData)], { type: "octet/stream" });
            const commitInfo = {
                contents: blob,
                path: FixPath(p)
            };
            this._client.filesUpload(commitInfo).then((metadata) => {
                cb(null, new DropboxFile(this, p, flags, new Stats(FileType.FILE, 0), fileData));
            }).catch((e) => {
                const err = ExtractTheFuckingError(e);
                // HACK: Casting to 'any' since tag can be 'too_many_write_operations'.
                switch (err['.tag']) {
                    case 'path':
                        const upError = err;
                        cb(WriteErrorToError(upError.path.reason, p, GetErrorMessage(e)));
                        break;
                    case 'too_many_write_operations':
                        // Retry in (500, 800) ms.
                        setTimeout(() => this.createFile(p, flags, mode, cb), 500 + (300 * (Math.random())));
                        break;
                    case 'other':
                    default:
                        cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), p));
                        break;
                }
            });
        }
        /**
         * Delete a file
         */
        unlink(path, cb) {
            // Must be a file. Check first.
            this.stat(path, false, (e, stat) => {
                if (stat) {
                    if (stat.isDirectory()) {
                        cb(ApiError.EISDIR(path));
                    }
                    else {
                        FilesDeleteWrapped(this._client, path, cb);
                    }
                }
                else {
                    cb(e);
                }
            });
        }
        /**
         * Delete a directory
         */
        rmdir(path, cb) {
            this.readdir(path, (e, paths) => {
                if (paths) {
                    if (paths.length > 0) {
                        cb(ApiError.ENOTEMPTY(path));
                    }
                    else {
                        FilesDeleteWrapped(this._client, path, cb);
                    }
                }
                else {
                    cb(e);
                }
            });
        }
        /**
         * Create a directory
         */
        mkdir(p, mode, cb) {
            // Dropbox's create_folder is recursive. Check if parent exists.
            const parent = dirname(p);
            this.stat(parent, false, (e, stats) => {
                if (e) {
                    cb(e);
                }
                else if (stats && !stats.isDirectory()) {
                    cb(ApiError.ENOTDIR(parent));
                }
                else {
                    const arg = {
                        path: FixPath(p)
                    };
                    this._client.filesCreateFolderV2(arg).then(() => cb()).catch((e) => {
                        const err = ExtractTheFuckingError(e);
                        if (err['.tag'] === "too_many_write_operations") {
                            // Retry in a bit.
                            setTimeout(() => this.mkdir(p, mode, cb), 500 + (300 * (Math.random())));
                        }
                        else {
                            cb(WriteErrorToError(ExtractTheFuckingError(e).path, p, GetErrorMessage(e)));
                        }
                    });
                }
            });
        }
        /**
         * Get the names of the files in a directory
         */
        readdir(path, cb) {
            const arg = {
                path: FixPath(path)
            };
            this._client.filesListFolder(arg).then((res) => {
                ContinueReadingDir(this._client, path, res, [], cb);
            }).catch((e) => {
                ProcessListFolderError(e, path, cb);
            });
        }
        /**
         * (Internal) Syncs file to Dropbox.
         */
        _syncFile(p, d, cb) {
            const blob = new Blob([buffer2ArrayBuffer(d)], { type: "octet/stream" });
            const arg = {
                contents: blob,
                path: FixPath(p),
                mode: {
                    '.tag': 'overwrite'
                }
            };
            this._client.filesUpload(arg).then(() => {
                cb();
            }).catch((e) => {
                const err = ExtractTheFuckingError(e);
                switch (err['.tag']) {
                    case 'path':
                        const upError = err;
                        cb(WriteErrorToError(upError.path.reason, p, GetErrorMessage(e)));
                        break;
                    case 'too_many_write_operations':
                        setTimeout(() => this._syncFile(p, d, cb), 500 + (300 * (Math.random())));
                        break;
                    case 'other':
                    default:
                        cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), p));
                        break;
                }
            });
        }
    }
    DropboxFileSystem.Name = "DropboxV2";
    DropboxFileSystem.Options = {
        client: {
            type: "object",
            description: "An *authenticated* Dropbox client. Must be from the 2.5.x JS SDK."
        }
    };
    function ProcessListFolderError(e, path, cb) {
        const err = ExtractTheFuckingError(e);
        switch (err['.tag']) {
            case 'path':
                const pathError = err;
                cb(LookupErrorToError(pathError.path, path, GetErrorMessage(e)));
                break;
            case 'other':
            default:
                cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), path));
                break;
        }
    }
    function ContinueReadingDir(client, path, res, previousEntries, cb) {
        const newEntries = res.entries.map((e) => e.path_display).filter((p) => !!p);
        const entries = previousEntries.concat(newEntries);
        if (!res.has_more) {
            cb(null, entries);
        }
        else {
            const arg = {
                cursor: res.cursor
            };
            client.filesListFolderContinue(arg).then((res) => {
                ContinueReadingDir(client, path, res, entries, cb);
            }).catch((e) => {
                ProcessListFolderError(e, path, cb);
            });
        }
    }

    DropboxFileSystem.DropboxFile = DropboxFile;

    return  DropboxFileSystem;
    
});
define('skylark-browserfs/backend/Emscripten',[
    '../libs/buffers',
    '../core/file_system',
    '../core/node_fs_stats',
    '../core/file',
    '../core/util',
    '../core/api_error'
], function (buffers,file_system, node_fs_stats, file, util, api_error) {
    'use strict';

    const { SynchronousFileSystem } = file_system;
    const { Stats, FileType } = node_fs_stats;
    const { BaseFile } = file;
    const { uint8Array2Buffer, buffer2Uint8array } = util;
    const { ApiError, ErrorCode, ErrorStrings } = api_error;
    const { Buffer } = buffers;

    /**
     * @hidden
     */
    function convertError(e, path = '') {
        const errno = e.errno;
        let parent = e.node;
        const paths = [];
        while (parent) {
            paths.unshift(parent.name);
            if (parent === parent.parent) {
                break;
            }
            parent = parent.parent;
        }
        return new ApiError(errno, ErrorStrings[errno], paths.length > 0 ? '/' + paths.join('/') : path);
    }
    class EmscriptenFile extends BaseFile {
        constructor(_fs, _FS, _path, _stream) {
            super();
            this._fs = _fs;
            this._FS = _FS;
            this._path = _path;
            this._stream = _stream;
        }
        getPos() {
            return undefined;
        }
        close(cb) {
            let err = null;
            try {
                this.closeSync();
            }
            catch (e) {
                err = e;
            }
            finally {
                cb(err);
            }
        }
        closeSync() {
            try {
                this._FS.close(this._stream);
            }
            catch (e) {
                throw convertError(e, this._path);
            }
        }
        stat(cb) {
            try {
                cb(null, this.statSync());
            }
            catch (e) {
                cb(e);
            }
        }
        statSync() {
            try {
                return this._fs.statSync(this._path, false);
            }
            catch (e) {
                throw convertError(e, this._path);
            }
        }
        truncate(len, cb) {
            let err = null;
            try {
                this.truncateSync(len);
            }
            catch (e) {
                err = e;
            }
            finally {
                cb(err);
            }
        }
        truncateSync(len) {
            try {
                this._FS.ftruncate(this._stream.fd, len);
            }
            catch (e) {
                throw convertError(e, this._path);
            }
        }
        write(buffer, offset, length, position, cb) {
            try {
                cb(null, this.writeSync(buffer, offset, length, position), buffer);
            }
            catch (e) {
                cb(e);
            }
        }
        writeSync(buffer, offset, length, position) {
            try {
                const u8 = buffer2Uint8array(buffer);
                // Emscripten is particular about what position is set to.
                const emPosition = position === null ? undefined : position;
                return this._FS.write(this._stream, u8, offset, length, emPosition);
            }
            catch (e) {
                throw convertError(e, this._path);
            }
        }
        read(buffer, offset, length, position, cb) {
            try {
                cb(null, this.readSync(buffer, offset, length, position), buffer);
            }
            catch (e) {
                cb(e);
            }
        }
        readSync(buffer, offset, length, position) {
            try {
                const u8 = buffer2Uint8array(buffer);
                // Emscripten is particular about what position is set to.
                const emPosition = position === null ? undefined : position;
                return this._FS.read(this._stream, u8, offset, length, emPosition);
            }
            catch (e) {
                throw convertError(e, this._path);
            }
        }
        sync(cb) {
            // NOP.
            cb();
        }
        syncSync() {
            // NOP.
        }
        chown(uid, gid, cb) {
            let err = null;
            try {
                this.chownSync(uid, gid);
            }
            catch (e) {
                err = e;
            }
            finally {
                cb(err);
            }
        }
        chownSync(uid, gid) {
            try {
                this._FS.fchown(this._stream.fd, uid, gid);
            }
            catch (e) {
                throw convertError(e, this._path);
            }
        }
        chmod(mode, cb) {
            let err = null;
            try {
                this.chmodSync(mode);
            }
            catch (e) {
                err = e;
            }
            finally {
                cb(err);
            }
        }
        chmodSync(mode) {
            try {
                this._FS.fchmod(this._stream.fd, mode);
            }
            catch (e) {
                throw convertError(e, this._path);
            }
        }
        utimes(atime, mtime, cb) {
            let err = null;
            try {
                this.utimesSync(atime, mtime);
            }
            catch (e) {
                err = e;
            }
            finally {
                cb(err);
            }
        }
        utimesSync(atime, mtime) {
            this._fs.utimesSync(this._path, atime, mtime);
        }
    }
    /**
     * Mounts an Emscripten file system into the BrowserFS file system.
     */
    class EmscriptenFileSystem extends SynchronousFileSystem {
        constructor(_FS) {
            super();
            this._FS = _FS;
        }
        /**
         * Create an EmscriptenFileSystem instance with the given options.
         */
        static Create(opts, cb) {
            cb(null, new EmscriptenFileSystem(opts.FS));
        }
        static isAvailable() { return true; }
        getName() { return this._FS.DB_NAME(); }
        isReadOnly() { return false; }
        supportsLinks() { return true; }
        supportsProps() { return true; }
        supportsSynch() { return true; }
        renameSync(oldPath, newPath) {
            try {
                this._FS.rename(oldPath, newPath);
            }
            catch (e) {
                if (e.errno === ErrorCode.ENOENT) {
                    throw convertError(e, this.existsSync(oldPath) ? newPath : oldPath);
                }
                else {
                    throw convertError(e);
                }
            }
        }
        statSync(p, isLstat) {
            try {
                const stats = isLstat ? this._FS.lstat(p) : this._FS.stat(p);
                const itemType = this.modeToFileType(stats.mode);
                return new Stats(itemType, stats.size, stats.mode, stats.atime.getTime(), stats.mtime.getTime(), stats.ctime.getTime());
            }
            catch (e) {
                throw convertError(e, p);
            }
        }
        openSync(p, flag, mode) {
            try {
                const stream = this._FS.open(p, flag.getFlagString(), mode);
                if (this._FS.isDir(stream.node.mode)) {
                    this._FS.close(stream);
                    throw ApiError.EISDIR(p);
                }
                return new EmscriptenFile(this, this._FS, p, stream);
            }
            catch (e) {
                throw convertError(e, p);
            }
        }
        unlinkSync(p) {
            try {
                this._FS.unlink(p);
            }
            catch (e) {
                throw convertError(e, p);
            }
        }
        rmdirSync(p) {
            try {
                this._FS.rmdir(p);
            }
            catch (e) {
                throw convertError(e, p);
            }
        }
        mkdirSync(p, mode) {
            try {
                this._FS.mkdir(p, mode);
            }
            catch (e) {
                throw convertError(e, p);
            }
        }
        readdirSync(p) {
            try {
                // Emscripten returns items for '.' and '..'. Node does not.
                return this._FS.readdir(p).filter((p) => p !== '.' && p !== '..');
            }
            catch (e) {
                throw convertError(e, p);
            }
        }
        truncateSync(p, len) {
            try {
                this._FS.truncate(p, len);
            }
            catch (e) {
                throw convertError(e, p);
            }
        }
        readFileSync(p, encoding, flag) {
            try {
                const data = this._FS.readFile(p, { flags: flag.getFlagString() });
                const buff = uint8Array2Buffer(data);
                if (encoding) {
                    return buff.toString(encoding);
                }
                else {
                    return buff;
                }
            }
            catch (e) {
                throw convertError(e, p);
            }
        }
        writeFileSync(p, data, encoding, flag, mode) {
            try {
                if (encoding) {
                    data = Buffer.from(data, encoding);
                }
                const u8 = buffer2Uint8array(data);
                this._FS.writeFile(p, u8, { flags: flag.getFlagString(), encoding: 'binary' });
                this._FS.chmod(p, mode);
            }
            catch (e) {
                throw convertError(e, p);
            }
        }
        chmodSync(p, isLchmod, mode) {
            try {
                isLchmod ? this._FS.lchmod(p, mode) : this._FS.chmod(p, mode);
            }
            catch (e) {
                throw convertError(e, p);
            }
        }
        chownSync(p, isLchown, uid, gid) {
            try {
                isLchown ? this._FS.lchown(p, uid, gid) : this._FS.chown(p, uid, gid);
            }
            catch (e) {
                throw convertError(e, p);
            }
        }
        symlinkSync(srcpath, dstpath, type) {
            try {
                this._FS.symlink(srcpath, dstpath);
            }
            catch (e) {
                throw convertError(e);
            }
        }
        readlinkSync(p) {
            try {
                return this._FS.readlink(p);
            }
            catch (e) {
                throw convertError(e, p);
            }
        }
        utimesSync(p, atime, mtime) {
            try {
                this._FS.utime(p, atime.getTime(), mtime.getTime());
            }
            catch (e) {
                throw convertError(e, p);
            }
        }
        modeToFileType(mode) {
            if (this._FS.isDir(mode)) {
                return FileType.DIRECTORY;
            }
            else if (this._FS.isFile(mode)) {
                return FileType.FILE;
            }
            else if (this._FS.isLink(mode)) {
                return FileType.SYMLINK;
            }
            else {
                throw ApiError.EPERM(`Invalid mode: ${mode}`);
            }
        }
    }
    EmscriptenFileSystem.Name = "EmscriptenFileSystem";
    EmscriptenFileSystem.Options = {
        FS: {
            type: "object",
            description: "The Emscripten file system to use (the `FS` variable)"
        }
    };

    EmscriptenFileSystem.EmscriptenFile = EmscriptenFile;

    return EmscriptenFileSystem;
});
define('skylark-browserfs/backend/FolderAdapter',[
    '../core/file_system',
    '../libs/path',
    '../core/api_error'
], function (file_system, path, api_error) {
    'use strict';

    const { BaseFileSystem } = file_system;
    const { ApiError } = api_error;

    /**
     * The FolderAdapter file system wraps a file system, and scopes all interactions to a subfolder of that file system.
     *
     * Example: Given a file system `foo` with folder `bar` and file `bar/baz`...
     *
     * ```javascript
     * BrowserFS.configure({
     *   fs: "FolderAdapter",
     *   options: {
     *     folder: "bar",
     *     wrapped: foo
     *   }
     * }, function(e) {
     *   var fs = BrowserFS.BFSRequire('fs');
     *   fs.readdirSync('/'); // ['baz']
     * });
     * ```
     */
    class FolderAdapter extends BaseFileSystem {
        constructor(folder, wrapped) {
            super();
            this._folder = folder;
            this._wrapped = wrapped;
        }
        /**
         * Creates a FolderAdapter instance with the given options.
         */
        static Create(opts, cb) {
            const fa = new FolderAdapter(opts.folder, opts.wrapped);
            fa._initialize(function (e) {
                if (e) {
                    cb(e);
                }
                else {
                    cb(null, fa);
                }
            });
        }
        static isAvailable() {
            return true;
        }
        getName() { return this._wrapped.getName(); }
        isReadOnly() { return this._wrapped.isReadOnly(); }
        supportsProps() { return this._wrapped.supportsProps(); }
        supportsSynch() { return this._wrapped.supportsSynch(); }
        supportsLinks() { return false; }
        /**
         * Initialize the file system. Ensures that the wrapped file system
         * has the given folder.
         */
        _initialize(cb) {
            this._wrapped.exists(this._folder, (exists) => {
                if (exists) {
                    cb();
                }
                else if (this._wrapped.isReadOnly()) {
                    cb(ApiError.ENOENT(this._folder));
                }
                else {
                    this._wrapped.mkdir(this._folder, 0x1ff, cb);
                }
            });
        }
    }
    FolderAdapter.Name = "FolderAdapter";
    FolderAdapter.Options = {
        folder: {
            type: "string",
            description: "The folder to use as the root directory"
        },
        wrapped: {
            type: "object",
            description: "The file system to wrap"
        }
    };
    /**
     * @hidden
     */
    function translateError(folder, e) {
        if (e !== null && typeof e === 'object') {
            const err = e;
            let p = err.path;
            if (p) {
                p = '/' + path.relative(folder, p);
                err.message = err.message.replace(err.path, p);
                err.path = p;
            }
        }
        return e;
    }
    /**
     * @hidden
     */
    function wrapCallback(folder, cb) {
        if (typeof cb === 'function') {
            return function (err) {
                if (arguments.length > 0) {
                    arguments[0] = translateError(folder, err);
                }
                cb.apply(null, arguments);
            };
        }
        else {
            return cb;
        }
    }
    /**
     * @hidden
     */
    function wrapFunction(name, wrapFirst, wrapSecond) {
        if (name.slice(name.length - 4) !== 'Sync') {
            // Async function. Translate error in callback.
            return function () {
                if (arguments.length > 0) {
                    if (wrapFirst) {
                        arguments[0] = path.join(this._folder, arguments[0]);
                    }
                    if (wrapSecond) {
                        arguments[1] = path.join(this._folder, arguments[1]);
                    }
                    arguments[arguments.length - 1] = wrapCallback(this._folder, arguments[arguments.length - 1]);
                }
                return this._wrapped[name].apply(this._wrapped, arguments);
            };
        }
        else {
            // Sync function. Translate error in catch.
            return function () {
                try {
                    if (wrapFirst) {
                        arguments[0] = path.join(this._folder, arguments[0]);
                    }
                    if (wrapSecond) {
                        arguments[1] = path.join(this._folder, arguments[1]);
                    }
                    return this._wrapped[name].apply(this._wrapped, arguments);
                }
                catch (e) {
                    throw translateError(this._folder, e);
                }
            };
        }
    }
    // First argument is a path.
    ['diskSpace', 'stat', 'statSync', 'open', 'openSync', 'unlink', 'unlinkSync',
        'rmdir', 'rmdirSync', 'mkdir', 'mkdirSync', 'readdir', 'readdirSync', 'exists',
        'existsSync', 'realpath', 'realpathSync', 'truncate', 'truncateSync', 'readFile',
        'readFileSync', 'writeFile', 'writeFileSync', 'appendFile', 'appendFileSync',
        'chmod', 'chmodSync', 'chown', 'chownSync', 'utimes', 'utimesSync', 'readlink',
        'readlinkSync'].forEach((name) => {
        FolderAdapter.prototype[name] = wrapFunction(name, true, false);
    });
    // First and second arguments are paths.
    ['rename', 'renameSync', 'link', 'linkSync', 'symlink', 'symlinkSync'].forEach((name) => {
        FolderAdapter.prototype[name] = wrapFunction(name, true, true);
    });

    return FolderAdapter;
});
define('skylark-browserfs/backend/HTML5FS',[
    "skylark-langx-async",
    '../generic/preload_file',
    '../core/file_system',
    '../core/api_error',
    '../core/file_flag',
    '../core/node_fs_stats',
    '../libs/path',
    '../core/global',
    '../core/util'
], function (async,preload_file, file_system, api_error, file_flag, node_fs_stats, path, global, util) {
    'use strict';
    const { BaseFileSystem } = file_system;
    const { ApiError, ErrorCode } = api_error;
    const { ActionType } = file_flag;
    const { Stats, FileType } = node_fs_stats;
    const asyncEach = async.each;
    const { buffer2ArrayBuffer, arrayBuffer2Buffer } = util;

    const { PreloadFile} = preload_file;

    /**
     * @hidden
     */
    function isDirectoryEntry(entry) {
        return entry.isDirectory;
    }
    /**
     * @hidden
     */
    const _getFS = global.webkitRequestFileSystem || global.requestFileSystem || null;
    /**
     * @hidden
     */
    function _requestQuota(type, size, success, errorCallback) {
        // We cast navigator and window to '<any>' because everything here is
        // nonstandard functionality, despite the fact that Chrome has the only
        // implementation of the HTML5FS and is likely driving the standardization
        // process. Thus, these objects defined off of navigator and window are not
        // present in the DefinitelyTyped TypeScript typings for FileSystem.
        if (typeof navigator['webkitPersistentStorage'] !== 'undefined') {
            switch (type) {
                case global.PERSISTENT:
                    navigator.webkitPersistentStorage.requestQuota(size, success, errorCallback);
                    break;
                case global.TEMPORARY:
                    navigator.webkitTemporaryStorage.requestQuota(size, success, errorCallback);
                    break;
                default:
                    errorCallback(new TypeError(`Invalid storage type: ${type}`));
                    break;
            }
        }
        else {
            global.webkitStorageInfo.requestQuota(type, size, success, errorCallback);
        }
    }
    /**
     * @hidden
     */
    function _toArray(list) {
        return Array.prototype.slice.call(list || [], 0);
    }
    /**
     * Converts the given DOMError into an appropriate ApiError.
     * @url https://developer.mozilla.org/en-US/docs/Web/API/DOMError
     * @hidden
     */
    function convertError(err, p, expectedDir) {
        switch (err.name) {
            /* The user agent failed to create a file or directory due to the existence of a file or
                directory with the same path.  */
            case "PathExistsError":
                return ApiError.EEXIST(p);
            /* The operation failed because it would cause the application to exceed its storage quota.  */
            case 'QuotaExceededError':
                return ApiError.FileError(ErrorCode.ENOSPC, p);
            /*  A required file or directory could not be found at the time an operation was processed.   */
            case 'NotFoundError':
                return ApiError.ENOENT(p);
            /* This is a security error code to be used in situations not covered by any other error codes.
                - A required file was unsafe for access within a Web application
                - Too many calls are being made on filesystem resources */
            case 'SecurityError':
                return ApiError.FileError(ErrorCode.EACCES, p);
            /* The modification requested was illegal. Examples of invalid modifications include moving a
                directory into its own child, moving a file into its parent directory without changing its name,
                or copying a directory to a path occupied by a file.  */
            case 'InvalidModificationError':
                return ApiError.FileError(ErrorCode.EPERM, p);
            /* The user has attempted to look up a file or directory, but the Entry found is of the wrong type
                [e.g. is a DirectoryEntry when the user requested a FileEntry].  */
            case 'TypeMismatchError':
                return ApiError.FileError(expectedDir ? ErrorCode.ENOTDIR : ErrorCode.EISDIR, p);
            /* A path or URL supplied to the API was malformed.  */
            case "EncodingError":
            /* An operation depended on state cached in an interface object, but that state that has changed
                since it was read from disk.  */
            case "InvalidStateError":
            /* The user attempted to write to a file or directory which could not be modified due to the state
                of the underlying filesystem.  */
            case "NoModificationAllowedError":
            default:
                return ApiError.FileError(ErrorCode.EINVAL, p);
        }
    }
    // A note about getFile and getDirectory options:
    // These methods are called at numerous places in this file, and are passed
    // some combination of these two options:
    //   - create: If true, the entry will be created if it doesn't exist.
    //             If false, an error will be thrown if it doesn't exist.
    //   - exclusive: If true, only create the entry if it doesn't already exist,
    //                and throw an error if it does.
    class HTML5FSFile extends PreloadFile {
        constructor(fs, entry, path, flag, stat, contents) {
            super(fs, path, flag, stat, contents);
            this._entry = entry;
        }
        sync(cb) {
            if (!this.isDirty()) {
                return cb();
            }
            this._entry.createWriter((writer) => {
                const buffer = this.getBuffer();
                const blob = new Blob([buffer2ArrayBuffer(buffer)]);
                const length = blob.size;
                writer.onwriteend = (err) => {
                    writer.onwriteend = null;
                    writer.onerror = null;
                    writer.truncate(length);
                    this.resetDirty();
                    cb();
                };
                writer.onerror = (err) => {
                    cb(convertError(err, this.getPath(), false));
                };
                writer.write(blob);
            });
        }
        close(cb) {
            this.sync(cb);
        }
    }
    /**
     * A read-write filesystem backed by the HTML5 FileSystem API.
     *
     * As the HTML5 FileSystem is only implemented in Blink, this interface is
     * only available in Chrome.
     */
    class HTML5FS extends BaseFileSystem {
        /**
         * @param size storage quota to request, in megabytes. Allocated value may be less.
         * @param type window.PERSISTENT or window.TEMPORARY. Defaults to PERSISTENT.
         */
        constructor(size = 5, type = global.PERSISTENT) {
            super();
            // Convert MB to bytes.
            this.size = 1024 * 1024 * size;
            this.type = type;
        }
        /**
         * Creates an HTML5FS instance with the given options.
         */
        static Create(opts, cb) {
            const fs = new HTML5FS(opts.size, opts.type);
            fs._allocate((e) => e ? cb(e) : cb(null, fs));
        }
        static isAvailable() {
            return !!_getFS;
        }
        getName() {
            return HTML5FS.Name;
        }
        isReadOnly() {
            return false;
        }
        supportsSymlinks() {
            return false;
        }
        supportsProps() {
            return false;
        }
        supportsSynch() {
            return false;
        }
        /**
         * Deletes everything in the FS. Used for testing.
         * Karma clears the storage after you quit it but not between runs of the test
         * suite, and the tests expect an empty FS every time.
         */
        empty(mainCb) {
            // Get a list of all entries in the root directory to delete them
            this._readdir('/', (err, entries) => {
                if (err) {
                    mainCb(err);
                }
                else {
                    // Called when every entry has been operated on
                    const finished = (er) => {
                        if (err) {
                            mainCb(err);
                        }
                        else {
                            mainCb();
                        }
                    };
                    // Removes files and recursively removes directories
                    const deleteEntry = (entry, cb) => {
                        const succ = () => {
                            cb();
                        };
                        const error = (err) => {
                            cb(convertError(err, entry.fullPath, !entry.isDirectory));
                        };
                        if (isDirectoryEntry(entry)) {
                            entry.removeRecursively(succ, error);
                        }
                        else {
                            entry.remove(succ, error);
                        }
                    };
                    // Loop through the entries and remove them, then call the callback
                    // when they're all finished.
                    asyncEach(entries, deleteEntry, finished);
                }
            });
        }
        rename(oldPath, newPath, cb) {
            let semaphore = 2;
            let successCount = 0;
            const root = this.fs.root;
            let currentPath = oldPath;
            const error = (err) => {
                if (--semaphore <= 0) {
                    cb(convertError(err, currentPath, false));
                }
            };
            const success = (file) => {
                if (++successCount === 2) {
                    return cb(new ApiError(ErrorCode.EINVAL, "Something was identified as both a file and a directory. This should never happen."));
                }
                // SPECIAL CASE: If newPath === oldPath, and the path exists, then
                // this operation trivially succeeds.
                if (oldPath === newPath) {
                    return cb();
                }
                // Get the new parent directory.
                currentPath = path.dirname(newPath);
                root.getDirectory(currentPath, {}, (parentDir) => {
                    currentPath = path.basename(newPath);
                    file.moveTo(parentDir, currentPath, (entry) => { cb(); }, (err) => {
                        // SPECIAL CASE: If oldPath is a directory, and newPath is a
                        // file, rename should delete the file and perform the move.
                        if (file.isDirectory) {
                            currentPath = newPath;
                            // Unlink only works on files. Try to delete newPath.
                            this.unlink(newPath, (e) => {
                                if (e) {
                                    // newPath is probably a directory.
                                    error(err);
                                }
                                else {
                                    // Recur, now that newPath doesn't exist.
                                    this.rename(oldPath, newPath, cb);
                                }
                            });
                        }
                        else {
                            error(err);
                        }
                    });
                }, error);
            };
            // We don't know if oldPath is a *file* or a *directory*, and there's no
            // way to stat items. So launch both requests, see which one succeeds.
            root.getFile(oldPath, {}, success, error);
            root.getDirectory(oldPath, {}, success, error);
        }
        stat(path, isLstat, cb) {
            // Throw an error if the entry doesn't exist, because then there's nothing
            // to stat.
            const opts = {
                create: false
            };
            // Called when the path has been successfully loaded as a file.
            const loadAsFile = (entry) => {
                const fileFromEntry = (file) => {
                    const stat = new Stats(FileType.FILE, file.size);
                    cb(null, stat);
                };
                entry.file(fileFromEntry, failedToLoad);
            };
            // Called when the path has been successfully loaded as a directory.
            const loadAsDir = (dir) => {
                // Directory entry size can't be determined from the HTML5 FS API, and is
                // implementation-dependant anyway, so a dummy value is used.
                const size = 4096;
                const stat = new Stats(FileType.DIRECTORY, size);
                cb(null, stat);
            };
            // Called when the path couldn't be opened as a directory or a file.
            const failedToLoad = (err) => {
                cb(convertError(err, path, false /* Unknown / irrelevant */));
            };
            // Called when the path couldn't be opened as a file, but might still be a
            // directory.
            const failedToLoadAsFile = () => {
                this.fs.root.getDirectory(path, opts, loadAsDir, failedToLoad);
            };
            // No method currently exists to determine whether a path refers to a
            // directory or a file, so this implementation tries both and uses the first
            // one that succeeds.
            this.fs.root.getFile(path, opts, loadAsFile, failedToLoadAsFile);
        }
        open(p, flags, mode, cb) {
            // XXX: err is a DOMError
            const error = (err) => {
                if (err.name === 'InvalidModificationError' && flags.isExclusive()) {
                    cb(ApiError.EEXIST(p));
                }
                else {
                    cb(convertError(err, p, false));
                }
            };
            this.fs.root.getFile(p, {
                create: flags.pathNotExistsAction() === ActionType.CREATE_FILE,
                exclusive: flags.isExclusive()
            }, (entry) => {
                // Try to fetch corresponding file.
                entry.file((file) => {
                    const reader = new FileReader();
                    reader.onloadend = (event) => {
                        const bfsFile = this._makeFile(p, entry, flags, file, reader.result);
                        cb(null, bfsFile);
                    };
                    reader.onerror = (ev) => {
                        error(reader.error);
                    };
                    reader.readAsArrayBuffer(file);
                }, error);
            }, error);
        }
        unlink(path, cb) {
            this._remove(path, cb, true);
        }
        rmdir(path, cb) {
            // Check if directory is non-empty, first.
            this.readdir(path, (e, files) => {
                if (e) {
                    cb(e);
                }
                else if (files.length > 0) {
                    cb(ApiError.ENOTEMPTY(path));
                }
                else {
                    this._remove(path, cb, false);
                }
            });
        }
        mkdir(path, mode, cb) {
            // Create the directory, but throw an error if it already exists, as per
            // mkdir(1)
            const opts = {
                create: true,
                exclusive: true
            };
            const success = (dir) => {
                cb();
            };
            const error = (err) => {
                cb(convertError(err, path, true));
            };
            this.fs.root.getDirectory(path, opts, success, error);
        }
        /**
         * Map _readdir's list of `FileEntry`s to their names and return that.
         */
        readdir(path, cb) {
            this._readdir(path, (e, entries) => {
                if (entries) {
                    const rv = [];
                    for (const entry of entries) {
                        rv.push(entry.name);
                    }
                    cb(null, rv);
                }
                else {
                    return cb(e);
                }
            });
        }
        /**
         * Returns a BrowserFS object representing a File.
         */
        _makeFile(path, entry, flag, stat, data = new ArrayBuffer(0)) {
            const stats = new Stats(FileType.FILE, stat.size);
            const buffer = arrayBuffer2Buffer(data);
            return new HTML5FSFile(this, entry, path, flag, stats, buffer);
        }
        /**
         * Returns an array of `FileEntry`s. Used internally by empty and readdir.
         */
        _readdir(path, cb) {
            const error = (err) => {
                cb(convertError(err, path, true));
            };
            // Grab the requested directory.
            this.fs.root.getDirectory(path, { create: false }, (dirEntry) => {
                const reader = dirEntry.createReader();
                let entries = [];
                // Call the reader.readEntries() until no more results are returned.
                const readEntries = () => {
                    reader.readEntries(((results) => {
                        if (results.length) {
                            entries = entries.concat(_toArray(results));
                            readEntries();
                        }
                        else {
                            cb(null, entries);
                        }
                    }), error);
                };
                readEntries();
            }, error);
        }
        /**
         * Requests a storage quota from the browser to back this FS.
         */
        _allocate(cb) {
            const success = (fs) => {
                this.fs = fs;
                cb();
            };
            const error = (err) => {
                cb(convertError(err, "/", true));
            };
            if (this.type === global.PERSISTENT) {
                _requestQuota(this.type, this.size, (granted) => {
                    _getFS(this.type, granted, success, error);
                }, error);
            }
            else {
                _getFS(this.type, this.size, success, error);
            }
        }
        /**
         * Delete a file or directory from the file system
         * isFile should reflect which call was made to remove the it (`unlink` or
         * `rmdir`). If this doesn't match what's actually at `path`, an error will be
         * returned
         */
        _remove(path, cb, isFile) {
            const success = (entry) => {
                const succ = () => {
                    cb();
                };
                const err = (err) => {
                    cb(convertError(err, path, !isFile));
                };
                entry.remove(succ, err);
            };
            const error = (err) => {
                cb(convertError(err, path, !isFile));
            };
            // Deleting the entry, so don't create it
            const opts = {
                create: false
            };
            if (isFile) {
                this.fs.root.getFile(path, opts, success, error);
            }
            else {
                this.fs.root.getDirectory(path, opts, success, error);
            }
        }
    }
    HTML5FS.Name = "HTML5FS";
    HTML5FS.Options = {
        size: {
            type: "number",
            optional: true,
            description: "Storage quota to request, in megabytes. Allocated value may be less. Defaults to 5."
        },
        type: {
            type: "number",
            optional: true,
            description: "window.PERSISTENT or window.TEMPORARY. Defaults to PERSISTENT."
        }
    };

    HTML5FS.HTML5FSFile = HTML5FSFile;

    return HTML5FS;
});
define('skylark-browserfs/generic/inode',[
    '../libs/buffers',
    '../core/node_fs_stats'
], function (buffers,node_fs_stats) {
    'use strict';

    const  { Stats, FileType } = node_fs_stats;
    const { Buffer } = buffers;

    /**
     * Generic inode definition that can easily be serialized.
     */
    class Inode {
        constructor(id, size, mode, atime, mtime, ctime) {
            this.id = id;
            this.size = size;
            this.mode = mode;
            this.atime = atime;
            this.mtime = mtime;
            this.ctime = ctime;
        }
        /**
         * Converts the buffer into an Inode.
         */
        static fromBuffer(buffer) {
            if (buffer === undefined) {
                throw new Error("NO");
            }
            return new Inode(buffer.toString('ascii', 30), buffer.readUInt32LE(0), buffer.readUInt16LE(4), buffer.readDoubleLE(6), buffer.readDoubleLE(14), buffer.readDoubleLE(22));
        }
        /**
         * Handy function that converts the Inode to a Node Stats object.
         */
        toStats() {
            return new Stats((this.mode & 0xF000) === FileType.DIRECTORY ? FileType.DIRECTORY : FileType.FILE, this.size, this.mode, this.atime, this.mtime, this.ctime);
        }
        /**
         * Get the size of this Inode, in bytes.
         */
        getSize() {
            // ASSUMPTION: ID is ASCII (1 byte per char).
            return 30 + this.id.length;
        }
        /**
         * Writes the inode into the start of the buffer.
         */
        toBuffer(buff = Buffer.alloc(this.getSize())) {
            buff.writeUInt32LE(this.size, 0);
            buff.writeUInt16LE(this.mode, 4);
            buff.writeDoubleLE(this.atime, 6);
            buff.writeDoubleLE(this.mtime, 14);
            buff.writeDoubleLE(this.ctime, 22);
            buff.write(this.id, 30, this.id.length, 'ascii');
            return buff;
        }
        /**
         * Updates the Inode using information from the stats object. Used by file
         * systems at sync time, e.g.:
         * - Program opens file and gets a File object.
         * - Program mutates file. File object is responsible for maintaining
         *   metadata changes locally -- typically in a Stats object.
         * - Program closes file. File object's metadata changes are synced with the
         *   file system.
         * @return True if any changes have occurred.
         */
        update(stats) {
            let hasChanged = false;
            if (this.size !== stats.size) {
                this.size = stats.size;
                hasChanged = true;
            }
            if (this.mode !== stats.mode) {
                this.mode = stats.mode;
                hasChanged = true;
            }
            const atimeMs = stats.atime.getTime();
            if (this.atime !== atimeMs) {
                this.atime = atimeMs;
                hasChanged = true;
            }
            const mtimeMs = stats.mtime.getTime();
            if (this.mtime !== mtimeMs) {
                this.mtime = mtimeMs;
                hasChanged = true;
            }
            const ctimeMs = stats.ctime.getTime();
            if (this.ctime !== ctimeMs) {
                this.ctime = ctimeMs;
                hasChanged = true;
            }
            return hasChanged;
        }
        // XXX: Copied from Stats. Should reconcile these two into something more
        //      compact.
        /**
         * @return [Boolean] True if this item is a file.
         */
        isFile() {
            return (this.mode & 0xF000) === FileType.FILE;
        }
        /**
         * @return [Boolean] True if this item is a directory.
         */
        isDirectory() {
            return (this.mode & 0xF000) === FileType.DIRECTORY;
        }
    }


    return Inode;
});
define('skylark-browserfs/generic/key_value_filesystem',[
    '../libs/buffers',
    '../core/file_system',
    '../core/api_error',
    '../core/node_fs_stats',
    '../libs/path',
    '../generic/inode',
    '../generic/preload_file',
    '../core/util'
], function (buffers,file_system, api_error, node_fs_stats, path, Inode, preload_file, util) {
    'use strict';

    const { BaseFileSystem, SynchronousFileSystem } = file_system;
    const { ApiError, ErrorCode } = api_error;
    const { FileType } = node_fs_stats;
    const { emptyBuffer } = util;
    const { PreloadFile} = preload_file;
    const { Buffer } = buffers;


    /**
     * @hidden
     */
    const ROOT_NODE_ID = "/";
    /**
     * @hidden
     */
    let emptyDirNode = null;
    /**
     * Returns an empty directory node.
     * @hidden
     */
    function getEmptyDirNode() {
        if (emptyDirNode) {
            return emptyDirNode;
        }
        return emptyDirNode = Buffer.from("{}");
    }
    /**
     * Generates a random ID.
     * @hidden
     */
    function GenerateRandomID() {
        // From http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
    /**
     * Helper function. Checks if 'e' is defined. If so, it triggers the callback
     * with 'e' and returns false. Otherwise, returns true.
     * @hidden
     */
    function noError(e, cb) {
        if (e) {
            cb(e);
            return false;
        }
        return true;
    }
    /**
     * Helper function. Checks if 'e' is defined. If so, it aborts the transaction,
     * triggers the callback with 'e', and returns false. Otherwise, returns true.
     * @hidden
     */
    function noErrorTx(e, tx, cb) {
        if (e) {
            tx.abort(() => {
                cb(e);
            });
            return false;
        }
        return true;
    }
    class LRUNode {
        constructor(key, value) {
            this.key = key;
            this.value = value;
            this.prev = null;
            this.next = null;
        }
    }
    // Adapted from https://chrisrng.svbtle.com/lru-cache-in-javascript
    class LRUCache {
        constructor(limit) {
            this.limit = limit;
            this.size = 0;
            this.map = {};
            this.head = null;
            this.tail = null;
        }
        /**
         * Change or add a new value in the cache
         * We overwrite the entry if it already exists
         */
        set(key, value) {
            const node = new LRUNode(key, value);
            if (this.map[key]) {
                this.map[key].value = node.value;
                this.remove(node.key);
            }
            else {
                if (this.size >= this.limit) {
                    delete this.map[this.tail.key];
                    this.size--;
                    this.tail = this.tail.prev;
                    this.tail.next = null;
                }
            }
            this.setHead(node);
        }
        /* Retrieve a single entry from the cache */
        get(key) {
            if (this.map[key]) {
                const value = this.map[key].value;
                const node = new LRUNode(key, value);
                this.remove(key);
                this.setHead(node);
                return value;
            }
            else {
                return null;
            }
        }
        /* Remove a single entry from the cache */
        remove(key) {
            const node = this.map[key];
            if (!node) {
                return;
            }
            if (node.prev !== null) {
                node.prev.next = node.next;
            }
            else {
                this.head = node.next;
            }
            if (node.next !== null) {
                node.next.prev = node.prev;
            }
            else {
                this.tail = node.prev;
            }
            delete this.map[key];
            this.size--;
        }
        /* Resets the entire cache - Argument limit is optional to be reset */
        removeAll() {
            this.size = 0;
            this.map = {};
            this.head = null;
            this.tail = null;
        }
        setHead(node) {
            node.next = this.head;
            node.prev = null;
            if (this.head !== null) {
                this.head.prev = node;
            }
            this.head = node;
            if (this.tail === null) {
                this.tail = node;
            }
            this.size++;
            this.map[node.key] = node;
        }
    }
    /**
     * A simple RW transaction for simple synchronous key-value stores.
     */
    class SimpleSyncRWTransaction {
        constructor(store) {
            this.store = store;
            /**
             * Stores data in the keys we modify prior to modifying them.
             * Allows us to roll back commits.
             */
            this.originalData = {};
            /**
             * List of keys modified in this transaction, if any.
             */
            this.modifiedKeys = [];
        }
        get(key) {
            const val = this.store.get(key);
            this.stashOldValue(key, val);
            return val;
        }
        put(key, data, overwrite) {
            this.markModified(key);
            return this.store.put(key, data, overwrite);
        }
        del(key) {
            this.markModified(key);
            this.store.del(key);
        }
        commit() { }
        abort() {
            // Rollback old values.
            for (const key of this.modifiedKeys) {
                const value = this.originalData[key];
                if (!value) {
                    // Key didn't exist.
                    this.store.del(key);
                }
                else {
                    // Key existed. Store old value.
                    this.store.put(key, value, true);
                }
            }
        }
        /**
         * Stashes given key value pair into `originalData` if it doesn't already
         * exist. Allows us to stash values the program is requesting anyway to
         * prevent needless `get` requests if the program modifies the data later
         * on during the transaction.
         */
        stashOldValue(key, value) {
            // Keep only the earliest value in the transaction.
            if (!this.originalData.hasOwnProperty(key)) {
                this.originalData[key] = value;
            }
        }
        /**
         * Marks the given key as modified, and stashes its value if it has not been
         * stashed already.
         */
        markModified(key) {
            if (this.modifiedKeys.indexOf(key) === -1) {
                this.modifiedKeys.push(key);
                if (!this.originalData.hasOwnProperty(key)) {
                    this.originalData[key] = this.store.get(key);
                }
            }
        }
    }
    class SyncKeyValueFile extends PreloadFile {
        constructor(_fs, _path, _flag, _stat, contents) {
            super(_fs, _path, _flag, _stat, contents);
        }
        syncSync() {
            if (this.isDirty()) {
                this._fs._syncSync(this.getPath(), this.getBuffer(), this.getStats());
                this.resetDirty();
            }
        }
        closeSync() {
            this.syncSync();
        }
    }
    /**
     * A "Synchronous key-value file system". Stores data to/retrieves data from an
     * underlying key-value store.
     *
     * We use a unique ID for each node in the file system. The root node has a
     * fixed ID.
     * @todo Introduce Node ID caching.
     * @todo Check modes.
     */
    class SyncKeyValueFileSystem extends SynchronousFileSystem {
        static isAvailable() { return true; }
        constructor(options) {
            super();
            this.store = options.store;
            // INVARIANT: Ensure that the root exists.
            this.makeRootDirectory();
        }
        getName() { return this.store.name(); }
        isReadOnly() { return false; }
        supportsSymlinks() { return false; }
        supportsProps() { return false; }
        supportsSynch() { return true; }
        /**
         * Delete all contents stored in the file system.
         */
        empty() {
            this.store.clear();
            // INVARIANT: Root always exists.
            this.makeRootDirectory();
        }
        renameSync(oldPath, newPath) {
            const tx = this.store.beginTransaction('readwrite'), oldParent = path.dirname(oldPath), oldName = path.basename(oldPath), newParent = path.dirname(newPath), newName = path.basename(newPath), 
            // Remove oldPath from parent's directory listing.
            oldDirNode = this.findINode(tx, oldParent), oldDirList = this.getDirListing(tx, oldParent, oldDirNode);
            if (!oldDirList[oldName]) {
                throw ApiError.ENOENT(oldPath);
            }
            const nodeId = oldDirList[oldName];
            delete oldDirList[oldName];
            // Invariant: Can't move a folder inside itself.
            // This funny little hack ensures that the check passes only if oldPath
            // is a subpath of newParent. We append '/' to avoid matching folders that
            // are a substring of the bottom-most folder in the path.
            if ((newParent + '/').indexOf(oldPath + '/') === 0) {
                throw new ApiError(ErrorCode.EBUSY, oldParent);
            }
            // Add newPath to parent's directory listing.
            let newDirNode, newDirList;
            if (newParent === oldParent) {
                // Prevent us from re-grabbing the same directory listing, which still
                // contains oldName.
                newDirNode = oldDirNode;
                newDirList = oldDirList;
            }
            else {
                newDirNode = this.findINode(tx, newParent);
                newDirList = this.getDirListing(tx, newParent, newDirNode);
            }
            if (newDirList[newName]) {
                // If it's a file, delete it.
                const newNameNode = this.getINode(tx, newPath, newDirList[newName]);
                if (newNameNode.isFile()) {
                    try {
                        tx.del(newNameNode.id);
                        tx.del(newDirList[newName]);
                    }
                    catch (e) {
                        tx.abort();
                        throw e;
                    }
                }
                else {
                    // If it's a directory, throw a permissions error.
                    throw ApiError.EPERM(newPath);
                }
            }
            newDirList[newName] = nodeId;
            // Commit the two changed directory listings.
            try {
                tx.put(oldDirNode.id, Buffer.from(JSON.stringify(oldDirList)), true);
                tx.put(newDirNode.id, Buffer.from(JSON.stringify(newDirList)), true);
            }
            catch (e) {
                tx.abort();
                throw e;
            }
            tx.commit();
        }
        statSync(p, isLstat) {
            // Get the inode to the item, convert it into a Stats object.
            return this.findINode(this.store.beginTransaction('readonly'), p).toStats();
        }
        createFileSync(p, flag, mode) {
            const tx = this.store.beginTransaction('readwrite'), data = emptyBuffer(), newFile = this.commitNewFile(tx, p, FileType.FILE, mode, data);
            // Open the file.
            return new SyncKeyValueFile(this, p, flag, newFile.toStats(), data);
        }
        openFileSync(p, flag) {
            const tx = this.store.beginTransaction('readonly'), node = this.findINode(tx, p), data = tx.get(node.id);
            if (data === undefined) {
                throw ApiError.ENOENT(p);
            }
            return new SyncKeyValueFile(this, p, flag, node.toStats(), data);
        }
        unlinkSync(p) {
            this.removeEntry(p, false);
        }
        rmdirSync(p) {
            // Check first if directory is empty.
            if (this.readdirSync(p).length > 0) {
                throw ApiError.ENOTEMPTY(p);
            }
            else {
                this.removeEntry(p, true);
            }
        }
        mkdirSync(p, mode) {
            const tx = this.store.beginTransaction('readwrite'), data = Buffer.from('{}');
            this.commitNewFile(tx, p, FileType.DIRECTORY, mode, data);
        }
        readdirSync(p) {
            const tx = this.store.beginTransaction('readonly');
            return Object.keys(this.getDirListing(tx, p, this.findINode(tx, p)));
        }
        _syncSync(p, data, stats) {
            // @todo Ensure mtime updates properly, and use that to determine if a data
            //       update is required.
            const tx = this.store.beginTransaction('readwrite'), 
            // We use the _findInode helper because we actually need the INode id.
            fileInodeId = this._findINode(tx, path.dirname(p), path.basename(p)), fileInode = this.getINode(tx, p, fileInodeId), inodeChanged = fileInode.update(stats);
            try {
                // Sync data.
                tx.put(fileInode.id, data, true);
                // Sync metadata.
                if (inodeChanged) {
                    tx.put(fileInodeId, fileInode.toBuffer(), true);
                }
            }
            catch (e) {
                tx.abort();
                throw e;
            }
            tx.commit();
        }
        /**
         * Checks if the root directory exists. Creates it if it doesn't.
         */
        makeRootDirectory() {
            const tx = this.store.beginTransaction('readwrite');
            if (tx.get(ROOT_NODE_ID) === undefined) {
                // Create new inode.
                const currTime = (new Date()).getTime(), 
                // Mode 0666
                dirInode = new Inode(GenerateRandomID(), 4096, 511 | FileType.DIRECTORY, currTime, currTime, currTime);
                // If the root doesn't exist, the first random ID shouldn't exist,
                // either.
                tx.put(dirInode.id, getEmptyDirNode(), false);
                tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false);
                tx.commit();
            }
        }
        /**
         * Helper function for findINode.
         * @param parent The parent directory of the file we are attempting to find.
         * @param filename The filename of the inode we are attempting to find, minus
         *   the parent.
         * @return string The ID of the file's inode in the file system.
         */
        _findINode(tx, parent, filename) {
            const readDirectory = (inode) => {
                // Get the root's directory listing.
                const dirList = this.getDirListing(tx, parent, inode);
                // Get the file's ID.
                if (dirList[filename]) {
                    return dirList[filename];
                }
                else {
                    throw ApiError.ENOENT(path.resolve(parent, filename));
                }
            };
            if (parent === '/') {
                if (filename === '') {
                    // BASE CASE #1: Return the root's ID.
                    return ROOT_NODE_ID;
                }
                else {
                    // BASE CASE #2: Find the item in the root ndoe.
                    return readDirectory(this.getINode(tx, parent, ROOT_NODE_ID));
                }
            }
            else {
                return readDirectory(this.getINode(tx, parent + path.sep + filename, this._findINode(tx, path.dirname(parent), path.basename(parent))));
            }
        }
        /**
         * Finds the Inode of the given path.
         * @param p The path to look up.
         * @return The Inode of the path p.
         * @todo memoize/cache
         */
        findINode(tx, p) {
            return this.getINode(tx, p, this._findINode(tx, path.dirname(p), path.basename(p)));
        }
        /**
         * Given the ID of a node, retrieves the corresponding Inode.
         * @param tx The transaction to use.
         * @param p The corresponding path to the file (used for error messages).
         * @param id The ID to look up.
         */
        getINode(tx, p, id) {
            const inode = tx.get(id);
            if (inode === undefined) {
                throw ApiError.ENOENT(p);
            }
            return Inode.fromBuffer(inode);
        }
        /**
         * Given the Inode of a directory, retrieves the corresponding directory
         * listing.
         */
        getDirListing(tx, p, inode) {
            if (!inode.isDirectory()) {
                throw ApiError.ENOTDIR(p);
            }
            const data = tx.get(inode.id);
            if (data === undefined) {
                throw ApiError.ENOENT(p);
            }
            return JSON.parse(data.toString());
        }
        /**
         * Creates a new node under a random ID. Retries 5 times before giving up in
         * the exceedingly unlikely chance that we try to reuse a random GUID.
         * @return The GUID that the data was stored under.
         */
        addNewNode(tx, data) {
            const retries = 0;
            let currId;
            while (retries < 5) {
                try {
                    currId = GenerateRandomID();
                    tx.put(currId, data, false);
                    return currId;
                }
                catch (e) {
                    // Ignore and reroll.
                }
            }
            throw new ApiError(ErrorCode.EIO, 'Unable to commit data to key-value store.');
        }
        /**
         * Commits a new file (well, a FILE or a DIRECTORY) to the file system with
         * the given mode.
         * Note: This will commit the transaction.
         * @param p The path to the new file.
         * @param type The type of the new file.
         * @param mode The mode to create the new file with.
         * @param data The data to store at the file's data node.
         * @return The Inode for the new file.
         */
        commitNewFile(tx, p, type, mode, data) {
            const parentDir = path.dirname(p), fname = path.basename(p), parentNode = this.findINode(tx, parentDir), dirListing = this.getDirListing(tx, parentDir, parentNode), currTime = (new Date()).getTime();
            // Invariant: The root always exists.
            // If we don't check this prior to taking steps below, we will create a
            // file with name '' in root should p == '/'.
            if (p === '/') {
                throw ApiError.EEXIST(p);
            }
            // Check if file already exists.
            if (dirListing[fname]) {
                throw ApiError.EEXIST(p);
            }
            let fileNode;
            try {
                // Commit data.
                const dataId = this.addNewNode(tx, data);
                fileNode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);
                // Commit file node.
                const fileNodeId = this.addNewNode(tx, fileNode.toBuffer());
                // Update and commit parent directory listing.
                dirListing[fname] = fileNodeId;
                tx.put(parentNode.id, Buffer.from(JSON.stringify(dirListing)), true);
            }
            catch (e) {
                tx.abort();
                throw e;
            }
            tx.commit();
            return fileNode;
        }
        /**
         * Remove all traces of the given path from the file system.
         * @param p The path to remove from the file system.
         * @param isDir Does the path belong to a directory, or a file?
         * @todo Update mtime.
         */
        removeEntry(p, isDir) {
            const tx = this.store.beginTransaction('readwrite'), parent = path.dirname(p), parentNode = this.findINode(tx, parent), parentListing = this.getDirListing(tx, parent, parentNode), fileName = path.basename(p);
            if (!parentListing[fileName]) {
                throw ApiError.ENOENT(p);
            }
            // Remove from directory listing of parent.
            const fileNodeId = parentListing[fileName];
            delete parentListing[fileName];
            // Get file inode.
            const fileNode = this.getINode(tx, p, fileNodeId);
            if (!isDir && fileNode.isDirectory()) {
                throw ApiError.EISDIR(p);
            }
            else if (isDir && !fileNode.isDirectory()) {
                throw ApiError.ENOTDIR(p);
            }
            try {
                // Delete data.
                tx.del(fileNode.id);
                // Delete node.
                tx.del(fileNodeId);
                // Update directory listing.
                tx.put(parentNode.id, Buffer.from(JSON.stringify(parentListing)), true);
            }
            catch (e) {
                tx.abort();
                throw e;
            }
            // Success.
            tx.commit();
        }
    }
    class AsyncKeyValueFile extends PreloadFile {
        constructor(_fs, _path, _flag, _stat, contents) {
            super(_fs, _path, _flag, _stat, contents);
        }
        sync(cb) {
            if (this.isDirty()) {
                this._fs._sync(this.getPath(), this.getBuffer(), this.getStats(), (e) => {
                    if (!e) {
                        this.resetDirty();
                    }
                    cb(e);
                });
            }
            else {
                cb();
            }
        }
        close(cb) {
            this.sync(cb);
        }
    }
    /**
     * An "Asynchronous key-value file system". Stores data to/retrieves data from
     * an underlying asynchronous key-value store.
     */
    class AsyncKeyValueFileSystem extends BaseFileSystem {
        constructor(cacheSize) {
            super();
            this._cache = null;
            if (cacheSize > 0) {
                this._cache = new LRUCache(cacheSize);
            }
        }
        static isAvailable() { return true; }
        /**
         * Initializes the file system. Typically called by subclasses' async
         * constructors.
         */
        init(store, cb) {
            this.store = store;
            // INVARIANT: Ensure that the root exists.
            this.makeRootDirectory(cb);
        }
        getName() { return this.store.name(); }
        isReadOnly() { return false; }
        supportsSymlinks() { return false; }
        supportsProps() { return false; }
        supportsSynch() { return false; }
        /**
         * Delete all contents stored in the file system.
         */
        empty(cb) {
            if (this._cache) {
                this._cache.removeAll();
            }
            this.store.clear((e) => {
                if (noError(e, cb)) {
                    // INVARIANT: Root always exists.
                    this.makeRootDirectory(cb);
                }
            });
        }
        rename(oldPath, newPath, cb) {
            // TODO: Make rename compatible with the cache.
            if (this._cache) {
                // Clear and disable cache during renaming process.
                const c = this._cache;
                this._cache = null;
                c.removeAll();
                const oldCb = cb;
                cb = (e) => {
                    // Restore empty cache.
                    this._cache = c;
                    oldCb(e);
                };
            }
            const tx = this.store.beginTransaction('readwrite');
            const oldParent = path.dirname(oldPath), oldName = path.basename(oldPath);
            const newParent = path.dirname(newPath), newName = path.basename(newPath);
            const inodes = {};
            const lists = {};
            let errorOccurred = false;
            // Invariant: Can't move a folder inside itself.
            // This funny little hack ensures that the check passes only if oldPath
            // is a subpath of newParent. We append '/' to avoid matching folders that
            // are a substring of the bottom-most folder in the path.
            if ((newParent + '/').indexOf(oldPath + '/') === 0) {
                return cb(new ApiError(ErrorCode.EBUSY, oldParent));
            }
            /**
             * Responsible for Phase 2 of the rename operation: Modifying and
             * committing the directory listings. Called once we have successfully
             * retrieved both the old and new parent's inodes and listings.
             */
            const theOleSwitcharoo = () => {
                // Sanity check: Ensure both paths are present, and no error has occurred.
                if (errorOccurred || !lists.hasOwnProperty(oldParent) || !lists.hasOwnProperty(newParent)) {
                    return;
                }
                const oldParentList = lists[oldParent], oldParentINode = inodes[oldParent], newParentList = lists[newParent], newParentINode = inodes[newParent];
                // Delete file from old parent.
                if (!oldParentList[oldName]) {
                    cb(ApiError.ENOENT(oldPath));
                }
                else {
                    const fileId = oldParentList[oldName];
                    delete oldParentList[oldName];
                    // Finishes off the renaming process by adding the file to the new
                    // parent.
                    const completeRename = () => {
                        newParentList[newName] = fileId;
                        // Commit old parent's list.
                        tx.put(oldParentINode.id, Buffer.from(JSON.stringify(oldParentList)), true, (e) => {
                            if (noErrorTx(e, tx, cb)) {
                                if (oldParent === newParent) {
                                    // DONE!
                                    tx.commit(cb);
                                }
                                else {
                                    // Commit new parent's list.
                                    tx.put(newParentINode.id, Buffer.from(JSON.stringify(newParentList)), true, (e) => {
                                        if (noErrorTx(e, tx, cb)) {
                                            tx.commit(cb);
                                        }
                                    });
                                }
                            }
                        });
                    };
                    if (newParentList[newName]) {
                        // 'newPath' already exists. Check if it's a file or a directory, and
                        // act accordingly.
                        this.getINode(tx, newPath, newParentList[newName], (e, inode) => {
                            if (noErrorTx(e, tx, cb)) {
                                if (inode.isFile()) {
                                    // Delete the file and continue.
                                    tx.del(inode.id, (e) => {
                                        if (noErrorTx(e, tx, cb)) {
                                            tx.del(newParentList[newName], (e) => {
                                                if (noErrorTx(e, tx, cb)) {
                                                    completeRename();
                                                }
                                            });
                                        }
                                    });
                                }
                                else {
                                    // Can't overwrite a directory using rename.
                                    tx.abort((e) => {
                                        cb(ApiError.EPERM(newPath));
                                    });
                                }
                            }
                        });
                    }
                    else {
                        completeRename();
                    }
                }
            };
            /**
             * Grabs a path's inode and directory listing, and shoves it into the
             * inodes and lists hashes.
             */
            const processInodeAndListings = (p) => {
                this.findINodeAndDirListing(tx, p, (e, node, dirList) => {
                    if (e) {
                        if (!errorOccurred) {
                            errorOccurred = true;
                            tx.abort(() => {
                                cb(e);
                            });
                        }
                        // If error has occurred already, just stop here.
                    }
                    else {
                        inodes[p] = node;
                        lists[p] = dirList;
                        theOleSwitcharoo();
                    }
                });
            };
            processInodeAndListings(oldParent);
            if (oldParent !== newParent) {
                processInodeAndListings(newParent);
            }
        }
        stat(p, isLstat, cb) {
            const tx = this.store.beginTransaction('readonly');
            this.findINode(tx, p, (e, inode) => {
                if (noError(e, cb)) {
                    cb(null, inode.toStats());
                }
            });
        }
        createFile(p, flag, mode, cb) {
            const tx = this.store.beginTransaction('readwrite'), data = emptyBuffer();
            this.commitNewFile(tx, p, FileType.FILE, mode, data, (e, newFile) => {
                if (noError(e, cb)) {
                    cb(null, new AsyncKeyValueFile(this, p, flag, newFile.toStats(), data));
                }
            });
        }
        openFile(p, flag, cb) {
            const tx = this.store.beginTransaction('readonly');
            // Step 1: Grab the file's inode.
            this.findINode(tx, p, (e, inode) => {
                if (noError(e, cb)) {
                    // Step 2: Grab the file's data.
                    tx.get(inode.id, (e, data) => {
                        if (noError(e, cb)) {
                            if (data === undefined) {
                                cb(ApiError.ENOENT(p));
                            }
                            else {
                                cb(null, new AsyncKeyValueFile(this, p, flag, inode.toStats(), data));
                            }
                        }
                    });
                }
            });
        }
        unlink(p, cb) {
            this.removeEntry(p, false, cb);
        }
        rmdir(p, cb) {
            // Check first if directory is empty.
            this.readdir(p, (err, files) => {
                if (err) {
                    cb(err);
                }
                else if (files.length > 0) {
                    cb(ApiError.ENOTEMPTY(p));
                }
                else {
                    this.removeEntry(p, true, cb);
                }
            });
        }
        mkdir(p, mode, cb) {
            const tx = this.store.beginTransaction('readwrite'), data = Buffer.from('{}');
            this.commitNewFile(tx, p, FileType.DIRECTORY, mode, data, cb);
        }
        readdir(p, cb) {
            const tx = this.store.beginTransaction('readonly');
            this.findINode(tx, p, (e, inode) => {
                if (noError(e, cb)) {
                    this.getDirListing(tx, p, inode, (e, dirListing) => {
                        if (noError(e, cb)) {
                            cb(null, Object.keys(dirListing));
                        }
                    });
                }
            });
        }
        _sync(p, data, stats, cb) {
            // @todo Ensure mtime updates properly, and use that to determine if a data
            //       update is required.
            const tx = this.store.beginTransaction('readwrite');
            // Step 1: Get the file node's ID.
            this._findINode(tx, path.dirname(p), path.basename(p), (e, fileInodeId) => {
                if (noErrorTx(e, tx, cb)) {
                    // Step 2: Get the file inode.
                    this.getINode(tx, p, fileInodeId, (e, fileInode) => {
                        if (noErrorTx(e, tx, cb)) {
                            const inodeChanged = fileInode.update(stats);
                            // Step 3: Sync the data.
                            tx.put(fileInode.id, data, true, (e) => {
                                if (noErrorTx(e, tx, cb)) {
                                    // Step 4: Sync the metadata (if it changed)!
                                    if (inodeChanged) {
                                        tx.put(fileInodeId, fileInode.toBuffer(), true, (e) => {
                                            if (noErrorTx(e, tx, cb)) {
                                                tx.commit(cb);
                                            }
                                        });
                                    }
                                    else {
                                        // No need to sync metadata; return.
                                        tx.commit(cb);
                                    }
                                }
                            });
                        }
                    });
                }
            });
        }
        /**
         * Checks if the root directory exists. Creates it if it doesn't.
         */
        makeRootDirectory(cb) {
            const tx = this.store.beginTransaction('readwrite');
            tx.get(ROOT_NODE_ID, (e, data) => {
                if (e || data === undefined) {
                    // Create new inode.
                    const currTime = (new Date()).getTime(), 
                    // Mode 0666
                    dirInode = new Inode(GenerateRandomID(), 4096, 511 | FileType.DIRECTORY, currTime, currTime, currTime);
                    // If the root doesn't exist, the first random ID shouldn't exist,
                    // either.
                    tx.put(dirInode.id, getEmptyDirNode(), false, (e) => {
                        if (noErrorTx(e, tx, cb)) {
                            tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false, (e) => {
                                if (e) {
                                    tx.abort(() => { cb(e); });
                                }
                                else {
                                    tx.commit(cb);
                                }
                            });
                        }
                    });
                }
                else {
                    // We're good.
                    tx.commit(cb);
                }
            });
        }
        /**
         * Helper function for findINode.
         * @param parent The parent directory of the file we are attempting to find.
         * @param filename The filename of the inode we are attempting to find, minus
         *   the parent.
         * @param cb Passed an error or the ID of the file's inode in the file system.
         */
        _findINode(tx, parent, filename, cb) {
            if (this._cache) {
                const id = this._cache.get(path.join(parent, filename));
                if (id) {
                    return cb(null, id);
                }
            }
            const handleDirectoryListings = (e, inode, dirList) => {
                if (e) {
                    cb(e);
                }
                else if (dirList[filename]) {
                    const id = dirList[filename];
                    if (this._cache) {
                        this._cache.set(path.join(parent, filename), id);
                    }
                    cb(null, id);
                }
                else {
                    cb(ApiError.ENOENT(path.resolve(parent, filename)));
                }
            };
            if (parent === '/') {
                if (filename === '') {
                    // BASE CASE #1: Return the root's ID.
                    if (this._cache) {
                        this._cache.set(path.join(parent, filename), ROOT_NODE_ID);
                    }
                    cb(null, ROOT_NODE_ID);
                }
                else {
                    // BASE CASE #2: Find the item in the root node.
                    this.getINode(tx, parent, ROOT_NODE_ID, (e, inode) => {
                        if (noError(e, cb)) {
                            this.getDirListing(tx, parent, inode, (e, dirList) => {
                                // handle_directory_listings will handle e for us.
                                handleDirectoryListings(e, inode, dirList);
                            });
                        }
                    });
                }
            }
            else {
                // Get the parent directory's INode, and find the file in its directory
                // listing.
                this.findINodeAndDirListing(tx, parent, handleDirectoryListings);
            }
        }
        /**
         * Finds the Inode of the given path.
         * @param p The path to look up.
         * @param cb Passed an error or the Inode of the path p.
         * @todo memoize/cache
         */
        findINode(tx, p, cb) {
            this._findINode(tx, path.dirname(p), path.basename(p), (e, id) => {
                if (noError(e, cb)) {
                    this.getINode(tx, p, id, cb);
                }
            });
        }
        /**
         * Given the ID of a node, retrieves the corresponding Inode.
         * @param tx The transaction to use.
         * @param p The corresponding path to the file (used for error messages).
         * @param id The ID to look up.
         * @param cb Passed an error or the inode under the given id.
         */
        getINode(tx, p, id, cb) {
            tx.get(id, (e, data) => {
                if (noError(e, cb)) {
                    if (data === undefined) {
                        cb(ApiError.ENOENT(p));
                    }
                    else {
                        cb(null, Inode.fromBuffer(data));
                    }
                }
            });
        }
        /**
         * Given the Inode of a directory, retrieves the corresponding directory
         * listing.
         */
        getDirListing(tx, p, inode, cb) {
            if (!inode.isDirectory()) {
                cb(ApiError.ENOTDIR(p));
            }
            else {
                tx.get(inode.id, (e, data) => {
                    if (noError(e, cb)) {
                        try {
                            cb(null, JSON.parse(data.toString()));
                        }
                        catch (e) {
                            // Occurs when data is undefined, or corresponds to something other
                            // than a directory listing. The latter should never occur unless
                            // the file system is corrupted.
                            cb(ApiError.ENOENT(p));
                        }
                    }
                });
            }
        }
        /**
         * Given a path to a directory, retrieves the corresponding INode and
         * directory listing.
         */
        findINodeAndDirListing(tx, p, cb) {
            this.findINode(tx, p, (e, inode) => {
                if (noError(e, cb)) {
                    this.getDirListing(tx, p, inode, (e, listing) => {
                        if (noError(e, cb)) {
                            cb(null, inode, listing);
                        }
                    });
                }
            });
        }
        /**
         * Adds a new node under a random ID. Retries 5 times before giving up in
         * the exceedingly unlikely chance that we try to reuse a random GUID.
         * @param cb Passed an error or the GUID that the data was stored under.
         */
        addNewNode(tx, data, cb) {
            let retries = 0, currId;
            const reroll = () => {
                if (++retries === 5) {
                    // Max retries hit. Return with an error.
                    cb(new ApiError(ErrorCode.EIO, 'Unable to commit data to key-value store.'));
                }
                else {
                    // Try again.
                    currId = GenerateRandomID();
                    tx.put(currId, data, false, (e, committed) => {
                        if (e || !committed) {
                            reroll();
                        }
                        else {
                            // Successfully stored under 'currId'.
                            cb(null, currId);
                        }
                    });
                }
            };
            reroll();
        }
        /**
         * Commits a new file (well, a FILE or a DIRECTORY) to the file system with
         * the given mode.
         * Note: This will commit the transaction.
         * @param p The path to the new file.
         * @param type The type of the new file.
         * @param mode The mode to create the new file with.
         * @param data The data to store at the file's data node.
         * @param cb Passed an error or the Inode for the new file.
         */
        commitNewFile(tx, p, type, mode, data, cb) {
            const parentDir = path.dirname(p), fname = path.basename(p), currTime = (new Date()).getTime();
            // Invariant: The root always exists.
            // If we don't check this prior to taking steps below, we will create a
            // file with name '' in root should p == '/'.
            if (p === '/') {
                return cb(ApiError.EEXIST(p));
            }
            // Let's build a pyramid of code!
            // Step 1: Get the parent directory's inode and directory listing
            this.findINodeAndDirListing(tx, parentDir, (e, parentNode, dirListing) => {
                if (noErrorTx(e, tx, cb)) {
                    if (dirListing[fname]) {
                        // File already exists.
                        tx.abort(() => {
                            cb(ApiError.EEXIST(p));
                        });
                    }
                    else {
                        // Step 2: Commit data to store.
                        this.addNewNode(tx, data, (e, dataId) => {
                            if (noErrorTx(e, tx, cb)) {
                                // Step 3: Commit the file's inode to the store.
                                const fileInode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);
                                this.addNewNode(tx, fileInode.toBuffer(), (e, fileInodeId) => {
                                    if (noErrorTx(e, tx, cb)) {
                                        // Step 4: Update parent directory's listing.
                                        dirListing[fname] = fileInodeId;
                                        tx.put(parentNode.id, Buffer.from(JSON.stringify(dirListing)), true, (e) => {
                                            if (noErrorTx(e, tx, cb)) {
                                                // Step 5: Commit and return the new inode.
                                                tx.commit((e) => {
                                                    if (noErrorTx(e, tx, cb)) {
                                                        cb(null, fileInode);
                                                    }
                                                });
                                            }
                                        });
                                    }
                                });
                            }
                        });
                    }
                }
            });
        }
        /**
         * Remove all traces of the given path from the file system.
         * @param p The path to remove from the file system.
         * @param isDir Does the path belong to a directory, or a file?
         * @todo Update mtime.
         */
        removeEntry(p, isDir, cb) {
            // Eagerly delete from cache (harmless even if removal fails)
            if (this._cache) {
                this._cache.remove(p);
            }
            const tx = this.store.beginTransaction('readwrite'), parent = path.dirname(p), fileName = path.basename(p);
            // Step 1: Get parent directory's node and directory listing.
            this.findINodeAndDirListing(tx, parent, (e, parentNode, parentListing) => {
                if (noErrorTx(e, tx, cb)) {
                    if (!parentListing[fileName]) {
                        tx.abort(() => {
                            cb(ApiError.ENOENT(p));
                        });
                    }
                    else {
                        // Remove from directory listing of parent.
                        const fileNodeId = parentListing[fileName];
                        delete parentListing[fileName];
                        // Step 2: Get file inode.
                        this.getINode(tx, p, fileNodeId, (e, fileNode) => {
                            if (noErrorTx(e, tx, cb)) {
                                if (!isDir && fileNode.isDirectory()) {
                                    tx.abort(() => {
                                        cb(ApiError.EISDIR(p));
                                    });
                                }
                                else if (isDir && !fileNode.isDirectory()) {
                                    tx.abort(() => {
                                        cb(ApiError.ENOTDIR(p));
                                    });
                                }
                                else {
                                    // Step 3: Delete data.
                                    tx.del(fileNode.id, (e) => {
                                        if (noErrorTx(e, tx, cb)) {
                                            // Step 4: Delete node.
                                            tx.del(fileNodeId, (e) => {
                                                if (noErrorTx(e, tx, cb)) {
                                                    // Step 5: Update directory listing.
                                                    tx.put(parentNode.id, Buffer.from(JSON.stringify(parentListing)), true, (e) => {
                                                        if (noErrorTx(e, tx, cb)) {
                                                            tx.commit(cb);
                                                        }
                                                    });
                                                }
                                            });
                                        }
                                    });
                                }
                            }
                        });
                    }
                }
            });
        }
    }


    return {
        SimpleSyncRWTransaction: SimpleSyncRWTransaction,
        SyncKeyValueFile: SyncKeyValueFile,
        SyncKeyValueFileSystem: SyncKeyValueFileSystem,
        AsyncKeyValueFile: AsyncKeyValueFile,
        AsyncKeyValueFileSystem: AsyncKeyValueFileSystem
    };
});
define('skylark-browserfs/backend/InMemory',['../generic/key_value_filesystem'], function (key_value_filesystem) {
    'use strict';

    const { SimpleSyncRWTransaction, SyncKeyValueFileSystem } = key_value_filesystem;
    /**
     * A simple in-memory key-value store backed by a JavaScript object.
     */
    class InMemoryStore {
        constructor() {
            this.store = {};
        }
        name() { return InMemoryFileSystem.Name; }
        clear() { this.store = {}; }
        beginTransaction(type) {
            return new SimpleSyncRWTransaction(this);
        }
        get(key) {
            return this.store[key];
        }
        put(key, data, overwrite) {
            if (!overwrite && this.store.hasOwnProperty(key)) {
                return false;
            }
            this.store[key] = data;
            return true;
        }
        del(key) {
            delete this.store[key];
        }
    }
    /**
     * A simple in-memory file system backed by an InMemoryStore.
     * Files are not persisted across page loads.
     */
    class InMemoryFileSystem extends SyncKeyValueFileSystem {
        constructor() {
            super({ store: new InMemoryStore() });
        }
        /**
         * Creates an InMemoryFileSystem instance.
         */
        static Create(options, cb) {
            cb(null, new InMemoryFileSystem());
        }
    }
    InMemoryFileSystem.Name = "InMemory";
    InMemoryFileSystem.Options = {};

    InMemoryFileSystem.InMemoryStore = InMemoryStore;

    return InMemoryFileSystem;
});
define('skylark-browserfs/backend/IndexedDB',[
    '../generic/key_value_filesystem',
    '../core/api_error',
    '../core/global',
    '../core/util'
], function (key_value_filesystem, api_error, global, util) {
    'use strict';
    const { AsyncKeyValueFileSystem } =  key_value_filesystem;
    const { ApiError, ErrorCode }  = api_error;
    const { arrayBuffer2Buffer, buffer2ArrayBuffer }  = util;

    /**
     * Get the indexedDB constructor for the current browser.
     * @hidden
     */
    const indexedDB = global.indexedDB ||
        global.mozIndexedDB ||
        global.webkitIndexedDB ||
        global.msIndexedDB;
    /**
     * Converts a DOMException or a DOMError from an IndexedDB event into a
     * standardized BrowserFS API error.
     * @hidden
     */
    function convertError(e, message = e.toString()) {
        switch (e.name) {
            case "NotFoundError":
                return new ApiError(ErrorCode.ENOENT, message);
            case "QuotaExceededError":
                return new ApiError(ErrorCode.ENOSPC, message);
            default:
                // The rest do not seem to map cleanly to standard error codes.
                return new ApiError(ErrorCode.EIO, message);
        }
    }
    /**
     * Produces a new onerror handler for IDB. Our errors are always fatal, so we
     * handle them generically: Call the user-supplied callback with a translated
     * version of the error, and let the error bubble up.
     * @hidden
     */
    function onErrorHandler(cb, code = ErrorCode.EIO, message = null) {
        return function (e) {
            // Prevent the error from canceling the transaction.
            e.preventDefault();
            cb(new ApiError(code, message !== null ? message : undefined));
        };
    }
    /**
     * @hidden
     */
    class IndexedDBROTransaction {
        constructor(tx, store) {
            this.tx = tx;
            this.store = store;
        }
        get(key, cb) {
            try {
                const r = this.store.get(key);
                r.onerror = onErrorHandler(cb);
                r.onsuccess = (event) => {
                    // IDB returns the value 'undefined' when you try to get keys that
                    // don't exist. The caller expects this behavior.
                    const result = event.target.result;
                    if (result === undefined) {
                        cb(null, result);
                    }
                    else {
                        // IDB data is stored as an ArrayBuffer
                        cb(null, arrayBuffer2Buffer(result));
                    }
                };
            }
            catch (e) {
                cb(convertError(e));
            }
        }
    }
    /**
     * @hidden
     */
    class IndexedDBRWTransaction extends IndexedDBROTransaction {
        constructor(tx, store) {
            super(tx, store);
        }
        put(key, data, overwrite, cb) {
            try {
                const arraybuffer = buffer2ArrayBuffer(data);
                let r;
                // Note: 'add' will never overwrite an existing key.
                r = overwrite ? this.store.put(arraybuffer, key) : this.store.add(arraybuffer, key);
                // XXX: NEED TO RETURN FALSE WHEN ADD HAS A KEY CONFLICT. NO ERROR.
                r.onerror = onErrorHandler(cb);
                r.onsuccess = (event) => {
                    cb(null, true);
                };
            }
            catch (e) {
                cb(convertError(e));
            }
        }
        del(key, cb) {
            try {
                // NOTE: IE8 has a bug with identifiers named 'delete' unless used as a string
                // like this.
                // http://stackoverflow.com/a/26479152
                const r = this.store['delete'](key);
                r.onerror = onErrorHandler(cb);
                r.onsuccess = (event) => {
                    cb();
                };
            }
            catch (e) {
                cb(convertError(e));
            }
        }
        commit(cb) {
            // Return to the event loop to commit the transaction.
            setTimeout(cb, 0);
        }
        abort(cb) {
            let _e = null;
            try {
                this.tx.abort();
            }
            catch (e) {
                _e = convertError(e);
            }
            finally {
                cb(_e);
            }
        }
    }
    class IndexedDBStore {
        constructor(db, storeName) {
            this.db = db;
            this.storeName = storeName;
        }
        static Create(storeName, cb) {
            const openReq = indexedDB.open(storeName, 1);
            openReq.onupgradeneeded = (event) => {
                const db = event.target.result;
                // Huh. This should never happen; we're at version 1. Why does another
                // database exist?
                if (db.objectStoreNames.contains(storeName)) {
                    db.deleteObjectStore(storeName);
                }
                db.createObjectStore(storeName);
            };
            openReq.onsuccess = (event) => {
                cb(null, new IndexedDBStore(event.target.result, storeName));
            };
            openReq.onerror = onErrorHandler(cb, ErrorCode.EACCES);
        }
        name() {
            return IndexedDBFileSystem.Name + " - " + this.storeName;
        }
        clear(cb) {
            try {
                const tx = this.db.transaction(this.storeName, 'readwrite'), objectStore = tx.objectStore(this.storeName), r = objectStore.clear();
                r.onsuccess = (event) => {
                    // Use setTimeout to commit transaction.
                    setTimeout(cb, 0);
                };
                r.onerror = onErrorHandler(cb);
            }
            catch (e) {
                cb(convertError(e));
            }
        }
        beginTransaction(type = 'readonly') {
            const tx = this.db.transaction(this.storeName, type), objectStore = tx.objectStore(this.storeName);
            if (type === 'readwrite') {
                return new IndexedDBRWTransaction(tx, objectStore);
            }
            else if (type === 'readonly') {
                return new IndexedDBROTransaction(tx, objectStore);
            }
            else {
                throw new ApiError(ErrorCode.EINVAL, 'Invalid transaction type.');
            }
        }
    }
    /**
     * A file system that uses the IndexedDB key value file system.
     */
    class IndexedDBFileSystem extends AsyncKeyValueFileSystem {
        constructor(cacheSize) {
            super(cacheSize);
        }
        /**
         * Constructs an IndexedDB file system with the given options.
         */
        static Create(opts = {}, cb) {
            IndexedDBStore.Create(opts.storeName ? opts.storeName : 'browserfs', (e, store) => {
                if (store) {
                    const idbfs = new IndexedDBFileSystem(typeof (opts.cacheSize) === 'number' ? opts.cacheSize : 100);
                    idbfs.init(store, (e) => {
                        if (e) {
                            cb(e);
                        }
                        else {
                            cb(null, idbfs);
                        }
                    });
                }
                else {
                    cb(e);
                }
            });
        }
        static isAvailable() {
            // In Safari's private browsing mode, indexedDB.open returns NULL.
            // In Firefox, it throws an exception.
            // In Chrome, it "just works", and clears the database when you leave the page.
            // Untested: Opera, IE.
            try {
                return typeof indexedDB !== 'undefined' && null !== indexedDB.open("__browserfs_test__");
            }
            catch (e) {
                return false;
            }
        }
    }
    IndexedDBFileSystem.Name = "IndexedDB";
    IndexedDBFileSystem.Options = {
        storeName: {
            type: "string",
            optional: true,
            description: "The name of this file system. You can have multiple IndexedDB file systems operating at once, but each must have a different name."
        },
        cacheSize: {
            type: "number",
            optional: true,
            description: "The size of the inode cache. Defaults to 100. A size of 0 or below disables caching."
        }
    };


    IndexedDBFileSystem.IndexedDBROTransaction = IndexedDBROTransaction;
    IndexedDBFileSystem.IndexedDBRWTransaction = IndexedDBRWTransaction;
    IndexedDBFileSystem.IndexedDBStore = IndexedDBStore;

    return IndexedDBFileSystem;
});
define('skylark-browserfs/backend/LocalStorage',[
    '../libs/buffers',
    '../generic/key_value_filesystem',
    '../core/api_error',
    '../core/global'
], function (buffers,key_value_filesystem, api_error, global) {
    'use strict';

    const { SyncKeyValueFileSystem, SimpleSyncRWTransaction } = key_value_filesystem;
    const { ApiError, ErrorCode } = api_error;

    const { Buffer} = buffers;

    /**
     * Some versions of FF and all versions of IE do not support the full range of
     * 16-bit numbers encoded as characters, as they enforce UTF-16 restrictions.
     * @url http://stackoverflow.com/questions/11170716/are-there-any-characters-that-are-not-allowed-in-localstorage/11173673#11173673
     * @hidden
     */
    let supportsBinaryString = false, binaryEncoding;
    try {
        global.localStorage.setItem("__test__", String.fromCharCode(0xD800));
        supportsBinaryString = global.localStorage.getItem("__test__") === String.fromCharCode(0xD800);
    }
    catch (e) {
        // IE throws an exception.
        supportsBinaryString = false;
    }
    binaryEncoding = supportsBinaryString ? 'binary_string' : 'binary_string_ie';
    if (!Buffer.isEncoding(binaryEncoding)) {
        // Fallback for non BrowserFS implementations of buffer that lack a
        // binary_string format.
        binaryEncoding = "base64";
    }
    /**
     * A synchronous key-value store backed by localStorage.
     */
    class LocalStorageStore {
        name() {
            return LocalStorageFileSystem.Name;
        }
        clear() {
            global.localStorage.clear();
        }
        beginTransaction(type) {
            // No need to differentiate.
            return new SimpleSyncRWTransaction(this);
        }
        get(key) {
            try {
                const data = global.localStorage.getItem(key);
                if (data !== null) {
                    return Buffer.from(data, binaryEncoding);
                }
            }
            catch (e) {
                // Do nothing.
            }
            // Key doesn't exist, or a failure occurred.
            return undefined;
        }
        put(key, data, overwrite) {
            try {
                if (!overwrite && global.localStorage.getItem(key) !== null) {
                    // Don't want to overwrite the key!
                    return false;
                }
                global.localStorage.setItem(key, data.toString(binaryEncoding));
                return true;
            }
            catch (e) {
                throw new ApiError(ErrorCode.ENOSPC, "LocalStorage is full.");
            }
        }
        del(key) {
            try {
                global.localStorage.removeItem(key);
            }
            catch (e) {
                throw new ApiError(ErrorCode.EIO, "Unable to delete key " + key + ": " + e);
            }
        }
    }
    /**
     * A synchronous file system backed by localStorage. Connects our
     * LocalStorageStore to our SyncKeyValueFileSystem.
     */
    class LocalStorageFileSystem extends SyncKeyValueFileSystem {
        /**
         * Creates a new LocalStorage file system using the contents of `localStorage`.
         */
        constructor() { super({ store: new LocalStorageStore() }); }
        /**
         * Creates a LocalStorageFileSystem instance.
         */
        static Create(options, cb) {
            cb(null, new LocalStorageFileSystem());
        }
        static isAvailable() {
            return typeof global.localStorage !== 'undefined';
        }
    }
    LocalStorageFileSystem.Name = "LocalStorage";
    LocalStorageFileSystem.Options = {};
    
    LocalStorageFileSystem.LocalStorageStore = LocalStorageStore;

    return LocalStorageFileSystem;
});
define('skylark-browserfs/backend/MountableFileSystem',[
    '../core/file_system',
    './InMemory',
    '../core/api_error',
    '../core/node_fs',
    '../libs/path',
    '../core/util'
], function (file_system, InMemory, api_error, fs, path, util) {
    'use strict';
    const { BaseFileSystem } = file_system;
    const {InMemoryFileSystem}  = InMemory;
    const { ApiError, ErrorCode }  = api_error;
    const { mkdirpSync }  = util;

    /**
     * The MountableFileSystem allows you to mount multiple backend types or
     * multiple instantiations of the same backend into a single file system tree.
     * The file systems do not need to know about each other; all interactions are
     * automatically facilitated through this interface.
     *
     * For example, if a file system is mounted at /mnt/blah, and a request came in
     * for /mnt/blah/foo.txt, the file system would see a request for /foo.txt.
     *
     * You can mount file systems when you configure the file system:
     * ```javascript
     * BrowserFS.configure({
     *   fs: "MountableFileSystem",
     *   options: {
     *     '/data': { fs: 'HTTPRequest', options: { index: "http://mysite.com/files/index.json" } },
     *     '/home': { fs: 'LocalStorage' }
     *   }
     * }, function(e) {
     *
     * });
     * ```
     *
     * For advanced users, you can also mount file systems *after* MFS is constructed:
     * ```javascript
     * BrowserFS.FileSystem.HTTPRequest.Create({
     *   index: "http://mysite.com/files/index.json"
     * }, function(e, xhrfs) {
     *   BrowserFS.FileSystem.MountableFileSystem.Create({
     *     '/data': xhrfs
     *   }, function(e, mfs) {
     *     BrowserFS.initialize(mfs);
     *
     *     // Added after-the-fact...
     *     BrowserFS.FileSystem.LocalStorage.Create(function(e, lsfs) {
     *       mfs.mount('/home', lsfs);
     *     });
     *   });
     * });
     * ```
     *
     * Since MountableFileSystem simply proxies requests to mounted file systems, it supports all of the operations that the mounted file systems support.
     *
     * With no mounted file systems, `MountableFileSystem` acts as a simple `InMemory` filesystem.
     */
    class MountableFileSystem extends BaseFileSystem {
        /**
         * Creates a new, empty MountableFileSystem.
         */
        constructor(rootFs) {
            super();
            // Contains the list of mount points in mntMap, sorted by string length in decreasing order.
            // Ensures that we scan the most specific mount points for a match first, which lets us
            // nest mount points.
            this.mountList = [];
            this.mntMap = {};
            this.rootFs = rootFs;
        }
        /**
         * Creates a MountableFileSystem instance with the given options.
         */
        static Create(opts, cb) {
            InMemoryFileSystem.Create({}, (e, imfs) => {
                if (imfs) {
                    const fs = new MountableFileSystem(imfs);
                    try {
                        Object.keys(opts).forEach((mountPoint) => {
                            fs.mount(mountPoint, opts[mountPoint]);
                        });
                    }
                    catch (e) {
                        return cb(e);
                    }
                    cb(null, fs);
                }
                else {
                    cb(e);
                }
            });
        }
        static isAvailable() {
            return true;
        }
        /**
         * Mounts the file system at the given mount point.
         */
        mount(mountPoint, fs) {
            if (mountPoint[0] !== '/') {
                mountPoint = `/${mountPoint}`;
            }
            mountPoint = path.resolve(mountPoint);
            if (this.mntMap[mountPoint]) {
                throw new ApiError(ErrorCode.EINVAL, "Mount point " + mountPoint + " is already taken.");
            }
            mkdirpSync(mountPoint, 0x1ff, this.rootFs);
            this.mntMap[mountPoint] = fs;
            this.mountList.push(mountPoint);
            this.mountList = this.mountList.sort((a, b) => b.length - a.length);
        }
        umount(mountPoint) {
            if (mountPoint[0] !== '/') {
                mountPoint = `/${mountPoint}`;
            }
            mountPoint = path.resolve(mountPoint);
            if (!this.mntMap[mountPoint]) {
                throw new ApiError(ErrorCode.EINVAL, "Mount point " + mountPoint + " is already unmounted.");
            }
            delete this.mntMap[mountPoint];
            this.mountList.splice(this.mountList.indexOf(mountPoint), 1);
            while (mountPoint !== '/') {
                if (this.rootFs.readdirSync(mountPoint).length === 0) {
                    this.rootFs.rmdirSync(mountPoint);
                    mountPoint = path.dirname(mountPoint);
                }
                else {
                    break;
                }
            }
        }
        /**
         * Returns the file system that the path points to.
         */
        _getFs(path) {
            const mountList = this.mountList, len = mountList.length;
            for (let i = 0; i < len; i++) {
                const mountPoint = mountList[i];
                // We know path is normalized, so it is a substring of the mount point.
                if (mountPoint.length <= path.length && path.indexOf(mountPoint) === 0) {
                    path = path.substr(mountPoint.length > 1 ? mountPoint.length : 0);
                    if (path === '') {
                        path = '/';
                    }
                    return { fs: this.mntMap[mountPoint], path: path, mountPoint: mountPoint };
                }
            }
            // Query our root file system.
            return { fs: this.rootFs, path: path, mountPoint: '/' };
        }
        // Global information methods
        getName() {
            return MountableFileSystem.Name;
        }
        diskSpace(path, cb) {
            cb(0, 0);
        }
        isReadOnly() {
            return false;
        }
        supportsLinks() {
            // I'm not ready for cross-FS links yet.
            return false;
        }
        supportsProps() {
            return false;
        }
        supportsSynch() {
            return true;
        }
        /**
         * Fixes up error messages so they mention the mounted file location relative
         * to the MFS root, not to the particular FS's root.
         * Mutates the input error, and returns it.
         */
        standardizeError(err, path, realPath) {
            const index = err.message.indexOf(path);
            if (index !== -1) {
                err.message = err.message.substr(0, index) + realPath + err.message.substr(index + path.length);
                err.path = realPath;
            }
            return err;
        }
        // The following methods involve multiple file systems, and thus have custom
        // logic.
        // Note that we go through the Node API to use its robust default argument
        // processing.
        rename(oldPath, newPath, cb) {
            // Scenario 1: old and new are on same FS.
            const fs1rv = this._getFs(oldPath);
            const fs2rv = this._getFs(newPath);
            if (fs1rv.fs === fs2rv.fs) {
                return fs1rv.fs.rename(fs1rv.path, fs2rv.path, (e) => {
                    if (e) {
                        this.standardizeError(this.standardizeError(e, fs1rv.path, oldPath), fs2rv.path, newPath);
                    }
                    cb(e);
                });
            }
            // Scenario 2: Different file systems.
            // Read old file, write new file, delete old file.
            return fs.readFile(oldPath, function (err, data) {
                if (err) {
                    return cb(err);
                }
                fs.writeFile(newPath, data, function (err) {
                    if (err) {
                        return cb(err);
                    }
                    fs.unlink(oldPath, cb);
                });
            });
        }
        renameSync(oldPath, newPath) {
            // Scenario 1: old and new are on same FS.
            const fs1rv = this._getFs(oldPath);
            const fs2rv = this._getFs(newPath);
            if (fs1rv.fs === fs2rv.fs) {
                try {
                    return fs1rv.fs.renameSync(fs1rv.path, fs2rv.path);
                }
                catch (e) {
                    this.standardizeError(this.standardizeError(e, fs1rv.path, oldPath), fs2rv.path, newPath);
                    throw e;
                }
            }
            // Scenario 2: Different file systems.
            const data = fs.readFileSync(oldPath);
            fs.writeFileSync(newPath, data);
            return fs.unlinkSync(oldPath);
        }
        readdirSync(p) {
            const fsInfo = this._getFs(p);
            // If null, rootfs did not have the directory
            // (or the target FS is the root fs).
            let rv = null;
            // Mount points are all defined in the root FS.
            // Ensure that we list those, too.
            if (fsInfo.fs !== this.rootFs) {
                try {
                    rv = this.rootFs.readdirSync(p);
                }
                catch (e) {
                    // Ignore.
                }
            }
            try {
                const rv2 = fsInfo.fs.readdirSync(fsInfo.path);
                if (rv === null) {
                    return rv2;
                }
                else {
                    // Filter out duplicates.
                    return rv2.concat(rv.filter((val) => rv2.indexOf(val) === -1));
                }
            }
            catch (e) {
                if (rv === null) {
                    throw this.standardizeError(e, fsInfo.path, p);
                }
                else {
                    // The root FS had something.
                    return rv;
                }
            }
        }
        readdir(p, cb) {
            const fsInfo = this._getFs(p);
            fsInfo.fs.readdir(fsInfo.path, (err, files) => {
                if (fsInfo.fs !== this.rootFs) {
                    try {
                        const rv = this.rootFs.readdirSync(p);
                        if (files) {
                            // Filter out duplicates.
                            files = files.concat(rv.filter((val) => files.indexOf(val) === -1));
                        }
                        else {
                            files = rv;
                        }
                    }
                    catch (e) {
                        // Root FS and target FS did not have directory.
                        if (err) {
                            return cb(this.standardizeError(err, fsInfo.path, p));
                        }
                    }
                }
                else if (err) {
                    // Root FS and target FS are the same, and did not have directory.
                    return cb(this.standardizeError(err, fsInfo.path, p));
                }
                cb(null, files);
            });
        }
        realpathSync(p, cache) {
            const fsInfo = this._getFs(p);
            try {
                const mountedPath = fsInfo.fs.realpathSync(fsInfo.path, {});
                // resolve is there to remove any trailing slash that may be present
                return path.resolve(path.join(fsInfo.mountPoint, mountedPath));
            }
            catch (e) {
                throw this.standardizeError(e, fsInfo.path, p);
            }
        }
        realpath(p, cache, cb) {
            const fsInfo = this._getFs(p);
            fsInfo.fs.realpath(fsInfo.path, {}, (err, rv) => {
                if (err) {
                    cb(this.standardizeError(err, fsInfo.path, p));
                }
                else {
                    // resolve is there to remove any trailing slash that may be present
                    cb(null, path.resolve(path.join(fsInfo.mountPoint, rv)));
                }
            });
        }
        rmdirSync(p) {
            const fsInfo = this._getFs(p);
            if (this._containsMountPt(p)) {
                throw ApiError.ENOTEMPTY(p);
            }
            else {
                try {
                    fsInfo.fs.rmdirSync(fsInfo.path);
                }
                catch (e) {
                    throw this.standardizeError(e, fsInfo.path, p);
                }
            }
        }
        rmdir(p, cb) {
            const fsInfo = this._getFs(p);
            if (this._containsMountPt(p)) {
                cb(ApiError.ENOTEMPTY(p));
            }
            else {
                fsInfo.fs.rmdir(fsInfo.path, (err) => {
                    cb(err ? this.standardizeError(err, fsInfo.path, p) : null);
                });
            }
        }
        /**
         * Returns true if the given path contains a mount point.
         */
        _containsMountPt(p) {
            const mountPoints = this.mountList, len = mountPoints.length;
            for (let i = 0; i < len; i++) {
                const pt = mountPoints[i];
                if (pt.length >= p.length && pt.slice(0, p.length) === p) {
                    return true;
                }
            }
            return false;
        }
    }
    MountableFileSystem.Name = "MountableFileSystem";
    MountableFileSystem.Options = {};
    /**
     * Tricky: Define all of the functions that merely forward arguments to the
     * relevant file system, or return/throw an error.
     * Take advantage of the fact that the *first* argument is always the path, and
     * the *last* is the callback function (if async).
     * @todo Can use numArgs to make proxying more efficient.
     * @hidden
     */
    function defineFcn(name, isSync, numArgs) {
        if (isSync) {
            return function (...args) {
                const path = args[0];
                const rv = this._getFs(path);
                args[0] = rv.path;
                try {
                    return rv.fs[name].apply(rv.fs, args);
                }
                catch (e) {
                    this.standardizeError(e, rv.path, path);
                    throw e;
                }
            };
        }
        else {
            return function (...args) {
                const path = args[0];
                const rv = this._getFs(path);
                args[0] = rv.path;
                if (typeof args[args.length - 1] === 'function') {
                    const cb = args[args.length - 1];
                    args[args.length - 1] = (...args) => {
                        if (args.length > 0 && args[0] instanceof ApiError) {
                            this.standardizeError(args[0], rv.path, path);
                        }
                        cb.apply(null, args);
                    };
                }
                return rv.fs[name].apply(rv.fs, args);
            };
        }
    }
    /**
     * @hidden
     */
    const fsCmdMap = [
        // 1 arg functions
        ['exists', 'unlink', 'readlink'],
        // 2 arg functions
        ['stat', 'mkdir', 'truncate'],
        // 3 arg functions
        ['open', 'readFile', 'chmod', 'utimes'],
        // 4 arg functions
        ['chown'],
        // 5 arg functions
        ['writeFile', 'appendFile']
    ];
    for (let i = 0; i < fsCmdMap.length; i++) {
        const cmds = fsCmdMap[i];
        for (const fnName of cmds) {
            MountableFileSystem.prototype[fnName] = defineFcn(fnName, false, i + 1);
            MountableFileSystem.prototype[fnName + 'Sync'] = defineFcn(fnName + 'Sync', true, i + 1);
        }
    }


    return MountableFileSystem;
});
define('skylark-browserfs/generic/mutex',['../generic/setImmediate'], function (setImmediate) {
    'use strict';
    /**
     * Non-recursive mutex
     * @hidden
     */
    class Mutex {
        constructor() {
            this._locked = false;
            this._waiters = [];
        }
        lock(cb) {
            if (this._locked) {
                this._waiters.push(cb);
                return;
            }
            this._locked = true;
            cb();
        }
        unlock() {
            if (!this._locked) {
                throw new Error('unlock of a non-locked mutex');
            }
            const next = this._waiters.shift();
            // don't unlock - we want to queue up next for the
            // _end_ of the current task execution, but we don't
            // want it to be called inline with whatever the
            // current stack is.  This way we still get the nice
            // behavior that an unlock immediately followed by a
            // lock won't cause starvation.
            if (next) {
                setImmediate(next);
                return;
            }
            this._locked = false;
        }
        tryLock() {
            if (this._locked) {
                return false;
            }
            this._locked = true;
            return true;
        }
        isLocked() {
            return this._locked;
        }
    }

    return Mutex;
});
define('skylark-browserfs/generic/locked_fs',['./mutex'], function (Mutex) {
    'use strict';
    /**
     * This class serializes access to an underlying async filesystem.
     * For example, on an OverlayFS instance with an async lower
     * directory operations like rename and rmdir may involve multiple
     * requests involving both the upper and lower filesystems -- they
     * are not executed in a single atomic step.  OverlayFS uses this
     * LockedFS to avoid having to reason about the correctness of
     * multiple requests interleaving.
     */
    class LockedFS {
        constructor(fs) {
            this._fs = fs;
            this._mu = new Mutex();
        }
        getName() {
            return 'LockedFS<' + this._fs.getName() + '>';
        }
        getFSUnlocked() {
            return this._fs;
        }
        diskSpace(p, cb) {
            // FIXME: should this lock?
            this._fs.diskSpace(p, cb);
        }
        isReadOnly() {
            return this._fs.isReadOnly();
        }
        supportsLinks() {
            return this._fs.supportsLinks();
        }
        supportsProps() {
            return this._fs.supportsProps();
        }
        supportsSynch() {
            return this._fs.supportsSynch();
        }
        rename(oldPath, newPath, cb) {
            this._mu.lock(() => {
                this._fs.rename(oldPath, newPath, (err) => {
                    this._mu.unlock();
                    cb(err);
                });
            });
        }
        renameSync(oldPath, newPath) {
            if (this._mu.isLocked()) {
                throw new Error('invalid sync call');
            }
            return this._fs.renameSync(oldPath, newPath);
        }
        stat(p, isLstat, cb) {
            this._mu.lock(() => {
                this._fs.stat(p, isLstat, (err, stat) => {
                    this._mu.unlock();
                    cb(err, stat);
                });
            });
        }
        statSync(p, isLstat) {
            if (this._mu.isLocked()) {
                throw new Error('invalid sync call');
            }
            return this._fs.statSync(p, isLstat);
        }
        open(p, flag, mode, cb) {
            this._mu.lock(() => {
                this._fs.open(p, flag, mode, (err, fd) => {
                    this._mu.unlock();
                    cb(err, fd);
                });
            });
        }
        openSync(p, flag, mode) {
            if (this._mu.isLocked()) {
                throw new Error('invalid sync call');
            }
            return this._fs.openSync(p, flag, mode);
        }
        unlink(p, cb) {
            this._mu.lock(() => {
                this._fs.unlink(p, (err) => {
                    this._mu.unlock();
                    cb(err);
                });
            });
        }
        unlinkSync(p) {
            if (this._mu.isLocked()) {
                throw new Error('invalid sync call');
            }
            return this._fs.unlinkSync(p);
        }
        rmdir(p, cb) {
            this._mu.lock(() => {
                this._fs.rmdir(p, (err) => {
                    this._mu.unlock();
                    cb(err);
                });
            });
        }
        rmdirSync(p) {
            if (this._mu.isLocked()) {
                throw new Error('invalid sync call');
            }
            return this._fs.rmdirSync(p);
        }
        mkdir(p, mode, cb) {
            this._mu.lock(() => {
                this._fs.mkdir(p, mode, (err) => {
                    this._mu.unlock();
                    cb(err);
                });
            });
        }
        mkdirSync(p, mode) {
            if (this._mu.isLocked()) {
                throw new Error('invalid sync call');
            }
            return this._fs.mkdirSync(p, mode);
        }
        readdir(p, cb) {
            this._mu.lock(() => {
                this._fs.readdir(p, (err, files) => {
                    this._mu.unlock();
                    cb(err, files);
                });
            });
        }
        readdirSync(p) {
            if (this._mu.isLocked()) {
                throw new Error('invalid sync call');
            }
            return this._fs.readdirSync(p);
        }
        exists(p, cb) {
            this._mu.lock(() => {
                this._fs.exists(p, (exists) => {
                    this._mu.unlock();
                    cb(exists);
                });
            });
        }
        existsSync(p) {
            if (this._mu.isLocked()) {
                throw new Error('invalid sync call');
            }
            return this._fs.existsSync(p);
        }
        realpath(p, cache, cb) {
            this._mu.lock(() => {
                this._fs.realpath(p, cache, (err, resolvedPath) => {
                    this._mu.unlock();
                    cb(err, resolvedPath);
                });
            });
        }
        realpathSync(p, cache) {
            if (this._mu.isLocked()) {
                throw new Error('invalid sync call');
            }
            return this._fs.realpathSync(p, cache);
        }
        truncate(p, len, cb) {
            this._mu.lock(() => {
                this._fs.truncate(p, len, (err) => {
                    this._mu.unlock();
                    cb(err);
                });
            });
        }
        truncateSync(p, len) {
            if (this._mu.isLocked()) {
                throw new Error('invalid sync call');
            }
            return this._fs.truncateSync(p, len);
        }
        readFile(fname, encoding, flag, cb) {
            this._mu.lock(() => {
                this._fs.readFile(fname, encoding, flag, (err, data) => {
                    this._mu.unlock();
                    cb(err, data);
                });
            });
        }
        readFileSync(fname, encoding, flag) {
            if (this._mu.isLocked()) {
                throw new Error('invalid sync call');
            }
            return this._fs.readFileSync(fname, encoding, flag);
        }
        writeFile(fname, data, encoding, flag, mode, cb) {
            this._mu.lock(() => {
                this._fs.writeFile(fname, data, encoding, flag, mode, (err) => {
                    this._mu.unlock();
                    cb(err);
                });
            });
        }
        writeFileSync(fname, data, encoding, flag, mode) {
            if (this._mu.isLocked()) {
                throw new Error('invalid sync call');
            }
            return this._fs.writeFileSync(fname, data, encoding, flag, mode);
        }
        appendFile(fname, data, encoding, flag, mode, cb) {
            this._mu.lock(() => {
                this._fs.appendFile(fname, data, encoding, flag, mode, (err) => {
                    this._mu.unlock();
                    cb(err);
                });
            });
        }
        appendFileSync(fname, data, encoding, flag, mode) {
            if (this._mu.isLocked()) {
                throw new Error('invalid sync call');
            }
            return this._fs.appendFileSync(fname, data, encoding, flag, mode);
        }
        chmod(p, isLchmod, mode, cb) {
            this._mu.lock(() => {
                this._fs.chmod(p, isLchmod, mode, (err) => {
                    this._mu.unlock();
                    cb(err);
                });
            });
        }
        chmodSync(p, isLchmod, mode) {
            if (this._mu.isLocked()) {
                throw new Error('invalid sync call');
            }
            return this._fs.chmodSync(p, isLchmod, mode);
        }
        chown(p, isLchown, uid, gid, cb) {
            this._mu.lock(() => {
                this._fs.chown(p, isLchown, uid, gid, (err) => {
                    this._mu.unlock();
                    cb(err);
                });
            });
        }
        chownSync(p, isLchown, uid, gid) {
            if (this._mu.isLocked()) {
                throw new Error('invalid sync call');
            }
            return this._fs.chownSync(p, isLchown, uid, gid);
        }
        utimes(p, atime, mtime, cb) {
            this._mu.lock(() => {
                this._fs.utimes(p, atime, mtime, (err) => {
                    this._mu.unlock();
                    cb(err);
                });
            });
        }
        utimesSync(p, atime, mtime) {
            if (this._mu.isLocked()) {
                throw new Error('invalid sync call');
            }
            return this._fs.utimesSync(p, atime, mtime);
        }
        link(srcpath, dstpath, cb) {
            this._mu.lock(() => {
                this._fs.link(srcpath, dstpath, (err) => {
                    this._mu.unlock();
                    cb(err);
                });
            });
        }
        linkSync(srcpath, dstpath) {
            if (this._mu.isLocked()) {
                throw new Error('invalid sync call');
            }
            return this._fs.linkSync(srcpath, dstpath);
        }
        symlink(srcpath, dstpath, type, cb) {
            this._mu.lock(() => {
                this._fs.symlink(srcpath, dstpath, type, (err) => {
                    this._mu.unlock();
                    cb(err);
                });
            });
        }
        symlinkSync(srcpath, dstpath, type) {
            if (this._mu.isLocked()) {
                throw new Error('invalid sync call');
            }
            return this._fs.symlinkSync(srcpath, dstpath, type);
        }
        readlink(p, cb) {
            this._mu.lock(() => {
                this._fs.readlink(p, (err, linkString) => {
                    this._mu.unlock();
                    cb(err, linkString);
                });
            });
        }
        readlinkSync(p) {
            if (this._mu.isLocked()) {
                throw new Error('invalid sync call');
            }
            return this._fs.readlinkSync(p);
        }
    }

    return LockedFS;
});
define('skylark-browserfs/backend/OverlayFS',[
    '../core/file_system',
    '../core/api_error',
    '../core/file_flag',
    '../core/node_fs_stats',
    '../generic/preload_file',
    '../generic/locked_fs',
    '../libs/path'
], function (file_system, api_error, file_flag, node_fs_stats, preload_file, LockedFS, path) {

    'use strict';


    const { BaseFileSystem } = file_system;
    const { ApiError, ErrorCode }  = api_error;
    const { FileFlag, ActionType }  = file_flag;
    const { Stats }  = node_fs_stats;
    const {PreloadFile}  = preload_file;

    /**
     * @hidden
     */
    const deletionLogPath = '/.deletedFiles.log';
    /**
     * Given a read-only mode, makes it writable.
     * @hidden
     */
    function makeModeWritable(mode) {
        return 0o222 | mode;
    }
    /**
     * @hidden
     */
    function getFlag(f) {
        return FileFlag.getFileFlag(f);
    }
    /**
     * Overlays a RO file to make it writable.
     */
    class OverlayFile extends PreloadFile {
        constructor(fs, path, flag, stats, data) {
            super(fs, path, flag, stats, data);
        }
        sync(cb) {
            if (!this.isDirty()) {
                cb(null);
                return;
            }
            this._fs._syncAsync(this, (err) => {
                this.resetDirty();
                cb(err);
            });
        }
        syncSync() {
            if (this.isDirty()) {
                this._fs._syncSync(this);
                this.resetDirty();
            }
        }
        close(cb) {
            this.sync(cb);
        }
        closeSync() {
            this.syncSync();
        }
    }
    /**
     * *INTERNAL, DO NOT USE DIRECTLY!*
     *
     * Core OverlayFS class that contains no locking whatsoever. We wrap these objects
     * in a LockedFS to prevent races.
     */
    class UnlockedOverlayFS extends BaseFileSystem {
        constructor(writable, readable) {
            super();
            this._isInitialized = false;
            this._initializeCallbacks = [];
            this._deletedFiles = {};
            this._deleteLog = '';
            // If 'true', we have scheduled a delete log update.
            this._deleteLogUpdatePending = false;
            // If 'true', a delete log update is needed after the scheduled delete log
            // update finishes.
            this._deleteLogUpdateNeeded = false;
            // If there was an error updating the delete log...
            this._deleteLogError = null;
            this._writable = writable;
            this._readable = readable;
            if (this._writable.isReadOnly()) {
                throw new ApiError(ErrorCode.EINVAL, "Writable file system must be writable.");
            }
        }
        static isAvailable() {
            return true;
        }
        getOverlayedFileSystems() {
            return {
                readable: this._readable,
                writable: this._writable
            };
        }
        _syncAsync(file, cb) {
            this.createParentDirectoriesAsync(file.getPath(), (err) => {
                if (err) {
                    return cb(err);
                }
                this._writable.writeFile(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode, cb);
            });
        }
        _syncSync(file) {
            this.createParentDirectories(file.getPath());
            this._writable.writeFileSync(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode);
        }
        getName() {
            return OverlayFS.Name;
        }
        /**
         * **INTERNAL METHOD**
         *
         * Called once to load up metadata stored on the writable file system.
         */
        _initialize(cb) {
            const callbackArray = this._initializeCallbacks;
            const end = (e) => {
                this._isInitialized = !e;
                this._initializeCallbacks = [];
                callbackArray.forEach(((cb) => cb(e)));
            };
            // if we're already initialized, immediately invoke the callback
            if (this._isInitialized) {
                return cb();
            }
            callbackArray.push(cb);
            // The first call to initialize initializes, the rest wait for it to complete.
            if (callbackArray.length !== 1) {
                return;
            }
            // Read deletion log, process into metadata.
            this._writable.readFile(deletionLogPath, 'utf8', getFlag('r'), (err, data) => {
                if (err) {
                    // ENOENT === Newly-instantiated file system, and thus empty log.
                    if (err.errno !== ErrorCode.ENOENT) {
                        return end(err);
                    }
                }
                else {
                    this._deleteLog = data;
                }
                this._reparseDeletionLog();
                end();
            });
        }
        isReadOnly() { return false; }
        supportsSynch() { return this._readable.supportsSynch() && this._writable.supportsSynch(); }
        supportsLinks() { return false; }
        supportsProps() { return this._readable.supportsProps() && this._writable.supportsProps(); }
        getDeletionLog() {
            return this._deleteLog;
        }
        restoreDeletionLog(log) {
            this._deleteLog = log;
            this._reparseDeletionLog();
            this.updateLog('');
        }
        rename(oldPath, newPath, cb) {
            if (!this.checkInitAsync(cb) || this.checkPathAsync(oldPath, cb) || this.checkPathAsync(newPath, cb)) {
                return;
            }
            if (oldPath === deletionLogPath || newPath === deletionLogPath) {
                return cb(ApiError.EPERM('Cannot rename deletion log.'));
            }
            // nothing to do if paths match
            if (oldPath === newPath) {
                return cb();
            }
            this.stat(oldPath, false, (oldErr, oldStats) => {
                if (oldErr) {
                    return cb(oldErr);
                }
                return this.stat(newPath, false, (newErr, newStats) => {
                    const self = this;
                    // precondition: both oldPath and newPath exist and are dirs.
                    // decreases: |files|
                    // Need to move *every file/folder* currently stored on
                    // readable to its new location on writable.
                    function copyDirContents(files) {
                        const file = files.shift();
                        if (!file) {
                            return cb();
                        }
                        const oldFile = path.resolve(oldPath, file);
                        const newFile = path.resolve(newPath, file);
                        // Recursion! Should work for any nested files / folders.
                        self.rename(oldFile, newFile, (err) => {
                            if (err) {
                                return cb(err);
                            }
                            copyDirContents(files);
                        });
                    }
                    let mode = 0o777;
                    // from linux's rename(2) manpage: oldpath can specify a
                    // directory.  In this case, newpath must either not exist, or
                    // it must specify an empty directory.
                    if (oldStats.isDirectory()) {
                        if (newErr) {
                            if (newErr.errno !== ErrorCode.ENOENT) {
                                return cb(newErr);
                            }
                            return this._writable.exists(oldPath, (exists) => {
                                // simple case - both old and new are on the writable layer
                                if (exists) {
                                    return this._writable.rename(oldPath, newPath, cb);
                                }
                                this._writable.mkdir(newPath, mode, (mkdirErr) => {
                                    if (mkdirErr) {
                                        return cb(mkdirErr);
                                    }
                                    this._readable.readdir(oldPath, (err, files) => {
                                        if (err) {
                                            return cb();
                                        }
                                        copyDirContents(files);
                                    });
                                });
                            });
                        }
                        mode = newStats.mode;
                        if (!newStats.isDirectory()) {
                            return cb(ApiError.ENOTDIR(newPath));
                        }
                        this.readdir(newPath, (readdirErr, files) => {
                            if (files && files.length) {
                                return cb(ApiError.ENOTEMPTY(newPath));
                            }
                            this._readable.readdir(oldPath, (err, files) => {
                                if (err) {
                                    return cb();
                                }
                                copyDirContents(files);
                            });
                        });
                    }
                    if (newStats && newStats.isDirectory()) {
                        return cb(ApiError.EISDIR(newPath));
                    }
                    this.readFile(oldPath, null, getFlag('r'), (err, data) => {
                        if (err) {
                            return cb(err);
                        }
                        return this.writeFile(newPath, data, null, getFlag('w'), oldStats.mode, (err) => {
                            if (err) {
                                return cb(err);
                            }
                            return this.unlink(oldPath, cb);
                        });
                    });
                });
            });
        }
        renameSync(oldPath, newPath) {
            this.checkInitialized();
            this.checkPath(oldPath);
            this.checkPath(newPath);
            if (oldPath === deletionLogPath || newPath === deletionLogPath) {
                throw ApiError.EPERM('Cannot rename deletion log.');
            }
            // Write newPath using oldPath's contents, delete oldPath.
            const oldStats = this.statSync(oldPath, false);
            if (oldStats.isDirectory()) {
                // Optimization: Don't bother moving if old === new.
                if (oldPath === newPath) {
                    return;
                }
                let mode = 0o777;
                if (this.existsSync(newPath)) {
                    const stats = this.statSync(newPath, false);
                    mode = stats.mode;
                    if (stats.isDirectory()) {
                        if (this.readdirSync(newPath).length > 0) {
                            throw ApiError.ENOTEMPTY(newPath);
                        }
                    }
                    else {
                        throw ApiError.ENOTDIR(newPath);
                    }
                }
                // Take care of writable first. Move any files there, or create an empty directory
                // if it doesn't exist.
                if (this._writable.existsSync(oldPath)) {
                    this._writable.renameSync(oldPath, newPath);
                }
                else if (!this._writable.existsSync(newPath)) {
                    this._writable.mkdirSync(newPath, mode);
                }
                // Need to move *every file/folder* currently stored on readable to its new location
                // on writable.
                if (this._readable.existsSync(oldPath)) {
                    this._readable.readdirSync(oldPath).forEach((name) => {
                        // Recursion! Should work for any nested files / folders.
                        this.renameSync(path.resolve(oldPath, name), path.resolve(newPath, name));
                    });
                }
            }
            else {
                if (this.existsSync(newPath) && this.statSync(newPath, false).isDirectory()) {
                    throw ApiError.EISDIR(newPath);
                }
                this.writeFileSync(newPath, this.readFileSync(oldPath, null, getFlag('r')), null, getFlag('w'), oldStats.mode);
            }
            if (oldPath !== newPath && this.existsSync(oldPath)) {
                this.unlinkSync(oldPath);
            }
        }
        stat(p, isLstat, cb) {
            if (!this.checkInitAsync(cb)) {
                return;
            }
            this._writable.stat(p, isLstat, (err, stat) => {
                if (err && err.errno === ErrorCode.ENOENT) {
                    if (this._deletedFiles[p]) {
                        cb(ApiError.ENOENT(p));
                    }
                    this._readable.stat(p, isLstat, (err, stat) => {
                        if (stat) {
                            // Make the oldStat's mode writable. Preserve the topmost
                            // part of the mode, which specifies if it is a file or a
                            // directory.
                            stat = Stats.clone(stat);
                            stat.mode = makeModeWritable(stat.mode);
                        }
                        cb(err, stat);
                    });
                }
                else {
                    cb(err, stat);
                }
            });
        }
        statSync(p, isLstat) {
            this.checkInitialized();
            try {
                return this._writable.statSync(p, isLstat);
            }
            catch (e) {
                if (this._deletedFiles[p]) {
                    throw ApiError.ENOENT(p);
                }
                const oldStat = Stats.clone(this._readable.statSync(p, isLstat));
                // Make the oldStat's mode writable. Preserve the topmost part of the
                // mode, which specifies if it is a file or a directory.
                oldStat.mode = makeModeWritable(oldStat.mode);
                return oldStat;
            }
        }
        open(p, flag, mode, cb) {
            if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {
                return;
            }
            this.stat(p, false, (err, stats) => {
                if (stats) {
                    switch (flag.pathExistsAction()) {
                        case ActionType.TRUNCATE_FILE:
                            return this.createParentDirectoriesAsync(p, (err) => {
                                if (err) {
                                    return cb(err);
                                }
                                this._writable.open(p, flag, mode, cb);
                            });
                        case ActionType.NOP:
                            return this._writable.exists(p, (exists) => {
                                if (exists) {
                                    this._writable.open(p, flag, mode, cb);
                                }
                                else {
                                    // at this point we know the stats object we got is from
                                    // the readable FS.
                                    stats = Stats.clone(stats);
                                    stats.mode = mode;
                                    this._readable.readFile(p, null, getFlag('r'), (readFileErr, data) => {
                                        if (readFileErr) {
                                            return cb(readFileErr);
                                        }
                                        if (stats.size === -1) {
                                            stats.size = data.length;
                                        }
                                        const f = new OverlayFile(this, p, flag, stats, data);
                                        cb(null, f);
                                    });
                                }
                            });
                        default:
                            return cb(ApiError.EEXIST(p));
                    }
                }
                else {
                    switch (flag.pathNotExistsAction()) {
                        case ActionType.CREATE_FILE:
                            return this.createParentDirectoriesAsync(p, (err) => {
                                if (err) {
                                    return cb(err);
                                }
                                return this._writable.open(p, flag, mode, cb);
                            });
                        default:
                            return cb(ApiError.ENOENT(p));
                    }
                }
            });
        }
        openSync(p, flag, mode) {
            this.checkInitialized();
            this.checkPath(p);
            if (p === deletionLogPath) {
                throw ApiError.EPERM('Cannot open deletion log.');
            }
            if (this.existsSync(p)) {
                switch (flag.pathExistsAction()) {
                    case ActionType.TRUNCATE_FILE:
                        this.createParentDirectories(p);
                        return this._writable.openSync(p, flag, mode);
                    case ActionType.NOP:
                        if (this._writable.existsSync(p)) {
                            return this._writable.openSync(p, flag, mode);
                        }
                        else {
                            // Create an OverlayFile.
                            const buf = this._readable.readFileSync(p, null, getFlag('r'));
                            const stats = Stats.clone(this._readable.statSync(p, false));
                            stats.mode = mode;
                            return new OverlayFile(this, p, flag, stats, buf);
                        }
                    default:
                        throw ApiError.EEXIST(p);
                }
            }
            else {
                switch (flag.pathNotExistsAction()) {
                    case ActionType.CREATE_FILE:
                        this.createParentDirectories(p);
                        return this._writable.openSync(p, flag, mode);
                    default:
                        throw ApiError.ENOENT(p);
                }
            }
        }
        unlink(p, cb) {
            if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {
                return;
            }
            this.exists(p, (exists) => {
                if (!exists) {
                    return cb(ApiError.ENOENT(p));
                }
                this._writable.exists(p, (writableExists) => {
                    if (writableExists) {
                        return this._writable.unlink(p, (err) => {
                            if (err) {
                                return cb(err);
                            }
                            this.exists(p, (readableExists) => {
                                if (readableExists) {
                                    this.deletePath(p);
                                }
                                cb(null);
                            });
                        });
                    }
                    else {
                        // if this only exists on the readable FS, add it to the
                        // delete map.
                        this.deletePath(p);
                        cb(null);
                    }
                });
            });
        }
        unlinkSync(p) {
            this.checkInitialized();
            this.checkPath(p);
            if (this.existsSync(p)) {
                if (this._writable.existsSync(p)) {
                    this._writable.unlinkSync(p);
                }
                // if it still exists add to the delete log
                if (this.existsSync(p)) {
                    this.deletePath(p);
                }
            }
            else {
                throw ApiError.ENOENT(p);
            }
        }
        rmdir(p, cb) {
            if (!this.checkInitAsync(cb)) {
                return;
            }
            const rmdirLower = () => {
                this.readdir(p, (err, files) => {
                    if (err) {
                        return cb(err);
                    }
                    if (files.length) {
                        return cb(ApiError.ENOTEMPTY(p));
                    }
                    this.deletePath(p);
                    cb(null);
                });
            };
            this.exists(p, (exists) => {
                if (!exists) {
                    return cb(ApiError.ENOENT(p));
                }
                this._writable.exists(p, (writableExists) => {
                    if (writableExists) {
                        this._writable.rmdir(p, (err) => {
                            if (err) {
                                return cb(err);
                            }
                            this._readable.exists(p, (readableExists) => {
                                if (readableExists) {
                                    rmdirLower();
                                }
                                else {
                                    cb();
                                }
                            });
                        });
                    }
                    else {
                        rmdirLower();
                    }
                });
            });
        }
        rmdirSync(p) {
            this.checkInitialized();
            if (this.existsSync(p)) {
                if (this._writable.existsSync(p)) {
                    this._writable.rmdirSync(p);
                }
                if (this.existsSync(p)) {
                    // Check if directory is empty.
                    if (this.readdirSync(p).length > 0) {
                        throw ApiError.ENOTEMPTY(p);
                    }
                    else {
                        this.deletePath(p);
                    }
                }
            }
            else {
                throw ApiError.ENOENT(p);
            }
        }
        mkdir(p, mode, cb) {
            if (!this.checkInitAsync(cb)) {
                return;
            }
            this.exists(p, (exists) => {
                if (exists) {
                    return cb(ApiError.EEXIST(p));
                }
                // The below will throw should any of the parent directories
                // fail to exist on _writable.
                this.createParentDirectoriesAsync(p, (err) => {
                    if (err) {
                        return cb(err);
                    }
                    this._writable.mkdir(p, mode, cb);
                });
            });
        }
        mkdirSync(p, mode) {
            this.checkInitialized();
            if (this.existsSync(p)) {
                throw ApiError.EEXIST(p);
            }
            else {
                // The below will throw should any of the parent directories fail to exist
                // on _writable.
                this.createParentDirectories(p);
                this._writable.mkdirSync(p, mode);
            }
        }
        readdir(p, cb) {
            if (!this.checkInitAsync(cb)) {
                return;
            }
            this.stat(p, false, (err, dirStats) => {
                if (err) {
                    return cb(err);
                }
                if (!dirStats.isDirectory()) {
                    return cb(ApiError.ENOTDIR(p));
                }
                this._writable.readdir(p, (err, wFiles) => {
                    if (err && err.code !== 'ENOENT') {
                        return cb(err);
                    }
                    else if (err || !wFiles) {
                        wFiles = [];
                    }
                    this._readable.readdir(p, (err, rFiles) => {
                        // if the directory doesn't exist on the lower FS set rFiles
                        // here to simplify the following code.
                        if (err || !rFiles) {
                            rFiles = [];
                        }
                        // Readdir in both, check delete log on read-only file system's files, merge, return.
                        const seenMap = {};
                        const filtered = wFiles.concat(rFiles.filter((fPath) => !this._deletedFiles[`${p}/${fPath}`])).filter((fPath) => {
                            // Remove duplicates.
                            const result = !seenMap[fPath];
                            seenMap[fPath] = true;
                            return result;
                        });
                        cb(null, filtered);
                    });
                });
            });
        }
        readdirSync(p) {
            this.checkInitialized();
            const dirStats = this.statSync(p, false);
            if (!dirStats.isDirectory()) {
                throw ApiError.ENOTDIR(p);
            }
            // Readdir in both, check delete log on RO file system's listing, merge, return.
            let contents = [];
            try {
                contents = contents.concat(this._writable.readdirSync(p));
            }
            catch (e) {
                // NOP.
            }
            try {
                contents = contents.concat(this._readable.readdirSync(p).filter((fPath) => !this._deletedFiles[`${p}/${fPath}`]));
            }
            catch (e) {
                // NOP.
            }
            const seenMap = {};
            return contents.filter((fileP) => {
                const result = !seenMap[fileP];
                seenMap[fileP] = true;
                return result;
            });
        }
        exists(p, cb) {
            // Cannot pass an error back to callback, so throw an exception instead
            // if not initialized.
            this.checkInitialized();
            this._writable.exists(p, (existsWritable) => {
                if (existsWritable) {
                    return cb(true);
                }
                this._readable.exists(p, (existsReadable) => {
                    cb(existsReadable && this._deletedFiles[p] !== true);
                });
            });
        }
        existsSync(p) {
            this.checkInitialized();
            return this._writable.existsSync(p) || (this._readable.existsSync(p) && this._deletedFiles[p] !== true);
        }
        chmod(p, isLchmod, mode, cb) {
            if (!this.checkInitAsync(cb)) {
                return;
            }
            this.operateOnWritableAsync(p, (err) => {
                if (err) {
                    return cb(err);
                }
                else {
                    this._writable.chmod(p, isLchmod, mode, cb);
                }
            });
        }
        chmodSync(p, isLchmod, mode) {
            this.checkInitialized();
            this.operateOnWritable(p, () => {
                this._writable.chmodSync(p, isLchmod, mode);
            });
        }
        chown(p, isLchmod, uid, gid, cb) {
            if (!this.checkInitAsync(cb)) {
                return;
            }
            this.operateOnWritableAsync(p, (err) => {
                if (err) {
                    return cb(err);
                }
                else {
                    this._writable.chown(p, isLchmod, uid, gid, cb);
                }
            });
        }
        chownSync(p, isLchown, uid, gid) {
            this.checkInitialized();
            this.operateOnWritable(p, () => {
                this._writable.chownSync(p, isLchown, uid, gid);
            });
        }
        utimes(p, atime, mtime, cb) {
            if (!this.checkInitAsync(cb)) {
                return;
            }
            this.operateOnWritableAsync(p, (err) => {
                if (err) {
                    return cb(err);
                }
                else {
                    this._writable.utimes(p, atime, mtime, cb);
                }
            });
        }
        utimesSync(p, atime, mtime) {
            this.checkInitialized();
            this.operateOnWritable(p, () => {
                this._writable.utimesSync(p, atime, mtime);
            });
        }
        deletePath(p) {
            this._deletedFiles[p] = true;
            this.updateLog(`d${p}\n`);
        }
        updateLog(addition) {
            this._deleteLog += addition;
            if (this._deleteLogUpdatePending) {
                this._deleteLogUpdateNeeded = true;
            }
            else {
                this._deleteLogUpdatePending = true;
                this._writable.writeFile(deletionLogPath, this._deleteLog, 'utf8', FileFlag.getFileFlag('w'), 0o644, (e) => {
                    this._deleteLogUpdatePending = false;
                    if (e) {
                        this._deleteLogError = e;
                    }
                    else if (this._deleteLogUpdateNeeded) {
                        this._deleteLogUpdateNeeded = false;
                        this.updateLog('');
                    }
                });
            }
        }
        _reparseDeletionLog() {
            this._deletedFiles = {};
            this._deleteLog.split('\n').forEach((path) => {
                // If the log entry begins w/ 'd', it's a deletion.
                this._deletedFiles[path.slice(1)] = path.slice(0, 1) === 'd';
            });
        }
        checkInitialized() {
            if (!this._isInitialized) {
                throw new ApiError(ErrorCode.EPERM, "OverlayFS is not initialized. Please initialize OverlayFS using its initialize() method before using it.");
            }
            else if (this._deleteLogError !== null) {
                const e = this._deleteLogError;
                this._deleteLogError = null;
                throw e;
            }
        }
        checkInitAsync(cb) {
            if (!this._isInitialized) {
                cb(new ApiError(ErrorCode.EPERM, "OverlayFS is not initialized. Please initialize OverlayFS using its initialize() method before using it."));
                return false;
            }
            else if (this._deleteLogError !== null) {
                const e = this._deleteLogError;
                this._deleteLogError = null;
                cb(e);
                return false;
            }
            return true;
        }
        checkPath(p) {
            if (p === deletionLogPath) {
                throw ApiError.EPERM(p);
            }
        }
        checkPathAsync(p, cb) {
            if (p === deletionLogPath) {
                cb(ApiError.EPERM(p));
                return true;
            }
            return false;
        }
        createParentDirectoriesAsync(p, cb) {
            let parent = path.dirname(p);
            const toCreate = [];
            const self = this;
            this._writable.stat(parent, false, statDone);
            function statDone(err, stat) {
                if (err) {
                    if (parent === "/") {
                        cb(new ApiError(ErrorCode.EBUSY, "Invariant failed: root does not exist!"));
                    }
                    else {
                        toCreate.push(parent);
                        parent = path.dirname(parent);
                        self._writable.stat(parent, false, statDone);
                    }
                }
                else {
                    createParents();
                }
            }
            function createParents() {
                if (!toCreate.length) {
                    return cb();
                }
                const dir = toCreate.pop();
                self._readable.stat(dir, false, (err, stats) => {
                    // stop if we couldn't read the dir
                    if (!stats) {
                        return cb();
                    }
                    self._writable.mkdir(dir, stats.mode, (err) => {
                        if (err) {
                            return cb(err);
                        }
                        createParents();
                    });
                });
            }
        }
        /**
         * With the given path, create the needed parent directories on the writable storage
         * should they not exist. Use modes from the read-only storage.
         */
        createParentDirectories(p) {
            let parent = path.dirname(p), toCreate = [];
            while (!this._writable.existsSync(parent)) {
                toCreate.push(parent);
                parent = path.dirname(parent);
            }
            toCreate = toCreate.reverse();
            toCreate.forEach((p) => {
                this._writable.mkdirSync(p, this.statSync(p, false).mode);
            });
        }
        /**
         * Helper function:
         * - Ensures p is on writable before proceeding. Throws an error if it doesn't exist.
         * - Calls f to perform operation on writable.
         */
        operateOnWritable(p, f) {
            if (this.existsSync(p)) {
                if (!this._writable.existsSync(p)) {
                    // File is on readable storage. Copy to writable storage before
                    // changing its mode.
                    this.copyToWritable(p);
                }
                f();
            }
            else {
                throw ApiError.ENOENT(p);
            }
        }
        operateOnWritableAsync(p, cb) {
            this.exists(p, (exists) => {
                if (!exists) {
                    return cb(ApiError.ENOENT(p));
                }
                this._writable.exists(p, (existsWritable) => {
                    if (existsWritable) {
                        cb();
                    }
                    else {
                        return this.copyToWritableAsync(p, cb);
                    }
                });
            });
        }
        /**
         * Copy from readable to writable storage.
         * PRECONDITION: File does not exist on writable storage.
         */
        copyToWritable(p) {
            const pStats = this.statSync(p, false);
            if (pStats.isDirectory()) {
                this._writable.mkdirSync(p, pStats.mode);
            }
            else {
                this.writeFileSync(p, this._readable.readFileSync(p, null, getFlag('r')), null, getFlag('w'), this.statSync(p, false).mode);
            }
        }
        copyToWritableAsync(p, cb) {
            this.stat(p, false, (err, pStats) => {
                if (err) {
                    return cb(err);
                }
                if (pStats.isDirectory()) {
                    return this._writable.mkdir(p, pStats.mode, cb);
                }
                // need to copy file.
                this._readable.readFile(p, null, getFlag('r'), (err, data) => {
                    if (err) {
                        return cb(err);
                    }
                    this.writeFile(p, data, null, getFlag('w'), pStats.mode, cb);
                });
            });
        }
    }
    /**
     * OverlayFS makes a read-only filesystem writable by storing writes on a second,
     * writable file system. Deletes are persisted via metadata stored on the writable
     * file system.
     */
    class OverlayFS extends LockedFS {
        /**
         * @param writable The file system to write modified files to.
         * @param readable The file system that initially populates this file system.
         */
        constructor(writable, readable) {
            super(new UnlockedOverlayFS(writable, readable));
        }
        /**
         * Constructs and initializes an OverlayFS instance with the given options.
         */
        static Create(opts, cb) {
            try {
                const fs = new OverlayFS(opts.writable, opts.readable);
                fs._initialize((e) => {
                    cb(e, fs);
                });
            }
            catch (e) {
                cb(e);
            }
        }
        static isAvailable() {
            return UnlockedOverlayFS.isAvailable();
        }
        getOverlayedFileSystems() {
            return super.getFSUnlocked().getOverlayedFileSystems();
        }
        unwrap() {
            return super.getFSUnlocked();
        }
        _initialize(cb) {
            super.getFSUnlocked()._initialize(cb);
        }
    }
    OverlayFS.Name = "OverlayFS";
    OverlayFS.Options = {
        writable: {
            type: "object",
            description: "The file system to write modified files to."
        },
        readable: {
            type: "object",
            description: "The file system that initially populates this file system."
        }
    };

    return OverlayFS;
});
define('skylark-browserfs/backend/WorkerFS',[
    '../libs/buffers',
    '../core/file_system',
    '../core/api_error',
    '../core/file_flag',
    '../core/util',
    '../core/file',
    '../core/node_fs_stats',
    '../generic/preload_file',
    '../core/global',
    '../core/node_fs'
], function (buffers,file_system, api_error, file_flag, util, file, node_fs_stats, preload_file, global, fs) {
    'use strict';

    const { BaseFileSystem } = file_system;
    const { ApiError, ErrorCode }  = api_error;
    const { FileFlag }  = file_flag;
    const { buffer2ArrayBuffer, arrayBuffer2Buffer, emptyBuffer }  = util;
    const { BaseFile }  = file;
    const { Stats }  = node_fs_stats;
    const {PreloadFile}  = preload_file;
    const { Buffer } = buffers;

    /**
     * @hidden
     */
    var SpecialArgType;
    (function (SpecialArgType) {
        // Callback
        SpecialArgType[SpecialArgType["CB"] = 0] = "CB";
        // File descriptor
        SpecialArgType[SpecialArgType["FD"] = 1] = "FD";
        // API error
        SpecialArgType[SpecialArgType["API_ERROR"] = 2] = "API_ERROR";
        // Stats object
        SpecialArgType[SpecialArgType["STATS"] = 3] = "STATS";
        // Initial probe for file system information.
        SpecialArgType[SpecialArgType["PROBE"] = 4] = "PROBE";
        // FileFlag object.
        SpecialArgType[SpecialArgType["FILEFLAG"] = 5] = "FILEFLAG";
        // Buffer object.
        SpecialArgType[SpecialArgType["BUFFER"] = 6] = "BUFFER";
        // Generic Error object.
        SpecialArgType[SpecialArgType["ERROR"] = 7] = "ERROR";
    })(SpecialArgType || (SpecialArgType = {}));
    /**
     * Converts callback arguments into ICallbackArgument objects, and back
     * again.
     * @hidden
     */
    class CallbackArgumentConverter {
        constructor() {
            this._callbacks = {};
            this._nextId = 0;
        }
        toRemoteArg(cb) {
            const id = this._nextId++;
            this._callbacks[id] = cb;
            return {
                type: SpecialArgType.CB,
                id: id
            };
        }
        toLocalArg(id) {
            const cb = this._callbacks[id];
            delete this._callbacks[id];
            return cb;
        }
    }
    /**
     * @hidden
     */
    class FileDescriptorArgumentConverter {
        constructor() {
            this._fileDescriptors = {};
            this._nextId = 0;
        }
        toRemoteArg(fd, p, flag, cb) {
            const id = this._nextId++;
            let data;
            let stat;
            this._fileDescriptors[id] = fd;
            // Extract needed information asynchronously.
            fd.stat((err, stats) => {
                if (err) {
                    cb(err);
                }
                else {
                    stat = bufferToTransferrableObject(stats.toBuffer());
                    // If it's a readable flag, we need to grab contents.
                    if (flag.isReadable()) {
                        fd.read(Buffer.alloc(stats.size), 0, stats.size, 0, (err, bytesRead, buff) => {
                            if (err) {
                                cb(err);
                            }
                            else {
                                data = bufferToTransferrableObject(buff);
                                cb(null, {
                                    type: SpecialArgType.FD,
                                    id: id,
                                    data: data,
                                    stat: stat,
                                    path: p,
                                    flag: flag.getFlagString()
                                });
                            }
                        });
                    }
                    else {
                        // File is not readable, which means writing to it will append or
                        // truncate/replace existing contents. Return an empty arraybuffer.
                        cb(null, {
                            type: SpecialArgType.FD,
                            id: id,
                            data: new ArrayBuffer(0),
                            stat: stat,
                            path: p,
                            flag: flag.getFlagString()
                        });
                    }
                }
            });
        }
        applyFdAPIRequest(request, cb) {
            const fdArg = request.args[0];
            this._applyFdChanges(fdArg, (err, fd) => {
                if (err) {
                    cb(err);
                }
                else {
                    // Apply method on now-changed file descriptor.
                    fd[request.method]((e) => {
                        if (request.method === 'close') {
                            delete this._fileDescriptors[fdArg.id];
                        }
                        cb(e);
                    });
                }
            });
        }
        _applyFdChanges(remoteFd, cb) {
            const fd = this._fileDescriptors[remoteFd.id], data = transferrableObjectToBuffer(remoteFd.data), remoteStats = Stats.fromBuffer(transferrableObjectToBuffer(remoteFd.stat));
            // Write data if the file is writable.
            const flag = FileFlag.getFileFlag(remoteFd.flag);
            if (flag.isWriteable()) {
                // Appendable: Write to end of file.
                // Writeable: Replace entire contents of file.
                fd.write(data, 0, data.length, flag.isAppendable() ? fd.getPos() : 0, (e) => {
                    function applyStatChanges() {
                        // Check if mode changed.
                        fd.stat((e, stats) => {
                            if (e) {
                                cb(e);
                            }
                            else {
                                if (stats.mode !== remoteStats.mode) {
                                    fd.chmod(remoteStats.mode, (e) => {
                                        cb(e, fd);
                                    });
                                }
                                else {
                                    cb(e, fd);
                                }
                            }
                        });
                    }
                    if (e) {
                        cb(e);
                    }
                    else {
                        // If writeable & not appendable, we need to ensure file contents are
                        // identical to those from the remote FD. Thus, we truncate to the
                        // length of the remote file.
                        if (!flag.isAppendable()) {
                            fd.truncate(data.length, () => {
                                applyStatChanges();
                            });
                        }
                        else {
                            applyStatChanges();
                        }
                    }
                });
            }
            else {
                cb(null, fd);
            }
        }
    }
    /**
     * @hidden
     */
    function apiErrorLocal2Remote(e) {
        return {
            type: SpecialArgType.API_ERROR,
            errorData: bufferToTransferrableObject(e.writeToBuffer())
        };
    }
    /**
     * @hidden
     */
    function apiErrorRemote2Local(e) {
        return ApiError.fromBuffer(transferrableObjectToBuffer(e.errorData));
    }
    /**
     * @hidden
     */
    function errorLocal2Remote(e) {
        return {
            type: SpecialArgType.ERROR,
            name: e.name,
            message: e.message,
            stack: e.stack
        };
    }
    /**
     * @hidden
     */
    function errorRemote2Local(e) {
        let cnstr = global[e.name];
        if (typeof (cnstr) !== 'function') {
            cnstr = Error;
        }
        const err = new cnstr(e.message);
        err.stack = e.stack;
        return err;
    }
    /**
     * @hidden
     */
    function statsLocal2Remote(stats) {
        return {
            type: SpecialArgType.STATS,
            statsData: bufferToTransferrableObject(stats.toBuffer())
        };
    }
    /**
     * @hidden
     */
    function statsRemote2Local(stats) {
        return Stats.fromBuffer(transferrableObjectToBuffer(stats.statsData));
    }
    /**
     * @hidden
     */
    function fileFlagLocal2Remote(flag) {
        return {
            type: SpecialArgType.FILEFLAG,
            flagStr: flag.getFlagString()
        };
    }
    /**
     * @hidden
     */
    function fileFlagRemote2Local(remoteFlag) {
        return FileFlag.getFileFlag(remoteFlag.flagStr);
    }
    /**
     * @hidden
     */
    function bufferToTransferrableObject(buff) {
        return buffer2ArrayBuffer(buff);
    }
    /**
     * @hidden
     */
    function transferrableObjectToBuffer(buff) {
        return arrayBuffer2Buffer(buff);
    }
    /**
     * @hidden
     */
    function bufferLocal2Remote(buff) {
        return {
            type: SpecialArgType.BUFFER,
            data: bufferToTransferrableObject(buff)
        };
    }
    /**
     * @hidden
     */
    function bufferRemote2Local(buffArg) {
        return transferrableObjectToBuffer(buffArg.data);
    }
    /**
     * @hidden
     */
    function isAPIRequest(data) {
        return data && typeof data === 'object' && data.hasOwnProperty('browserfsMessage') && data['browserfsMessage'];
    }
    /**
     * @hidden
     */
    function isAPIResponse(data) {
        return data && typeof data === 'object' && data.hasOwnProperty('browserfsMessage') && data['browserfsMessage'];
    }
    /**
     * Represents a remote file in a different worker/thread.
     */
    class WorkerFile extends PreloadFile {
        constructor(_fs, _path, _flag, _stat, remoteFdId, contents) {
            super(_fs, _path, _flag, _stat, contents);
            this._remoteFdId = remoteFdId;
        }
        getRemoteFdId() {
            return this._remoteFdId;
        }
        /**
         * @hidden
         */
        toRemoteArg() {
            return {
                type: SpecialArgType.FD,
                id: this._remoteFdId,
                data: bufferToTransferrableObject(this.getBuffer()),
                stat: bufferToTransferrableObject(this.getStats().toBuffer()),
                path: this.getPath(),
                flag: this.getFlag().getFlagString()
            };
        }
        sync(cb) {
            this._syncClose('sync', cb);
        }
        close(cb) {
            this._syncClose('close', cb);
        }
        _syncClose(type, cb) {
            if (this.isDirty()) {
                this._fs.syncClose(type, this, (e) => {
                    if (!e) {
                        this.resetDirty();
                    }
                    cb(e);
                });
            }
            else {
                cb();
            }
        }
    }
    /**
     * WorkerFS lets you access a BrowserFS instance that is running in a different
     * JavaScript context (e.g. access BrowserFS in one of your WebWorkers, or
     * access BrowserFS running on the main page from a WebWorker).
     *
     * For example, to have a WebWorker access files in the main browser thread,
     * do the following:
     *
     * MAIN BROWSER THREAD:
     *
     * ```javascript
     *   // Listen for remote file system requests.
     *   BrowserFS.FileSystem.WorkerFS.attachRemoteListener(webWorkerObject);
     * ```
     *
     * WEBWORKER THREAD:
     *
     * ```javascript
     *   // Set the remote file system as the root file system.
     *   BrowserFS.configure({ fs: "WorkerFS", options: { worker: self }}, function(e) {
     *     // Ready!
     *   });
     * ```
     *
     * Note that synchronous operations are not permitted on the WorkerFS, regardless
     * of the configuration option of the remote FS.
     */
    class WorkerFS extends BaseFileSystem {
        /**
         * Constructs a new WorkerFS instance that connects with BrowserFS running on
         * the specified worker.
         */
        constructor(worker) {
            super();
            this._callbackConverter = new CallbackArgumentConverter();
            this._isInitialized = false;
            this._isReadOnly = false;
            this._supportLinks = false;
            this._supportProps = false;
            this._worker = worker;
            this._worker.addEventListener('message', (e) => {
                const resp = e.data;
                if (isAPIResponse(resp)) {
                    let i;
                    const args = resp.args;
                    const fixedArgs = new Array(args.length);
                    // Dispatch event to correct id.
                    for (i = 0; i < fixedArgs.length; i++) {
                        fixedArgs[i] = this._argRemote2Local(args[i]);
                    }
                    this._callbackConverter.toLocalArg(resp.cbId).apply(null, fixedArgs);
                }
            });
        }
        static Create(opts, cb) {
            const fs = new WorkerFS(opts.worker);
            fs._initialize(() => {
                cb(null, fs);
            });
        }
        static isAvailable() {
            return typeof (importScripts) !== 'undefined' || typeof (Worker) !== 'undefined';
        }
        /**
         * Attaches a listener to the remote worker for file system requests.
         */
        static attachRemoteListener(worker) {
            const fdConverter = new FileDescriptorArgumentConverter();
            function argLocal2Remote(arg, requestArgs, cb) {
                switch (typeof arg) {
                    case 'object':
                        if (arg instanceof Stats) {
                            cb(null, statsLocal2Remote(arg));
                        }
                        else if (arg instanceof ApiError) {
                            cb(null, apiErrorLocal2Remote(arg));
                        }
                        else if (arg instanceof BaseFile) {
                            // Pass in p and flags from original request.
                            cb(null, fdConverter.toRemoteArg(arg, requestArgs[0], requestArgs[1], cb));
                        }
                        else if (arg instanceof FileFlag) {
                            cb(null, fileFlagLocal2Remote(arg));
                        }
                        else if (arg instanceof Buffer) {
                            cb(null, bufferLocal2Remote(arg));
                        }
                        else if (arg instanceof Error) {
                            cb(null, errorLocal2Remote(arg));
                        }
                        else {
                            cb(null, arg);
                        }
                        break;
                    default:
                        cb(null, arg);
                        break;
                }
            }
            function argRemote2Local(arg, fixedRequestArgs) {
                if (!arg) {
                    return arg;
                }
                switch (typeof arg) {
                    case 'object':
                        if (typeof arg['type'] === 'number') {
                            const specialArg = arg;
                            switch (specialArg.type) {
                                case SpecialArgType.CB:
                                    const cbId = arg.id;
                                    return function () {
                                        let i;
                                        const fixedArgs = new Array(arguments.length);
                                        let message, countdown = arguments.length;
                                        function abortAndSendError(err) {
                                            if (countdown > 0) {
                                                countdown = -1;
                                                message = {
                                                    browserfsMessage: true,
                                                    cbId: cbId,
                                                    args: [apiErrorLocal2Remote(err)]
                                                };
                                                worker.postMessage(message);
                                            }
                                        }
                                        for (i = 0; i < arguments.length; i++) {
                                            // Capture i and argument.
                                            ((i, arg) => {
                                                argLocal2Remote(arg, fixedRequestArgs, (err, fixedArg) => {
                                                    fixedArgs[i] = fixedArg;
                                                    if (err) {
                                                        abortAndSendError(err);
                                                    }
                                                    else if (--countdown === 0) {
                                                        message = {
                                                            browserfsMessage: true,
                                                            cbId: cbId,
                                                            args: fixedArgs
                                                        };
                                                        worker.postMessage(message);
                                                    }
                                                });
                                            })(i, arguments[i]);
                                        }
                                        if (arguments.length === 0) {
                                            message = {
                                                browserfsMessage: true,
                                                cbId: cbId,
                                                args: fixedArgs
                                            };
                                            worker.postMessage(message);
                                        }
                                    };
                                case SpecialArgType.API_ERROR:
                                    return apiErrorRemote2Local(specialArg);
                                case SpecialArgType.STATS:
                                    return statsRemote2Local(specialArg);
                                case SpecialArgType.FILEFLAG:
                                    return fileFlagRemote2Local(specialArg);
                                case SpecialArgType.BUFFER:
                                    return bufferRemote2Local(specialArg);
                                case SpecialArgType.ERROR:
                                    return errorRemote2Local(specialArg);
                                default:
                                    // No idea what this is.
                                    return arg;
                            }
                        }
                        else {
                            return arg;
                        }
                    default:
                        return arg;
                }
            }
            worker.addEventListener('message', (e) => {
                const request = e.data;
                if (isAPIRequest(request)) {
                    const args = request.args, fixedArgs = new Array(args.length);
                    switch (request.method) {
                        case 'close':
                        case 'sync':
                            (() => {
                                // File descriptor-relative methods.
                                const remoteCb = args[1];
                                fdConverter.applyFdAPIRequest(request, (err) => {
                                    // Send response.
                                    const response = {
                                        browserfsMessage: true,
                                        cbId: remoteCb.id,
                                        args: err ? [apiErrorLocal2Remote(err)] : []
                                    };
                                    worker.postMessage(response);
                                });
                            })();
                            break;
                        case 'probe':
                            (() => {
                                const rootFs = fs.getRootFS(), remoteCb = args[1], probeResponse = {
                                    type: SpecialArgType.PROBE,
                                    isReadOnly: rootFs.isReadOnly(),
                                    supportsLinks: rootFs.supportsLinks(),
                                    supportsProps: rootFs.supportsProps()
                                }, response = {
                                    browserfsMessage: true,
                                    cbId: remoteCb.id,
                                    args: [probeResponse]
                                };
                                worker.postMessage(response);
                            })();
                            break;
                        default:
                            // File system methods.
                            for (let i = 0; i < args.length; i++) {
                                fixedArgs[i] = argRemote2Local(args[i], fixedArgs);
                            }
                            const rootFS = fs.getRootFS();
                            rootFS[request.method].apply(rootFS, fixedArgs);
                            break;
                    }
                }
            });
        }
        getName() {
            return WorkerFS.Name;
        }
        isReadOnly() { return this._isReadOnly; }
        supportsSynch() { return false; }
        supportsLinks() { return this._supportLinks; }
        supportsProps() { return this._supportProps; }
        rename(oldPath, newPath, cb) {
            this._rpc('rename', arguments);
        }
        stat(p, isLstat, cb) {
            this._rpc('stat', arguments);
        }
        open(p, flag, mode, cb) {
            this._rpc('open', arguments);
        }
        unlink(p, cb) {
            this._rpc('unlink', arguments);
        }
        rmdir(p, cb) {
            this._rpc('rmdir', arguments);
        }
        mkdir(p, mode, cb) {
            this._rpc('mkdir', arguments);
        }
        readdir(p, cb) {
            this._rpc('readdir', arguments);
        }
        exists(p, cb) {
            this._rpc('exists', arguments);
        }
        realpath(p, cache, cb) {
            this._rpc('realpath', arguments);
        }
        truncate(p, len, cb) {
            this._rpc('truncate', arguments);
        }
        readFile(fname, encoding, flag, cb) {
            this._rpc('readFile', arguments);
        }
        writeFile(fname, data, encoding, flag, mode, cb) {
            this._rpc('writeFile', arguments);
        }
        appendFile(fname, data, encoding, flag, mode, cb) {
            this._rpc('appendFile', arguments);
        }
        chmod(p, isLchmod, mode, cb) {
            this._rpc('chmod', arguments);
        }
        chown(p, isLchown, uid, gid, cb) {
            this._rpc('chown', arguments);
        }
        utimes(p, atime, mtime, cb) {
            this._rpc('utimes', arguments);
        }
        link(srcpath, dstpath, cb) {
            this._rpc('link', arguments);
        }
        symlink(srcpath, dstpath, type, cb) {
            this._rpc('symlink', arguments);
        }
        readlink(p, cb) {
            this._rpc('readlink', arguments);
        }
        syncClose(method, fd, cb) {
            this._worker.postMessage({
                browserfsMessage: true,
                method: method,
                args: [fd.toRemoteArg(), this._callbackConverter.toRemoteArg(cb)]
            });
        }
        /**
         * Called once both local and remote sides are set up.
         */
        _initialize(cb) {
            if (!this._isInitialized) {
                const message = {
                    browserfsMessage: true,
                    method: 'probe',
                    args: [this._argLocal2Remote(emptyBuffer()), this._callbackConverter.toRemoteArg((probeResponse) => {
                            this._isInitialized = true;
                            this._isReadOnly = probeResponse.isReadOnly;
                            this._supportLinks = probeResponse.supportsLinks;
                            this._supportProps = probeResponse.supportsProps;
                            cb();
                        })]
                };
                this._worker.postMessage(message);
            }
            else {
                cb();
            }
        }
        _argRemote2Local(arg) {
            if (!arg) {
                return arg;
            }
            switch (typeof arg) {
                case 'object':
                    if (typeof arg['type'] === 'number') {
                        const specialArg = arg;
                        switch (specialArg.type) {
                            case SpecialArgType.API_ERROR:
                                return apiErrorRemote2Local(specialArg);
                            case SpecialArgType.FD:
                                const fdArg = specialArg;
                                return new WorkerFile(this, fdArg.path, FileFlag.getFileFlag(fdArg.flag), Stats.fromBuffer(transferrableObjectToBuffer(fdArg.stat)), fdArg.id, transferrableObjectToBuffer(fdArg.data));
                            case SpecialArgType.STATS:
                                return statsRemote2Local(specialArg);
                            case SpecialArgType.FILEFLAG:
                                return fileFlagRemote2Local(specialArg);
                            case SpecialArgType.BUFFER:
                                return bufferRemote2Local(specialArg);
                            case SpecialArgType.ERROR:
                                return errorRemote2Local(specialArg);
                            default:
                                return arg;
                        }
                    }
                    else {
                        return arg;
                    }
                default:
                    return arg;
            }
        }
        _rpc(methodName, args) {
            const fixedArgs = new Array(args.length);
            for (let i = 0; i < args.length; i++) {
                fixedArgs[i] = this._argLocal2Remote(args[i]);
            }
            const message = {
                browserfsMessage: true,
                method: methodName,
                args: fixedArgs
            };
            this._worker.postMessage(message);
        }
        /**
         * Converts a local argument into a remote argument. Public so WorkerFile objects can call it.
         */
        _argLocal2Remote(arg) {
            if (!arg) {
                return arg;
            }
            switch (typeof arg) {
                case "object":
                    if (arg instanceof Stats) {
                        return statsLocal2Remote(arg);
                    }
                    else if (arg instanceof ApiError) {
                        return apiErrorLocal2Remote(arg);
                    }
                    else if (arg instanceof WorkerFile) {
                        return arg.toRemoteArg();
                    }
                    else if (arg instanceof FileFlag) {
                        return fileFlagLocal2Remote(arg);
                    }
                    else if (arg instanceof Buffer) {
                        return bufferLocal2Remote(arg);
                    }
                    else if (arg instanceof Error) {
                        return errorLocal2Remote(arg);
                    }
                    else {
                        return "Unknown argument";
                    }
                case "function":
                    return this._callbackConverter.toRemoteArg(arg);
                default:
                    return arg;
            }
        }
    }
    WorkerFS.Name = "WorkerFS";
    WorkerFS.Options = {
        worker: {
            type: "object",
            description: "The target worker that you want to connect to, or the current worker if in a worker context.",
            validator: function (v, cb) {
                // Check for a `postMessage` function.
                if (v['postMessage']) {
                    cb();
                }
                else {
                    cb(new ApiError(ErrorCode.EINVAL, `option must be a Web Worker instance.`));
                }
            }
        }
    };

    return WorkerFS;
});
define('skylark-browserfs/generic/xhr',[
    '../libs/buffers',
    '../core/util',
    '../core/api_error'
], function (buffers,util, api_error) {
    'use strict';
    /**
     * Contains utility methods for performing a variety of tasks with
     * XmlHttpRequest across browsers.
     */
    const { isIE, emptyBuffer } = util;
    const { ApiError, ErrorCode } = api_error;
    const { Buffer } = buffers;

    const xhrIsAvailable = (typeof (XMLHttpRequest) !== "undefined" && XMLHttpRequest !== null);
    function asyncDownloadFileModern(p, type, cb) {
        const req = new XMLHttpRequest();
        req.open('GET', p, true);
        let jsonSupported = true;
        switch (type) {
            case 'buffer':
                req.responseType = 'arraybuffer';
                break;
            case 'json':
                // Some browsers don't support the JSON response type.
                // They either reset responseType, or throw an exception.
                // @see https://github.com/Modernizr/Modernizr/blob/master/src/testXhrType.js
                try {
                    req.responseType = 'json';
                    jsonSupported = req.responseType === 'json';
                }
                catch (e) {
                    jsonSupported = false;
                }
                break;
            default:
                return cb(new ApiError(ErrorCode.EINVAL, "Invalid download type: " + type));
        }
        req.onreadystatechange = function (e) {
            if (req.readyState === 4) {
                if (req.status === 200) {
                    switch (type) {
                        case 'buffer':
                            // XXX: WebKit-based browsers return *null* when XHRing an empty file.
                            return cb(null, req.response ? Buffer.from(req.response) : emptyBuffer());
                        case 'json':
                            if (jsonSupported) {
                                return cb(null, req.response);
                            }
                            else {
                                return cb(null, JSON.parse(req.responseText));
                            }
                    }
                }
                else {
                    return cb(new ApiError(ErrorCode.EIO, `XHR error: response returned code ${req.status}`));
                }
            }
        };
        req.send();
    }
    function syncDownloadFileModern(p, type) {
        const req = new XMLHttpRequest();
        req.open('GET', p, false);
        // On most platforms, we cannot set the responseType of synchronous downloads.
        // @todo Test for this; IE10 allows this, as do older versions of Chrome/FF.
        let data = null;
        let err = null;
        // Classic hack to download binary data as a string.
        req.overrideMimeType('text/plain; charset=x-user-defined');
        req.onreadystatechange = function (e) {
            if (req.readyState === 4) {
                if (req.status === 200) {
                    switch (type) {
                        case 'buffer':
                            // Convert the text into a buffer.
                            const text = req.responseText;
                            data = Buffer.alloc(text.length);
                            // Throw away the upper bits of each character.
                            for (let i = 0; i < text.length; i++) {
                                // This will automatically throw away the upper bit of each
                                // character for us.
                                data[i] = text.charCodeAt(i);
                            }
                            return;
                        case 'json':
                            data = JSON.parse(req.responseText);
                            return;
                    }
                }
                else {
                    err = new ApiError(ErrorCode.EIO, `XHR error: response returned code ${req.status}`);
                    return;
                }
            }
        };
        req.send();
        if (err) {
            throw err;
        }
        return data;
    }
    function syncDownloadFileIE10(p, type) {
        const req = new XMLHttpRequest();
        req.open('GET', p, false);
        switch (type) {
            case 'buffer':
                req.responseType = 'arraybuffer';
                break;
            case 'json':
                // IE10 does not support the JSON type.
                break;
            default:
                throw new ApiError(ErrorCode.EINVAL, "Invalid download type: " + type);
        }
        let data;
        let err;
        req.onreadystatechange = function (e) {
            if (req.readyState === 4) {
                if (req.status === 200) {
                    switch (type) {
                        case 'buffer':
                            data = Buffer.from(req.response);
                            break;
                        case 'json':
                            data = JSON.parse(req.response);
                            break;
                    }
                }
                else {
                    err = new ApiError(ErrorCode.EIO, `XHR error: response returned code ${req.status}`);
                }
            }
        };
        req.send();
        if (err) {
            throw err;
        }
        return data;
    }
    /**
     * @hidden
     */
    function getFileSize(async, p, cb) {
        const req = new XMLHttpRequest();
        req.open('HEAD', p, async);
        req.onreadystatechange = function (e) {
            if (req.readyState === 4) {
                if (req.status === 200) {
                    try {
                        return cb(null, parseInt(req.getResponseHeader('Content-Length') || '-1', 10));
                    }
                    catch (e) {
                        // In the event that the header isn't present or there is an error...
                        return cb(new ApiError(ErrorCode.EIO, "XHR HEAD error: Could not read content-length."));
                    }
                }
                else {
                    return cb(new ApiError(ErrorCode.EIO, `XHR HEAD error: response returned code ${req.status}`));
                }
            }
        };
        req.send();
    }
    /**
     * Asynchronously download a file as a buffer or a JSON object.
     * Note that the third function signature with a non-specialized type is
     * invalid, but TypeScript requires it when you specialize string arguments to
     * constants.
     * @hidden
     */
    let asyncDownloadFile = asyncDownloadFileModern;
    /**
     * Synchronously download a file as a buffer or a JSON object.
     * Note that the third function signature with a non-specialized type is
     * invalid, but TypeScript requires it when you specialize string arguments to
     * constants.
     * @hidden
     */
    let syncDownloadFile = (isIE && typeof Blob !== 'undefined') ? syncDownloadFileIE10 : syncDownloadFileModern;
    /**
     * Synchronously retrieves the size of the given file in bytes.
     * @hidden
     */
    function getFileSizeSync(p) {
        let rv = -1;
        getFileSize(false, p, function (err, size) {
            if (err) {
                throw err;
            }
            rv = size;
        });
        return rv;
    }
    /**
     * Asynchronously retrieves the size of the given file in bytes.
     * @hidden
     */
    function getFileSizeAsync(p, cb) {
        getFileSize(true, p, cb);
    }



    return {
        xhrIsAvailable: xhrIsAvailable,
        asyncDownloadFile: asyncDownloadFile,
        syncDownloadFile: syncDownloadFile,
        getFileSizeSync: getFileSizeSync,
        getFileSizeAsync: getFileSizeAsync
    };
});
define('skylark-browserfs/generic/fetch',[
    '../libs/buffers',
    '../core/api_error'
], function (buffers,api_error) {
    'use strict';

    /**
     * Contains utility methods using 'fetch'.
     */
    const { ApiError, ErrorCode }= api_error;

    const fetchIsAvailable = (typeof (fetch) !== "undefined" && fetch !== null);
    const { Buffer } = buffers;

    function fetchFileAsync(p, type, cb) {
        let request;
        try {
            request = fetch(p);
        }
        catch (e) {
            // XXX: fetch will throw a TypeError if the URL has credentials in it
            return cb(new ApiError(ErrorCode.EINVAL, e.message));
        }
        request
            .then((res) => {
            if (!res.ok) {
                return cb(new ApiError(ErrorCode.EIO, `fetch error: response returned code ${res.status}`));
            }
            else {
                switch (type) {
                    case 'buffer':
                        res.arrayBuffer()
                            .then((buf) => cb(null, Buffer.from(buf)))
                            .catch((err) => cb(new ApiError(ErrorCode.EIO, err.message)));
                        break;
                    case 'json':
                        res.json()
                            .then((json) => cb(null, json))
                            .catch((err) => cb(new ApiError(ErrorCode.EIO, err.message)));
                        break;
                    default:
                        cb(new ApiError(ErrorCode.EINVAL, "Invalid download type: " + type));
                }
            }
        })
            .catch((err) => cb(new ApiError(ErrorCode.EIO, err.message)));
    }

    /**
     * Asynchronously retrieves the size of the given file in bytes.
     * @hidden
     */

    function fetchFileSizeAsync(p, cb) {
        fetch(p, { method: 'HEAD' })
            .then((res) => {
            if (!res.ok) {
                return cb(new ApiError(ErrorCode.EIO, `fetch HEAD error: response returned code ${res.status}`));
            }
            else {
                return cb(null, parseInt(res.headers.get('Content-Length') || '-1', 10));
            }
        })
            .catch((err) => cb(new ApiError(ErrorCode.EIO, err.message)));
    }

    return {
        fetchIsAvailable: fetchIsAvailable,
        fetchFileAsync: fetchFileAsync,
        fetchFileSizeAsync: fetchFileSizeAsync
    };
});
define('skylark-browserfs/generic/file_index',[
    '../core/node_fs_stats',
    '../libs/path'
], function (node_fs_stats, path) {
    'use strict';

    const {Stats, FileType }  = node_fs_stats;

    /**
     * A simple class for storing a filesystem index. Assumes that all paths passed
     * to it are *absolute* paths.
     *
     * Can be used as a partial or a full index, although care must be taken if used
     * for the former purpose, especially when directories are concerned.
     */
    class FileIndex {
        /**
         * Constructs a new FileIndex.
         */
        constructor() {
            // _index is a single-level key,value store that maps *directory* paths to
            // DirInodes. File information is only contained in DirInodes themselves.
            this._index = {};
            // Create the root directory.
            this.addPath('/', new DirInode());
        }
        /**
         * Static method for constructing indices from a JSON listing.
         * @param listing Directory listing generated by tools/XHRIndexer.coffee
         * @return A new FileIndex object.
         */
        static fromListing(listing) {
            const idx = new FileIndex();
            // Add a root DirNode.
            const rootInode = new DirInode();
            idx._index['/'] = rootInode;
            const queue = [['', listing, rootInode]];
            while (queue.length > 0) {
                let inode;
                const next = queue.pop();
                const pwd = next[0];
                const tree = next[1];
                const parent = next[2];
                for (const node in tree) {
                    if (tree.hasOwnProperty(node)) {
                        const children = tree[node];
                        const name = `${pwd}/${node}`;
                        if (children) {
                            idx._index[name] = inode = new DirInode();
                            queue.push([name, children, inode]);
                        }
                        else {
                            // This inode doesn't have correct size information, noted with -1.
                            inode = new FileInode(new Stats(FileType.FILE, -1, 0x16D));
                        }
                        if (parent) {
                            parent._ls[node] = inode;
                        }
                    }
                }
            }
            return idx;
        }
        /**
         * Runs the given function over all files in the index.
         */
        fileIterator(cb) {
            for (const path in this._index) {
                if (this._index.hasOwnProperty(path)) {
                    const dir = this._index[path];
                    const files = dir.getListing();
                    for (const file of files) {
                        const item = dir.getItem(file);
                        if (isFileInode(item)) {
                            cb(item.getData());
                        }
                    }
                }
            }
        }
        /**
         * Adds the given absolute path to the index if it is not already in the index.
         * Creates any needed parent directories.
         * @param path The path to add to the index.
         * @param inode The inode for the
         *   path to add.
         * @return 'True' if it was added or already exists, 'false' if there
         *   was an issue adding it (e.g. item in path is a file, item exists but is
         *   different).
         * @todo If adding fails and implicitly creates directories, we do not clean up
         *   the new empty directories.
         */
        addPath(path, inode) {
            if (!inode) {
                throw new Error('Inode must be specified');
            }
            if (path[0] !== '/') {
                throw new Error('Path must be absolute, got: ' + path);
            }
            // Check if it already exists.
            if (this._index.hasOwnProperty(path)) {
                return this._index[path] === inode;
            }
            const splitPath = this._split_path(path);
            const dirpath = splitPath[0];
            const itemname = splitPath[1];
            // Try to add to its parent directory first.
            let parent = this._index[dirpath];
            if (parent === undefined && path !== '/') {
                // Create parent.
                parent = new DirInode();
                if (!this.addPath(dirpath, parent)) {
                    return false;
                }
            }
            // Add myself to my parent.
            if (path !== '/') {
                if (!parent.addItem(itemname, inode)) {
                    return false;
                }
            }
            // If I'm a directory, add myself to the index.
            if (isDirInode(inode)) {
                this._index[path] = inode;
            }
            return true;
        }
        /**
         * Adds the given absolute path to the index if it is not already in the index.
         * The path is added without special treatment (no joining of adjacent separators, etc).
         * Creates any needed parent directories.
         * @param path The path to add to the index.
         * @param inode The inode for the
         *   path to add.
         * @return 'True' if it was added or already exists, 'false' if there
         *   was an issue adding it (e.g. item in path is a file, item exists but is
         *   different).
         * @todo If adding fails and implicitly creates directories, we do not clean up
         *   the new empty directories.
         */
        addPathFast(path, inode) {
            const itemNameMark = path.lastIndexOf('/');
            const parentPath = itemNameMark === 0 ? "/" : path.substring(0, itemNameMark);
            const itemName = path.substring(itemNameMark + 1);
            // Try to add to its parent directory first.
            let parent = this._index[parentPath];
            if (parent === undefined) {
                // Create parent.
                parent = new DirInode();
                this.addPathFast(parentPath, parent);
            }
            if (!parent.addItem(itemName, inode)) {
                return false;
            }
            // If adding a directory, add to the index as well.
            if (inode.isDir()) {
                this._index[path] = inode;
            }
            return true;
        }
        /**
         * Removes the given path. Can be a file or a directory.
         * @return The removed item,
         *   or null if it did not exist.
         */
        removePath(path) {
            const splitPath = this._split_path(path);
            const dirpath = splitPath[0];
            const itemname = splitPath[1];
            // Try to remove it from its parent directory first.
            const parent = this._index[dirpath];
            if (parent === undefined) {
                return null;
            }
            // Remove myself from my parent.
            const inode = parent.remItem(itemname);
            if (inode === null) {
                return null;
            }
            // If I'm a directory, remove myself from the index, and remove my children.
            if (isDirInode(inode)) {
                const children = inode.getListing();
                for (const child of children) {
                    this.removePath(path + '/' + child);
                }
                // Remove the directory from the index, unless it's the root.
                if (path !== '/') {
                    delete this._index[path];
                }
            }
            return inode;
        }
        /**
         * Retrieves the directory listing of the given path.
         * @return An array of files in the given path, or 'null' if it does not exist.
         */
        ls(path) {
            const item = this._index[path];
            if (item === undefined) {
                return null;
            }
            return item.getListing();
        }
        /**
         * Returns the inode of the given item.
         * @return Returns null if the item does not exist.
         */
        getInode(path) {
            const splitPath = this._split_path(path);
            const dirpath = splitPath[0];
            const itemname = splitPath[1];
            // Retrieve from its parent directory.
            const parent = this._index[dirpath];
            if (parent === undefined) {
                return null;
            }
            // Root case
            if (dirpath === path) {
                return parent;
            }
            return parent.getItem(itemname);
        }
        /**
         * Split into a (directory path, item name) pair
         */
        _split_path(p) {
            const dirpath = path.dirname(p);
            const itemname = p.substr(dirpath.length + (dirpath === "/" ? 0 : 1));
            return [dirpath, itemname];
        }
    }
    
    /**
     * Inode for a file. Stores an arbitrary (filesystem-specific) data payload.
     */
    class FileInode {
        constructor(data) {
            this.data = data;
        }
        isFile() { return true; }
        isDir() { return false; }
        getData() { return this.data; }
        setData(data) { this.data = data; }
    }
    /**
     * Inode for a directory. Currently only contains the directory listing.
     */
    class DirInode {
        /**
         * Constructs an inode for a directory.
         */
        constructor(data = null) {
            this.data = data;
            this._ls = {};
        }
        isFile() {
            return false;
        }
        isDir() {
            return true;
        }
        getData() { return this.data; }
        /**
         * Return a Stats object for this inode.
         * @todo Should probably remove this at some point. This isn't the
         *       responsibility of the FileIndex.
         */
        getStats() {
            return new Stats(FileType.DIRECTORY, 4096, 0x16D);
        }
        /**
         * Returns the directory listing for this directory. Paths in the directory are
         * relative to the directory's path.
         * @return The directory listing for this directory.
         */
        getListing() {
            return Object.keys(this._ls);
        }
        /**
         * Returns the inode for the indicated item, or null if it does not exist.
         * @param p Name of item in this directory.
         */
        getItem(p) {
            const item = this._ls[p];
            return item ? item : null;
        }
        /**
         * Add the given item to the directory listing. Note that the given inode is
         * not copied, and will be mutated by the DirInode if it is a DirInode.
         * @param p Item name to add to the directory listing.
         * @param inode The inode for the
         *   item to add to the directory inode.
         * @return True if it was added, false if it already existed.
         */
        addItem(p, inode) {
            if (p in this._ls) {
                return false;
            }
            this._ls[p] = inode;
            return true;
        }
        /**
         * Removes the given item from the directory listing.
         * @param p Name of item to remove from the directory listing.
         * @return Returns the item
         *   removed, or null if the item did not exist.
         */
        remItem(p) {
            const item = this._ls[p];
            if (item === undefined) {
                return null;
            }
            delete this._ls[p];
            return item;
        }
    }
    /**
     * @hidden
     */
    function isFileInode(inode) {
        return !!inode && inode.isFile();
    }
    /**
     * @hidden
     */
    function isDirInode(inode) {
        return !!inode && inode.isDir();
    }


    return {
        FileIndex: FileIndex,
        FileInode: FileInode,
        DirInode: DirInode,
        isFileInode: isFileInode,
        isDirInode: isDirInode
    };
});
define('skylark-browserfs/backend/HTTPRequest',[
    '../core/file_system',
    '../core/api_error',
    '../core/file_flag',
    '../core/util',
    '../core/node_fs_stats',
    '../generic/preload_file',
    '../generic/xhr',
    '../generic/fetch',
    '../generic/file_index'
], function (file_system, api_error, file_flag, util, node_fs_stats, preload_file, xhr, fetch, file_index) {
    'use strict';

    const { BaseFileSystem } = file_system;
    const { ApiError, ErrorCode }  = api_error;
    const { ActionType }  = file_flag;
    const { copyingSlice }  = util;
    const  {Stats} = node_fs_stats;
    const { NoSyncFile }  = preload_file;
    const { xhrIsAvailable, asyncDownloadFile, syncDownloadFile, getFileSizeAsync, getFileSizeSync }  = xhr;
    const { fetchIsAvailable, fetchFileAsync, fetchFileSizeAsync }  = fetch;
    const { FileIndex, isFileInode, isDirInode }  = file_index;
    /**
     * Try to convert the given buffer into a string, and pass it to the callback.
     * Optimization that removes the needed try/catch into a helper function, as
     * this is an uncommon case.
     * @hidden
     */
    function tryToString(buff, encoding, cb) {
        try {
            cb(null, buff.toString(encoding));
        }
        catch (e) {
            cb(e);
        }
    }
    function syncNotAvailableError() {
        throw new ApiError(ErrorCode.ENOTSUP, `Synchronous HTTP download methods are not available in this environment.`);
    }
    /**
     * A simple filesystem backed by HTTP downloads. You must create a directory listing using the
     * `make_http_index` tool provided by BrowserFS.
     *
     * If you install BrowserFS globally with `npm i -g browserfs`, you can generate a listing by
     * running `make_http_index` in your terminal in the directory you would like to index:
     *
     * ```
     * make_http_index > index.json
     * ```
     *
     * Listings objects look like the following:
     *
     * ```json
     * {
     *   "home": {
     *     "jvilk": {
     *       "someFile.txt": null,
     *       "someDir": {
     *         // Empty directory
     *       }
     *     }
     *   }
     * }
     * ```
     *
     * *This example has the folder `/home/jvilk` with subfile `someFile.txt` and subfolder `someDir`.*
     */
    class HTTPRequest extends BaseFileSystem {
        constructor(index, prefixUrl = '', preferXHR = false) {
            super();
            // prefix_url must end in a directory separator.
            if (prefixUrl.length > 0 && prefixUrl.charAt(prefixUrl.length - 1) !== '/') {
                prefixUrl = prefixUrl + '/';
            }
            this.prefixUrl = prefixUrl;
            this._index = FileIndex.fromListing(index);
            if (fetchIsAvailable && (!preferXHR || !xhrIsAvailable)) {
                this._requestFileAsyncInternal = fetchFileAsync;
                this._requestFileSizeAsyncInternal = fetchFileSizeAsync;
            }
            else {
                this._requestFileAsyncInternal = asyncDownloadFile;
                this._requestFileSizeAsyncInternal = getFileSizeAsync;
            }
            if (xhrIsAvailable) {
                this._requestFileSyncInternal = syncDownloadFile;
                this._requestFileSizeSyncInternal = getFileSizeSync;
            }
            else {
                this._requestFileSyncInternal = syncNotAvailableError;
                this._requestFileSizeSyncInternal = syncNotAvailableError;
            }
        }
        /**
         * Construct an HTTPRequest file system backend with the given options.
         */
        static Create(opts, cb) {
            if (opts.index === undefined) {
                opts.index = `index.json`;
            }
            if (typeof (opts.index) === "string") {
                asyncDownloadFile(opts.index, "json", (e, data) => {
                    if (e) {
                        cb(e);
                    }
                    else {
                        cb(null, new HTTPRequest(data, opts.baseUrl));
                    }
                });
            }
            else {
                cb(null, new HTTPRequest(opts.index, opts.baseUrl));
            }
        }
        static isAvailable() {
            return xhrIsAvailable || fetchIsAvailable;
        }
        empty() {
            this._index.fileIterator(function (file) {
                file.fileData = null;
            });
        }
        getName() {
            return HTTPRequest.Name;
        }
        diskSpace(path, cb) {
            // Read-only file system. We could calculate the total space, but that's not
            // important right now.
            cb(0, 0);
        }
        isReadOnly() {
            return true;
        }
        supportsLinks() {
            return false;
        }
        supportsProps() {
            return false;
        }
        supportsSynch() {
            // Synchronous operations are only available via the XHR interface for now.
            return xhrIsAvailable;
        }
        /**
         * Special HTTPFS function: Preload the given file into the index.
         * @param [String] path
         * @param [BrowserFS.Buffer] buffer
         */
        preloadFile(path, buffer) {
            const inode = this._index.getInode(path);
            if (isFileInode(inode)) {
                if (inode === null) {
                    throw ApiError.ENOENT(path);
                }
                const stats = inode.getData();
                stats.size = buffer.length;
                stats.fileData = buffer;
            }
            else {
                throw ApiError.EISDIR(path);
            }
        }
        stat(path, isLstat, cb) {
            const inode = this._index.getInode(path);
            if (inode === null) {
                return cb(ApiError.ENOENT(path));
            }
            let stats;
            if (isFileInode(inode)) {
                stats = inode.getData();
                // At this point, a non-opened file will still have default stats from the listing.
                if (stats.size < 0) {
                    this._requestFileSizeAsync(path, function (e, size) {
                        if (e) {
                            return cb(e);
                        }
                        stats.size = size;
                        cb(null, Stats.clone(stats));
                    });
                }
                else {
                    cb(null, Stats.clone(stats));
                }
            }
            else if (isDirInode(inode)) {
                stats = inode.getStats();
                cb(null, stats);
            }
            else {
                cb(ApiError.FileError(ErrorCode.EINVAL, path));
            }
        }
        statSync(path, isLstat) {
            const inode = this._index.getInode(path);
            if (inode === null) {
                throw ApiError.ENOENT(path);
            }
            let stats;
            if (isFileInode(inode)) {
                stats = inode.getData();
                // At this point, a non-opened file will still have default stats from the listing.
                if (stats.size < 0) {
                    stats.size = this._requestFileSizeSync(path);
                }
            }
            else if (isDirInode(inode)) {
                stats = inode.getStats();
            }
            else {
                throw ApiError.FileError(ErrorCode.EINVAL, path);
            }
            return stats;
        }
        open(path, flags, mode, cb) {
            // INVARIANT: You can't write to files on this file system.
            if (flags.isWriteable()) {
                return cb(new ApiError(ErrorCode.EPERM, path));
            }
            const self = this;
            // Check if the path exists, and is a file.
            const inode = this._index.getInode(path);
            if (inode === null) {
                return cb(ApiError.ENOENT(path));
            }
            if (isFileInode(inode)) {
                const stats = inode.getData();
                switch (flags.pathExistsAction()) {
                    case ActionType.THROW_EXCEPTION:
                    case ActionType.TRUNCATE_FILE:
                        return cb(ApiError.EEXIST(path));
                    case ActionType.NOP:
                        // Use existing file contents.
                        // XXX: Uh, this maintains the previously-used flag.
                        if (stats.fileData) {
                            return cb(null, new NoSyncFile(self, path, flags, Stats.clone(stats), stats.fileData));
                        }
                        // @todo be lazier about actually requesting the file
                        this._requestFileAsync(path, 'buffer', function (err, buffer) {
                            if (err) {
                                return cb(err);
                            }
                            // we don't initially have file sizes
                            stats.size = buffer.length;
                            stats.fileData = buffer;
                            return cb(null, new NoSyncFile(self, path, flags, Stats.clone(stats), buffer));
                        });
                        break;
                    default:
                        return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.'));
                }
            }
            else {
                return cb(ApiError.EISDIR(path));
            }
        }
        openSync(path, flags, mode) {
            // INVARIANT: You can't write to files on this file system.
            if (flags.isWriteable()) {
                throw new ApiError(ErrorCode.EPERM, path);
            }
            // Check if the path exists, and is a file.
            const inode = this._index.getInode(path);
            if (inode === null) {
                throw ApiError.ENOENT(path);
            }
            if (isFileInode(inode)) {
                const stats = inode.getData();
                switch (flags.pathExistsAction()) {
                    case ActionType.THROW_EXCEPTION:
                    case ActionType.TRUNCATE_FILE:
                        throw ApiError.EEXIST(path);
                    case ActionType.NOP:
                        // Use existing file contents.
                        // XXX: Uh, this maintains the previously-used flag.
                        if (stats.fileData) {
                            return new NoSyncFile(this, path, flags, Stats.clone(stats), stats.fileData);
                        }
                        // @todo be lazier about actually requesting the file
                        const buffer = this._requestFileSync(path, 'buffer');
                        // we don't initially have file sizes
                        stats.size = buffer.length;
                        stats.fileData = buffer;
                        return new NoSyncFile(this, path, flags, Stats.clone(stats), buffer);
                    default:
                        throw new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.');
                }
            }
            else {
                throw ApiError.EISDIR(path);
            }
        }
        readdir(path, cb) {
            try {
                cb(null, this.readdirSync(path));
            }
            catch (e) {
                cb(e);
            }
        }
        readdirSync(path) {
            // Check if it exists.
            const inode = this._index.getInode(path);
            if (inode === null) {
                throw ApiError.ENOENT(path);
            }
            else if (isDirInode(inode)) {
                return inode.getListing();
            }
            else {
                throw ApiError.ENOTDIR(path);
            }
        }
        /**
         * We have the entire file as a buffer; optimize readFile.
         */
        readFile(fname, encoding, flag, cb) {
            // Wrap cb in file closing code.
            const oldCb = cb;
            // Get file.
            this.open(fname, flag, 0x1a4, function (err, fd) {
                if (err) {
                    return cb(err);
                }
                cb = function (err, arg) {
                    fd.close(function (err2) {
                        if (!err) {
                            err = err2;
                        }
                        return oldCb(err, arg);
                    });
                };
                const fdCast = fd;
                const fdBuff = fdCast.getBuffer();
                if (encoding === null) {
                    cb(err, copyingSlice(fdBuff));
                }
                else {
                    tryToString(fdBuff, encoding, cb);
                }
            });
        }
        /**
         * Specially-optimized readfile.
         */
        readFileSync(fname, encoding, flag) {
            // Get file.
            const fd = this.openSync(fname, flag, 0x1a4);
            try {
                const fdCast = fd;
                const fdBuff = fdCast.getBuffer();
                if (encoding === null) {
                    return copyingSlice(fdBuff);
                }
                return fdBuff.toString(encoding);
            }
            finally {
                fd.closeSync();
            }
        }
        _getHTTPPath(filePath) {
            if (filePath.charAt(0) === '/') {
                filePath = filePath.slice(1);
            }
            return this.prefixUrl + filePath;
        }
        _requestFileAsync(p, type, cb) {
            this._requestFileAsyncInternal(this._getHTTPPath(p), type, cb);
        }
        _requestFileSync(p, type) {
            return this._requestFileSyncInternal(this._getHTTPPath(p), type);
        }
        /**
         * Only requests the HEAD content, for the file size.
         */
        _requestFileSizeAsync(path, cb) {
            this._requestFileSizeAsyncInternal(this._getHTTPPath(path), cb);
        }
        _requestFileSizeSync(path) {
            return this._requestFileSizeSyncInternal(this._getHTTPPath(path));
        }
    }
    HTTPRequest.Name = "HTTPRequest";
    HTTPRequest.Options = {
        index: {
            type: ["string", "object"],
            optional: true,
            description: "URL to a file index as a JSON file or the file index object itself, generated with the make_http_index script. Defaults to `index.json`."
        },
        baseUrl: {
            type: "string",
            optional: true,
            description: "Used as the URL prefix for fetched files. Default: Fetch files relative to the index."
        },
        preferXHR: {
            type: "boolean",
            optional: true,
            description: "Whether to prefer XmlHttpRequest or fetch for async operations if both are available. Default: false"
        }
    };

    return HTTPRequest;
});
define('skylark-browserfs/generic/extended_ascii',[],function () {
    'use strict';
    /**
     * (Nonstandard) String utility function for 8-bit ASCII with the extended
     * character set. Unlike the ASCII above, we do not mask the high bits.
     *
     * Placed into a separate file so it can be used with other Buffer implementations.
     * @see http://en.wikipedia.org/wiki/Extended_ASCII
     */
    class ExtendedASCII {
        static str2byte(str, buf) {
            const length = str.length > buf.length ? buf.length : str.length;
            for (let i = 0; i < length; i++) {
                let charCode = str.charCodeAt(i);
                if (charCode > 0x7F) {
                    // Check if extended ASCII.
                    const charIdx = ExtendedASCII.extendedChars.indexOf(str.charAt(i));
                    if (charIdx > -1) {
                        charCode = charIdx + 0x80;
                    }
                    // Otherwise, keep it as-is.
                }
                buf[charCode] = i;
            }
            return length;
        }
        static byte2str(buff) {
            const chars = new Array(buff.length);
            for (let i = 0; i < buff.length; i++) {
                const charCode = buff[i];
                if (charCode > 0x7F) {
                    chars[i] = ExtendedASCII.extendedChars[charCode - 128];
                }
                else {
                    chars[i] = String.fromCharCode(charCode);
                }
            }
            return chars.join('');
        }
        static byteLength(str) { return str.length; }
    }
    
    ExtendedASCII.extendedChars = ['\u00C7', '\u00FC', '\u00E9', '\u00E2', '\u00E4',
        '\u00E0', '\u00E5', '\u00E7', '\u00EA', '\u00EB', '\u00E8', '\u00EF',
        '\u00EE', '\u00EC', '\u00C4', '\u00C5', '\u00C9', '\u00E6', '\u00C6',
        '\u00F4', '\u00F6', '\u00F2', '\u00FB', '\u00F9', '\u00FF', '\u00D6',
        '\u00DC', '\u00F8', '\u00A3', '\u00D8', '\u00D7', '\u0192', '\u00E1',
        '\u00ED', '\u00F3', '\u00FA', '\u00F1', '\u00D1', '\u00AA', '\u00BA',
        '\u00BF', '\u00AE', '\u00AC', '\u00BD', '\u00BC', '\u00A1', '\u00AB',
        '\u00BB', '_', '_', '_', '\u00A6', '\u00A6', '\u00C1', '\u00C2', '\u00C0',
        '\u00A9', '\u00A6', '\u00A6', '+', '+', '\u00A2', '\u00A5', '+', '+', '-',
        '-', '+', '-', '+', '\u00E3', '\u00C3', '+', '+', '-', '-', '\u00A6', '-',
        '+', '\u00A4', '\u00F0', '\u00D0', '\u00CA', '\u00CB', '\u00C8', 'i',
        '\u00CD', '\u00CE', '\u00CF', '+', '+', '_', '_', '\u00A6', '\u00CC', '_',
        '\u00D3', '\u00DF', '\u00D4', '\u00D2', '\u00F5', '\u00D5', '\u00B5',
        '\u00FE', '\u00DE', '\u00DA', '\u00DB', '\u00D9', '\u00FD', '\u00DD',
        '\u00AF', '\u00B4', '\u00AD', '\u00B1', '_', '\u00BE', '\u00B6', '\u00A7',
        '\u00F7', '\u00B8', '\u00B0', '\u00A8', '\u00B7', '\u00B9', '\u00B3',
        '\u00B2', '_', ' '];

    return ExtendedASCII;
});
define('skylark-browserfs/backend/ZipFS',[
    '../core/api_error',
    '../core/node_fs_stats',
    '../core/file_system',
    '../core/file_flag',
    '../generic/preload_file',
    '../core/util',
    '../generic/extended_ascii',
    '../generic/setImmediate',
    '../generic/file_index'
], function (api_error,  node_fs_stats, file_system, file_flag, preload_file, util, ExtendedASCII, setImmediate, file_index) {
    'use strict';

    const { ApiError, ErrorCode }  = api_error;
    const { Stats, FileType }  = node_fs_stats;
    const { SynchronousFileSystem }  = file_system;
    const { ActionType }  = file_flag;
    const { NoSyncFile }  = preload_file;
    const { arrayish2Buffer, copyingSlice, bufferValidator }  = util;
    /**
     * @hidden
     */
    let inflateRaw;
    try {
        inflateRaw = require('pako/lib/inflate').inflateRaw;
    } catch (e) {
        console.warn(e);
    }
    const { FileIndex, DirInode, FileInode, isDirInode, isFileInode } = '../generic/file_index';
    /**
     * Maps CompressionMethod => function that decompresses.
     * @hidden
     */
    const decompressionMethods = {};
    /**
     * 4.4.2.2: Indicates the compatibiltiy of a file's external attributes.
     */
    var ExternalFileAttributeType;
    (function (ExternalFileAttributeType) {
        ExternalFileAttributeType[ExternalFileAttributeType["MSDOS"] = 0] = "MSDOS";
        ExternalFileAttributeType[ExternalFileAttributeType["AMIGA"] = 1] = "AMIGA";
        ExternalFileAttributeType[ExternalFileAttributeType["OPENVMS"] = 2] = "OPENVMS";
        ExternalFileAttributeType[ExternalFileAttributeType["UNIX"] = 3] = "UNIX";
        ExternalFileAttributeType[ExternalFileAttributeType["VM_CMS"] = 4] = "VM_CMS";
        ExternalFileAttributeType[ExternalFileAttributeType["ATARI_ST"] = 5] = "ATARI_ST";
        ExternalFileAttributeType[ExternalFileAttributeType["OS2_HPFS"] = 6] = "OS2_HPFS";
        ExternalFileAttributeType[ExternalFileAttributeType["MAC"] = 7] = "MAC";
        ExternalFileAttributeType[ExternalFileAttributeType["Z_SYSTEM"] = 8] = "Z_SYSTEM";
        ExternalFileAttributeType[ExternalFileAttributeType["CP_M"] = 9] = "CP_M";
        ExternalFileAttributeType[ExternalFileAttributeType["NTFS"] = 10] = "NTFS";
        ExternalFileAttributeType[ExternalFileAttributeType["MVS"] = 11] = "MVS";
        ExternalFileAttributeType[ExternalFileAttributeType["VSE"] = 12] = "VSE";
        ExternalFileAttributeType[ExternalFileAttributeType["ACORN_RISC"] = 13] = "ACORN_RISC";
        ExternalFileAttributeType[ExternalFileAttributeType["VFAT"] = 14] = "VFAT";
        ExternalFileAttributeType[ExternalFileAttributeType["ALT_MVS"] = 15] = "ALT_MVS";
        ExternalFileAttributeType[ExternalFileAttributeType["BEOS"] = 16] = "BEOS";
        ExternalFileAttributeType[ExternalFileAttributeType["TANDEM"] = 17] = "TANDEM";
        ExternalFileAttributeType[ExternalFileAttributeType["OS_400"] = 18] = "OS_400";
        ExternalFileAttributeType[ExternalFileAttributeType["OSX"] = 19] = "OSX";
    })(ExternalFileAttributeType || (ExternalFileAttributeType = {}));
    /**
     * 4.4.5
     */
    var CompressionMethod;
    (function (CompressionMethod) {
        CompressionMethod[CompressionMethod["STORED"] = 0] = "STORED";
        CompressionMethod[CompressionMethod["SHRUNK"] = 1] = "SHRUNK";
        CompressionMethod[CompressionMethod["REDUCED_1"] = 2] = "REDUCED_1";
        CompressionMethod[CompressionMethod["REDUCED_2"] = 3] = "REDUCED_2";
        CompressionMethod[CompressionMethod["REDUCED_3"] = 4] = "REDUCED_3";
        CompressionMethod[CompressionMethod["REDUCED_4"] = 5] = "REDUCED_4";
        CompressionMethod[CompressionMethod["IMPLODE"] = 6] = "IMPLODE";
        CompressionMethod[CompressionMethod["DEFLATE"] = 8] = "DEFLATE";
        CompressionMethod[CompressionMethod["DEFLATE64"] = 9] = "DEFLATE64";
        CompressionMethod[CompressionMethod["TERSE_OLD"] = 10] = "TERSE_OLD";
        CompressionMethod[CompressionMethod["BZIP2"] = 12] = "BZIP2";
        CompressionMethod[CompressionMethod["LZMA"] = 14] = "LZMA";
        CompressionMethod[CompressionMethod["TERSE_NEW"] = 18] = "TERSE_NEW";
        CompressionMethod[CompressionMethod["LZ77"] = 19] = "LZ77";
        CompressionMethod[CompressionMethod["WAVPACK"] = 97] = "WAVPACK";
        CompressionMethod[CompressionMethod["PPMD"] = 98] = "PPMD"; // PPMd version I, Rev 1
    })(CompressionMethod || (CompressionMethod = {}));
    /**
     * Converts the input time and date in MS-DOS format into a JavaScript Date
     * object.
     * @hidden
     */
    function msdos2date(time, date) {
        // MS-DOS Date
        // |0 0 0 0  0|0 0 0  0|0 0 0  0 0 0 0
        //   D (1-31)  M (1-23)  Y (from 1980)
        const day = date & 0x1F;
        // JS date is 0-indexed, DOS is 1-indexed.
        const month = ((date >> 5) & 0xF) - 1;
        const year = (date >> 9) + 1980;
        // MS DOS Time
        // |0 0 0 0  0|0 0 0  0 0 0|0  0 0 0 0
        //    Second      Minute       Hour
        const second = time & 0x1F;
        const minute = (time >> 5) & 0x3F;
        const hour = time >> 11;
        return new Date(year, month, day, hour, minute, second);
    }
    /**
     * Safely returns the string from the buffer, even if it is 0 bytes long.
     * (Normally, calling toString() on a buffer with start === end causes an
     * exception).
     * @hidden
     */
    function safeToString(buff, useUTF8, start, length) {
        if (length === 0) {
            return "";
        }
        else if (useUTF8) {
            return buff.toString('utf8', start, start + length);
        }
        else {
            return ExtendedASCII.byte2str(buff.slice(start, start + length));
        }
    }
    /*
       4.3.6 Overall .ZIP file format:

          [local file header 1]
          [encryption header 1]
          [file data 1]
          [data descriptor 1]
          .
          .
          .
          [local file header n]
          [encryption header n]
          [file data n]
          [data descriptor n]
          [archive decryption header]
          [archive extra data record]
          [central directory header 1]
          .
          .
          .
          [central directory header n]
          [zip64 end of central directory record]
          [zip64 end of central directory locator]
          [end of central directory record]
    */
    /**
     * 4.3.7  Local file header:
     *
     *     local file header signature     4 bytes  (0x04034b50)
     *     version needed to extract       2 bytes
     *     general purpose bit flag        2 bytes
     *     compression method              2 bytes
     *    last mod file time              2 bytes
     *    last mod file date              2 bytes
     *    crc-32                          4 bytes
     *    compressed size                 4 bytes
     *    uncompressed size               4 bytes
     *    file name length                2 bytes
     *    extra field length              2 bytes
     *
     *    file name (variable size)
     *    extra field (variable size)
     */
    class FileHeader {
        constructor(data) {
            this.data = data;
            if (data.readUInt32LE(0) !== 0x04034b50) {
                throw new ApiError(ErrorCode.EINVAL, "Invalid Zip file: Local file header has invalid signature: " + this.data.readUInt32LE(0));
            }
        }
        versionNeeded() { return this.data.readUInt16LE(4); }
        flags() { return this.data.readUInt16LE(6); }
        compressionMethod() { return this.data.readUInt16LE(8); }
        lastModFileTime() {
            // Time and date is in MS-DOS format.
            return msdos2date(this.data.readUInt16LE(10), this.data.readUInt16LE(12));
        }
        rawLastModFileTime() {
            return this.data.readUInt32LE(10);
        }
        crc32() { return this.data.readUInt32LE(14); }
        /**
         * These two values are COMPLETELY USELESS.
         *
         * Section 4.4.9:
         *   If bit 3 of the general purpose bit flag is set,
         *   these fields are set to zero in the local header and the
         *   correct values are put in the data descriptor and
         *   in the central directory.
         *
         * So we'll just use the central directory's values.
         */
        // public compressedSize(): number { return this.data.readUInt32LE(18); }
        // public uncompressedSize(): number { return this.data.readUInt32LE(22); }
        fileNameLength() { return this.data.readUInt16LE(26); }
        extraFieldLength() { return this.data.readUInt16LE(28); }
        fileName() {
            return safeToString(this.data, this.useUTF8(), 30, this.fileNameLength());
        }
        extraField() {
            const start = 30 + this.fileNameLength();
            return this.data.slice(start, start + this.extraFieldLength());
        }
        totalSize() { return 30 + this.fileNameLength() + this.extraFieldLength(); }
        useUTF8() { return (this.flags() & 0x800) === 0x800; }
    }
    /**
     * 4.3.8  File data
     *
     *   Immediately following the local header for a file
     *   SHOULD be placed the compressed or stored data for the file.
     *   If the file is encrypted, the encryption header for the file
     *   SHOULD be placed after the local header and before the file
     *   data. The series of [local file header][encryption header]
     *   [file data][data descriptor] repeats for each file in the
     *   .ZIP archive.
     *
     *   Zero-byte files, directories, and other file types that
     *   contain no content MUST not include file data.
     */
    class FileData {
        constructor(header, record, data) {
            this.header = header;
            this.record = record;
            this.data = data;
        }
        decompress() {
            // Check the compression
            const compressionMethod = this.header.compressionMethod();
            const fcn = decompressionMethods[compressionMethod];
            if (fcn) {
                return fcn(this.data, this.record.compressedSize(), this.record.uncompressedSize(), this.record.flag());
            }
            else {
                let name = CompressionMethod[compressionMethod];
                if (!name) {
                    name = `Unknown: ${compressionMethod}`;
                }
                throw new ApiError(ErrorCode.EINVAL, `Invalid compression method on file '${this.header.fileName()}': ${name}`);
            }
        }
        getHeader() {
            return this.header;
        }
        getRecord() {
            return this.record;
        }
        getRawData() {
            return this.data;
        }
    }
    /**
     * 4.3.9  Data descriptor:
     *
     *    crc-32                          4 bytes
     *    compressed size                 4 bytes
     *    uncompressed size               4 bytes
     */
    class DataDescriptor {
        constructor(data) {
            this.data = data;
        }
        crc32() { return this.data.readUInt32LE(0); }
        compressedSize() { return this.data.readUInt32LE(4); }
        uncompressedSize() { return this.data.readUInt32LE(8); }
    }
    /*
    ` 4.3.10  Archive decryption header:

          4.3.10.1 The Archive Decryption Header is introduced in version 6.2
          of the ZIP format specification.  This record exists in support
          of the Central Directory Encryption Feature implemented as part of
          the Strong Encryption Specification as described in this document.
          When the Central Directory Structure is encrypted, this decryption
          header MUST precede the encrypted data segment.
     */
    /**
     * 4.3.11  Archive extra data record:
     *
     *      archive extra data signature    4 bytes  (0x08064b50)
     *      extra field length              4 bytes
     *      extra field data                (variable size)
     *
     *    4.3.11.1 The Archive Extra Data Record is introduced in version 6.2
     *    of the ZIP format specification.  This record MAY be used in support
     *    of the Central Directory Encryption Feature implemented as part of
     *    the Strong Encryption Specification as described in this document.
     *    When present, this record MUST immediately precede the central
     *    directory data structure.
     */
    class ArchiveExtraDataRecord {
        constructor(data) {
            this.data = data;
            if (this.data.readUInt32LE(0) !== 0x08064b50) {
                throw new ApiError(ErrorCode.EINVAL, "Invalid archive extra data record signature: " + this.data.readUInt32LE(0));
            }
        }
        length() { return this.data.readUInt32LE(4); }
        extraFieldData() { return this.data.slice(8, 8 + this.length()); }
    }
    /**
     * 4.3.13 Digital signature:
     *
     *      header signature                4 bytes  (0x05054b50)
     *      size of data                    2 bytes
     *      signature data (variable size)
     *
     *    With the introduction of the Central Directory Encryption
     *    feature in version 6.2 of this specification, the Central
     *    Directory Structure MAY be stored both compressed and encrypted.
     *    Although not required, it is assumed when encrypting the
     *    Central Directory Structure, that it will be compressed
     *    for greater storage efficiency.  Information on the
     *    Central Directory Encryption feature can be found in the section
     *    describing the Strong Encryption Specification. The Digital
     *    Signature record will be neither compressed nor encrypted.
     */
    class DigitalSignature {
        constructor(data) {
            this.data = data;
            if (this.data.readUInt32LE(0) !== 0x05054b50) {
                throw new ApiError(ErrorCode.EINVAL, "Invalid digital signature signature: " + this.data.readUInt32LE(0));
            }
        }
        size() { return this.data.readUInt16LE(4); }
        signatureData() { return this.data.slice(6, 6 + this.size()); }
    }
    /**
     * 4.3.12  Central directory structure:
     *
     *  central file header signature   4 bytes  (0x02014b50)
     *  version made by                 2 bytes
     *  version needed to extract       2 bytes
     *  general purpose bit flag        2 bytes
     *  compression method              2 bytes
     *  last mod file time              2 bytes
     *  last mod file date              2 bytes
     *  crc-32                          4 bytes
     *  compressed size                 4 bytes
     *  uncompressed size               4 bytes
     *  file name length                2 bytes
     *  extra field length              2 bytes
     *  file comment length             2 bytes
     *  disk number start               2 bytes
     *  internal file attributes        2 bytes
     *  external file attributes        4 bytes
     *  relative offset of local header 4 bytes
     *
     *  file name (variable size)
     *  extra field (variable size)
     *  file comment (variable size)
     */
    class CentralDirectory {
        constructor(zipData, data) {
            this.zipData = zipData;
            this.data = data;
            // Sanity check.
            if (this.data.readUInt32LE(0) !== 0x02014b50) {
                throw new ApiError(ErrorCode.EINVAL, `Invalid Zip file: Central directory record has invalid signature: ${this.data.readUInt32LE(0)}`);
            }
            this._filename = this.produceFilename();
        }
        versionMadeBy() { return this.data.readUInt16LE(4); }
        versionNeeded() { return this.data.readUInt16LE(6); }
        flag() { return this.data.readUInt16LE(8); }
        compressionMethod() { return this.data.readUInt16LE(10); }
        lastModFileTime() {
            // Time and date is in MS-DOS format.
            return msdos2date(this.data.readUInt16LE(12), this.data.readUInt16LE(14));
        }
        rawLastModFileTime() {
            return this.data.readUInt32LE(12);
        }
        crc32() { return this.data.readUInt32LE(16); }
        compressedSize() { return this.data.readUInt32LE(20); }
        uncompressedSize() { return this.data.readUInt32LE(24); }
        fileNameLength() { return this.data.readUInt16LE(28); }
        extraFieldLength() { return this.data.readUInt16LE(30); }
        fileCommentLength() { return this.data.readUInt16LE(32); }
        diskNumberStart() { return this.data.readUInt16LE(34); }
        internalAttributes() { return this.data.readUInt16LE(36); }
        externalAttributes() { return this.data.readUInt32LE(38); }
        headerRelativeOffset() { return this.data.readUInt32LE(42); }
        produceFilename() {
            /*
              4.4.17.1 claims:
              * All slashes are forward ('/') slashes.
              * Filename doesn't begin with a slash.
              * No drive letters or any nonsense like that.
              * If filename is missing, the input came from standard input.
        
              Unfortunately, this isn't true in practice. Some Windows zip utilities use
              a backslash here, but the correct Unix-style path in file headers.
        
              To avoid seeking all over the file to recover the known-good filenames
              from file headers, we simply convert '/' to '\' here.
            */
            const fileName = safeToString(this.data, this.useUTF8(), 46, this.fileNameLength());
            return fileName.replace(/\\/g, "/");
        }
        fileName() {
            return this._filename;
        }
        rawFileName() {
            return this.data.slice(46, 46 + this.fileNameLength());
        }
        extraField() {
            const start = 44 + this.fileNameLength();
            return this.data.slice(start, start + this.extraFieldLength());
        }
        fileComment() {
            const start = 46 + this.fileNameLength() + this.extraFieldLength();
            return safeToString(this.data, this.useUTF8(), start, this.fileCommentLength());
        }
        rawFileComment() {
            const start = 46 + this.fileNameLength() + this.extraFieldLength();
            return this.data.slice(start, start + this.fileCommentLength());
        }
        totalSize() {
            return 46 + this.fileNameLength() + this.extraFieldLength() + this.fileCommentLength();
        }
        isDirectory() {
            // NOTE: This assumes that the zip file implementation uses the lower byte
            //       of external attributes for DOS attributes for
            //       backwards-compatibility. This is not mandated, but appears to be
            //       commonplace.
            //       According to the spec, the layout of external attributes is
            //       platform-dependent.
            //       If that fails, we also check if the name of the file ends in '/',
            //       which is what Java's ZipFile implementation does.
            const fileName = this.fileName();
            return (this.externalAttributes() & 0x10 ? true : false) || (fileName.charAt(fileName.length - 1) === '/');
        }
        isFile() { return !this.isDirectory(); }
        useUTF8() { return (this.flag() & 0x800) === 0x800; }
        isEncrypted() { return (this.flag() & 0x1) === 0x1; }
        getFileData() {
            // Need to grab the header before we can figure out where the actual
            // compressed data starts.
            const start = this.headerRelativeOffset();
            const header = new FileHeader(this.zipData.slice(start));
            return new FileData(header, this, this.zipData.slice(start + header.totalSize()));
        }
        getData() {
            return this.getFileData().decompress();
        }
        getRawData() {
            return this.getFileData().getRawData();
        }
        getStats() {
            return new Stats(FileType.FILE, this.uncompressedSize(), 0x16D, Date.now(), this.lastModFileTime().getTime());
        }
    }
    /**
     * 4.3.16: end of central directory record
     *  end of central dir signature    4 bytes  (0x06054b50)
     *  number of this disk             2 bytes
     *  number of the disk with the
     *  start of the central directory  2 bytes
     *  total number of entries in the
     *  central directory on this disk  2 bytes
     *  total number of entries in
     *  the central directory           2 bytes
     *  size of the central directory   4 bytes
     *  offset of start of central
     *  directory with respect to
     *  the starting disk number        4 bytes
     *  .ZIP file comment length        2 bytes
     *  .ZIP file comment       (variable size)
     */
    class EndOfCentralDirectory {
        constructor(data) {
            this.data = data;
            if (this.data.readUInt32LE(0) !== 0x06054b50) {
                throw new ApiError(ErrorCode.EINVAL, `Invalid Zip file: End of central directory record has invalid signature: ${this.data.readUInt32LE(0)}`);
            }
        }
        diskNumber() { return this.data.readUInt16LE(4); }
        cdDiskNumber() { return this.data.readUInt16LE(6); }
        cdDiskEntryCount() { return this.data.readUInt16LE(8); }
        cdTotalEntryCount() { return this.data.readUInt16LE(10); }
        cdSize() { return this.data.readUInt32LE(12); }
        cdOffset() { return this.data.readUInt32LE(16); }
        cdZipCommentLength() { return this.data.readUInt16LE(20); }
        cdZipComment() {
            // Assuming UTF-8. The specification doesn't specify.
            return safeToString(this.data, true, 22, this.cdZipCommentLength());
        }
        rawCdZipComment() {
            return this.data.slice(22, 22 + this.cdZipCommentLength());
        }
    }
    /**
     * Contains the table of contents of a Zip file.
     */
    class ZipTOC {
        constructor(index, directoryEntries, eocd, data) {
            this.index = index;
            this.directoryEntries = directoryEntries;
            this.eocd = eocd;
            this.data = data;
        }
    }
    /**
     * Zip file-backed filesystem
     * Implemented according to the standard:
     * http://www.pkware.com/documents/casestudies/APPNOTE.TXT
     *
     * While there are a few zip libraries for JavaScript (e.g. JSZip and zip.js),
     * they are not a good match for BrowserFS. In particular, these libraries
     * perform a lot of unneeded data copying, and eagerly decompress every file
     * in the zip file upon loading to check the CRC32. They also eagerly decode
     * strings. Furthermore, these libraries duplicate functionality already present
     * in BrowserFS (e.g. UTF-8 decoding and binary data manipulation).
     *
     * This filesystem takes advantage of BrowserFS's Buffer implementation, which
     * efficiently represents the zip file in memory (in both ArrayBuffer-enabled
     * browsers *and* non-ArrayBuffer browsers), and which can neatly be 'sliced'
     * without copying data. Each struct defined in the standard is represented with
     * a buffer slice pointing to an offset in the zip file, and has getters for
     * each field. As we anticipate that this data will not be read often, we choose
     * not to store each struct field in the JavaScript object; instead, to reduce
     * memory consumption, we retrieve it directly from the binary data each time it
     * is requested.
     *
     * When the filesystem is instantiated, we determine the directory structure
     * of the zip file as quickly as possible. We lazily decompress and check the
     * CRC32 of files. We do not cache decompressed files; if this is a desired
     * feature, it is best implemented as a generic file system wrapper that can
     * cache data from arbitrary file systems.
     *
     * For inflation, we use `pako`'s implementation:
     * https://github.com/nodeca/pako
     *
     * Current limitations:
     * * No encryption.
     * * No ZIP64 support.
     * * Read-only.
     *   Write support would require that we:
     *   - Keep track of changed/new files.
     *   - Compress changed files, and generate appropriate metadata for each.
     *   - Update file offsets for other files in the zip file.
     *   - Stream it out to a location.
     *   This isn't that bad, so we might do this at a later date.
     */
    class ZipFS extends SynchronousFileSystem {
        constructor(input, name = '') {
            super();
            this.name = name;
            this._index = new FileIndex();
            this._directoryEntries = [];
            this._eocd = null;
            this._index = input.index;
            this._directoryEntries = input.directoryEntries;
            this._eocd = input.eocd;
            this.data = input.data;
        }
        /**
         * Constructs a ZipFS instance with the given options.
         */
        static Create(opts, cb) {
            try {
                ZipFS._computeIndex(opts.zipData, (e, zipTOC) => {
                    if (zipTOC) {
                        const fs = new ZipFS(zipTOC, opts.name);
                        cb(null, fs);
                    }
                    else {
                        cb(e);
                    }
                });
            }
            catch (e) {
                cb(e);
            }
        }
        static isAvailable() { return true; }
        static RegisterDecompressionMethod(m, fcn) {
            decompressionMethods[m] = fcn;
        }
        /**
         * Locates the end of central directory record at the end of the file.
         * Throws an exception if it cannot be found.
         */
        static _getEOCD(data) {
            // Unfortunately, the comment is variable size and up to 64K in size.
            // We assume that the magic signature does not appear in the comment, and
            // in the bytes between the comment and the signature. Other ZIP
            // implementations make this same assumption, since the alternative is to
            // read thread every entry in the file to get to it. :(
            // These are *negative* offsets from the end of the file.
            const startOffset = 22;
            const endOffset = Math.min(startOffset + 0xFFFF, data.length - 1);
            // There's not even a byte alignment guarantee on the comment so we need to
            // search byte by byte. *grumble grumble*
            for (let i = startOffset; i < endOffset; i++) {
                // Magic number: EOCD Signature
                if (data.readUInt32LE(data.length - i) === 0x06054b50) {
                    return new EndOfCentralDirectory(data.slice(data.length - i));
                }
            }
            throw new ApiError(ErrorCode.EINVAL, "Invalid ZIP file: Could not locate End of Central Directory signature.");
        }
        static _addToIndex(cd, index) {
            // Paths must be absolute, yet zip file paths are always relative to the
            // zip root. So we append '/' and call it a day.
            let filename = cd.fileName();
            if (filename.charAt(0) === '/') {
                throw new ApiError(ErrorCode.EPERM, `Unexpectedly encountered an absolute path in a zip file. Please file a bug.`);
            }
            // XXX: For the file index, strip the trailing '/'.
            if (filename.charAt(filename.length - 1) === '/') {
                filename = filename.substr(0, filename.length - 1);
            }
            if (cd.isDirectory()) {
                index.addPathFast('/' + filename, new DirInode(cd));
            }
            else {
                index.addPathFast('/' + filename, new FileInode(cd));
            }
        }
        static _computeIndex(data, cb) {
            try {
                const index = new FileIndex();
                const eocd = ZipFS._getEOCD(data);
                if (eocd.diskNumber() !== eocd.cdDiskNumber()) {
                    return cb(new ApiError(ErrorCode.EINVAL, "ZipFS does not support spanned zip files."));
                }
                const cdPtr = eocd.cdOffset();
                if (cdPtr === 0xFFFFFFFF) {
                    return cb(new ApiError(ErrorCode.EINVAL, "ZipFS does not support Zip64."));
                }
                const cdEnd = cdPtr + eocd.cdSize();
                ZipFS._computeIndexResponsive(data, index, cdPtr, cdEnd, cb, [], eocd);
            }
            catch (e) {
                cb(e);
            }
        }
        static _computeIndexResponsiveTrampoline(data, index, cdPtr, cdEnd, cb, cdEntries, eocd) {
            try {
                ZipFS._computeIndexResponsive(data, index, cdPtr, cdEnd, cb, cdEntries, eocd);
            }
            catch (e) {
                cb(e);
            }
        }
        static _computeIndexResponsive(data, index, cdPtr, cdEnd, cb, cdEntries, eocd) {
            if (cdPtr < cdEnd) {
                let count = 0;
                while (count++ < 200 && cdPtr < cdEnd) {
                    const cd = new CentralDirectory(data, data.slice(cdPtr));
                    ZipFS._addToIndex(cd, index);
                    cdPtr += cd.totalSize();
                    cdEntries.push(cd);
                }
                setImmediate(() => {
                    ZipFS._computeIndexResponsiveTrampoline(data, index, cdPtr, cdEnd, cb, cdEntries, eocd);
                });
            }
            else {
                cb(null, new ZipTOC(index, cdEntries, eocd, data));
            }
        }
        getName() {
            return ZipFS.Name + (this.name !== '' ? ` ${this.name}` : '');
        }
        /**
         * Get the CentralDirectory object for the given path.
         */
        getCentralDirectoryEntry(path) {
            const inode = this._index.getInode(path);
            if (inode === null) {
                throw ApiError.ENOENT(path);
            }
            if (isFileInode(inode)) {
                return inode.getData();
            }
            else if (isDirInode(inode)) {
                return inode.getData();
            }
            else {
                // Should never occur.
                throw ApiError.EPERM(`Invalid inode: ${inode}`);
            }
        }
        getCentralDirectoryEntryAt(index) {
            const dirEntry = this._directoryEntries[index];
            if (!dirEntry) {
                throw new RangeError(`Invalid directory index: ${index}.`);
            }
            return dirEntry;
        }
        getNumberOfCentralDirectoryEntries() {
            return this._directoryEntries.length;
        }
        getEndOfCentralDirectory() {
            return this._eocd;
        }
        diskSpace(path, cb) {
            // Read-only file system.
            cb(this.data.length, 0);
        }
        isReadOnly() {
            return true;
        }
        supportsLinks() {
            return false;
        }
        supportsProps() {
            return false;
        }
        supportsSynch() {
            return true;
        }
        statSync(path, isLstat) {
            const inode = this._index.getInode(path);
            if (inode === null) {
                throw ApiError.ENOENT(path);
            }
            let stats;
            if (isFileInode(inode)) {
                stats = inode.getData().getStats();
            }
            else if (isDirInode(inode)) {
                stats = inode.getStats();
            }
            else {
                throw new ApiError(ErrorCode.EINVAL, "Invalid inode.");
            }
            return stats;
        }
        openSync(path, flags, mode) {
            // INVARIANT: Cannot write to RO file systems.
            if (flags.isWriteable()) {
                throw new ApiError(ErrorCode.EPERM, path);
            }
            // Check if the path exists, and is a file.
            const inode = this._index.getInode(path);
            if (!inode) {
                throw ApiError.ENOENT(path);
            }
            else if (isFileInode(inode)) {
                const cdRecord = inode.getData();
                const stats = cdRecord.getStats();
                switch (flags.pathExistsAction()) {
                    case ActionType.THROW_EXCEPTION:
                    case ActionType.TRUNCATE_FILE:
                        throw ApiError.EEXIST(path);
                    case ActionType.NOP:
                        return new NoSyncFile(this, path, flags, stats, cdRecord.getData());
                    default:
                        throw new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.');
                }
            }
            else {
                throw ApiError.EISDIR(path);
            }
        }
        readdirSync(path) {
            // Check if it exists.
            const inode = this._index.getInode(path);
            if (!inode) {
                throw ApiError.ENOENT(path);
            }
            else if (isDirInode(inode)) {
                return inode.getListing();
            }
            else {
                throw ApiError.ENOTDIR(path);
            }
        }
        /**
         * Specially-optimized readfile.
         */
        readFileSync(fname, encoding, flag) {
            // Get file.
            const fd = this.openSync(fname, flag, 0x1a4);
            try {
                const fdCast = fd;
                const fdBuff = fdCast.getBuffer();
                if (encoding === null) {
                    return copyingSlice(fdBuff);
                }
                return fdBuff.toString(encoding);
            }
            finally {
                fd.closeSync();
            }
        }
    }
    ZipFS.Name = "ZipFS";
    ZipFS.Options = {
        zipData: {
            type: "object",
            description: "The zip file as a Buffer object.",
            validator: bufferValidator
        },
        name: {
            type: "string",
            optional: true,
            description: "The name of the zip file (optional)."
        }
    };
    ZipFS.CompressionMethod = CompressionMethod;
    ZipFS.RegisterDecompressionMethod(CompressionMethod.DEFLATE, (data, compressedSize, uncompressedSize) => {
        return arrayish2Buffer(inflateRaw(data.slice(0, compressedSize), { chunkSize: uncompressedSize }));
    });
    ZipFS.RegisterDecompressionMethod(CompressionMethod.STORED, (data, compressedSize, uncompressedSize) => {
        return copyingSlice(data, 0, uncompressedSize);
    });

    return ZipFS;

});
define('skylark-browserfs/backend/IsoFS',[
    '../core/api_error',
    '../core/node_fs_stats',
    '../core/file_system',
    '../core/file_flag',
    '../generic/preload_file',
    '../core/util',
    '../libs/path'
], function (api_error,  node_fs_stats,file_system, file_flag, preload_file, util, path) {
    'use strict';

    const { ApiError, ErrorCode } = api_error;
    const { Stats, FileType }  = node_fs_stats;
    const { SynchronousFileSystem }  = file_system;
    const { ActionType }  = file_flag;
    const { NoSyncFile }  = preload_file;
    const { copyingSlice, bufferValidator }  = util;

    /**
     * @hidden
     */
    const rockRidgeIdentifier = "IEEE_P1282";
    /**
     * @hidden
     */
    function getASCIIString(data, startIndex, length) {
        return data.toString('ascii', startIndex, startIndex + length).trim();
    }
    /**
     * @hidden
     */
    function getJolietString(data, startIndex, length) {
        if (length === 1) {
            // Special: Root, parent, current directory are still a single byte.
            return String.fromCharCode(data[startIndex]);
        }
        // UTF16-BE, which isn't natively supported by NodeJS Buffers.
        // Length should be even, but pessimistically floor just in case.
        const pairs = Math.floor(length / 2);
        const chars = new Array(pairs);
        for (let i = 0; i < pairs; i++) {
            const pos = startIndex + (i << 1);
            chars[i] = String.fromCharCode(data[pos + 1] | (data[pos] << 8));
        }
        return chars.join('');
    }
    /**
     * @hidden
     */
    function getDate(data, startIndex) {
        const year = parseInt(getASCIIString(data, startIndex, 4), 10);
        const mon = parseInt(getASCIIString(data, startIndex + 4, 2), 10);
        const day = parseInt(getASCIIString(data, startIndex + 6, 2), 10);
        const hour = parseInt(getASCIIString(data, startIndex + 8, 2), 10);
        const min = parseInt(getASCIIString(data, startIndex + 10, 2), 10);
        const sec = parseInt(getASCIIString(data, startIndex + 12, 2), 10);
        const hundrethsSec = parseInt(getASCIIString(data, startIndex + 14, 2), 10);
        // Last is a time-zone offset, but JavaScript dates don't support time zones well.
        return new Date(year, mon, day, hour, min, sec, hundrethsSec * 100);
    }
    /**
     * @hidden
     */
    function getShortFormDate(data, startIndex) {
        const yearsSince1900 = data[startIndex];
        const month = data[startIndex + 1];
        const day = data[startIndex + 2];
        const hour = data[startIndex + 3];
        const minute = data[startIndex + 4];
        const second = data[startIndex + 5];
        // JavaScript's Date support isn't so great; ignore timezone.
        // const offsetFromGMT = this._data[24];
        return new Date(yearsSince1900, month - 1, day, hour, minute, second);
    }
    /**
     * @hidden
     */
    function constructSystemUseEntry(bigData, i) {
        const data = bigData.slice(i);
        const sue = new SystemUseEntry(data);
        switch (sue.signatureWord()) {
            case 17221 /* CE */:
                return new CEEntry(data);
            case 20548 /* PD */:
                return new PDEntry(data);
            case 21328 /* SP */:
                return new SPEntry(data);
            case 21332 /* ST */:
                return new STEntry(data);
            case 17746 /* ER */:
                return new EREntry(data);
            case 17747 /* ES */:
                return new ESEntry(data);
            case 20568 /* PX */:
                return new PXEntry(data);
            case 20558 /* PN */:
                return new PNEntry(data);
            case 21324 /* SL */:
                return new SLEntry(data);
            case 20045 /* NM */:
                return new NMEntry(data);
            case 17228 /* CL */:
                return new CLEntry(data);
            case 20556 /* PL */:
                return new PLEntry(data);
            case 21061 /* RE */:
                return new REEntry(data);
            case 21574 /* TF */:
                return new TFEntry(data);
            case 21318 /* SF */:
                return new SFEntry(data);
            case 21074 /* RR */:
                return new RREntry(data);
            default:
                return sue;
        }
    }
    /**
     * @hidden
     */
    function constructSystemUseEntries(data, i, len, isoData) {
        // If the remaining allocated space following the last recorded System Use Entry in a System
        // Use field or Continuation Area is less than four bytes long, it cannot contain a System
        // Use Entry and shall be ignored
        len = len - 4;
        let entries = new Array();
        while (i < len) {
            const entry = constructSystemUseEntry(data, i);
            const length = entry.length();
            if (length === 0) {
                // Invalid SU section; prevent infinite loop.
                return entries;
            }
            i += length;
            if (entry instanceof STEntry) {
                // ST indicates the end of entries.
                break;
            }
            if (entry instanceof CEEntry) {
                entries = entries.concat(entry.getEntries(isoData));
            }
            else {
                entries.push(entry);
            }
        }
        return entries;
    }
    /**
     * @hidden
     */
    class VolumeDescriptor {
        constructor(data) {
            this._data = data;
        }
        type() {
            return this._data[0];
        }
        standardIdentifier() {
            return getASCIIString(this._data, 1, 5);
        }
        version() {
            return this._data[6];
        }
        data() {
            return this._data.slice(7, 2048);
        }
    }
    /**
     * @hidden
     */
    class PrimaryOrSupplementaryVolumeDescriptor extends VolumeDescriptor {
        constructor(data) {
            super(data);
            this._root = null;
        }
        systemIdentifier() {
            return this._getString32(8);
        }
        volumeIdentifier() {
            return this._getString32(40);
        }
        volumeSpaceSize() {
            return this._data.readUInt32LE(80);
        }
        volumeSetSize() {
            return this._data.readUInt16LE(120);
        }
        volumeSequenceNumber() {
            return this._data.readUInt16LE(124);
        }
        logicalBlockSize() {
            return this._data.readUInt16LE(128);
        }
        pathTableSize() {
            return this._data.readUInt32LE(132);
        }
        locationOfTypeLPathTable() {
            return this._data.readUInt32LE(140);
        }
        locationOfOptionalTypeLPathTable() {
            return this._data.readUInt32LE(144);
        }
        locationOfTypeMPathTable() {
            return this._data.readUInt32BE(148);
        }
        locationOfOptionalTypeMPathTable() {
            return this._data.readUInt32BE(152);
        }
        rootDirectoryEntry(isoData) {
            if (this._root === null) {
                this._root = this._constructRootDirectoryRecord(this._data.slice(156));
                this._root.rootCheckForRockRidge(isoData);
            }
            return this._root;
        }
        volumeSetIdentifier() {
            return this._getString(190, 128);
        }
        publisherIdentifier() {
            return this._getString(318, 128);
        }
        dataPreparerIdentifier() {
            return this._getString(446, 128);
        }
        applicationIdentifier() {
            return this._getString(574, 128);
        }
        copyrightFileIdentifier() {
            return this._getString(702, 38);
        }
        abstractFileIdentifier() {
            return this._getString(740, 36);
        }
        bibliographicFileIdentifier() {
            return this._getString(776, 37);
        }
        volumeCreationDate() {
            return getDate(this._data, 813);
        }
        volumeModificationDate() {
            return getDate(this._data, 830);
        }
        volumeExpirationDate() {
            return getDate(this._data, 847);
        }
        volumeEffectiveDate() {
            return getDate(this._data, 864);
        }
        fileStructureVersion() {
            return this._data[881];
        }
        applicationUsed() {
            return this._data.slice(883, 883 + 512);
        }
        reserved() {
            return this._data.slice(1395, 1395 + 653);
        }
        _getString32(idx) {
            return this._getString(idx, 32);
        }
    }
    /**
     * @hidden
     */
    class PrimaryVolumeDescriptor extends PrimaryOrSupplementaryVolumeDescriptor {
        constructor(data) {
            super(data);
            if (this.type() !== 1 /* PrimaryVolumeDescriptor */) {
                throw new ApiError(ErrorCode.EIO, `Invalid primary volume descriptor.`);
            }
        }
        name() {
            return "ISO9660";
        }
        _constructRootDirectoryRecord(data) {
            return new ISODirectoryRecord(data, -1);
        }
        _getString(idx, len) {
            return this._getString(idx, len);
        }
    }
    /**
     * @hidden
     */
    class SupplementaryVolumeDescriptor extends PrimaryOrSupplementaryVolumeDescriptor {
        constructor(data) {
            super(data);
            if (this.type() !== 2 /* SupplementaryVolumeDescriptor */) {
                throw new ApiError(ErrorCode.EIO, `Invalid supplementary volume descriptor.`);
            }
            const escapeSequence = this.escapeSequence();
            const third = escapeSequence[2];
            // Third character identifies what 'level' of the UCS specification to follow.
            // We ignore it.
            if (escapeSequence[0] !== 0x25 || escapeSequence[1] !== 0x2F ||
                (third !== 0x40 && third !== 0x43 && third !== 0x45)) {
                throw new ApiError(ErrorCode.EIO, `Unrecognized escape sequence for SupplementaryVolumeDescriptor: ${escapeSequence.toString()}`);
            }
        }
        name() {
            return "Joliet";
        }
        escapeSequence() {
            return this._data.slice(88, 120);
        }
        _constructRootDirectoryRecord(data) {
            return new JolietDirectoryRecord(data, -1);
        }
        _getString(idx, len) {
            return getJolietString(this._data, idx, len);
        }
    }
    /**
     * @hidden
     */
    class DirectoryRecord {
        constructor(data, rockRidgeOffset) {
            this._suEntries = null;
            this._fileOrDir = null;
            this._data = data;
            this._rockRidgeOffset = rockRidgeOffset;
        }
        hasRockRidge() {
            return this._rockRidgeOffset > -1;
        }
        getRockRidgeOffset() {
            return this._rockRidgeOffset;
        }
        /**
         * !!ONLY VALID ON ROOT NODE!!
         * Checks if Rock Ridge is enabled, and sets the offset.
         */
        rootCheckForRockRidge(isoData) {
            const dir = this.getDirectory(isoData);
            this._rockRidgeOffset = dir.getDotEntry(isoData)._getRockRidgeOffset(isoData);
            if (this._rockRidgeOffset > -1) {
                // Wipe out directory. Start over with RR knowledge.
                this._fileOrDir = null;
            }
        }
        length() {
            return this._data[0];
        }
        extendedAttributeRecordLength() {
            return this._data[1];
        }
        lba() {
            return this._data.readUInt32LE(2) * 2048;
        }
        dataLength() {
            return this._data.readUInt32LE(10);
        }
        recordingDate() {
            return getShortFormDate(this._data, 18);
        }
        fileFlags() {
            return this._data[25];
        }
        fileUnitSize() {
            return this._data[26];
        }
        interleaveGapSize() {
            return this._data[27];
        }
        volumeSequenceNumber() {
            return this._data.readUInt16LE(28);
        }
        identifier() {
            return this._getString(33, this._data[32]);
        }
        fileName(isoData) {
            if (this.hasRockRidge()) {
                const fn = this._rockRidgeFilename(isoData);
                if (fn !== null) {
                    return fn;
                }
            }
            const ident = this.identifier();
            if (this.isDirectory(isoData)) {
                return ident;
            }
            // Files:
            // - MUST have 0x2E (.) separating the name from the extension
            // - MUST have 0x3B (;) separating the file name and extension from the version
            // Gets expanded to two-byte char in Unicode directory records.
            const versionSeparator = ident.indexOf(';');
            if (versionSeparator === -1) {
                // Some Joliet filenames lack the version separator, despite the standard
                // specifying that it should be there.
                return ident;
            }
            else if (ident[versionSeparator - 1] === '.') {
                // Empty extension. Do not include '.' in the filename.
                return ident.slice(0, versionSeparator - 1);
            }
            else {
                // Include up to version separator.
                return ident.slice(0, versionSeparator);
            }
        }
        isDirectory(isoData) {
            let rv = !!(this.fileFlags() & 2 /* Directory */);
            // If it lacks the Directory flag, it may still be a directory if we've exceeded the directory
            // depth limit. Rock Ridge marks these as files and adds a special attribute.
            if (!rv && this.hasRockRidge()) {
                rv = this.getSUEntries(isoData).filter((e) => e instanceof CLEntry).length > 0;
            }
            return rv;
        }
        isSymlink(isoData) {
            return this.hasRockRidge() && this.getSUEntries(isoData).filter((e) => e instanceof SLEntry).length > 0;
        }
        getSymlinkPath(isoData) {
            let p = "";
            const entries = this.getSUEntries(isoData);
            const getStr = this._getGetString();
            for (const entry of entries) {
                if (entry instanceof SLEntry) {
                    const components = entry.componentRecords();
                    for (const component of components) {
                        const flags = component.flags();
                        if (flags & 2 /* CURRENT */) {
                            p += "./";
                        }
                        else if (flags & 4 /* PARENT */) {
                            p += "../";
                        }
                        else if (flags & 8 /* ROOT */) {
                            p += "/";
                        }
                        else {
                            p += component.content(getStr);
                            if (!(flags & 1 /* CONTINUE */)) {
                                p += '/';
                            }
                        }
                    }
                    if (!entry.continueFlag()) {
                        // We are done with this link.
                        break;
                    }
                }
            }
            if (p.length > 1 && p[p.length - 1] === '/') {
                // Trim trailing '/'.
                return p.slice(0, p.length - 1);
            }
            else {
                return p;
            }
        }
        getFile(isoData) {
            if (this.isDirectory(isoData)) {
                throw new Error(`Tried to get a File from a directory.`);
            }
            if (this._fileOrDir === null) {
                this._fileOrDir = isoData.slice(this.lba(), this.lba() + this.dataLength());
            }
            return this._fileOrDir;
        }
        getDirectory(isoData) {
            if (!this.isDirectory(isoData)) {
                throw new Error(`Tried to get a Directory from a file.`);
            }
            if (this._fileOrDir === null) {
                this._fileOrDir = this._constructDirectory(isoData);
            }
            return this._fileOrDir;
        }
        getSUEntries(isoData) {
            if (!this._suEntries) {
                this._constructSUEntries(isoData);
            }
            return this._suEntries;
        }
        _rockRidgeFilename(isoData) {
            const nmEntries = this.getSUEntries(isoData).filter((e) => e instanceof NMEntry);
            if (nmEntries.length === 0 || nmEntries[0].flags() & (2 /* CURRENT */ | 4 /* PARENT */)) {
                return null;
            }
            let str = '';
            const getString = this._getGetString();
            for (const e of nmEntries) {
                str += e.name(getString);
                if (!(e.flags() & 1 /* CONTINUE */)) {
                    break;
                }
            }
            return str;
        }
        _constructSUEntries(isoData) {
            let i = 33 + this._data[32];
            if (i % 2 === 1) {
                // Skip padding field.
                i++;
            }
            i += this._rockRidgeOffset;
            this._suEntries = constructSystemUseEntries(this._data, i, this.length(), isoData);
        }
        /**
         * !!ONLY VALID ON FIRST ENTRY OF ROOT DIRECTORY!!
         * Returns -1 if rock ridge is not enabled. Otherwise, returns the offset
         * at which system use fields begin.
         */
        _getRockRidgeOffset(isoData) {
            // In the worst case, we get some garbage SU entries.
            // Fudge offset to 0 before proceeding.
            this._rockRidgeOffset = 0;
            const suEntries = this.getSUEntries(isoData);
            if (suEntries.length > 0) {
                const spEntry = suEntries[0];
                if (spEntry instanceof SPEntry && spEntry.checkBytesPass()) {
                    // SUSP is in use.
                    for (let i = 1; i < suEntries.length; i++) {
                        const entry = suEntries[i];
                        if (entry instanceof RREntry || (entry instanceof EREntry && entry.extensionIdentifier() === rockRidgeIdentifier)) {
                            // Rock Ridge is in use!
                            return spEntry.bytesSkipped();
                        }
                    }
                }
            }
            // Failed.
            this._rockRidgeOffset = -1;
            return -1;
        }
    }
    /**
     * @hidden
     */
    class ISODirectoryRecord extends DirectoryRecord {
        constructor(data, rockRidgeOffset) {
            super(data, rockRidgeOffset);
        }
        _getString(i, len) {
            return getASCIIString(this._data, i, len);
        }
        _constructDirectory(isoData) {
            return new ISODirectory(this, isoData);
        }
        _getGetString() {
            return getASCIIString;
        }
    }
    /**
     * @hidden
     */
    class JolietDirectoryRecord extends DirectoryRecord {
        constructor(data, rockRidgeOffset) {
            super(data, rockRidgeOffset);
        }
        _getString(i, len) {
            return getJolietString(this._data, i, len);
        }
        _constructDirectory(isoData) {
            return new JolietDirectory(this, isoData);
        }
        _getGetString() {
            return getJolietString;
        }
    }
    /**
     * @hidden
     */
    class SystemUseEntry {
        constructor(data) {
            this._data = data;
        }
        signatureWord() {
            return this._data.readUInt16BE(0);
        }
        signatureWordString() {
            return getASCIIString(this._data, 0, 2);
        }
        length() {
            return this._data[2];
        }
        suVersion() {
            return this._data[3];
        }
    }
    /**
     * Continuation entry.
     * @hidden
     */
    class CEEntry extends SystemUseEntry {
        constructor(data) {
            super(data);
            this._entries = null;
        }
        /**
         * Logical block address of the continuation area.
         */
        continuationLba() {
            return this._data.readUInt32LE(4);
        }
        /**
         * Offset into the logical block.
         */
        continuationLbaOffset() {
            return this._data.readUInt32LE(12);
        }
        /**
         * Length of the continuation area.
         */
        continuationLength() {
            return this._data.readUInt32LE(20);
        }
        getEntries(isoData) {
            if (!this._entries) {
                const start = this.continuationLba() * 2048 + this.continuationLbaOffset();
                this._entries = constructSystemUseEntries(isoData, start, this.continuationLength(), isoData);
            }
            return this._entries;
        }
    }
    /**
     * Padding entry.
     * @hidden
     */
    class PDEntry extends SystemUseEntry {
        constructor(data) {
            super(data);
        }
    }
    /**
     * Identifies that SUSP is in-use.
     * @hidden
     */
    class SPEntry extends SystemUseEntry {
        constructor(data) {
            super(data);
        }
        checkBytesPass() {
            return this._data[4] === 0xBE && this._data[5] === 0xEF;
        }
        bytesSkipped() {
            return this._data[6];
        }
    }
    /**
     * Identifies the end of the SUSP entries.
     * @hidden
     */
    class STEntry extends SystemUseEntry {
        constructor(data) {
            super(data);
        }
    }
    /**
     * Specifies system-specific extensions to SUSP.
     * @hidden
     */
    class EREntry extends SystemUseEntry {
        constructor(data) {
            super(data);
        }
        identifierLength() {
            return this._data[4];
        }
        descriptorLength() {
            return this._data[5];
        }
        sourceLength() {
            return this._data[6];
        }
        extensionVersion() {
            return this._data[7];
        }
        extensionIdentifier() {
            return getASCIIString(this._data, 8, this.identifierLength());
        }
        extensionDescriptor() {
            return getASCIIString(this._data, 8 + this.identifierLength(), this.descriptorLength());
        }
        extensionSource() {
            return getASCIIString(this._data, 8 + this.identifierLength() + this.descriptorLength(), this.sourceLength());
        }
    }
    /**
     * @hidden
     */
    class ESEntry extends SystemUseEntry {
        constructor(data) {
            super(data);
        }
        extensionSequence() {
            return this._data[4];
        }
    }
    /**
     * RockRidge: Marks that RockRidge is in use [deprecated]
     * @hidden
     */
    class RREntry extends SystemUseEntry {
        constructor(data) {
            super(data);
        }
    }
    /**
     * RockRidge: Records POSIX file attributes.
     * @hidden
     */
    class PXEntry extends SystemUseEntry {
        constructor(data) {
            super(data);
        }
        mode() {
            return this._data.readUInt32LE(4);
        }
        fileLinks() {
            return this._data.readUInt32LE(12);
        }
        uid() {
            return this._data.readUInt32LE(20);
        }
        gid() {
            return this._data.readUInt32LE(28);
        }
        inode() {
            return this._data.readUInt32LE(36);
        }
    }
    /**
     * RockRidge: Records POSIX device number.
     * @hidden
     */
    class PNEntry extends SystemUseEntry {
        constructor(data) {
            super(data);
        }
        devTHigh() {
            return this._data.readUInt32LE(4);
        }
        devTLow() {
            return this._data.readUInt32LE(12);
        }
    }
    /**
     * RockRidge: Records symbolic link
     * @hidden
     */
    class SLEntry extends SystemUseEntry {
        constructor(data) {
            super(data);
        }
        flags() {
            return this._data[4];
        }
        continueFlag() {
            return this.flags() & 0x1;
        }
        componentRecords() {
            const records = new Array();
            let i = 5;
            while (i < this.length()) {
                const record = new SLComponentRecord(this._data.slice(i));
                records.push(record);
                i += record.length();
            }
            return records;
        }
    }
    /**
     * @hidden
     */
    class SLComponentRecord {
        constructor(data) {
            this._data = data;
        }
        flags() {
            return this._data[0];
        }
        length() {
            return 2 + this.componentLength();
        }
        componentLength() {
            return this._data[1];
        }
        content(getString) {
            return getString(this._data, 2, this.componentLength());
        }
    }
    /**
     * RockRidge: Records alternate file name
     * @hidden
     */
    class NMEntry extends SystemUseEntry {
        constructor(data) {
            super(data);
        }
        flags() {
            return this._data[4];
        }
        name(getString) {
            return getString(this._data, 5, this.length() - 5);
        }
    }
    /**
     * RockRidge: Records child link
     * @hidden
     */
    class CLEntry extends SystemUseEntry {
        constructor(data) {
            super(data);
        }
        childDirectoryLba() {
            return this._data.readUInt32LE(4);
        }
    }
    /**
     * RockRidge: Records parent link.
     * @hidden
     */
    class PLEntry extends SystemUseEntry {
        constructor(data) {
            super(data);
        }
        parentDirectoryLba() {
            return this._data.readUInt32LE(4);
        }
    }
    /**
     * RockRidge: Records relocated directory.
     * @hidden
     */
    class REEntry extends SystemUseEntry {
        constructor(data) {
            super(data);
        }
    }
    /**
     * RockRidge: Records file timestamps
     * @hidden
     */
    class TFEntry extends SystemUseEntry {
        constructor(data) {
            super(data);
        }
        flags() {
            return this._data[4];
        }
        creation() {
            if (this.flags() & 1 /* CREATION */) {
                if (this._longFormDates()) {
                    return getDate(this._data, 5);
                }
                else {
                    return getShortFormDate(this._data, 5);
                }
            }
            else {
                return null;
            }
        }
        modify() {
            if (this.flags() & 2 /* MODIFY */) {
                const previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;
                if (this._longFormDates) {
                    return getDate(this._data, 5 + (previousDates * 17));
                }
                else {
                    return getShortFormDate(this._data, 5 + (previousDates * 7));
                }
            }
            else {
                return null;
            }
        }
        access() {
            if (this.flags() & 4 /* ACCESS */) {
                let previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;
                previousDates += (this.flags() & 2 /* MODIFY */) ? 1 : 0;
                if (this._longFormDates) {
                    return getDate(this._data, 5 + (previousDates * 17));
                }
                else {
                    return getShortFormDate(this._data, 5 + (previousDates * 7));
                }
            }
            else {
                return null;
            }
        }
        backup() {
            if (this.flags() & 16 /* BACKUP */) {
                let previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;
                previousDates += (this.flags() & 2 /* MODIFY */) ? 1 : 0;
                previousDates += (this.flags() & 4 /* ACCESS */) ? 1 : 0;
                if (this._longFormDates) {
                    return getDate(this._data, 5 + (previousDates * 17));
                }
                else {
                    return getShortFormDate(this._data, 5 + (previousDates * 7));
                }
            }
            else {
                return null;
            }
        }
        expiration() {
            if (this.flags() & 32 /* EXPIRATION */) {
                let previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;
                previousDates += (this.flags() & 2 /* MODIFY */) ? 1 : 0;
                previousDates += (this.flags() & 4 /* ACCESS */) ? 1 : 0;
                previousDates += (this.flags() & 16 /* BACKUP */) ? 1 : 0;
                if (this._longFormDates) {
                    return getDate(this._data, 5 + (previousDates * 17));
                }
                else {
                    return getShortFormDate(this._data, 5 + (previousDates * 7));
                }
            }
            else {
                return null;
            }
        }
        effective() {
            if (this.flags() & 64 /* EFFECTIVE */) {
                let previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;
                previousDates += (this.flags() & 2 /* MODIFY */) ? 1 : 0;
                previousDates += (this.flags() & 4 /* ACCESS */) ? 1 : 0;
                previousDates += (this.flags() & 16 /* BACKUP */) ? 1 : 0;
                previousDates += (this.flags() & 32 /* EXPIRATION */) ? 1 : 0;
                if (this._longFormDates) {
                    return getDate(this._data, 5 + (previousDates * 17));
                }
                else {
                    return getShortFormDate(this._data, 5 + (previousDates * 7));
                }
            }
            else {
                return null;
            }
        }
        _longFormDates() {
            return !!(this.flags() && 128 /* LONG_FORM */);
        }
    }
    /**
     * RockRidge: File data in sparse format.
     * @hidden
     */
    class SFEntry extends SystemUseEntry {
        constructor(data) {
            super(data);
        }
        virtualSizeHigh() {
            return this._data.readUInt32LE(4);
        }
        virtualSizeLow() {
            return this._data.readUInt32LE(12);
        }
        tableDepth() {
            return this._data[20];
        }
    }
    /**
     * @hidden
     */
    class Directory {
        constructor(record, isoData) {
            this._fileList = [];
            this._fileMap = {};
            this._record = record;
            let i = record.lba();
            let iLimit = i + record.dataLength();
            if (!(record.fileFlags() & 2 /* Directory */)) {
                // Must have a CL entry.
                const cl = record.getSUEntries(isoData).filter((e) => e instanceof CLEntry)[0];
                i = cl.childDirectoryLba() * 2048;
                iLimit = Infinity;
            }
            while (i < iLimit) {
                const len = isoData[i];
                // Zero-padding between sectors.
                // TODO: Could optimize this to seek to nearest-sector upon
                // seeing a 0.
                if (len === 0) {
                    i++;
                    continue;
                }
                const r = this._constructDirectoryRecord(isoData.slice(i));
                const fname = r.fileName(isoData);
                // Skip '.' and '..' entries.
                if (fname !== '\u0000' && fname !== '\u0001') {
                    // Skip relocated entries.
                    if (!r.hasRockRidge() || r.getSUEntries(isoData).filter((e) => e instanceof REEntry).length === 0) {
                        this._fileMap[fname] = r;
                        this._fileList.push(fname);
                    }
                }
                else if (iLimit === Infinity) {
                    // First entry contains needed data.
                    iLimit = i + r.dataLength();
                }
                i += r.length();
            }
        }
        /**
         * Get the record with the given name.
         * Returns undefined if not present.
         */
        getRecord(name) {
            return this._fileMap[name];
        }
        getFileList() {
            return this._fileList;
        }
        getDotEntry(isoData) {
            return this._constructDirectoryRecord(isoData.slice(this._record.lba()));
        }
    }
    /**
     * @hidden
     */
    class ISODirectory extends Directory {
        constructor(record, isoData) {
            super(record, isoData);
        }
        _constructDirectoryRecord(data) {
            return new ISODirectoryRecord(data, this._record.getRockRidgeOffset());
        }
    }
    /**
     * @hidden
     */
    class JolietDirectory extends Directory {
        constructor(record, isoData) {
            super(record, isoData);
        }
        _constructDirectoryRecord(data) {
            return new JolietDirectoryRecord(data, this._record.getRockRidgeOffset());
        }
    }
    /**
     * Mounts an ISO file as a read-only file system.
     *
     * Supports:
     * * Vanilla ISO9660 ISOs
     * * Microsoft Joliet and Rock Ridge extensions to the ISO9660 standard
     */
    class IsoFS extends SynchronousFileSystem {
        /**
         * **Deprecated. Please use IsoFS.Create() method instead.**
         *
         * Constructs a read-only file system from the given ISO.
         * @param data The ISO file in a buffer.
         * @param name The name of the ISO (optional; used for debug messages / identification via getName()).
         */
        constructor(data, name = "") {
            super();
            this._data = data;
            // Skip first 16 sectors.
            let vdTerminatorFound = false;
            let i = 16 * 2048;
            const candidateVDs = new Array();
            while (!vdTerminatorFound) {
                const slice = data.slice(i);
                const vd = new VolumeDescriptor(slice);
                switch (vd.type()) {
                    case 1 /* PrimaryVolumeDescriptor */:
                        candidateVDs.push(new PrimaryVolumeDescriptor(slice));
                        break;
                    case 2 /* SupplementaryVolumeDescriptor */:
                        candidateVDs.push(new SupplementaryVolumeDescriptor(slice));
                        break;
                    case 255 /* VolumeDescriptorSetTerminator */:
                        vdTerminatorFound = true;
                        break;
                }
                i += 2048;
            }
            if (candidateVDs.length === 0) {
                throw new ApiError(ErrorCode.EIO, `Unable to find a suitable volume descriptor.`);
            }
            candidateVDs.forEach((v) => {
                // Take an SVD over a PVD.
                if (!this._pvd || this._pvd.type() !== 2 /* SupplementaryVolumeDescriptor */) {
                    this._pvd = v;
                }
            });
            this._root = this._pvd.rootDirectoryEntry(data);
            this._name = name;
        }
        /**
         * Creates an IsoFS instance with the given options.
         */
        static Create(opts, cb) {
            try {
                cb(null, new IsoFS(opts.data, opts.name));
            }
            catch (e) {
                cb(e);
            }
        }
        static isAvailable() {
            return true;
        }
        getName() {
            let name = `IsoFS${this._name}${this._pvd ? `-${this._pvd.name()}` : ''}`;
            if (this._root && this._root.hasRockRidge()) {
                name += `-RockRidge`;
            }
            return name;
        }
        diskSpace(path, cb) {
            // Read-only file system.
            cb(this._data.length, 0);
        }
        isReadOnly() {
            return true;
        }
        supportsLinks() {
            return false;
        }
        supportsProps() {
            return false;
        }
        supportsSynch() {
            return true;
        }
        statSync(p, isLstat) {
            const record = this._getDirectoryRecord(p);
            if (record === null) {
                throw ApiError.ENOENT(p);
            }
            return this._getStats(p, record);
        }
        openSync(p, flags, mode) {
            // INVARIANT: Cannot write to RO file systems.
            if (flags.isWriteable()) {
                throw new ApiError(ErrorCode.EPERM, p);
            }
            // Check if the path exists, and is a file.
            const record = this._getDirectoryRecord(p);
            if (!record) {
                throw ApiError.ENOENT(p);
            }
            else if (record.isSymlink(this._data)) {
                return this.openSync(path.resolve(p, record.getSymlinkPath(this._data)), flags, mode);
            }
            else if (!record.isDirectory(this._data)) {
                const data = record.getFile(this._data);
                const stats = this._getStats(p, record);
                switch (flags.pathExistsAction()) {
                    case ActionType.THROW_EXCEPTION:
                    case ActionType.TRUNCATE_FILE:
                        throw ApiError.EEXIST(p);
                    case ActionType.NOP:
                        return new NoSyncFile(this, p, flags, stats, data);
                    default:
                        throw new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.');
                }
            }
            else {
                throw ApiError.EISDIR(p);
            }
        }
        readdirSync(path) {
            // Check if it exists.
            const record = this._getDirectoryRecord(path);
            if (!record) {
                throw ApiError.ENOENT(path);
            }
            else if (record.isDirectory(this._data)) {
                return record.getDirectory(this._data).getFileList().slice(0);
            }
            else {
                throw ApiError.ENOTDIR(path);
            }
        }
        /**
         * Specially-optimized readfile.
         */
        readFileSync(fname, encoding, flag) {
            // Get file.
            const fd = this.openSync(fname, flag, 0x1a4);
            try {
                const fdCast = fd;
                const fdBuff = fdCast.getBuffer();
                if (encoding === null) {
                    return copyingSlice(fdBuff);
                }
                return fdBuff.toString(encoding);
            }
            finally {
                fd.closeSync();
            }
        }
        _getDirectoryRecord(path) {
            // Special case.
            if (path === '/') {
                return this._root;
            }
            const components = path.split('/').slice(1);
            let dir = this._root;
            for (const component of components) {
                if (dir.isDirectory(this._data)) {
                    dir = dir.getDirectory(this._data).getRecord(component);
                    if (!dir) {
                        return null;
                    }
                }
                else {
                    return null;
                }
            }
            return dir;
        }
        _getStats(p, record) {
            if (record.isSymlink(this._data)) {
                const newP = path.resolve(p, record.getSymlinkPath(this._data));
                const dirRec = this._getDirectoryRecord(newP);
                if (!dirRec) {
                    return null;
                }
                return this._getStats(newP, dirRec);
            }
            else {
                const len = record.dataLength();
                let mode = 0x16D;
                const date = record.recordingDate().getTime();
                let atime = date;
                let mtime = date;
                let ctime = date;
                if (record.hasRockRidge()) {
                    const entries = record.getSUEntries(this._data);
                    for (const entry of entries) {
                        if (entry instanceof PXEntry) {
                            mode = entry.mode();
                        }
                        else if (entry instanceof TFEntry) {
                            const flags = entry.flags();
                            if (flags & 4 /* ACCESS */) {
                                atime = entry.access().getTime();
                            }
                            if (flags & 2 /* MODIFY */) {
                                mtime = entry.modify().getTime();
                            }
                            if (flags & 1 /* CREATION */) {
                                ctime = entry.creation().getTime();
                            }
                        }
                    }
                }
                // Mask out writeable flags. This is a RO file system.
                mode = mode & 0x16D;
                return new Stats(record.isDirectory(this._data) ? FileType.DIRECTORY : FileType.FILE, len, mode, atime, mtime, ctime);
            }
        }
    }
    IsoFS.Name = "IsoFS";
    IsoFS.Options = {
        data: {
            type: "object",
            description: "The ISO file in a buffer",
            validator: bufferValidator
        }
    };


    return IsoFS;
});
define('skylark-browserfs/core/backends',[
    './util',
    '../backend/AsyncMirror',
    '../backend/Dropbox',
    '../backend/Emscripten',
    '../backend/FolderAdapter',
    '../backend/HTML5FS',
    '../backend/InMemory',
    '../backend/IndexedDB',
    '../backend/LocalStorage',
    '../backend/MountableFileSystem',
    '../backend/OverlayFS',
    '../backend/WorkerFS',
    '../backend/HTTPRequest',
    '../backend/ZipFS',
    '../backend/IsoFS'
], function (util, AsyncMirror, Dropbox, Emscripten, FolderAdapter, HTML5FS, InMemory, IndexedDB, LocalStorage, MountableFileSystem, OverlayFS, WorkerFS, HTTPRequest, ZipFS, IsoFS) {
    'use strict';
    const { checkOptions } = util;

    

    // Monkey-patch `Create` functions to check options before file system initialization.
    [AsyncMirror, Dropbox, Emscripten, FolderAdapter, HTML5FS, InMemory, IndexedDB, IsoFS, LocalStorage, MountableFileSystem, OverlayFS, WorkerFS, HTTPRequest, ZipFS].forEach((fsType) => {
        const create = fsType.Create;
        fsType.Create = function (opts, cb) {
            const oneArg = typeof (opts) === "function";
            const normalizedCb = oneArg ? opts : cb;
            const normalizedOpts = oneArg ? {} : opts;
            function wrappedCb(e) {
                if (e) {
                    normalizedCb(e);
                }
                else {
                    create.call(fsType, normalizedOpts, normalizedCb);
                }
            }
            checkOptions(fsType, normalizedOpts, wrappedCb);
        };
    });
    /**
     * @hidden
     */
    const Backends = { AsyncMirror, Dropbox, Emscripten, FolderAdapter, HTML5FS, InMemory, IndexedDB, IsoFS, LocalStorage, MountableFileSystem, OverlayFS, WorkerFS, HTTPRequest, XmlHttpRequest: HTTPRequest, ZipFS };
    // Make sure all backends cast to FileSystemConstructor (for type checking)
    const _ = Backends;
    // tslint:disable-next-line:no-unused-expression
    _;
    // tslint:enable-next-line:no-unused-expression
    return Backends;
});
define('skylark-browserfs/core/browserfs',[
    '../libs/process',
    '../libs/buffers',
    './node_fs',
    '../libs/path',
    '../generic/emscripten_fs',
    './backends',
    './util',
    './api_error',
    '../generic/setImmediate'
], function (process,buffers, fs, path, EmscriptenFS, Backends, BFSUtils, Errors, setImmediate) {
    'use strict';

    const {Buffer} = buffers;
    
    /**
     * BrowserFS's main module. This is exposed in the browser via the BrowserFS global.
     * Due to limitations in typedoc, we document these functions in ./typedoc.ts.
     */
    if (process['initializeTTYs']) {
        process['initializeTTYs']();
    }
    /**
     * Installs BFSRequire as global `require`, a Node Buffer polyfill as the global `Buffer` variable,
     * and a Node process polyfill as the global `process` variable.
     */
    function install(obj) {
        obj.Buffer = Buffer;
        obj.process = process;
        const oldRequire = obj.require ? obj.require : null;
        // Monkey-patch require for Node-style code.
        obj.require = function (arg) {
            const rv = BFSRequire(arg);
            if (!rv) {
                return oldRequire.apply(null, Array.prototype.slice.call(arguments, 0));
            }
            else {
                return rv;
            }
        };
    }
    /**
     * @hidden
     */
    function registerFileSystem(name, fs) {
        Backends[name] = fs;
    }
    function BFSRequire(module) {
        switch (module) {
            case 'fs':
                return fs;
            case 'path':
                return path;
            case 'buffer':
                // The 'buffer' module has 'Buffer' as a property.
                return buffer;
            case 'process':
                return process;
            case 'bfs_utils':
                return BFSUtils;
            default:
                return Backends[module];
        }
    }
    /**
     * Initializes BrowserFS with the given root file system.
     */
    function initialize(rootfs) {
        return fs.initialize(rootfs);
    }
    /**
     * Creates a file system with the given configuration, and initializes BrowserFS with it.
     * See the FileSystemConfiguration type for more info on the configuration object.
     */
    function configure(config, cb) {
        getFileSystem(config, (e, fs) => {
            if (fs) {
                initialize(fs);
                cb();
            }
            else {
                cb(e);
            }
        });
    }
    /**
     * Retrieve a file system with the given configuration.
     * @param config A FileSystemConfiguration object. See FileSystemConfiguration for details.
     * @param cb Called when the file system is constructed, or when an error occurs.
     */
    function getFileSystem(config, cb) {
        const fsName = config['fs'];
        if (!fsName) {
            return cb(new Errors.ApiError(Errors.ErrorCode.EPERM, 'Missing "fs" property on configuration object.'));
        }
        const options = config['options'];
        let waitCount = 0;
        let called = false;
        function finish() {
            if (!called) {
                called = true;
                const fsc = Backends[fsName];
                if (!fsc) {
                    cb(new Errors.ApiError(Errors.ErrorCode.EPERM, `File system ${fsName} is not available in BrowserFS.`));
                }
                else {
                    fsc.Create(options, cb);
                }
            }
        }
        if (options !== null && typeof (options) === "object") {
            let finishedIterating = false;
            const props = Object.keys(options).filter((k) => k !== 'fs');
            // Check recursively if other fields have 'fs' properties.
            props.forEach((p) => {
                const d = options[p];
                if (d !== null && typeof (d) === "object" && d['fs']) {
                    waitCount++;
                    getFileSystem(d, function (e, fs) {
                        waitCount--;
                        if (e) {
                            if (called) {
                                return;
                            }
                            called = true;
                            cb(e);
                        }
                        else {
                            options[p] = fs;
                            if (waitCount === 0 && finishedIterating) {
                                finish();
                            }
                        }
                    });
                }
            });
            finishedIterating = true;
        }
        if (waitCount === 0) {
            finish();
        }
    }

    return {
        install: install,
        registerFileSystem: registerFileSystem,
        BFSRequire: BFSRequire,
        initialize: initialize,
        configure: configure,
        getFileSystem: getFileSystem,
        EmscriptenFS,
        "FileSystem" : Backends,
        Errors,
        setImmediate
    };
});
define('skylark-browserfs/main',[
    "./core/browserfs"
],function(browserfs){
    return browserfs;
});
define('skylark-browserfs', ['skylark-browserfs/main'], function (main) { return main; });

define('skylark-98js/helpers',[
	"skylark-jquery",
	"./win98"
],function($,win98js){
	var TAU =     //////|//////
	          /////     |     /////
	       ///         tau         ///
	     ///     ...--> | <--...     ///
	   ///     -'   one | turn  '-     ///
	  //     .'         |         '.     //
	 //     /           |           \     //
	//     |            | <-..       |     //
	//    |          .->|     \       |    //
	//    |         /   |      |      |    //
	- - - - - - Math.PI + Math.PI - - - - - 0
	//    |         \   |      |      |    //
	//    |          '->|     /       |    //
	//     |            | <-''       |     //
	 //     \           |           /     //
	  //     '.         |         .'     //
	   ///     -.       |       .-     ///
	     ///     '''----|----'''     ///
	       ///          |          ///
	         //////     |     /////
	              //////|//////          C/r;

	var $G = $(window);

	function Cursor(cursor_def) {
		return "url(images/cursors/" + cursor_def[0] + ".png) " +
			cursor_def[1].join(" ") +
			", " + cursor_def[2]
	}

	function E(t) {
		return document.createElement(t);
	}

	var DESKTOP_ICON_SIZE = 32;
	var TASKBAR_ICON_SIZE = 16;
	var TITLEBAR_ICON_SIZE = 16;

	// For Wayback Machine, match URLs like https://web.archive.org/web/20191213113214/https://98.js.org/
	// (also match URLs like https://98.js.org/ because why not)
	const web_server_root_for_icons =
		location.href.match(/98.js.org/) ?
			location.href.match(/.*98.js.org/)[0] + "/" :
			"/";

	function getIconPath(iconID, size) {
		return web_server_root_for_icons + "images/icons/" + iconID + "-" + size + "x" + size + ".png";
	}

	function Canvas(width, height) {
		var new_canvas = E("canvas");
		var new_ctx = new_canvas.getContext("2d");
		new_ctx.imageSmoothingEnabled = false;
		new_ctx.mozImageSmoothingEnabled = false;
		new_ctx.webkitImageSmoothingEnabled = false;
		if (width && height) {
			// new Canvas(width, height)
			new_canvas.width = width;
			new_canvas.height = height;
		} else {
			// new Canvas(image)
			var copy_of = width;
			if (copy_of) {
				new_canvas.width = copy_of.width;
				new_canvas.height = copy_of.height;
				new_ctx.drawImage(copy_of, 0, 0);
			}
		}
		new_canvas.ctx = new_ctx;
		return new_canvas;
	}

	function mustHaveMethods(obj, methodNames) {
		for (const methodName of methodNames) {
			if (typeof obj[methodName] != 'function') {
				console.error("Missing method", methodName, "on object", obj);
				throw new TypeError("missing method " + methodName);
			}
		}
		return true;
	}
	const windowInterfaceMethods = [
		"close",
		"minimize",
		"unminimize",
		// "maximize",
		// "unmaximize",
		"bringToFront", // TODO: maybe setZIndex instead
		"getTitle",
		// "getIconName",
		"getIconAtSize",
		"focus",
		"blur",
		"onFocus",
		"onBlur",
		"onClosed",
	];


	function file_name_from_path(file_path) {
		return file_path.split("\\").pop().split("/").pop();
	}

	function file_extension_from_path(file_path) {
		return (file_path.match(/\.(\w+)$/) || [, ""])[1];
	}
	return {
		Cursor,
		DESKTOP_ICON_SIZE,
		TASKBAR_ICON_SIZE,
		TITLEBAR_ICON_SIZE,
		getIconPath,
		Canvas,
		mustHaveMethods,
		windowInterfaceMethods,
		file_name_from_path,

		file_extension_from_path
	}
});
define('skylark-98js/FolderViewItem',[
	"skylark-jquery",
	"./win98",
	"./helpers"
],function($,win98js,helpers){
    "use strict";

	function FolderViewItem(options) {
		// TODO: rename options to be consistent,
		// like is_folder, is_shortcut, etc.
		// TODO: rename CSS class to folder-view-item, or find a better name
		var $container = $("<div class='desktop-icon' draggable='true' tabindex=-1/>");
		var $icon_wrapper = $("<div class='icon-wrapper'/>").appendTo($container);
		var $selection_effect = $("<div class='selection-effect'/>").appendTo($icon_wrapper);
		var $title = $("<div class='title'/>").text(options.title);
		var $icon;
		$container.append($icon_wrapper, $title);

		// TODO: handle the loading state display in some intentional way

		// TODO: or if set to "web" mode, single click
		// also Enter is currently implemented by triggering dblclick which is awkward
		let single_click_timeout;
		$container.on("dblclick", (event) => {
			if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {
				return; // Not true to Windows 98. But in Windows 98 it doesn't do two things, it just does the double click action.
				// At any rate, it feels nice to make Ctrl+click do only one thing (toggling the selection state).
			}
			options.open();
			clearTimeout(single_click_timeout);
		});
		// TODO: allow dragging files out from this folder view to the system file browser, with dataTransfer.setData("DownloadURL", ...)
		// sadly will only work for a single file (unless it secretly supports text/uri-list (either as a separate type or for DownloadURL))
		// also it won't work if I want to do custom drag-and-drop (e.g. repositioning icons)
		// so I have to choose one feature or the other (right?), probably custom drag-and-drop

		$title.on("click", () => {
			if (!$container[0]._was_selected_at_pointerdown) {
				return; // this click is for selecting the item
			}
			// @TODO: if the folder view wasn't focused at pointerdown,
			// don't start rename
			single_click_timeout = setTimeout(() => {
				if ($container.hasClass("selected")) {
					this.start_rename();
				}
			}, 500);
		});

		if (options.shortcut) {
			$container.addClass("shortcut");
		}
		$container[0].dataset.filePath = options.file_path;

		this.element = $container[0];

		this.icons = options.icons;
		this.iconSize = options.iconSize || helpers.DESKTOP_ICON_SIZE;

		this.file_path = options.file_path;
		this.is_system_folder = options.is_system_folder;

		this._update_icon = () => {
			if (this.icons) {
				const $old_icon = $icon;
				const src = this.icons[this.iconSize];
				$icon = $("<img class='icon'/>");
				$icon.attr({
					draggable: false,
					src,
					width: this.iconSize,
					height: this.iconSize,
				});
				$selection_effect[0].style.setProperty("--icon-image", `url("${src}")`);
				if ($old_icon) {
					$old_icon.replaceWith($icon);
				} else {
					$icon_wrapper.prepend($icon);
				}
			} else {
				$icon && $icon.remove();
				$icon = null;
				$selection_effect[0].style.setProperty("--icon-image", "none");
			}
			$icon_wrapper[0].style.setProperty("--icon-size", this.iconSize + "px");
			$icon_wrapper[0].style.setProperty("--shortcut-icon", `url("${helpers.getIconPath("shortcut", this.iconSize)}")`);
		};
		this.setIcons = (new_icons) => {
			this.icons = new_icons;
			this._update_icon();
		};
		this.setIconSize = (new_size) => {
			if (this.iconSize === new_size) {
				return;
			}
			this.iconSize = new_size;
			this._update_icon();
		};
		this._update_icon();

		this.start_rename = () => {
			if (!options.rename) {
				return;
			}
			if ($container.hasClass("renaming")) {
				return;
			}
			$container.addClass("renaming");
			$container.attr("draggable", false);
			const old_title = $title.text();
			// @TODO: auto-size the input box,
			// and wrap to multiple lines
			const $input = $("<input type='text'/>");
			$input.val(old_title);
			$input.on("keydown", (e) => {
				// relying on blur event to trigger the rename,
				// or to reset the input to the old title
				if (e.key === "Enter") {
					$container.focus();
					e.preventDefault();
				} else if (e.key === "Escape") {
					$input.val(old_title);
					$container.focus();
					e.preventDefault();
				}
			});
			$input.on("blur", () => {
				const new_title = $input.val();
				if (new_title.trim() === "") {
					showMessageBox({
						title: "Rename",
						message: "You must type a filename.",
						iconID: "error",
					}).then(() => {
						$input.focus(); // @TODO: why is this needed? it's supposed to refocus the last focused element
						// well I guess it doesn't work for the desktop, just windows
					});
					return;
				}
				$input.remove(); // technically not necessary
				$title.text(new_title);
				$container.removeClass("renaming");
				$container.attr("draggable", true);
				if (new_title !== old_title) {
					// console.log("renaming", this.file_path, "to", new_title);
					options.rename(new_title)
						.catch((error) => {
							$title.text(old_title);
							alert("Failed to rename:\n\n" + error);
						});
				}
			});
			$title.empty().append($input);
			$input[0].focus();
			$input[0].select();
		};
	}

	return FolderViewItem;
});
define('skylark-98js/filesystem-setup',[
	"skylark-jquery",
	"skylark-browserfs",
	"./win98"
],function($,BrowserFS, win98js){

	var __fs_initialized;
	var __fs_errored;
	var __fs_timed_out;
	var __fs_waiting_callbacks = [];


	// For Wayback Machine, match URLs like https://web.archive.org/web/20191213113214/https://98.js.org/
	// (also match URLs like https://98.js.org/ because why not)
	const web_server_root_for_browserfs =
		location.href.match(/98.js.org/) ?
			location.href.match(/.*98.js.org/)[0] + "/" :
			"/";

	BrowserFS.configure({
		fs: "OverlayFS",
		options: {
			writable: {
				fs: "IndexedDB",
				options: {
					storeName: "C:"
				}
			},
			readable: {
				fs: "XmlHttpRequest",
				options: {
					index: web_server_root_for_browserfs + "filesystem-index.json",
					baseUrl: web_server_root_for_browserfs
				}
			}
		}
		// TODO: mount the repo contents at something like C:\98\
		// but other OS stuff from a subfolder of the repo as root (C? HD? hard-drive? disk? OS?)
		// the desktop at something like.. well I guess C:\98\desktop
		// and I could have the default desktop setup in source control there
	}, function (error) {
		if (error) {
			__fs_errored = true;
			if (__fs_waiting_callbacks.length) {
				// TODO: DRY (can probably simplify this logic significantly)
				alert("The filesystem is not available. It failed to initialize.");
			}
			__fs_waiting_callbacks = [];
			// TODO: message box; offer to reset the filesystem
			throw error;
		}
		__fs_initialized = true;
		for (var i = 0; i < __fs_waiting_callbacks.length; i++) {
			__fs_waiting_callbacks[i]();
		}
		__fs_waiting_callbacks = [];
	});

	setTimeout(function () {
		__fs_timed_out = true;
		if (__fs_waiting_callbacks.length) {
			// TODO: DRY (can probably simplify this logic significantly)
			alert("The filesystem is not working.");
		}
		__fs_waiting_callbacks = [];
	}, 5000);

	function withFilesystem(callback) {
		if (__fs_initialized) {
			callback();
		} else if (__fs_errored) {
			alert("The filesystem is not available. It failed to initialize.");
		} else if (__fs_timed_out) {
			alert("The filesystem is not working.");
		} else {
			// wait within a global period of time while it should be configuring (and not show a message box)
			// TODO: hm, maybe a global timeout isn't what we want
			// The desktop should load, regardless of how long it takes.
			// Other operations could fail in a second or more. Depending on the operation.
			__fs_waiting_callbacks.push(callback);
		}
	}
	// TODO: never use alert(); use thematic, non-blocking dialog windows, preferably with warning and error icons
	// I have a show_error_message in jspaint, but with no warning or error icons - as of writing; see https://github.com/1j01/jspaint/issues/84


	return {
		withFilesystem
	}

});
define('skylark-98js/FolderView',[
	"skylark-jquery",
	"skylark-browserfs",
	"./win98",
	"./FolderViewItem",
	"./filesystem-setup",
	"./helpers"
],function($,BrowserFS, win98js,FolderViewItem,FilesystemSetup,helpers){
	const grid_size_x_for_large_icons = 75;
	const grid_size_y_for_large_icons = 75;
	// @TODO: this is supposed to be dynamic based on length of names
	const grid_size_x_for_small_icons = 150;
	const grid_size_y_for_small_icons = 17;

	window.resetAllFolderCustomizations = () => {
		for (let i = 0; i < localStorage.length; i++) {
			if (localStorage.key(i).startsWith("folder-config:")) {
				localStorage.removeItem(localStorage.key(i));
			}
		}
	};

	const icon_size_by_view_mode = {
		LARGE_ICONS: 32,
		SMALL_ICONS: 16,
		DETAILS: 16,
		LIST: 16,
		DESKTOP: 32,
	};

	FolderView.VIEW_MODES = {
		THUMBNAILS: "THUMBNAILS", // hidden until you right click in a folder, go to Properties, and enable thumbnails
		LARGE_ICONS: "LARGE_ICONS", // left to right, then top to bottom
		SMALL_ICONS: "SMALL_ICONS", // left to right, then top to bottom
		DETAILS: "DETAILS", // table view
		LIST: "LIST", // top to bottom, then left to right
		DESKTOP: "DESKTOP", // like Large Icons, but arranged top to bottom before left to right; does not apply to the Desktop folder, only the Desktop itself
	};

	FolderView.SORT_MODES = {
		NAME: "NAME",
		TYPE: "TYPE",
		SIZE: "SIZE",
		DATE: "DATE",
		// there are many other attributes, some for specific types of files/objects
	};

	// TODO: what's the "right" way to do file type / program associations for icons?

	// TODO: get more icons; can extract from shell32.dll, moricons.dll, and other files from a VM
	// also get more file extensions; can find a mime types listing data dump
	// https://github.com/1j01/retrores
	// Note: extensions must be lowercase here. This is used to implement case-insensitive matching.
	var file_extension_icons = {
		txt: "notepad-file",
		md: "notepad-file",
		json: "notepad-file",
		js: "notepad-file",
		css: "notepad-file",
		html: "notepad-file",
		gitattributes: "notepad-file",
		gitignore: "notepad-file",
		png: "image-gif", // "image-png"? nope... (but should it be image-gif or image-wmf?)
		jpg: "image-jpeg",
		jpeg: "image-jpeg",
		gif: "image-gif",
		webp: "image-other",
		bmp: "paint-file",
		tif: "kodak-imaging-file",
		tiff: "kodak-imaging-file",
		// wmf: "image-wmf"? nope (https://en.wikipedia.org/wiki/Windows_Metafile)
		// emf: "image-wmf"? nope
		// wmz: "image-wmf"? nope
		// emz: "image-wmf"? nope
		wav: "sound",
		mp3: "sound", // TODO: show blue video icon, as it's a container format that can contain video
		ogg: "sound", // TODO: probably ditto
		wma: "sound",
		// "doc": "doc"?
		"exe": "task",
		htm: "html",
		html: "html",
		url: "html",
		theme: "themes",
		themepack: "themes",
	};

	// @TODO: maintain less fake naming abstraction
	// base it more on the actual filesystem
	// @TODO: bring system folders, icons, and file associations into one place
	const system_folder_path_to_name = {
		"/": "(C:)", //"My Computer",
		"/my-pictures/": "My Pictures",
		"/my-documents/": "My Documents",
		"/network-neighborhood/": "Network Neighborhood",
		"/desktop/": "Desktop",
		"/programs/": "Program Files",
		"/recycle-bin/": "Recycle Bin",
	};
	const system_folder_name_to_path = Object.fromEntries(
		Object.entries(system_folder_path_to_name).map(([key, value]) => [value, key])
	);
	const system_folder_lowercase_name_to_path = Object.fromEntries(
		Object.entries(system_folder_name_to_path).map(([key, value]) => [key.toLowerCase(), value])
	);


	const set_dragging_file_paths = (dragging_file_paths) => {
		window.dragging_file_paths = dragging_file_paths;
		let frame = window;
		while (frame !== frame.parent) {
			frame = frame.parent;
			frame.dragging_file_paths = dragging_file_paths;
		}
	};

	function FolderView(folder_path, { asDesktop = false, onStatus, openFolder, openFileOrFolder, onConfigure } = {}) {
		const self = this;
		// TODO: ensure a trailing slash / use path.join where appropriate

		var $folder_view = $(`<div class="folder-view" tabindex="0">`);

		this.element = $folder_view[0];

		this.items = [];

		this.add_item = (folder_view_item) => {
			$folder_view.append(folder_view_item.element);
			this.items.push(folder_view_item);
			// if (this.items.length === 1) {
			// 	// this.items[0].element.focus();
			// 	this.items[0].element.classList.add("focused");
			// }
		};

		// config:
		// - [x] view_mode
		// - [x] sort_mode
		// - [ ] auto_arrange
		// - [ ] icon_positions
		// - [x] view_as_web_page

		this.config = {};
		var storage_key = `folder-config:${asDesktop ? "desktop" : folder_path}`;
		try {
			const config_json = localStorage.getItem(storage_key);
			const config = JSON.parse(config_json);
			if (config) {
				Object.assign(this.config, config);
			}
		} catch (e) {
			console.error("Failed to read folder config:", e);
		}
		// Handling defaults and invalid values at the same time
		if (!FolderView.VIEW_MODES[this.config.view_mode]) {
			this.config.view_mode = asDesktop ?
				FolderView.VIEW_MODES.DESKTOP :
				FolderView.VIEW_MODES.LARGE_ICONS;
		}
		if (!FolderView.SORT_MODES[this.config.sort_mode]) {
			this.config.sort_mode = FolderView.SORT_MODES.NAME;
		}
		///this.config.view_as_web_page ??= folder_path !== "/desktop/";
		if (!this.config.view_as_web_page) {
			this.config.view_as_web_page = folder_path !== "/desktop/";
		}

		this.element.dataset.viewMode = this.config.view_mode;
		this.configure = (config_props) => {
			Object.assign(this.config, config_props);
			if (config_props.view_mode) {
				this.element.dataset.viewMode = config_props.view_mode;
			}
			this.arrange_icons();
			try {
				localStorage.setItem(storage_key, JSON.stringify(this.config));
			} catch (e) {
				console.error("Can't write to localStorage:", e);
			}
			///onConfigure?.(config_props);
			if (onConfigure) {
				onConfigure(config_props);
			}
		};

		this.cycle_view_mode = () => {
			// const view_modes = Object.values(FolderView.VIEW_MODES);
			const view_modes = [
				// FolderView.VIEW_MODES.THUMBNAILS, conditionally?
				FolderView.VIEW_MODES.LARGE_ICONS,
				FolderView.VIEW_MODES.SMALL_ICONS,
				FolderView.VIEW_MODES.LIST,
				// FolderView.VIEW_MODES.DETAILS, // same as list for now
			];
			const current_view_mode_index = view_modes.indexOf(this.config.view_mode);
			const next_view_mode_index = (current_view_mode_index + 1) % view_modes.length;
			this.configure({ view_mode: view_modes[next_view_mode_index] });
		};

		let waiting_on_stats = false;
		this.arrange_icons = () => {
			if (waiting_on_stats) {
				return;
			}
			if (!self.element.isConnected) { // checking parentElement doesn't work if under a shadowRoot
				// console.trace("not in DOM");
				return; // prevent errors computing layout if folder view removed before stats resolve
			}
			const pending_promises = this.items.map((item) => item.pendingStatPromise).filter(Boolean);
			const any_pending = pending_promises.length > 0;
			if (any_pending) {
				if (!waiting_on_stats) {
					// should I choose a batch size? or is waiting on all stats fine?
					// batches mean that it would update multiple times, which could be jarring.
					Promise.allSettled(pending_promises).then(() => {
						waiting_on_stats = false;
						self.arrange_icons();
					});
				}
				waiting_on_stats = true;
			}
			const horizontal_first =
				this.config.view_mode === FolderView.VIEW_MODES.LARGE_ICONS ||
				this.config.view_mode === FolderView.VIEW_MODES.SMALL_ICONS;
			const large_icons =
				this.config.view_mode === FolderView.VIEW_MODES.LARGE_ICONS ||
				this.config.view_mode === FolderView.VIEW_MODES.DESKTOP;
			const icon_size = icon_size_by_view_mode[this.config.view_mode] || 32;

			const grid_size_x = large_icons ? grid_size_x_for_large_icons : grid_size_x_for_small_icons;
			const grid_size_y = large_icons ? grid_size_y_for_large_icons : grid_size_y_for_small_icons;
			var x = 0;
			var y = 0;
			const dir_ness = (item) =>
				// system folders always go first
				// not all system folder shortcuts on the desktop have real paths (currently)
				// so we can't check system_folder_path_to_name, need a separate attribute.
				// system_folder_path_to_name[item.file_path] ? 2 :
				item.is_system_folder ? 2 :
					// then folders, then everything else
					///item.resolvedStats?.isDirectory() ? 1 : 0;
					item.resolvedStats && item.resolvedStats.isDirectory() ? 1 : 0;
			const get_ext = (item) => (item.file_path ||/*??*/ "").split(".").pop();
			if (this.config.sort_mode === FolderView.SORT_MODES.NAME) {
				this.items.sort((a, b) =>
					dir_ness(b) - dir_ness(a) ||
					(a.title ||/*??*/ "").localeCompare(b.title ||/*??*/ "")
				);
			} else if (this.config.sort_mode === FolderView.SORT_MODES.TYPE) {
				this.items.sort((a, b) =>
					dir_ness(b) - dir_ness(a) ||
					(get_ext(a) ||/*??*/ "").localeCompare(get_ext(b) ||/*??*/ "")
				);
			} else if (this.config.sort_mode === FolderView.SORT_MODES.SIZE) {
				this.items.sort((a, b) =>
					dir_ness(b) - dir_ness(a) ||
					(a.resolvedStats.size ||/*??*/ 0) - (b.resolvedStats && b.resolvedStats.size ||/*??*/ 0)
				);
			} else if (this.config.sort_mode === FolderView.SORT_MODES.DATE) {
				this.items.sort((a, b) =>
					dir_ness(b) - dir_ness(a) ||
					(a.resolvedStats && a.resolvedStats.mtime ||/*??*/ 0) - (b.resolvedStats && b.resolvedStats.mtime ||/*??*/ 0)
				);
			}
			for (const item of this.items) {
				$(item.element).css({
					left: x,
					top: y,
				});
				if (horizontal_first) {
					x += grid_size_x;
					if (x + grid_size_x > $folder_view[0].clientWidth) {
						y += grid_size_y;
						x = 0;
					}
				} else {
					y += grid_size_y;
					if (y + grid_size_y > $folder_view[0].clientHeight) {
						x += grid_size_x;
						y = 0;
					}
				}

				item.setIconSize(icon_size);

				// apply sort - well, I'm positioning things absolutely, so I don't need to do this (AS LONG AS I DON'T ASSUME THE DOM ORDER, and use self.items instead)
				// and this is very slow for large folders.
				// this.element.appendChild(item.element);
			}

			if (!any_pending) {
				// this.items[0].element.classList.add("focused");
				this.items.forEach((item, index) => {
					item.element.classList.toggle("focused", index === 0);
				});
				// console.log("this.element.ownerDocument.activeElement", this.element.ownerDocument.activeElement);
				// if (this.element.ownerDocument.activeElement === this.element) {
				this.items[0] && this.items[0].element.focus();
				// }
				updateStatus();
			}
		};

		function updateStatus() {
			onStatus && onStatus({
				items: self.items,
				selectedItems: self.items.filter((item) => item.element.classList.contains("selected")),
			});
		}

		function deleteRecursiveSync(fs, itemPath) {
			if (fs.statSync(itemPath).isDirectory()) {
				for (const childItemName of fs.readdirSync(itemPath)) {
					deleteRecursiveSync(itemPath + "/" + childItemName);
				}
				fs.rmdirSync(itemPath);
			} else {
				fs.unlinkSync(itemPath);
			}
		}

		self.focus = function () {
			if ($folder_view.is(":focus-within")) {
				return; // don't mess with renaming inputs, for instance, if you click on the input
			}
			$folder_view.focus();
			// This doesn't do much if it's yet to be populated:
			if ($folder_view.find(".desktop-icon.focused").length === 0) {
				this.items[0] && this.items[0].element.focus();
			}
			// Initial focus is handled in arrange_icons currently.
		};

		self.select_all = function () {
			$folder_view.find(".desktop-icon").addClass("selected");
			updateStatus();
		};

		self.select_inverse = function () {
			$folder_view.find(".desktop-icon").each(function () {
				$(this).toggleClass("selected");
			});
			updateStatus();
		};

		self.delete_selected = function () {
			const selected_file_paths = $folder_view.find(".desktop-icon.selected")
				.toArray().map((icon_el) => icon_el.dataset.filePath)
				.filter((file_path) => system_folder_path_to_name[file_path] === undefined);

			if (selected_file_paths.length === 0) {
				return;
			}
			// @NOTE: if system setting for displaying file extensions was implemented, this should be changed...
			const name_of_first = $folder_view.find(".desktop-icon.selected .title").text().replace(/\.([^.]+)$/, "");
			showMessageBox({
				title: selected_file_paths.length === 1 ? "Confirm File Delete" : "Confirm Multiple File Delete",
				message: selected_file_paths.length === 1 ?
					`Are you sure you want to delete '${name_of_first}'?` :
					`Are you sure you want to delete these ${selected_file_paths.length} items?`,
				buttons: [
					{
						label: "Yes",
						value: "yes",
						default: true,
					},
					{
						label: "No",
						value: "no",
					},
				],
				iconID: "nuke",
			}).then((result) => {
				if (result !== "yes") {
					return;
				}
				FilesystemSetup.withFilesystem(function () {
					const fs = BrowserFS.BFSRequire('fs');
					let num_deleted = 0;
					for (const file_path of selected_file_paths) {
						let single_delete_success = false;
						try {
							deleteRecursiveSync(fs, file_path);
							single_delete_success = true;
							num_deleted += 1;
						} catch (error) {
							console.log("failed to delete", file_path, error);
						}
						if (single_delete_success) {
							self.items.forEach((item) => {
								if (item.element.dataset.filePath === file_path) {
									item.element.remove();
									updateStatus();
								}
							});
						}
					}
					// TODO: pluralization, and be more specific about folders vs files vs selected items, and total
					if (num_deleted < selected_file_paths.length) {
						alert(`Failed to delete ${selected_file_paths.length - num_deleted} items.`);
					}
					// self.refresh();
				});
			});
		};

		self.start_rename = () => {
			for (const item of self.items) {
				if (item.element.classList.contains("focused")) {
					item.start_rename();
					break;
				}
			}
		};

		// Read the folder and create icon items
		FilesystemSetup.withFilesystem(function () {
			var fs = BrowserFS.BFSRequire('fs');
			fs.readdir(folder_path, function (error, contents) {
				if (error) {
					alert("Failed to read contents of the directory " + folder_path);
					throw error;
				}

				for (var i = 0; i < contents.length; i++) {
					var fname = contents[i];
					add_fs_item(fname, -1000, -1000);
				}
				self.arrange_icons();
			});
		});

		// NOTE: in Windows, icons by default only get moved if they go offscreen (by maybe half the grid size)
		// we're handling it as if Auto Arrange is on (@TODO: support Auto Arrange off)
		const resizeObserver = new ResizeObserver(entries => {
			self.arrange_icons();
		});
		resizeObserver.observe(self.element);

		// Handle selecting icons
		(function () {
			var $marquee = $("<div class='marquee'/>").appendTo($folder_view).hide();
			var start = { x: 0, y: 0 };
			var current = { x: 0, y: 0 };
			var dragging = false;
			var drag_update = function () {
				var min_x = Math.min(start.x, current.x);
				var min_y = Math.min(start.y, current.y);
				var max_x = Math.max(start.x, current.x);
				var max_y = Math.max(start.y, current.y);
				$marquee.show().css({
					position: "absolute",
					left: min_x,
					top: min_y,
					width: max_x - min_x,
					height: max_y - min_y,
				});
				$folder_view.find(".desktop-icon").each(function (i, folder_view_icon) {
					// Note: this is apparently considerably more complex in Windows 98
					// like things are not considered the same heights and/or positions based on the size of their names
					var icon_offset = $(folder_view_icon).offset();
					var icon_left = parseFloat($(folder_view_icon).css("left"));
					var icon_top = parseFloat($(folder_view_icon).css("top"));
					var icon_width = $(folder_view_icon).width();
					var icon_height = $(folder_view_icon).height();
					folder_view_icon.classList.toggle("selected",
						icon_left < max_x &&
						icon_top < max_y &&
						icon_left + icon_width > min_x &&
						icon_top + icon_height > min_y
					);
				});
				updateStatus();
			};
			$folder_view.on("pointerdown", ".desktop-icon", function (e) {
				const item_el = e.currentTarget;
				item_el._was_selected_at_pointerdown = item_el.classList.contains("selected");
				select_item(item_el, e, true);
			});
			$folder_view.on("pointerdown", function (e) {
				// TODO: allow a margin of mouse movement before starting selecting
				var view_was_focused = $folder_view.is(":focus-within");
				self.focus();
				var $icon = $(e.target).closest(".desktop-icon");
				$marquee.hide();
				// var folder_view_offset = $folder_view.offset();
				var folder_view_offset = self.element.getBoundingClientRect();
				start = { x: e.pageX - folder_view_offset.left + $folder_view[0].scrollLeft, y: e.pageY - folder_view_offset.top + $folder_view[0].scrollTop };
				current = { x: e.pageX - folder_view_offset.left + $folder_view[0].scrollLeft, y: e.pageY - folder_view_offset.top + $folder_view[0].scrollTop };
				if ($icon.length > 0) {
					$marquee.hide();
					set_dragging_file_paths($(".desktop-icon.selected").get().map((icon) =>
						icon.dataset.filePath
					).filter((file_path) => file_path));
				} else {
					set_dragging_file_paths([]);
					// start dragging marquee unless over scrollbar
					let scrollbar_width = $folder_view[0].offsetWidth - $folder_view[0].clientWidth;
					let scrollbar_height = $folder_view[0].offsetHeight - $folder_view[0].clientHeight;
					scrollbar_width += 2; // for marquee border (@TODO: make marquee unable to cause scrollbar, by putting it in an overflow: hidden container)
					scrollbar_height += 2; // for marquee border
					const rect = $folder_view[0].getBoundingClientRect();
					const over_scrollbar = e.clientX > rect.right - scrollbar_width || e.clientY > rect.bottom - scrollbar_height;
					// console.log(`over_scrollbar: ${over_scrollbar}, e.clientX: ${e.clientX}, rect.right - scrollbar_width: ${rect.right - scrollbar_width}`);
					dragging = !over_scrollbar;
					// don't deselect right away unless the 
					// TODO: deselect on pointerUP, if the desktop was focused
					// or when starting selecting (re: TODO: allow a margin of movement before starting selecting)
					if (dragging && view_was_focused) {
						drag_update();
					}
				}
				$($folder_view[0].ownerDocument).on("pointermove", handle_pointermove);
				$($folder_view[0].ownerDocument).on("pointerup blur", handle_pointerup_blur);
			});
			function handle_pointermove (e) {
				// var folder_view_offset = $folder_view.offset();
				var folder_view_offset = self.element.getBoundingClientRect();
				current = { x: e.pageX - folder_view_offset.left + $folder_view[0].scrollLeft, y: e.pageY - folder_view_offset.top + $folder_view[0].scrollTop };
				// clamp coordinates to within folder view
				// This accomplishes three things:
				// 1. it improves the visual coherence of the marquee as an object
				// 2. it makes the marquee not cause a scrollbar
				// 3. it prevents selecting things you can't see
				const scrollbar_width = $folder_view.width() - $folder_view[0].clientWidth;
				const scrollbar_height = $folder_view.height() - $folder_view[0].clientHeight;
				const clamp_left = $folder_view[0].scrollLeft;
				const clamp_top = $folder_view[0].scrollTop;
				const clamp_right = $folder_view.width() + $folder_view[0].scrollLeft - scrollbar_width;
				const clamp_bottom = $folder_view.height() + $folder_view[0].scrollTop - scrollbar_height;
				current.x = Math.max(clamp_left, Math.min(clamp_right, current.x));
				current.y = Math.max(clamp_top, Math.min(clamp_bottom, current.y));
				if (dragging) {
					drag_update();
					// scroll the view by dragging the mouse at/past the edge
					const scroll_speed = 10;
					if (current.x === clamp_left) {
						$folder_view[0].scrollLeft -= scroll_speed;
					} else if (current.x === clamp_right) {
						$folder_view[0].scrollLeft += scroll_speed;
					}
					if (current.y === clamp_top) {
						$folder_view[0].scrollTop -= scroll_speed;
					} else if (current.y === clamp_bottom) {
						$folder_view[0].scrollTop += scroll_speed;
					}
				}
			};
			function handle_pointerup_blur() {
				$marquee.hide();
				dragging = false;
				set_dragging_file_paths([]);
				$($folder_view[0].ownerDocument).off("pointermove", handle_pointermove);
				$($folder_view[0].ownerDocument).off("pointerup blur", handle_pointerup_blur);
			};
		})();

		let search_string = "";
		let search_timeout;

		$folder_view.on("keydown", function (e) {
			// console.log("keydown", e.isDefaultPrevented());

			if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") {
				return;
			}
			if (e.key == "Enter") {
				$folder_view.find(".desktop-icon.selected").trigger("dblclick");
			} else if (e.ctrlKey && e.key == "a") {
				folder_view.select_all();
				e.preventDefault();
			} else if (e.key == "Delete") {
				self.delete_selected();
				e.preventDefault();
			} else if (
				e.key == "ArrowLeft" ||
				e.key == "ArrowRight" ||
				e.key == "ArrowUp" ||
				e.key == "ArrowDown"
			) {
				e.preventDefault();
				const move_x = e.key == "ArrowLeft" ? -1 : e.key == "ArrowRight" ? 1 : 0;
				const move_y = e.key == "ArrowUp" ? -1 : e.key == "ArrowDown" ? 1 : 0;
				navigate_grid(move_x, move_y, e);
				// @TODO: wrap around columns in list view
			} else if (
				e.key == "PageUp" ||
				e.key == "PageDown"
			) {
				e.preventDefault();
				if (self.config.view_mode === FolderView.VIEW_MODES.LIST) {
					const x_dir = e.key == "PageUp" ? -1 : 1;
					const full_page_size = $folder_view.width();
					const item_width = $folder_view.find(".desktop-icon").outerWidth();
					const page_increment = full_page_size - item_width;
					for (let increment = page_increment; increment > 0; increment -= item_width) {
						if (navigate_grid(x_dir * increment / item_width, 0, e)) { // grid units
							break;
						}
					}
				} else {
					const y_dir = e.key == "PageUp" ? -1 : 1;
					const full_page_size = $folder_view.height();
					const item_height = $folder_view.find(".desktop-icon").outerHeight();
					const page_increment = full_page_size - item_height;
					for (let increment = page_increment; increment > 0; increment -= item_height) {
						if (navigate_grid(0, y_dir * increment / item_height, e)) { // grid units
							break;
						}
					}
				}
			} else if (e.key == "Home") {
				e.preventDefault();
				select_item(self.items[0], e);
			} else if (e.key == "End") {
				e.preventDefault();
				select_item(self.items[self.items.length - 1], e);
			} else if (e.key == " " && search_string.length === 0) {
				// Usually there's something focused,
				// so this is pretty "niche", but space bar selects the focused item.
				// Ctrl+Space toggles selection of the focused item.
				e.preventDefault();
				if ((e.ctrlKey || e.metaKey) && $folder_view.find(".desktop-icon.selected").length > 0) {
					$folder_view.find(".desktop-icon.focused").toggleClass("selected");
				} else {
					$folder_view.find(".desktop-icon.focused").addClass("selected"); // don't use select_item() as it shouldn't unselect anything
				}
				updateStatus();
			} else if (e.key === "F2") {
				e.preventDefault();
				self.start_rename();
			} else {
				if (e.isDefaultPrevented() || e.ctrlKey || e.altKey || e.metaKey) {
					return;
				}
				if (search_timeout) {
					clearTimeout(search_timeout);
				}
				if (search_string === e.key) {
					// cycle through items starting with the same letter
					// Note: not adding to search_string here, so it stays as e.key
					// @TODO: what if you have an item like "Llama Photos", can you not search for "Llama" to go to it, in the presence of other 'L' items?
					const candidates = self.items.filter((item) => {
						const title = item.element.querySelector(".title").textContent; // @TODO: proper access
						return title.toLocaleLowerCase().startsWith(search_string.toLocaleLowerCase());
					});
					if (candidates.length > 0) {
						const index = candidates.findIndex((item) => item.element.classList.contains("focused"));
						if (index === -1) {
							select_item(candidates[0], e);
						} else {
							select_item(candidates[(index + 1) % candidates.length], e);
						}
					}
				} else {
					// focus item matching search string
					if (e.key !== "Shift" && e.key !== "Compose") { // Note: composition doesn't actually work; I'd need an input element to do this properly
						search_string += e.key;
					}
					// console.log("search_string: " + search_string);
					search_timeout = setTimeout(function () {
						search_string = "";
						// console.log("reset search_string");
					}, 1000);

					if (search_string.length > 0) {
						for (const item of self.items) {
							const title = item.element.querySelector(".title").textContent; // @TODO: proper access
							if (title.toLocaleLowerCase().startsWith(search_string.toLocaleLowerCase())) {
								select_item(item, {}); // passing fake event so it doesn't use shiftKey to determine multi-select
								break;
							}
						}
					}
				}
			}
		});

		var selection_anchor_item_el;

		function select_item(item_or_item_el, event, delay_scroll) {
			const item_el_to_select = item_or_item_el instanceof Element ? item_or_item_el : item_or_item_el.element;
			const extend_selection = event.shiftKey;
			if (selection_anchor_item_el && !self.items.some(item => item.element === selection_anchor_item_el)) {
				selection_anchor_item_el = null; // item was removed somehow
			}
			if (extend_selection && !selection_anchor_item_el) {
				// select_item() hasn't been called yet (e.g. hitting Shift+Down without first hitting an arrow key without Shift, in a newly loaded folder view)
				// use the focused item as the anchor
				selection_anchor_item_el = self.items.find((item) => item.element.classList.contains("focused"))/*?*/.element ||/*??*/ item_el_to_select;
			}
			// console.log("select_item", item_or_item_el, event, "extend_selection", extend_selection);
			$folder_view.find(".desktop-icon").each(function (i, item_el) {
				if (extend_selection) {
					// select items in a rectangle between the anchor and the new item
					const anchor_rect = selection_anchor_item_el.getBoundingClientRect();
					const item_el_to_select_rect = item_el_to_select.getBoundingClientRect();
					const item_el_rect = item_el.getBoundingClientRect();
					const rectangle = {
						top: Math.min(anchor_rect.top, item_el_to_select_rect.top),
						left: Math.min(anchor_rect.left, item_el_to_select_rect.left),
						bottom: Math.max(anchor_rect.bottom, item_el_to_select_rect.bottom),
						right: Math.max(anchor_rect.right, item_el_to_select_rect.right)
					};
					$(item_el).toggleClass("selected", (
						item_el_rect.top >= rectangle.top &&
						item_el_rect.left >= rectangle.left &&
						item_el_rect.bottom <= rectangle.bottom &&
						item_el_rect.right <= rectangle.right
					));
				} else {
					if (event.type === "pointerdown" && (event.ctrlKey || event.metaKey)) {
						// toggle with Ctrl+click
						if (item_el === item_el_to_select) {
							$(item_el).toggleClass("selected");
						}
					} else {
						// select with click or arrow keys,
						// but if holding Ctrl it should only move focus, not select.
						if (!event.ctrlKey && !event.metaKey) {
							item_el.classList.toggle("selected", item_el === item_el_to_select);
						}
					}
				}
				item_el.classList.toggle("focused", item_el === item_el_to_select);
			});
			if (delay_scroll) {
				// Windows 98 does this for clicks.
				// I'm not sure if it's to make it less jarring (I feel like there's a case for that),
				// or if it's to avoid some problems with drag and drop perhaps.
				setTimeout(() => {
					item_el_to_select.scrollIntoView({ block: "nearest" });
				}, 500);
			} else {
				item_el_to_select.scrollIntoView({ block: "nearest" });
			}
			updateStatus();

			if (!event.shiftKey) {
				selection_anchor_item_el = item_el_to_select;
			}
		}

		function navigate_grid(move_x, move_y, event) {
			// @TODO: how this is supposed to work for icons not aligned to the grid?
			// I can imagine a few ways of doing it, like scanning for the nearest icon with a sweeping line or perhaps a "cone" (triangle) (changing width line)
			// but it'd be nice to know for sure

			let $starting_icon = $folder_view.find(".desktop-icon.focused");
			// ideally we'd keep a focused icon always,
			// use the nearest icon upwards after a delete etc.
			// but I can't guarantee that
			if ($starting_icon.length == 0) {
				$starting_icon = $folder_view.find(".desktop-icon");
			}
			if ($starting_icon.length == 0) {
				return false;
			}
			// @TODO: use the actual grid size, not a calculated item size
			// or make it more grid-agnostic (Windows 98 allowed freely moving icons around)
			const item_width = $starting_icon.outerWidth();
			const item_height = $starting_icon.outerHeight();
			// const item_pos = $starting_icon.position();
			const item_pos = $starting_icon[0].getBoundingClientRect();
			let x = item_pos.left;// + item_width / 2;
			let y = item_pos.top;// + item_height / 2;
			x += move_x * item_width;
			y += move_y * item_height;
			const candidates = $folder_view.find(".desktop-icon").toArray().sort(function (a, b) {
				// const a_pos = $(a).position();
				// const b_pos = $(b).position();
				const a_pos = a.getBoundingClientRect();
				const b_pos = b.getBoundingClientRect();
				const a_dist = Math.abs(a_pos.left - x) + Math.abs(a_pos.top - y);
				const b_dist = Math.abs(b_pos.left - x) + Math.abs(b_pos.top - y);
				return a_dist - b_dist;
			});
			const $icon = $(candidates[0]);
			if ($icon.length > 0) {
				select_item($icon[0], event);
				return true;
			}
			return false;
		}

		var stat = function (file_path) {
			// fs should be guaranteed available at this point
			// as this function is currently used
			var fs = BrowserFS.BFSRequire('fs');
			return new Promise(function (resolve, reject) {
				fs.stat(file_path, function (err, stats) {
					if (err) {
						return reject(err);
					}
					resolve(stats);
				});
			});
		};
		var icon_id_from_stats_and_path = function (stats, file_path) {
			if (stats.isDirectory()) {
				// if extending this to different folder icons,
				// note that "folder" is relied on (for sorting)
				return "folder";
			}
			var file_extension = helpers.file_extension_from_path(file_path);
			// TODO: look inside exe for icons
			var icon_name = file_extension_icons[file_extension.toLowerCase()];
			return icon_name || "document";
		};
		var icons_from_icon_id = function (icon_id) {
			return {
				16: helpers.getIconPath(icon_id, 16),
				32: helpers.getIconPath(icon_id, 32),
				48: helpers.getIconPath(icon_id, 48),
			};
		};

		// var add_fs_item = function(file_path, x, y){
		var add_fs_item = function (initial_file_name, x, y) {
			var initial_file_path = folder_path + initial_file_name;
			var item = new FolderViewItem({
				title: initial_file_name,
				open: async function () {
					if (openFolder) {
						let stats = item.resolvedStats;
						if (!stats) {
							if (item.pendingStatPromise) {
								try {
									stats = await item.pendingStatPromise;
								} catch (error) {
									alert(`Failed to get info about '${item.file_path}':\n\n${error}`);
									return;
								}
							} else {
								alert(`Cannot open '${item.file_path}'. File type information not available.`);
								return;
							}
						}
						if (stats.isDirectory()) {
							openFolder(item.file_path);
							return;
						}
					}
					if (openFileOrFolder) {
						openFileOrFolder(item.file_path);
						return;
					}
					alert(`No handler for opening files or folders.`);
				},
				rename: (new_name) => {
					var fs = BrowserFS.BFSRequire('fs');
					return new Promise(function (resolve, reject) {
						const new_file_path = folder_path + new_name;
						fs.rename(item.file_path, new_file_path, function (err) {
							if (err) {
								return reject(err);
							}
							resolve();
							item.file_path = new_file_path;
							item.title = new_name;
							item.element.dataset.filePath = new_file_path;
							if (item.resolvedStats) {
								const icon_id = icon_id_from_stats_and_path(item.resolvedStats, new_file_path);
								item.setIcons(icons_from_icon_id(icon_id));
							} // else the icon will be updated when the stats are resolved
						});
					});
				},
				shortcut: initial_file_path.match(/\.url$/),
				file_path: initial_file_path,
				iconSize: icon_size_by_view_mode[self.config.view_mode],
			});
			item.pendingStatPromise = stat(initial_file_path);
			item.pendingStatPromise.then((stats) => {
				item.pendingStatPromise = null;
				item.resolvedStats = stats; // trying to indicate in the name the async nature
				// @TODO: know which sizes are available
				const icon_id = icon_id_from_stats_and_path(stats, item.file_path);
				item.setIcons(icons_from_icon_id(icon_id));
			}, (error) => {
				// Without this, the folder view infinitely recursed arranging items because
				// it was waiting for the promise to be settled (resolved or rejected),
				// but checking for item.pendingStatPromise to see if it's still pending.
				item.pendingStatPromise = null;
			});
			self.add_item(item);
			$(item.element).css({
				left: x,
				top: y,
			});
		};
		var drop_file = function (file, x, y) {

			var Buffer = BrowserFS.BFSRequire('buffer').Buffer;
			var fs = BrowserFS.BFSRequire('fs');

			var file_path = folder_path + file.name;

			var reader = new FileReader;
			reader.onerror = function (error) {
				throw error;
			};
			reader.onload = function (e) {
				var buffer = Buffer.from(reader.result);
				fs.writeFile(file_path, buffer, { flag: "wx" }, function (error) {
					if (error) {
						if (error.code === "EEXIST") {
							// TODO: options to replace or keep both files with numbers like "file (1).txt"
							alert("File already exists!");
						}
						throw error;
					}
					// TODO: could do utimes as well with file.lastModified or file.lastModifiedDate

					add_fs_item(file.name, x, y);
				});
			};
			reader.readAsArrayBuffer(file);
		};

		var dragover_pageX = 0;
		var dragover_pageY = 0;
		$folder_view.on("dragover", function (e) {
			e.preventDefault();
			dragover_pageX = e.originalEvent.pageX;
			dragover_pageY = e.originalEvent.pageY;
		});
		$folder_view.on("drop", function (e) {
			e.preventDefault();
			var x = e.originalEvent.pageX || dragover_pageX;
			var y = e.originalEvent.pageY || e.dragover_pageY
			// TODO: handle dragging icons onto other icons
			withFilesystem(function () {
				var files = e.originalEvent.dataTransfer.files;
				$.map(files, function (file) {
					// TODO: stagger positions, don't just put everything on top of each other
					// also center on the mouse position; currently it's placed via the top left
					drop_file(file, x, y);
				});
			});
		});
	}

	return FolderView;
});
define('skylark-98js/os-gui/$Window',[
	"skylark-jquery",
	"../win98"
],function($,win98js){

	// TODO: E\("([a-z]+)"\) -> "<$1>" or get rid of jQuery as a dependency
	function E(tagName) {
		return document.createElement(tagName);
	}

	function element_to_string(element) {
		// returns a CSS-selector-like string for the given element
		// if (element instanceof Element) { // doesn't work with different window.Element from iframes
		if (typeof element === "object" && "tagName" in element) {
			return element.tagName.toLowerCase() +
				(element.id ? "#" + element.id : "") +
				(element.className ? "." + element.className.split(" ").join(".") : "") +
				(element.src ? `[src="${element.src}"]` : "") + // Note: not escaped; may not actually work as a selector (but this is for debugging)
				(element.srcdoc ? "[srcdoc]" : "") + // (srcdoc can be long)
				(element.href ? `[href="${element.href}"]` : "");
		} else if (element) {
			return element.constructor.name;
		} else {
			return `${element}`;
		}
	}

	function find_tabstops(container_el) {
		const $el = $(container_el);
		// This function finds focusable controls, but not necessarily all of them;
		// for radio elements, it only gives one: either the checked one, or the first one if none are checked.

		// Note: for audio[controls], Chrome at least has two tabstops (the audio element and three dots menu button).
		// It might be possible to detect this in the shadow DOM, I don't know, I haven't worked with the shadow DOM.
		// But it might be more reliable to make a dummy tabstop element to detect when you tab out of the first/last element.
		// Also for iframes!
		// Assuming that doesn't mess with screen readers.
		// Right now you can't tab to the three dots menu if it's the last element.
		// @TODO: see what ally.js does. Does it handle audio[controls]? https://allyjs.io/api/query/tabsequence.html

		let $controls = $el.find(`
			input:enabled,
			textarea:enabled,
			select:enabled,
			button:enabled,
			a[href],
			[tabIndex='0'],
			details summary,
			iframe,
			object,
			embed,
			video[controls],
			audio[controls],
			[contenteditable]:not([contenteditable='false'])
		`).filter(":visible");
		// const $controls = $el.find(":tabbable"); // https://api.jqueryui.com/tabbable-selector/

		// Radio buttons should be treated as a group with one tabstop.
		// If there's no selected ("checked") radio, it should still visit the group,
		// but if there is a selected radio in the group, it should skip all unselected radios in the group.
		const radios = {}; // best radio found so far, per group
		const to_skip = [];
		for (const el of $controls.toArray()) {
			if (el.nodeName.toLowerCase() === "input" && el.type === "radio") {
				if (radios[el.name]) {
					if (el.checked) {
						to_skip.push(radios[el.name]);
						radios[el.name] = el;
					} else {
						to_skip.push(el);
					}
				} else {
					radios[el.name] = el;
				}
			}
		}
		const $tabstops = $controls.not(to_skip);
		// debug viz:
		// $tabstops.css({boxShadow: "0 0 2px 2px green"});
		// $(to_skip).css({boxShadow: "0 0 2px 2px gray"})
		return $tabstops;
	}
	var $G = $(window);


	$Window.Z_INDEX = 5;

	var minimize_slots = []; // for if there's no taskbar

	// @TODO: make this a class,
	// instead of a weird pseudo-class
	function $Window(options) {
		options = options || {};
		// @TODO: handle all option defaults here
		// and validate options.

		var $w = $(E("div")).addClass("window os-window").appendTo("body");
		$w[0].$window = $w;
		$w.element = $w[0];
		$w[0].id = `os-window-${Math.random().toString(36).substr(2, 9)}`;
		$w.$titlebar = $(E("div")).addClass("window-titlebar").appendTo($w);
		$w.$title_area = $(E("div")).addClass("window-title-area").appendTo($w.$titlebar);
		$w.$title = $(E("span")).addClass("window-title").appendTo($w.$title_area);
		if (options.toolWindow) {
			options.minimizeButton = false;
			options.maximizeButton = false;
		}
		if (options.minimizeButton !== false) {
			$w.$minimize = $(E("button")).addClass("window-minimize-button window-action-minimize window-button").appendTo($w.$titlebar);
			$w.$minimize.attr("aria-label", "Minimize window"); // @TODO: for taskbarless minimized windows, "restore"
			$w.$minimize.append("<span class='window-button-icon'></span>");
		}
		if (options.maximizeButton !== false) {
			$w.$maximize = $(E("button")).addClass("window-maximize-button window-action-maximize window-button").appendTo($w.$titlebar);
			$w.$maximize.attr("aria-label", "Maximize or restore window"); // @TODO: specific text for the state
			if (!options.resizable) {
				$w.$maximize.attr("disabled", true);
			}
			$w.$maximize.append("<span class='window-button-icon'></span>");
		}
		if (options.closeButton !== false) {
			$w.$x = $(E("button")).addClass("window-close-button window-action-close window-button").appendTo($w.$titlebar);
			$w.$x.attr("aria-label", "Close window");
			$w.$x.append("<span class='window-button-icon'></span>");
		}
		$w.$content = $(E("div")).addClass("window-content").appendTo($w);
		$w.$content.attr("tabIndex", "-1");
		$w.$content.css("outline", "none");
		if (options.toolWindow) {
			$w.addClass("tool-window");
		}
		if (options.parentWindow) {
			options.parentWindow.addChildWindow($w);
			// semantic parent logic is currently only suited for tool windows
			// for dialog windows, it would make the dialog window not show as focused
			// (alternatively, I could simply, when following the semantic parent chain, look for windows that are not tool windows)
			if (options.toolWindow) {
				$w[0].dataset.semanticParent = options.parentWindow[0].id;
			}
		}

		var $component = options.$component;
		if (typeof options.icon === "object" && "tagName" in options.icon) {
			options.icons = { any: options.icon };
		} else if (options.icon) {
			// old terrible API using globals that you have to define
			console.warn("DEPRECATED: use options.icons instead of options.icon, e.g. new $Window({icons: {16: 'app-16x16.png', any: 'app-icon.svg'}})");
			if (typeof $Icon !== "undefined" && typeof TITLEBAR_ICON_SIZE !== "undefined") {
				$w.icon_name = options.icon;
				$w.$icon = $Icon(options.icon, TITLEBAR_ICON_SIZE).prependTo($w.$titlebar);
			} else {
				throw new Error("Use {icon: img_element} or {icons: {16: url_or_img_element}} options");
			}
		}
		$w.icons = options.icons || {};
		let iconSize = 16;
		$w.setTitlebarIconSize = function (target_icon_size) {
			if ($w.icons) {
				$w.$icon && $w.$icon.remove();
				$w.$icon = $($w.getIconAtSize(target_icon_size));
				$w.$icon.prependTo($w.$titlebar);
			}
			iconSize = target_icon_size;
			$w.trigger("icon-change");
		};
		$w.getTitlebarIconSize = function () {
			return iconSize;
		};
		// @TODO: this could be a static method, like OSGUI.getIconAtSize(icons, targetSize)
		$w.getIconAtSize = function (target_icon_size) {
			let icon_size;
			if ($w.icons[target_icon_size]) {
				icon_size = target_icon_size;
			} else if ($w.icons["any"]) {
				icon_size = "any";
			} else {
				const sizes = Object.keys($w.icons).filter(size => isFinite(size) && isFinite(parseFloat(size)));
				sizes.sort((a, b) => Math.abs(a - target_icon_size) - Math.abs(b - target_icon_size));
				icon_size = sizes[0];
			}
			if (icon_size) {
				const icon = $w.icons[icon_size];
				let icon_element;
				if (icon.nodeType !== undefined) {
					icon_element = icon.cloneNode(true);
				} else {
					icon_element = E("img");
					const $icon = $(icon_element);
					if (icon.srcset) {
						$icon.attr("srcset", icon.srcset);
					} else {
						$icon.attr("src", icon.src || icon);
					}
					$icon.attr({
						width: icon_size,
						height: icon_size,
						draggable: false,
					});
					$icon.css({
						width: target_icon_size,
						height: target_icon_size,
					});
				}
				return icon_element;
			}
			return null;
		};
		// @TODO: automatically update icon size based on theme (with a CSS variable)
		$w.setTitlebarIconSize(iconSize);

		$w.getIconName = () => {
			console.warn("DEPRECATED: use $w.icons object instead of $w.icon_name");
			return $w.icon_name;
		};
		$w.setIconByID = (icon_name) => {
			console.warn("DEPRECATED: use $w.setIcons(icons) instead of $w.setIconByID(icon_name)");
			var old_$icon = $w.$icon;
			$w.$icon = $Icon(icon_name, TITLEBAR_ICON_SIZE);
			old_$icon.replaceWith($w.$icon);
			$w.icon_name = icon_name;
			$w.task && $w.task.updateIcon();
			$w.trigger("icon-change");
			return $w;
		};
		$w.setIcons = (icons) => {
			$w.icons = icons;
			$w.setTitlebarIconSize(iconSize);
			$w.task && $w.task.updateIcon();
			// icon-change already sent by setTitlebarIconSize
		};

		if ($component) {
			$w.addClass("component-window");
		}

		setTimeout(() => {
			if (get_direction() == "rtl") {
				$w.addClass("rtl"); // for reversing the titlebar gradient
			}
		}, 0);

		// returns writing/layout direction, "ltr" or "rtl"
		function get_direction() {
			return window.get_direction ? window.get_direction() : getComputedStyle($w[0]).direction;
		}

		// This is very silly, using jQuery's event handling to implement simpler event handling.
		// But I'll implement it in a non-silly way at least when I remove jQuery. Maybe sooner.
		const $event_target = $({});
		const make_simple_listenable = (name) => {
			return (callback) => {
				const fn = () => {
					callback();
				};
				$event_target.on(name, fn);
				const dispose = () => {
					$event_target.off(name, fn);
				};
				return dispose;
			};
		};
		$w.onFocus = make_simple_listenable("focus");
		$w.onBlur = make_simple_listenable("blur");
		$w.onClosed = make_simple_listenable("closed");

		$w.setDimensions = ({ innerWidth, innerHeight, outerWidth, outerHeight }) => {
			let width_from_frame, height_from_frame;
			// It's good practice to make all measurements first, then update the DOM.
			// Once you update the DOM, the browser has to recalculate layout, which can be slow.
			if (innerWidth) {
				width_from_frame = $w.outerWidth() - $w.$content.outerWidth();
			}
			if (innerHeight) {
				height_from_frame = $w.outerHeight() - $w.$content.outerHeight();
				const $menu_bar = $w.$content.find(".menus"); // only if inside .content; might move to a slot outside .content later
				if ($menu_bar.length) {
					// maybe this isn't technically part of the frame, per se? but it's part of the non-client area, which is what I technically mean.
					height_from_frame += $menu_bar.outerHeight();
				}
			}
			if (outerWidth) {
				$w.outerWidth(outerWidth);
			}
			if (outerHeight) {
				$w.outerHeight(outerHeight);
			}
			if (innerWidth) {
				$w.outerWidth(innerWidth + width_from_frame);
			}
			if (innerHeight) {
				$w.outerHeight(innerHeight + height_from_frame);
			}
		};
		$w.setDimensions(options);

		let child_$windows = [];
		$w.addChildWindow = ($child_window) => {
			child_$windows.push($child_window);
		};
		const showAsFocused = () => {
			if ($w.hasClass("focused")) {
				return;
			}
			$w.addClass("focused");
			$event_target.triggerHandler("focus");
			$w.trigger("focus");
		};
		const stopShowingAsFocused = () => {
			if (!$w.hasClass("focused")) {
				return;
			}
			$w.removeClass("focused");
			$event_target.triggerHandler("blur");
			$w.trigger("blur");
		};
		$w.focus = () => {
			// showAsFocused();	
			$w.bringToFront();
			refocus();
		};
		$w.blur = () => {
			stopShowingAsFocused();
			if (document.activeElement && document.activeElement.closest(".window") == $w[0]) {
				document.activeElement.blur();
			}
		};

		if (options.toolWindow) {
			if (options.parentWindow) {
				options.parentWindow.onFocus(showAsFocused);
				options.parentWindow.onBlur(stopShowingAsFocused);
				// TODO: also show as focused if focus is within the window

				// initial state
				// might need a setTimeout, idk...
				if (document.activeElement && document.activeElement.closest(".window") == options.parentWindow[0]) {
					showAsFocused();
				}
			} else {
				// the browser window is the parent window
				// show focus whenever the browser window is focused
				$(window).on("focus", showAsFocused);
				$(window).on("blur", stopShowingAsFocused);
				// initial state
				if (document.hasFocus()) {
					showAsFocused();
				}
			}
		} else {
			// global focusout is needed, to continue showing as focused while child windows or menu popups are focused (@TODO: Is this redundant with focusin?)
			// global focusin is needed, to show as focused when a child window becomes focused (when perhaps nothing was focused before, so no focusout event)
			// global blur is needed, to show as focused when an iframe gets focus, because focusin/out doesn't fire at all in that case
			// global focus is needed, to stop showing as focused when an iframe loses focus
			// pretty ridiculous!!
			// but it still doesn't handle the case where the browser window is not focused, and the user clicks an iframe directly.
			// for that, we need to listen inside the iframe, because no events are fired at all outside in that case,
			// and :focus/:focus-within doesn't work with iframes so we can't even do a hack with transitionstart.
			// @TODO: simplify the strategy; I ended up piling a few strategies on top of each other, and the earlier ones may be redundant.
			// In particular, 1. I ended up making it proactively inject into iframes, rather than when focused since there's a case where focus can't be detected otherwise.
			// 2. I ended up simulating focusin events for iframes.
			// I may want to rely on that, or, I may want to remove that and set up a refocus chain directly instead,
			// avoiding refocus() which may interfere with drag operations in an iframe when focusing the iframe (e.g. clicking into Paint to draw or drag a sub-window).

			// console.log("adding global focusin/focusout/blur/focus for window", $w[0].id);
			const global_focus_update_handler = make_focus_in_out_handler($w[0], true); // must be $w and not $content so semantic parent chain works, with [data-semantic-parent] pointing to the window not the content
			window.addEventListener("focusin", global_focus_update_handler);
			window.addEventListener("focusout", global_focus_update_handler);
			window.addEventListener("blur", global_focus_update_handler);
			window.addEventListener("focus", global_focus_update_handler);

			function setupIframe(iframe) {
				if (!focus_update_handlers_by_container.has(iframe)) {
					const iframe_update_focus = make_focus_in_out_handler(iframe, false);
					// this also operates as a flag to prevent multiple handlers from being added, or waiting for the iframe to load duplicately
					focus_update_handlers_by_container.set(iframe, iframe_update_focus);

					// @TODO: try removing setTimeout(s)
					setTimeout(() => { // for iframe src to be set? I forget.
						// Note: try must be INSIDE setTimeout, not outside, to work.
						try {
							const wait_for_iframe_load = (callback) => {
								// Note: error may occur accessing iframe.contentDocument; this must be handled by the caller.
								// To that end, this function must access it synchronously, to allow the caller to handle the error.
								if (iframe.contentDocument.readyState == "complete") {
									callback();
								} else {
									// iframe.contentDocument.addEventListener("readystatechange", () => {
									// 	if (iframe.contentDocument.readyState == "complete") {
									// 		callback();
									// 	}
									// });
									setTimeout(() => {
										wait_for_iframe_load(callback);
									}, 100);
								}
							};
							wait_for_iframe_load(() => {
								// console.log("adding focusin/focusout/blur/focus for iframe", iframe);
								iframe.contentWindow.addEventListener("focusin", iframe_update_focus);
								iframe.contentWindow.addEventListener("focusout", iframe_update_focus);
								iframe.contentWindow.addEventListener("blur", iframe_update_focus);
								iframe.contentWindow.addEventListener("focus", iframe_update_focus);
								observeIframes(iframe.contentDocument);
							});
						} catch (error) {
							warn_iframe_access(iframe, error);
						}
					}, 100);
				}
			}

			function observeIframes(container_node) {
				const observer = new MutationObserver((mutations) => {
					for (const mutation of mutations) {
						for (const node of mutation.addedNodes) {
							if (node.tagName == "IFRAME") {
								setupIframe(node);
							}
						}
					}
				});
				observer.observe(container_node, { childList: true, subtree: true });
				// needed in recursive calls (for iframes inside iframes)
				// (for the window, it shouldn't be able to have iframes yet)
				for (const iframe of container_node.querySelectorAll("iframe")) {
					setupIframe(iframe);
				}
			}

			observeIframes($w.$content[0]);
			
			function make_focus_in_out_handler(logical_container_el, is_root) {
				// In case of iframes, logical_container_el is the iframe, and container_node is the iframe's contentDocument.
				// container_node is not a parameter here because it can change over time, may be an empty document before the iframe is loaded.

				return function handle_focus_in_out(event) {
					const container_node = logical_container_el.tagName == "IFRAME" ? logical_container_el.contentDocument : logical_container_el;
					const document = container_node.ownerDocument /*??*/ ||  container_node;
					// is this equivalent?
					// const document = logical_container_el.tagName == "IFRAME" ? logical_container_el.contentDocument : logical_container_el.ownerDocument;

					// console.log(`handling ${event.type} for container`, container_el);
					let newly_focused = event ? (event.type === "focusout" || event.type === "blur") ? event.relatedTarget : event.target : document.activeElement;
					if (event && event.type === "blur") {
						newly_focused = null; // only handle iframe
					}

					// console.log(`[${$w.title()}] (is_root=${is_root})`, `newly_focused is (preliminarily)`, element_to_string(newly_focused), `\nlogical_container_el`, logical_container_el, `\ncontainer_node`, container_node, `\ndocument.activeElement`, document.activeElement, `\ndocument.hasFocus()`, document.hasFocus(), `\ndocument`, document);

					// Iframes are stingy about focus events, so we need to check if focus is actually within an iframe.
					if (
						document.activeElement &&
						document.activeElement.tagName === "IFRAME" &&
						(event && event.type === "focusout" || event && event.type === "blur") &&
						!newly_focused // doesn't exist for security reasons in this case
					) {
						newly_focused = document.activeElement;
						// console.log(`[${$w.title()}] (is_root=${is_root})`, `newly_focused is (actually)`, element_to_string(newly_focused));
					}

					const outside_or_at_exactly =
						!newly_focused ||
						// contains() only works with DOM nodes (elements and documents), not window objects.
						// Since container_node is a DOM node, it will never have a Window inside of it (ignoring iframes).
						newly_focused.window === newly_focused || // is a Window object (cross-frame test)
						!container_node.contains(newly_focused); // Note: node.contains(node) === true
					const firmly_outside = outside_or_at_exactly && container_node !== newly_focused;

					// console.log(`[${$w.title()}] (is_root=${is_root})`, `outside_or_at_exactly=${outside_or_at_exactly}`, `firmly_outside=${firmly_outside}`);
					if (firmly_outside && is_root) {
						stopShowingAsFocused();
					}
					if (
						!outside_or_at_exactly &&
						newly_focused.tagName !== "HTML" &&
						newly_focused.tagName !== "BODY" &&
						newly_focused !== container_node &&
						!newly_focused.matches(".window-content") &&
						!newly_focused.closest(".menus") &&
						!newly_focused.closest(".window-titlebar")
					) {
						last_focus_by_container.set(logical_container_el, newly_focused); // overwritten for iframes below
						debug_focus_tracking(document, container_node, newly_focused, is_root);
					}

					if (
						!outside_or_at_exactly &&
						newly_focused.tagName === "IFRAME"
					) {
						const iframe = newly_focused;
						// console.log("iframe", iframe, onfocusin_by_container.has(iframe));
						try {
							const focus_in_iframe = iframe.contentDocument.activeElement;
							if (
								focus_in_iframe &&
								focus_in_iframe.tagName !== "HTML" &&
								focus_in_iframe.tagName !== "BODY" &&
								!focus_in_iframe.closest(".menus")
							) {
								// last_focus_by_container.set(logical_container_el, iframe); // done above
								last_focus_by_container.set(iframe, focus_in_iframe);
								debug_focus_tracking(iframe.contentDocument, iframe.contentDocument, focus_in_iframe, is_root);
							}
						} catch (e) {
							warn_iframe_access(iframe, e);
						}
					}


					// For child windows and menu popups, follow "semantic parent" chain.
					// Menu popups and child windows aren't descendants of the window they belong to,
					// but should keep the window shown as focused.
					// (In principle this sort of feature could be useful for focus tracking*,
					// but right now it's only for child windows and menu popups, which should not be tracked for refocus,
					// so I'm doing this after last_focus_by_container.set, for now anyway.)
					// ((*: and it may even be surprising if it doesn't work, if one sees the attribute on menus and attempts to use it.
					// But who's going to see that? The menus close so it's a pain to see the DOM structure! :P **))
					// (((**: without window.debugKeepMenusOpen)))
					if (is_root) {
						do {
							// if (!newly_focused?.closest) {
							// 	console.warn("what is this?", newly_focused);
							// 	break;
							// }
							const waypoint = newly_focused && newly_focused.closest && newly_focused.closest("[data-semantic-parent]");
							if (waypoint) {
								const id = waypoint.dataset.semanticParent;
								const parent = waypoint.ownerDocument.getElementById(id);
								// console.log("following semantic parent, from", newly_focused, "\nto", parent, "\nvia", waypoint);
								newly_focused = parent;
								if (!parent) {
									console.warn("semantic parent not found with id", id);
									break;
								}
							} else {
								break;
							}
						} while (true);
					}

					// Note: allowing showing window as focused from listeners inside iframe (non-root) too,
					// in order to handle clicking an iframe when the browser window was not previously focused (e.g. after reload)
					if (
						newly_focused &&
						newly_focused.window !== newly_focused && // cross-frame test for Window object
						container_node.contains(newly_focused)
					) {
						showAsFocused();
						$w.bringToFront();
						if (!is_root) {
							// trigger focusin events for iframes
							// @TODO: probably don't need showAsFocused() here since it'll be handled externally (on this simulated focusin),
							// and might not need a lot of other logic frankly if I'm simulating focusin events
							let el = logical_container_el;
							while (el) {
								// console.log("dispatching focusin event for", el);
								el.dispatchEvent(new Event("focusin", {
									bubbles: true,
									target: el,
									view: el.ownerDocument.defaultView,
								}));
								el = el.currentView && el.currentView.frameElement;
							}
						}
					} else if (is_root) {
						stopShowingAsFocused();
					}
				}
			}
			// initial state is unfocused
		}

		$w.css("touch-action", "none");

		let minimize_target_el = null; // taskbar button (optional)
		$w.setMinimizeTarget = function (new_taskbar_button_el) {
			minimize_target_el = new_taskbar_button_el;
		};

		let task;
		Object.defineProperty($w, "task", {
			get() {
				return task;
			},
			set(new_task) {
				console.warn("DEPRECATED: use $w.setMinimizeTarget(taskbar_button_el) instead of setting $window.task object");
				task = new_task;
			},
		});

		let before_minimize;
		$w.minimize = () => {
			minimize_target_el = minimize_target_el || task && task.$task[0];
			if (animating_titlebar) {
				when_done_animating_titlebar.push($w.minimize);
				return;
			}
			if ($w.is(":visible")) {
				if (minimize_target_el && !$w.hasClass("minimized-without-taskbar")) {
					const before_rect = $w.$titlebar[0].getBoundingClientRect();
					const after_rect = minimize_target_el.getBoundingClientRect();
					$w.animateTitlebar(before_rect, after_rect, () => {
						$w.hide();
						$w.blur();
					});
				} else {
					// no taskbar

					// @TODO: make this metrically similar to what Windows 98 does
					// @TODO: DRY! This is copied heavily from maximize()
					// @TODO: after minimize (without taskbar) and maximize, restore should restore original position before minimize
					// OR should it not maximize but restore the unmaximized state? I think I tested it but I forget.

					const to_width = 150;
					const spacing = 10;
					if ($w.hasClass("minimized-without-taskbar")) {
						// unminimizing
						minimize_slots[$w._minimize_slot_index] = null;
					} else {
						// minimizing
						let i = 0;
						while (minimize_slots[i]) {
							i++;
						}
						$w._minimize_slot_index = i;
						minimize_slots[i] = $w;
					}
					const to_x = $w._minimize_slot_index * (to_width + spacing) + 10;
					const titlebar_height = $w.$titlebar.outerHeight();
					let before_unminimize;
					const instantly_minimize = () => {
						before_minimize = {
							position: $w.css("position"),
							left: $w.css("left"),
							top: $w.css("top"),
							width: $w.css("width"),
							height: $w.css("height"),
						};

						$w.addClass("minimized-without-taskbar");
						if ($w.hasClass("maximized")) {
							$w.removeClass("maximized");
							$w.addClass("was-maximized");
							$w.$maximize.removeClass("window-action-restore");
							$w.$maximize.addClass("window-action-maximize");
						}
						$w.$minimize.removeClass("window-action-minimize");
						$w.$minimize.addClass("window-action-restore");
						if (before_unminimize) {
							$w.css({
								position: before_unminimize.position,
								left: before_unminimize.left,
								top: before_unminimize.top,
								width: before_unminimize.width,
								height: before_unminimize.height,
							});
						} else {
							$w.css({
								position: "fixed",
								top: `calc(100% - ${titlebar_height + 5}px)`,
								left: to_x,
								width: to_width,
								height: titlebar_height,
							});
						}
					};
					const instantly_unminimize = () => {
						before_unminimize = {
							position: $w.css("position"),
							left: $w.css("left"),
							top: $w.css("top"),
							width: $w.css("width"),
							height: $w.css("height"),
						};

						$w.removeClass("minimized-without-taskbar");
						if ($w.hasClass("was-maximized")) {
							$w.removeClass("was-maximized");
							$w.addClass("maximized");
							$w.$maximize.removeClass("window-action-maximize");
							$w.$maximize.addClass("window-action-restore");
						}
						$w.$minimize.removeClass("window-action-restore");
						$w.$minimize.addClass("window-action-minimize");
						$w.css({ width: "", height: "" });
						if (before_minimize) {
							$w.css({
								position: before_minimize.position,
								left: before_minimize.left,
								top: before_minimize.top,
								width: before_minimize.width,
								height: before_minimize.height,
							});
						}
					};

					const before_rect = $w.$titlebar[0].getBoundingClientRect();
					let after_rect;
					$w.css("transform", "");
					if ($w.hasClass("minimized-without-taskbar")) {
						instantly_unminimize();
						after_rect = $w.$titlebar[0].getBoundingClientRect();
						instantly_minimize();
					} else {
						instantly_minimize();
						after_rect = $w.$titlebar[0].getBoundingClientRect();
						instantly_unminimize();
					}
					$w.animateTitlebar(before_rect, after_rect, () => {
						if ($w.hasClass("minimized-without-taskbar")) {
							instantly_unminimize();
						} else {
							instantly_minimize();
							$w.blur();
						}
					});
				}
			}
		};
		$w.unminimize = () => {
			if (animating_titlebar) {
				when_done_animating_titlebar.push($w.unminimize);
				return;
			}
			if ($w.hasClass("minimized-without-taskbar")) {
				$w.minimize();
				return;
			}
			if ($w.is(":hidden")) {
				const before_rect = minimize_target_el.getBoundingClientRect();
				$w.show();
				const after_rect = $w.$titlebar[0].getBoundingClientRect();
				$w.hide();
				$w.animateTitlebar(before_rect, after_rect, () => {
					$w.show();
					$w.bringToFront();
					$w.focus();
				});
			}
		};

		let before_maximize;
		$w.maximize = () => {
			if (!options.resizable) {
				return;
			}
			if (animating_titlebar) {
				when_done_animating_titlebar.push($w.maximize);
				return;
			}
			if ($w.hasClass("minimized-without-taskbar")) {
				$w.minimize();
				return;
			}

			const instantly_maximize = () => {
				before_maximize = {
					position: $w.css("position"),
					left: $w.css("left"),
					top: $w.css("top"),
					width: $w.css("width"),
					height: $w.css("height"),
				};

				$w.addClass("maximized");
				const $taskbar = $(".taskbar");
				const scrollbar_width = window.innerWidth - $(window).width();
				const scrollbar_height = window.innerHeight - $(window).height();
				const taskbar_height = $taskbar.length ? $taskbar.outerHeight() + 1 : 0;
				$w.css({
					position: "fixed",
					top: 0,
					left: 0,
					width: `calc(100vw - ${scrollbar_width}px)`,
					height: `calc(100vh - ${scrollbar_height}px - ${taskbar_height}px)`,
				});
			};
			const instantly_unmaximize = () => {
				$w.removeClass("maximized");
				$w.css({ width: "", height: "" });
				if (before_maximize) {
					$w.css({
						position: before_maximize.position,
						left: before_maximize.left,
						top: before_maximize.top,
						width: before_maximize.width,
						height: before_maximize.height,
					});
				}
			};

			const before_rect = $w.$titlebar[0].getBoundingClientRect();
			let after_rect;
			$w.css("transform", "");
			const restoring = $w.hasClass("maximized");
			if (restoring) {
				instantly_unmaximize();
				after_rect = $w.$titlebar[0].getBoundingClientRect();
				instantly_maximize();
			} else {
				instantly_maximize();
				after_rect = $w.$titlebar[0].getBoundingClientRect();
				instantly_unmaximize();
			}
			$w.animateTitlebar(before_rect, after_rect, () => {
				if (restoring) {
					instantly_unmaximize(); // finalize in some way
					$w.$maximize.removeClass("window-action-restore");
					$w.$maximize.addClass("window-action-maximize");
				} else {
					instantly_maximize(); // finalize in some way
					$w.$maximize.removeClass("window-action-maximize");
					$w.$maximize.addClass("window-action-restore");
				}
			});
		};
		$w.restore = () => {
			if ($w.is(".minimized-without-taskbar, .minimized")) {
				$w.unminimize();
			} else if ($w.is(".maximized")) {
				$w.maximize();
			}
		};
		// must not pass event to functions by accident; also methods may not be defined yet
		$w.$minimize && $w.$minimize.on("click", (e)=> { $w.minimize(); });
		$w.$maximize && $w.$maximize.on("click", (e)=> { $w.maximize(); });
		$w.$x && $w.$x.on("click", (e)=> { $w.close(); });
		$w.$title_area.on("dblclick", (e)=> { $w.maximize(); });

		$w.css({
			position: "absolute",
			zIndex: $Window.Z_INDEX++
		});
		$w.bringToFront = () => {
			$w.css({
				zIndex: $Window.Z_INDEX++
			});
			for (const $childWindow of child_$windows) {
				$childWindow.bringToFront();
			}
		};

		// Keep track of last focused elements per container,
		// where containers include:
		// - window (global focus tracking)
		// - $w[0] (window-local, for restoring focus when refocusing window)
		// - any iframes that are same-origin (for restoring focus when refocusing window)
		// @TODO: should these be WeakMaps? probably.
		// @TODO: share this Map between all windows? but clean it up when destroying windows? or would a WeakMap take care of that?
		var last_focus_by_container = new Map(); // element to restore focus to, by container
		var focus_update_handlers_by_container = new Map(); // event handlers by container; note use as a flag to avoid adding multiple handlers
		var debug_svg_by_container = new Map(); // visualization
		var debug_svgs_in_window = []; // visualization
		var warned_iframes = new WeakSet(); // prevent spamming console

		const warn_iframe_access = (iframe, error) => {
			const log_template = (message) => [`OS-GUI.js failed to access an iframe (${element_to_string(iframe)}) for focus integration.
	${message}
	Original error:
	`, error];

			let cross_origin;
			if (iframe.srcdoc) {
				cross_origin = false;
			} else {
				try {
					const url = new URL(iframe.src);
					cross_origin = url.origin !== window.location.origin; // shouldn't need to use iframe.ownerDocument.location.origin because intermediate iframes must be same-origin
				} catch (parse_error) {
					console.error(...log_template(`This may be a bug in OS-GUI. Is this a cross-origin iframe? Failed to parse URL (${parse_error}).`));
					return;
				}
			}
			if (cross_origin) {
				if (options.iframes && options.iframes.ignoreCrossOrigin && !warned_iframes.has(iframe)) {
					console.warn(...log_template(`Only same-origin iframes can work with focus integration (showing window as focused, refocusing last focused controls).
	If you can re-host the content on the same origin, you can resolve this and enable focus integration.
	You can also disable this warning by passing {iframes: {ignoreCrossOrigin: true}} to $Window.`));
					warned_iframes.add(iframe);
				}
			} else {
				console.error(...log_template(`This may be a bug in OS-GUI, since it doesn't appear to be a cross-origin iframe.`));
			}
		};

		const debug_focus_tracking = (document, container_el, descendant_el, is_root) => {
			if (!$Window.DEBUG_FOCUS) {
				return;
			}
			let svg = debug_svg_by_container.get(container_el);
			if (!svg) {
				svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
				svg.style.position = "fixed";
				svg.style.top = "0";
				svg.style.left = "0";
				svg.style.width = "100%";
				svg.style.height = "100%";
				svg.style.pointerEvents = "none";
				svg.style.zIndex = "100000000";
				svg.style.direction = "ltr"; // position labels correctly
				debug_svg_by_container.set(container_el, svg);
				debug_svgs_in_window.push(svg);
				document.body.appendChild(svg);
			}
			svg._container_el = container_el;
			svg._descendant_el = descendant_el;
			svg._is_root = is_root;
			animate_debug_focus_tracking();
		};
		const update_debug_focus_tracking = (svg) => {
			const container_el = svg._container_el;
			const descendant_el = svg._descendant_el;
			const is_root = svg._is_root;

			while (svg.lastChild) {
				svg.removeChild(svg.lastChild);
			}
			const descendant_rect = descendant_el.getBoundingClientRect && descendant_el.getBoundingClientRect() ||/*??*/ { left: 0, top: 0, width: innerWidth, height: innerHeight, right: innerWidth, bottom: innerHeight };
			const container_rect = container_el.getBoundingClientRect && ontainer_el.getBoundingClientRect() ||/*??*/ { left: 0, top: 0, width: innerWidth, height: innerHeight, right: innerWidth, bottom: innerHeight };
			// draw rectangles with labels
			for (const rect of [descendant_rect, container_rect]) {
				const rect_el = document.createElementNS("http://www.w3.org/2000/svg", "rect");
				rect_el.setAttribute("x", rect.left);
				rect_el.setAttribute("y", rect.top);
				rect_el.setAttribute("width", rect.width);
				rect_el.setAttribute("height", rect.height);
				rect_el.setAttribute("stroke", rect === descendant_rect ? "#f44" : "#f44");
				rect_el.setAttribute("stroke-width", "2");
				rect_el.setAttribute("fill", "none");
				if (!is_root) {
					rect_el.setAttribute("stroke-dasharray", "5,5");
				}
				svg.appendChild(rect_el);
				const text_el = document.createElementNS("http://www.w3.org/2000/svg", "text");
				text_el.setAttribute("x", rect.left);
				text_el.setAttribute("y", rect.top + (rect === descendant_rect ? 20 : 0)); // align container text on outside, descendant text on inside
				text_el.setAttribute("fill", rect === descendant_rect ? "#f44" : "aqua");
				text_el.setAttribute("font-size", "20");
				text_el.style.textShadow = "1px 1px 1px black, 0 0 10px black";
				text_el.textContent = element_to_string(rect === descendant_rect ? descendant_el : container_el);
				svg.appendChild(text_el);
			}
			// draw lines connecting the two rects
			const lines = [
				[descendant_rect.left, descendant_rect.top, container_rect.left, container_rect.top],
				[descendant_rect.right, descendant_rect.top, container_rect.right, container_rect.top],
				[descendant_rect.left, descendant_rect.bottom, container_rect.left, container_rect.bottom],
				[descendant_rect.right, descendant_rect.bottom, container_rect.right, container_rect.bottom],
			];
			for (const line of lines) {
				const line_el = document.createElementNS("http://www.w3.org/2000/svg", "line");
				line_el.setAttribute("x1", line[0]);
				line_el.setAttribute("y1", line[1]);
				line_el.setAttribute("x2", line[2]);
				line_el.setAttribute("y2", line[3]);
				line_el.setAttribute("stroke", "green");
				line_el.setAttribute("stroke-width", "2");
				svg.appendChild(line_el);
			}
		};
		let debug_animation_frame_id;
		const animate_debug_focus_tracking = () => {
			cancelAnimationFrame(debug_animation_frame_id);
			if (!$Window.DEBUG_FOCUS) {
				clean_up_debug_focus_tracking();
				return;
			}
			debug_animation_frame_id = requestAnimationFrame(animate_debug_focus_tracking);
			for (const svg of debug_svgs_in_window) {
				update_debug_focus_tracking(svg);
			}
		};
		const clean_up_debug_focus_tracking = () => {
			cancelAnimationFrame(debug_animation_frame_id);
			for (const svg of debug_svgs_in_window) {
				svg.remove();
			}
			debug_svgs_in_window.length = 0;
			debug_svg_by_container.clear();
		};

		const refocus = (container_el = $w.$content[0]) => {
			const logical_container_el = container_el.matches(".window-content") ? $w[0] : container_el;
			const last_focus = last_focus_by_container.get(logical_container_el);
			if (last_focus) {
				last_focus.focus({ preventScroll: true });
				if (last_focus.tagName === "IFRAME") {
					try {
						refocus(last_focus);
					} catch (e) {
						warn_iframe_access(last_focus, e);
					}
				}
				return;
			}
			const $tabstops = find_tabstops(container_el);
			const $default = $tabstops.filter(".default");
			if ($default.length) {
				$default[0].focus({ preventScroll: true });
				return;
			}
			if ($tabstops.length) {
				if ($tabstops[0].tagName === "IFRAME") {
					try {
						refocus($tabstops[0]); // not .contentDocument.body because we want the container tracked by last_focus_by_container
					} catch (e) {
						warn_iframe_access($tabstops[0], e);
					}
				} else {
					$tabstops[0].focus({ preventScroll: true });
				}
				return;
			}
			if (options.toolWindow && options.parentWindow) {
				options.parentWindow.triggerHandler("refocus-window");
				return;
			}
			container_el.focus({ preventScroll: true });
			if (container_el.tagName === "IFRAME") {
				try {
					refocus(container_el.contentDocument.body);
				} catch (e) {
					warn_iframe_access(container_el, e);
				}
			}
		};

		$w.on("refocus-window", () => {
			refocus();
		});

		// redundant events are for handling synthetic events,
		// which may be sent individually, rather than in tandem
		$w.on("pointerdown mousedown", handle_pointer_activation);
		// Note that jQuery treats some events differently, and can't listen for some synthetic events
		// but pointerdown and mousedown seem to be supported. That said, if you trigger() either,
		// addEventListener() handlers will not be called. So if I remove the dependency on jQuery,
		// it will not be possible to listen for some .trigger() events.
		// https://jsfiddle.net/1j01/ndvwts9y/1/

		// Assumption: focusin comes after pointerdown/mousedown
		// This is probably guaranteed, because you can prevent the default of focusing from pointerdown/mousedown
		$G.on("focusin", (e) => {
			last_focus_by_container.set(window, e.target);
			// debug_focus_tracking(document, window, e.target);
		});

		function handle_pointer_activation(event) {
			// console.log("handle_pointer_activation", event.type, event.target);
			$w.bringToFront();
			// Test cases where it should refocus the last focused control in the window:
			// - Click in the blank space of the window
			//   - Click in blank space again now that something's focused
			// - Click on the window title bar
			//   - Click on title bar buttons
			// - Closing a second window should focus the first window
			//   - Open a dialog window from an app window that has a tool window, then close the dialog window
			//     - @TODO: Even if the tool window has controls, it should focus the parent window, I think
			// - Clicking on a control in the window should focus said control
			// - Clicking on a disabled control in the window should focus the window
			//   - Make sure to test this with another window previously focused
			// - Simulated clicks (important for JS Paint's eye gaze and speech recognition modes)
			// - (@TODO: Should clicking a child window focus the parent window?)
			// - After potentially selecting text but not selecting anything
			// It should NOT refocus when:
			// - Clicking on a control in a different window
			// - When other event handlers set focus
			//   - Using the keyboard to focus something outside the window, such as a menu popup
			//   - Clicking a control that focuses something outside the window
			//     - Button that opens another window (e.g. Recursive Dialog button in tests)
			//     - Button that focuses a control in another window (e.g. Focus Other button in tests)
			// - Trying to select text

			// Wait for other pointerdown handlers and default behavior, and focusin events.
			requestAnimationFrame(() => {
				const last_focus_global = last_focus_by_container.get(window);
				// const last_focus_in_window = last_focus_by_container.get($w.$content[0]);
				// console.log("a tick after", event.type, { last_focus_in_window, last_focus_global, activeElement: document.activeElement, win_elem: $w[0] });
				// console.log("did focus change?", document.activeElement !== last_focus_global);

				// If something programmatically got focus, don't refocus.
				if (
					document.activeElement &&
					document.activeElement !== document &&
					document.activeElement !== document.body &&
					document.activeElement !== $w.$content[0] &&
					document.activeElement !== last_focus_global
				) {
					return;
				}
				// If menus got focus, don't refocus.
				if (document.activeElement && document.activeElement.closest && document.activeElement.closest(".menus, .menu-popup")) {
					// console.log("click in menus");
					return;
				}

				// If the element is selectable, wait until the click is done and see if anything was selected first.
				// This is a bit of a weird compromise, for now.
				const target_style = getComputedStyle(event.target);
				if (target_style.userSelect !== "none") {
					// Immediately show the window as focused, just don't refocus a specific control.
					$w.$content.focus();

					$w.one("pointerup pointercancel", () => {
						requestAnimationFrame(() => { // this seems to make it more reliable in regards to double clicking
							if (!getSelection().toString().trim()) {
								refocus();
							}
						});
					});
					return;
				}
				// Set focus to the last focused control, which should be updated if a click just occurred.
				refocus();
			});
		}

		$w.on("keydown", (e) => {
			if (e.isDefaultPrevented()) {
				return;
			}
			if (e.ctrlKey || e.altKey || e.metaKey) {
				return;
			}
			// console.log("keydown", e.key, e.target);
			if (e.target.closest(".menus")) {
				// console.log("keydown in menus");
				return;
			}
			const $buttons = $w.$content.find("button");
			const $focused = $(document.activeElement);
			const focused_index = $buttons.index($focused);
			switch (e.keyCode) {
				case 40: // Down
				case 39: // Right
					if ($focused.is("button") && !e.shiftKey) {
						if (focused_index < $buttons.length - 1) {
							$buttons[focused_index + 1].focus();
							e.preventDefault();
						}
					}
					break;
				case 38: // Up
				case 37: // Left
					if ($focused.is("button") && !e.shiftKey) {
						if (focused_index > 0) {
							$buttons[focused_index - 1].focus();
							e.preventDefault();
						}
					}
					break;
				case 32: // Space
				case 13: // Enter (doesn't actually work in chrome because the button gets clicked immediately)
					if ($focused.is("button") && !e.shiftKey) {
						$focused.addClass("pressed");
						const release = () => {
							$focused.removeClass("pressed");
							$focused.off("focusout", release);
							$(window).off("keyup", keyup);
						};
						const keyup = (e) => {
							if (e.keyCode === 32 || e.keyCode === 13) {
								release();
							}
						};
						$focused.on("focusout", release);
						$(window).on("keyup", keyup);
					}
					break;
				case 9: { // Tab
					// wrap around when tabbing through controls in a window
					const $controls = find_tabstops($w.$content[0]);
					if ($controls.length > 0) {
						const focused_control_index = $controls.index($focused);
						if (e.shiftKey) {
							if (focused_control_index === 0) {
								e.preventDefault();
								$controls[$controls.length - 1].focus();
							}
						} else {
							if (focused_control_index === $controls.length - 1) {
								e.preventDefault();
								$controls[0].focus();
							}
						}
					}
					break;
				}
				case 27: // Escape
					// @TODO: make this optional, and probably default false
					$w.close();
					break;
			}
		});

		$w.applyBounds = () => {
			// TODO: outerWidth vs width? not sure
			const bound_width = Math.max(document.body.scrollWidth, innerWidth);
			const bound_height = Math.max(document.body.scrollHeight, innerHeight);
			$w.css({
				left: Math.max(0, Math.min(bound_width - $w.width(), $w.position().left)),
				top: Math.max(0, Math.min(bound_height - $w.height(), $w.position().top)),
			});
		};

		$w.bringTitleBarInBounds = () => {
			// Try to make the titlebar always accessible
			const bound_width = Math.max(document.body.scrollWidth, innerWidth);
			const bound_height = Math.max(document.body.scrollHeight, innerHeight);
			const min_horizontal_pixels_on_screen = 40; // enough for space past a close button
			$w.css({
				left: Math.max(
					min_horizontal_pixels_on_screen - $w.outerWidth(),
					Math.min(
						bound_width - min_horizontal_pixels_on_screen,
						$w.position().left
					)
				),
				top: Math.max(0, Math.min(
					bound_height - $w.$titlebar.outerHeight() - 5,
					$w.position().top
				)),
			});
		};

		$w.center = () => {
			$w.css({
				left: (innerWidth - $w.width()) / 2 + window.scrollX,
				top: (innerHeight - $w.height()) / 2 + window.scrollY,
			});
			$w.applyBounds();
		};


		$G.on("resize", $w.bringTitleBarInBounds);

		var drag_offset_x, drag_offset_y, drag_pointer_x, drag_pointer_y, drag_pointer_id;
		var update_drag = (e) => {
			if (drag_pointer_id === (e.pointerId ||/*??*/ e.originalEvent.pointerId)) {
				drag_pointer_x = e.clientX ||/*??*/ drag_pointer_x;
				drag_pointer_y = e.clientY ||/*??*/ drag_pointer_y;
			}
			$w.css({
				left: drag_pointer_x + scrollX - drag_offset_x,
				top: drag_pointer_y + scrollY - drag_offset_y,
			});
		};
		$w.$titlebar.css("touch-action", "none");
		$w.$titlebar.on("selectstart", (e) => { // preventing mousedown would break :active state, I'm not sure if just selectstart is enough...
			e.preventDefault();
		});
		$w.$titlebar.on("mousedown", "button", (e) => {
			// Prevent focus on titlebar buttons.
			// This can break the :active state. In Firefox, a setTimeout before any focus() was enough,
			// but now in Chrome 95, focus() breaks the :active state too, and setTimeout only delays the brokenness,
			// so I have to use a CSS class now for the pressed state.
			refocus();
			// Emulate :enabled:active:hover state with .pressing class
			const button = e.currentTarget;
			if (!$(button).is(":enabled")) {
				return;
			}
			button.classList.add("pressing");
			const release = (event) => {
				// blur is just to handle the edge case of alt+tabbing/ctrl+tabbing away
				if (event && event.type === "blur") {
					// if (document.activeElement?.tagName === "IFRAME") {
					if (document.hasFocus()) {
						return; // the window isn't really blurred; an iframe got focus
					}
				}
				button.classList.remove("pressing");
				$G.off("mouseup blur", release);
				$(button).off("mouseenter", on_mouse_enter);
				$(button).off("mouseleave", on_mouse_leave);
			};
			const on_mouse_enter = () => { button.classList.add("pressing"); };
			const on_mouse_leave = () => { button.classList.remove("pressing"); };
			$G.on("mouseup blur", release);
			$(button).on("mouseenter", on_mouse_enter);
			$(button).on("mouseleave", on_mouse_leave);
		});
		$w.$titlebar.on("pointerdown", (e) => {
			if ($(e.target).closest("button").length) {
				return;
			}
			if ($w.hasClass("maximized")) {
				return;
			}
			const customEvent = $.Event("window-drag-start");
			$w.trigger(customEvent);
			if (customEvent.isDefaultPrevented()) {
				return; // allow custom drag behavior of component windows in jspaint (Tools / Colors)
			}
			drag_offset_x = e.clientX + scrollX - $w.position().left;
			drag_offset_y = e.clientY + scrollY - $w.position().top;
			drag_pointer_x = e.clientX;
			drag_pointer_y = e.clientY;
			drag_pointer_id = (e.pointerId ||/*??*/ e.originalEvent.pointerId);
			$G.on("pointermove", update_drag);
			$G.on("scroll", update_drag);
			$("body").addClass("dragging"); // for when mouse goes over an iframe
		});
		$G.on("pointerup pointercancel", (e) => {
			if ((e.pointerId ||/*??*/ e.originalEvent.pointerId) !== drag_pointer_id) { return; }
			$G.off("pointermove", update_drag);
			$G.off("scroll", update_drag);
			$("body").removeClass("dragging");
			// $w.applyBounds(); // Windows doesn't really try to keep windows on screen
			// but you also can't really drag off of the desktop, whereas here you can drag to way outside the web page.
			$w.bringTitleBarInBounds();
			drag_pointer_id = -1; // prevent bringTitleBarInBounds from making the window go to top left when unminimizing window from taskbar after previously dragging it
		});
		$w.$titlebar.on("dblclick", (e) => {
			if ($component) {
				$component.dock();
			}
		});

		if (options.resizable) {

			const HANDLE_MIDDLE = 0;
			const HANDLE_START = -1;
			const HANDLE_END = 1;
			const HANDLE_LEFT = HANDLE_START;
			const HANDLE_RIGHT = HANDLE_END;
			const HANDLE_TOP = HANDLE_START;
			const HANDLE_BOTTOM = HANDLE_END;

			[
				[HANDLE_TOP, HANDLE_RIGHT], // ↗
				[HANDLE_TOP, HANDLE_MIDDLE], // ↑
				[HANDLE_TOP, HANDLE_LEFT], // ↖
				[HANDLE_MIDDLE, HANDLE_LEFT], // ←
				[HANDLE_BOTTOM, HANDLE_LEFT], // ↙
				[HANDLE_BOTTOM, HANDLE_MIDDLE], // ↓
				[HANDLE_BOTTOM, HANDLE_RIGHT], // ↘
				[HANDLE_MIDDLE, HANDLE_RIGHT], // →
			].forEach(([y_axis, x_axis]) => {
				// const resizes_height = y_axis !== HANDLE_MIDDLE;
				// const resizes_width = x_axis !== HANDLE_MIDDLE;
				const $handle = $("<div>").addClass("handle").appendTo($w);

				let cursor = "";
				if (y_axis === HANDLE_TOP) { cursor += "n"; }
				if (y_axis === HANDLE_BOTTOM) { cursor += "s"; }
				if (x_axis === HANDLE_LEFT) { cursor += "w"; }
				if (x_axis === HANDLE_RIGHT) { cursor += "e"; }
				cursor += "-resize";

				// Note: MISNOMER: innerWidth() is less "inner" than width(), because it includes padding!
				// Here's a little diagram of sorts:
				// outerWidth(true): margin, [ outerWidth(): border, [ innerWidth(): padding, [ width(): content ] ] ]
				const handle_thickness = ($w.outerWidth() - $w.width()) / 2; // padding + border
				const border_width = ($w.outerWidth() - $w.innerWidth()) / 2; // border; need to outset the handles by this amount so they overlap the border + padding, and not the content
				const window_frame_height = $w.outerHeight() - $w.$content.outerHeight(); // includes titlebar and borders, padding, but not content
				const window_frame_width = $w.outerWidth() - $w.$content.outerWidth(); // includes borders, padding, but not content
				$handle.css({
					position: "absolute",
					top: y_axis === HANDLE_TOP ? -border_width : y_axis === HANDLE_MIDDLE ? `calc(${handle_thickness}px - ${border_width}px)` : "",
					bottom: y_axis === HANDLE_BOTTOM ? -border_width : "",
					left: x_axis === HANDLE_LEFT ? -border_width : x_axis === HANDLE_MIDDLE ? `calc(${handle_thickness}px - ${border_width}px)` : "",
					right: x_axis === HANDLE_RIGHT ? -border_width : "",
					width: x_axis === HANDLE_MIDDLE ? `calc(100% - ${handle_thickness}px * 2 + ${border_width * 2}px)` : `${handle_thickness}px`,
					height: y_axis === HANDLE_MIDDLE ? `calc(100% - ${handle_thickness}px * 2 + ${border_width * 2}px)` : `${handle_thickness}px`,
					// background: x_axis === HANDLE_MIDDLE || y_axis === HANDLE_MIDDLE ? "rgba(255,0,0,0.4)" : "rgba(0,255,0,0.8)",
					touchAction: "none",
					cursor,
				});

				let rect;
				let resize_offset_x, resize_offset_y, resize_pointer_x, resize_pointer_y, resize_pointer_id;
				$handle.on("pointerdown", (e) => {
					e.preventDefault();

					$G.on("pointermove", handle_pointermove);
					$G.on("scroll", update_resize); // scroll doesn't have clientX/Y, so we have to remember it
					$("body").addClass("dragging"); // for when mouse goes over an iframe
					$G.on("pointerup pointercancel", end_resize);

					rect = {
						x: $w.position().left,
						y: $w.position().top,
						width: $w.outerWidth(),
						height: $w.outerHeight(),
					};

					resize_offset_x = e.clientX + scrollX - rect.x - (x_axis === HANDLE_RIGHT ? rect.width : 0);
					resize_offset_y = e.clientY + scrollY - rect.y - (y_axis === HANDLE_BOTTOM ? rect.height : 0);
					resize_pointer_x = e.clientX;
					resize_pointer_y = e.clientY;
					resize_pointer_id = (e.pointerId ||/*??*/ e.originalEvent.pointerId);

					$handle[0].setPointerCapture(resize_pointer_id); // keeps cursor consistent when mouse moves over other elements

					// handle_pointermove(e); // was useful for checking that the offset is correct (should not do anything, if it's correct!)
				});
				function handle_pointermove(e) {
					if ((e.pointerId ||/*??*/ e.originalEvent.pointerId) !== resize_pointer_id) { return; }
					resize_pointer_x = e.clientX;
					resize_pointer_y = e.clientY;
					update_resize();
				}
				function end_resize(e) {
					if ((e.pointerId ||/*??*/ e.originalEvent.pointerId) !== resize_pointer_id) { return; }
					$G.off("pointermove", handle_pointermove);
					$G.off("scroll", onscroll);
					$("body").removeClass("dragging");
					$G.off("pointerup pointercancel", end_resize);
					$w.bringTitleBarInBounds();
				}
				function update_resize() {
					const mouse_x = resize_pointer_x + scrollX - resize_offset_x;
					const mouse_y = resize_pointer_y + scrollY - resize_offset_y;
					let delta_x = 0;
					let delta_y = 0;
					let width, height;
					if (x_axis === HANDLE_RIGHT) {
						delta_x = 0;
						width = ~~(mouse_x - rect.x);
					} else if (x_axis === HANDLE_LEFT) {
						delta_x = ~~(mouse_x - rect.x);
						width = ~~(rect.x + rect.width - mouse_x);
					} else {
						width = ~~(rect.width);
					}
					if (y_axis === HANDLE_BOTTOM) {
						delta_y = 0;
						height = ~~(mouse_y - rect.y);
					} else if (y_axis === HANDLE_TOP) {
						delta_y = ~~(mouse_y - rect.y);
						height = ~~(rect.y + rect.height - mouse_y);
					} else {
						height = ~~(rect.height);
					}
					let new_rect = {
						x: rect.x + delta_x,
						y: rect.y + delta_y,
						width,
						height,
					};

					new_rect.width = Math.max(1, new_rect.width);
					new_rect.height = Math.max(1, new_rect.height);

					// Constraints
					if (options.constrainRect) {
						new_rect = options.constrainRect(new_rect, x_axis, y_axis);
					}
					new_rect.width = Math.max(new_rect.width, options.minOuterWidth ||/*??*/ 100);
					new_rect.height = Math.max(new_rect.height, options.minOuterHeight ||/*??*/ 0);
					new_rect.width = Math.max(new_rect.width, (options.minInnerWidth ||/*??*/ 0) + window_frame_width);
					new_rect.height = Math.max(new_rect.height, (options.minInnerHeight ||/*??*/ 0) + window_frame_height);
					// prevent free movement via resize past minimum size
					if (x_axis === HANDLE_LEFT) {
						new_rect.x = Math.min(new_rect.x, rect.x + rect.width - new_rect.width);
					}
					if (y_axis === HANDLE_TOP) {
						new_rect.y = Math.min(new_rect.y, rect.y + rect.height - new_rect.height);
					}

					$w.css({
						top: new_rect.y,
						left: new_rect.x,
					});
					$w.outerWidth(new_rect.width);
					$w.outerHeight(new_rect.height);
				}
			});
		}

		$w.$Button = (text, handler) => {
			var $b = $(E("button"))
				.appendTo($w.$content)
				.text(text)
				.on("click", () => {
					if (handler) {
						handler();
					}
					$w.close();
				});
			return $b;
		};
		$w.title = title => {
			if (title) {
				$w.$title.text(title);
				$w.trigger("title-change");
				if ($w.task) {
					$w.task.updateTitle();
				}
				return $w;
			} else {
				return $w.$title.text();
			}
		};
		$w.getTitle = () => {
			return $w.title();
		};
		let animating_titlebar = false;
		let when_done_animating_titlebar = []; // queue of functions to call when done animating,
		// so maximize() / minimize() / restore() eventually gives the same result as if there was no animation
		$w.animateTitlebar = (from, to, callback = () => { }) => {
			// flying titlebar animation
			animating_titlebar = true;
			const $eye_leader = $w.$titlebar.clone(true);
			$eye_leader.find("button").remove();
			$eye_leader.appendTo("body");
			const duration_ms = $Window.OVERRIDE_TRANSITION_DURATION ||/*??*/ 200; // TODO: how long?
			const duration_str = `${duration_ms}ms`;
			$eye_leader.css({
				transition: `left ${duration_str} linear, top ${duration_str} linear, width ${duration_str} linear, height ${duration_str} linear`,
				position: "fixed",
				zIndex: 10000000,
				pointerEvents: "none",
				left: from.left,
				top: from.top,
				width: from.width,
				height: from.height,
			});
			setTimeout(() => {
				$eye_leader.css({
					left: to.left,
					top: to.top,
					width: to.width,
					height: to.height,
				});
			}, 5);
			let handled_transition_completion = false;
			const handle_transition_completion = () => {
				if (handled_transition_completion) {
					return; // ignore multiple calls (an idempotency pattern)
				} else {
					handled_transition_completion = true;
				}
				animating_titlebar = false;
				$eye_leader.remove();
				callback();
				let anima = when_done_animating_titlebar.shift()
				anima && anima(); // relies on animating_titlebar = false;
			};
			$eye_leader.on("transitionend transitioncancel", handle_transition_completion);
			setTimeout(handle_transition_completion, duration_ms * 1.2);
		};
		$w.close = (force) => {
			if (force && force !== true) {
				throw new TypeError("force must be a boolean or undefined, not " + Object.prototype.toString.call(force));
			}
			if (!force) {
				var e = $.Event("close");
				$w.trigger(e);
				if (e.isDefaultPrevented()) {
					return;
				}
			}
			if ($component) {
				$component.detach();
			}
			$w.closed = true;
			$event_target.triggerHandler("closed");
			$w.trigger("closed");
			// TODO: change usages of "close" to "closed" where appropriate
			// and probably rename the "close" event ("before[-]close"? "may-close"? "close-request"?)

			// MUST be after any events are triggered!
			$w.remove();

			// TODO: support modals, which should focus what was focused before the modal was opened.
			// (Note: must consider the element being removed from the DOM, or hidden, or made un-focusable)
			// (Also: modals should steal focus / be brought to the front when focusing the parent window, and the parent window's content should be inert/uninteractive)
			
			// Focus next-topmost window
			var $next_topmost = $($(".window:visible").toArray().sort((a, b) => b.style.zIndex - a.style.zIndex)[0]);
			$next_topmost.triggerHandler("refocus-window");

			// Cleanup
			clean_up_debug_focus_tracking();
		};
		$w.closed = false;

		let current_menu_bar;
		// @TODO: should this be like setMenus(menu_definitions)?
		// It seems like setMenuBar(menu_bar) might be prone to bugs
		// trying to set the same menu bar on multiple windows.
		$w.setMenuBar = (menu_bar) => {
			// $w.find(".menus").remove(); // ugly, if only because of the class name haha
			if (current_menu_bar) {
				current_menu_bar.element.remove();
			}
			if (menu_bar) {
				$w.$titlebar.after(menu_bar.element);
				menu_bar.setKeyboardScope($w[0]);
				current_menu_bar = menu_bar;
			}
		};

		if (options.title) {
			$w.title(options.title);
		}

		if (!$component) {
			$w.center();
		}

		// mustHaveMethods($w, windowInterfaceMethods);

		return $w;
	}

	function $FormWindow(title) {
		var $w = new $Window();

		$w.title(title);
		$w.$form = $(E("form")).appendTo($w.$content);
		$w.$main = $(E("div")).appendTo($w.$form);
		$w.$buttons = $(E("div")).appendTo($w.$form).addClass("button-group");

		$w.$Button = (label, action) => {
			var $b = $(E("button")).appendTo($w.$buttons).text(label);
			$b.on("click", (e) => {
				// prevent the form from submitting
				// @TODO: instead, prevent the form's submit event
				e.preventDefault();

				action();
			});

			$b.on("pointerdown", () => {
				$b.focus();
			});

			return $b;
		};

		return $w;
	}

	$Window.$FormWindow = $FormWindow;
	
	return $Window;
});

define('skylark-98js/iframe-windows',[
	"skylark-jquery",
	"./win98",
	"./os-gui/$Window"
],function($,win98js,$Window){
	var programs_being_loaded = 0;

	var $G = $(window);
	
	function enhance_iframe(iframe) {
		var $iframe = $(iframe);

		$("body").addClass("loading-program");
		programs_being_loaded += 1;

		$iframe.on("load", function () {

			if (--programs_being_loaded <= 0) {
				$("body").removeClass("loading-program");
			}

			try {
				console.assert(iframe.contentWindow.document === iframe.contentDocument); // just something that won't get optimized away if we were to ever use a minifier (or by the JIT compiler??)
			} catch (e) {
				console.warn(`[enhance_iframe] iframe integration is not available for '${iframe.src}'`);
				return;
			}

			if (window.themeCSSProperties) {
				applyTheme(themeCSSProperties, iframe.contentDocument.documentElement);
			}

			// Let the iframe to handle mouseup events outside itself
			// (without using setPointerCapture)
			iframe.contentDocument.addEventListener("mousedown", (event) => {
				var delegate_pointerup = function () {
					if (iframe.contentWindow && iframe.contentWindow.jQuery) {
						iframe.contentWindow.jQuery("body").trigger("pointerup");
					}
					if (iframe.contentWindow) {
						const event = new iframe.contentWindow.MouseEvent("mouseup", { button: 0 });
						iframe.contentWindow.dispatchEvent(event);
						const event2 = new iframe.contentWindow.MouseEvent("mouseup", { button: 2 });
						iframe.contentWindow.dispatchEvent(event2);
					}
					clean_up_delegation();
				};
				// @TODO: delegate pointermove events too?
				// @TODO: do delegation in os-gui.js library instead
				// is it delegation? I think I mean proxying (but I'm really tired and don't have internet right now so I can't say for sure haha)

				$G.on("mouseup blur", delegate_pointerup);
				iframe.contentDocument.addEventListener("mouseup", clean_up_delegation);
				function clean_up_delegation() {
					$G.off("mouseup blur", delegate_pointerup);
					iframe.contentDocument.removeEventListener("mouseup", clean_up_delegation);
				}
			});

			// Let the containing page handle keyboard events, with an opportunity to cancel them
			proxy_keyboard_events(iframe);

			// on Wayback Machine, and iframe's url not saved yet
			if (iframe.contentDocument.querySelector("#error #livewebInfo.available")) {
				var message = document.createElement("div");
				message.style.position = "absolute";
				message.style.left = "0";
				message.style.right = "0";
				message.style.top = "0";
				message.style.bottom = "0";
				message.style.background = "#c0c0c0";
				message.style.color = "#000";
				message.style.padding = "50px";
				iframe.contentDocument.body.appendChild(message);
				message.innerHTML = `<a target="_blank">Save this url in the Wayback Machine</a>`;
				message.querySelector("a").href =
					"https://web.archive.org/save/https://98.js.org/" +
					iframe.src.replace(/.*https:\/\/98.js.org\/?/, "");
				message.querySelector("a").style.color = "blue";
			}

			var $contentWindow = $(iframe.contentWindow);
			$contentWindow.on("pointerdown click", function (e) {
				iframe.$window && iframe.$window.focus();

				// from close_menus in $MenuBar
				$(".menu-button").trigger("release");
				// Close any rogue floating submenus
				$(".menu-popup").hide();
			});
			// We want to disable pointer events for other iframes, but not this one
			$contentWindow.on("pointerdown", function (e) {
				$iframe.css("pointer-events", "all");
				$("body").addClass("drag");
			});
			$contentWindow.on("pointerup", function (e) {
				$("body").removeClass("drag");
				$iframe.css("pointer-events", "");
			});
			// $("iframe").css("pointer-events", ""); is called elsewhere.
			// Otherwise iframes would get stuck in this interaction mode

			iframe.contentWindow.close = function () {
				iframe.$window && iframe.$window.close();
			};
			// TODO: hook into saveAs (a la FileSaver.js) and another function for opening files
			// iframe.contentWindow.saveAs = function(){
			// 	saveAsDialog();
			// };

			// Don't override alert (except within the specific pages)
			// but override the underlying message box function that
			// the alert override uses, so that the message boxes can
			// go outside the window.
			iframe.contentWindow.showMessageBox = (options) => {
				return showMessageBox({
					title: options.title /*??*/ ||  iframe.contentWindow.defaultMessageBoxTitle,
					...options,
				});
			};
		});
		$iframe.css({
			minWidth: 0,
			minHeight: 0, // overrides user agent styling apparently, fixes Sound Recorder
			flex: 1,
			border: 0, // overrides user agent styling
		});
	}

	// Let the containing page handle keyboard events, with an opportunity to cancel them
	function proxy_keyboard_events(iframe) {
		// Note: iframe must be same-origin, or this will fail.
		for (const event_type of ["keyup", "keydown", "keypress"]) {
			iframe.contentWindow.addEventListener(event_type, (event) => {
				const proxied_event = new KeyboardEvent(event_type, {
					target: iframe,
					view: iframe.ownerDocument.defaultView,
					bubbles: true,
					cancelable: true,
					key: event.key,
					keyCode: event.keyCode,
					which: event.which,
					code: event.code,
					shiftKey: event.shiftKey,
					ctrlKey: event.ctrlKey,
					metaKey: event.metaKey,
					altKey: event.altKey,
					repeat: event.repeat,
					//...@TODO: should it copy ALL properties?
				});
				const result = iframe.dispatchEvent(proxied_event);
				// console.log("proxied", event, "as", proxied_event, "result", result);
				if (!result) {
					event.preventDefault();
				}
			}, true);
		}
	}

	function make_iframe_window(options) {
		///options.resizable ??= true;
		if (options.resizable == undefined) {
			options.resizable = true;
		}
		var $win = new $Window(options);

		var $iframe = $win.$iframe = $("<iframe>").attr({ src: options.src });
		enhance_iframe($iframe[0]);
		$win.$content.append($iframe);
		var iframe = $win.iframe = $iframe[0];
		// TODO: should I instead of having iframe.$window, have a get$Window type of dealio?
		// where all is $window needed?
		// I know it's used from within the iframe contents as frameElement.$window
		iframe.$window = $win;

		$iframe.on("load", function () {
			$win.show();
			$win.focus();
		});

		$win.$content.css({
			display: "flex",
			flexDirection: "column",
		});

		// TODO: cascade windows
		$win.center();
		$win.hide();

		return $win;
	}

	// Fix dragging things (i.e. windows) over iframes (i.e. other windows)
	// (when combined with a bit of css, .drag iframe { pointer-events: none; })
	// (and a similar thing in make_iframe_window)
	$(window).on("pointerdown", function (e) {
		//console.log(e.type);
		$("body").addClass("drag");
	});
	$(window).on("pointerup dragend blur", function (e) {
		//console.log(e.type);
		if (e.type === "blur") {
			if (document.activeElement.tagName.match(/iframe/i)) {
				return;
			}
		}
		$("body").removeClass("drag");
		$("iframe").css("pointer-events", "");
	});

	return {
		enhance_iframe,
		proxy_keyboard_events,
		make_iframe_window
	}

});
define('skylark-98js/Task',[
	"skylark-jquery",
	"./win98"
],function($,win98js){
	function Task(win) {
		Task.all_tasks.push(this);

		this.$window = win;
		
		const $task = this.$task = $("<button class='task toggle'/>").appendTo($(".tasks"));
		const $title = $("<span class='title'/>");

		this.updateTitle = () => {
			$title.text(win.getTitle());
		};

		let $icon;
		this.updateIcon = () => {
			const old_$icon = $icon;
			$icon = win.getIconAtSize(16);
			if (!$icon) {
				// $icon = $("<img src='images/icons/task-16x16.png'/>");
				old_$icon && old_$icon.remove();
				return;
			}
			if (old_$icon) {
				old_$icon.replaceWith($icon);
			} else {
				$task.prepend($icon);
			}
		};

		this.updateTitle();
		this.updateIcon();

		win.on("title-change", this.updateTitle);
		win.on("icon-change", this.updateIcon);

		win.setMinimizeTarget($task[0]);

		$task.append($icon, $title);
		$task.on("pointerdown", function (e) {
			e.preventDefault(); // prevent focus, so that the window keeps focus and we can know for minimization if it it should be focused or minimized
			// @TODO: do it on whole taskbar
		});
		$task.on("click", function () {
			if ($task.hasClass("selected")) {
				win.minimize();
				win.blur();
			} else {
				win.unminimize();
				win.bringToFront();
				win.focus();
			}
		});

		/*
		win.onFocus(() => {
			$task.addClass("selected");
		});
		win.onBlur(() => {
			$task.removeClass("selected");
		});
		win.onClosed(() => {
			$task.remove();
			const index = Task.all_tasks.indexOf(this);
			if (index !== -1) {
				Task.all_tasks.splice(index, 1);
			}
		});
		*/
		win.on("focus",() => {
			$task.addClass("selected");
		});
		win.on("blur",() => {
			$task.removeClass("selected");
		});
		win.on("closed",() => {
			$task.remove();
			const index = Task.all_tasks.indexOf(this);
			if (index !== -1) {
				Task.all_tasks.splice(index, 1);
			}
		});

		if (win.is && win.is(":visible")) {
			win.focus();
		}
	}

	Task.all_tasks = [];

	return Task;

});
define('skylark-98js/visualizer-overlay',[
	"skylark-jquery",
	"./win98"
],function($,win98js){
	function getOffset(element, fromElement) {
		let el = element,
			offsetLeft = 0,
			offsetTop = 0;

		do {
			offsetLeft += el.offsetLeft;
			offsetTop += el.offsetTop;

			el = el.offsetParent;
		} while (el && el !== fromElement);

		return { offsetLeft, offsetTop };
	}

	window.monkey_patch_render = (obj) => obj.render();

	class VisualizerOverlay {
		constructor(visualizerCanvas, renderOptions) {
			this.visualizerCanvas = visualizerCanvas;

			this.wrappyCanvas = document.createElement("canvas");
			this.wrappyCtx = this.wrappyCanvas.getContext("2d");

			this.overlayCanvases = [];
			this.animateFns = [];

			window.monkey_patch_render = (obj) => {
				// check for Butterchurn's Visualizer class
				if (obj.audio && obj.renderer) {
					obj.render();
					this.render(renderOptions);
					return;
				}
				return obj.render();
			};
		}

		makeOverlayCanvas(windowEl) {
			const canvas = document.createElement("canvas");
			const ctx = canvas.getContext("2d");
			canvas.style.position = "absolute";
			canvas.style.left = "0";
			canvas.style.top = "0";
			canvas.style.pointerEvents = "none";
			canvas.style.mixBlendMode = "color-dodge";
			canvas.style.willChange = "opacity"; // hint fixes flickering in chrome
			canvas.className = "visualizer-overlay-canvas";
			windowEl.appendChild(canvas);
			this.overlayCanvases.push(canvas);
			this.animateFns.push(options => {
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				const scale =
					(windowEl.classList.contains("doubled") ? 2 : 1) *
					(window.devicePixelRatio || 1);
				if (
					canvas.width !== windowEl.clientWidth * scale ||
					canvas.height !== windowEl.clientHeight * scale
				) {
					canvas.width = windowEl.clientWidth * scale;
					canvas.height = windowEl.clientHeight * scale;
				}
				canvas.style.width = windowEl.clientWidth + "px";
				canvas.style.height = windowEl.clientHeight + "px";
				const stuff = windowEl.querySelectorAll("*");
				Array.from(stuff)
					.map(el => {
						const width = el.clientWidth;
						const height = el.clientHeight;
						const area = width * height;
						return { element: el, width, height, area };
					})
					.filter(({ area }) => area > 0)
					.sort((a, b) => b.area - a.area)
					.forEach(({ element, width, height, area }) => {
						const { offsetLeft, offsetTop } = getOffset(element, windowEl);
						ctx.save();
						ctx.scale(scale, scale);
						ctx.translate(offsetLeft, offsetTop);
						if (options.stretch) {
							ctx.drawImage(this.wrappyCanvas, 0, 0, width, height);
						} else {
							ctx.drawImage(
								this.wrappyCanvas,
								0,
								0,
								width,
								height,
								0,
								0,
								width,
								height
							);
						}
						if (area < 30 * 30) {
							ctx.globalCompositeOperation = "destination-out";
							ctx.globalAlpha = 0.5;
							ctx.fillStyle = "black";
							ctx.fillRect(0, 0, width, height);
						}
						ctx.restore();
					});
			});
		}

		render(options) {
			const { visualizerCanvas, wrappyCanvas, wrappyCtx, animateFns } = this;
			const { width, height } = visualizerCanvas;
			if (options.mirror) {
				const drawImage = () => {
					wrappyCtx.drawImage(
						visualizerCanvas,
						0,
						0,
						width,
						height,
						0,
						0,
						width,
						height
					);
					// zoom in the source area:
					// wrappyCtx.drawImage(visualizerCanvas, width/4, height/4, width/2, height/2, 0, 0, width, height);
					// wrappyCtx.drawImage(visualizerCanvas, width/4, height/4, width/4, height/4, 0, 0, width, height);
					// for testing:
					// wrappyCtx.fillStyle = "aqua";
					// wrappyCtx.fillRect(0, 0, width, height);
				};
				wrappyCanvas.width = width * 2;
				wrappyCanvas.height = height * 2;
				wrappyCtx.save();
				drawImage();
				wrappyCtx.translate(0, height);
				wrappyCtx.scale(1, -1);
				wrappyCtx.translate(0, -height);
				drawImage();
				wrappyCtx.translate(width, 0);
				wrappyCtx.scale(-1, 1);
				wrappyCtx.translate(-width, 0);
				drawImage();
				wrappyCtx.translate(0, height);
				wrappyCtx.scale(1, -1);
				wrappyCtx.translate(0, -height);
				drawImage();
				wrappyCtx.restore();
			} else if (options.tile) {
				wrappyCanvas.width = width * 2;
				wrappyCanvas.height = height * 2;
				for (let xi = 0; xi < 2; xi++) {
					for (let yi = 0; yi < 2; yi++) {
						wrappyCtx.drawImage(
							visualizerCanvas,
							0,
							0,
							width,
							height,
							width * xi,
							height * yi,
							width,
							height
						);
					}
				}
			} else {
				wrappyCanvas.width = width;
				wrappyCanvas.height = height;
				wrappyCtx.drawImage(visualizerCanvas, 0, 0, width, height);
			}

			animateFns.forEach(fn => fn(options));
		}
		cleanUp() {
			this.overlayCanvases.forEach(canvas => {
				canvas.remove();
			});
			window.monkey_patch_render = (obj) => obj.render();
		}
		fadeOutAndCleanUp() {
			this.fadeOut();
			this.overlayCanvases[0].addEventListener("transitionend", () => {
				this.cleanUp();
			});
		}
		fadeOut() {
			this.overlayCanvases.forEach(canvas => {
				canvas.style.transition =
					"opacity 1s cubic-bezier(0.125, 0.960, 0.475, 0.915)";
				canvas.style.opacity = "0";
			});
		}
		fadeIn() {
			this.overlayCanvases.forEach(canvas => {
				canvas.style.transition = "opacity 0.2s ease";
				canvas.style.opacity = "1";
			});
		}
	}


	return VisualizerOverlay;
});
define('skylark-98js/programs',[
	"skylark-jquery",
	"skylark-browserfs",
	"./win98",
	"./filesystem-setup",
	"./helpers",
	"./FolderViewItem",
	"./iframe-windows",
	"./Task",
	"./visualizer-overlay",
	"./os-gui/$Window"
],function($,BrowserFS, win98js,FilesystemSetup,helpers,FolderViewItem,iframeWindows,Task,VisualizerOverlay, $Window){
	let make_iframe_window = iframeWindows.make_iframe_window;

	function show_help(options) {
		const $help_window = $Window({
			title: options.title || "Help Topics",
			icons: iconsAtTwoSizes("chm"),
			resizable: true,
		})
		$help_window.addClass("help-window");

		let ignore_one_load = true;
		let back_length = 0;
		let forward_length = 0;

		const $main = $(E("div")).addClass("main");
		const $toolbar = $(E("div")).addClass("toolbar");
		const add_toolbar_button = (name, sprite_n, action_fn, enabled_fn) => {
			const $button = $("<button class='lightweight'>")
				.append($("<span>").text(name))
				.appendTo($toolbar)
				.on("click", () => {
					action_fn();
				});
			$("<div class='icon'/>")
				.appendTo($button)
				.css({
					backgroundPosition: `${-sprite_n * 55}px 0px`,
				});
			const update_enabled = () => {
				$button[0].disabled = enabled_fn && !enabled_fn();
			};
			update_enabled();
			$help_window.on("click", "*", update_enabled);
			$help_window.on("update-buttons", update_enabled);
			return $button;
		};
		const measure_sidebar_width = () =>
			$contents.outerWidth() +
			parseFloat(getComputedStyle($contents[0]).getPropertyValue("margin-left")) +
			parseFloat(getComputedStyle($contents[0]).getPropertyValue("margin-right")) +
			$resizer.outerWidth();
		const $hide_button = add_toolbar_button("Hide", 0, () => {
			const toggling_width = measure_sidebar_width();
			$contents.hide();
			$resizer.hide();
			$hide_button.hide();
			$show_button.show();
			$help_window.width($help_window.width() - toggling_width);
			$help_window.css("left", $help_window.offset().left + toggling_width);
		});
		const $show_button = add_toolbar_button("Show", 5, () => {
			$contents.show();
			$resizer.show();
			$show_button.hide();
			$hide_button.show();
			const toggling_width = measure_sidebar_width();
			$help_window.width($help_window.width() + toggling_width);
			$help_window.css("left", $help_window.offset().left - toggling_width);
			// $help_window.applyBounds() would push the window to fit (before trimming it only if needed)
			// Trim the window to fit (especially for if maximized)
			if ($help_window.offset().left < 0) {
				$help_window.width($help_window.width() + $help_window.offset().left);
				$help_window.css("left", 0);
			}
		}).hide();
		add_toolbar_button("Back", 1, () => {
			$iframe[0].contentWindow.history.back();
			ignore_one_load = true;
			back_length -= 1;
			forward_length += 1;
		}, () => back_length > 0);
		add_toolbar_button("Forward", 2, () => {
			$iframe[0].contentWindow.history.forward();
			ignore_one_load = true;
			forward_length -= 1;
			back_length += 1;
		}, () => forward_length > 0);
		add_toolbar_button("Options", 3, () => { }, () => false); // TODO: hotkey and underline on O
		add_toolbar_button("Web Help", 4, () => {
			iframe.src = "help/online_support.htm";
		});

		const $iframe = $("<iframe sandbox='allow-same-origin allow-scripts allow-forms allow-modals allow-popups allow-downloads'>")
			.attr({ src: "help/default.html" })
			.addClass("inset-deep");
		const iframe = $iframe[0];
		enhance_iframe(iframe);
		iframe.$window = $help_window; // for focus handling integration
		const $resizer = $(E("div")).addClass("resizer");
		const $contents = $(E("ul")).addClass("contents inset-deep");

		// TODO: fix race conditions
		$iframe.on("load", () => {
			if (!ignore_one_load) {
				back_length += 1;
				forward_length = 0;
			}
			iframe.contentWindow.location.href
			ignore_one_load = false;
			$help_window.triggerHandler("update-buttons");
		});

		$main.append($contents, $resizer, $iframe);
		$help_window.$content.append($toolbar, $main);

		$help_window.css({ width: 800, height: 600 });

		$iframe.attr({ name: "help-frame" });
		$iframe.css({
			backgroundColor: "white",
			border: "",
			margin: "1px",
		});
		$contents.css({
			margin: "1px",
		});
		$help_window.center();

		$main.css({
			position: "relative", // for resizer
		});

		const resizer_width = 4;
		$resizer.css({
			cursor: "ew-resize",
			width: resizer_width,
			boxSizing: "border-box",
			background: "var(--ButtonFace)",
			borderLeft: "1px solid var(--ButtonShadow)",
			boxShadow: "inset 1px 0 0 var(--ButtonHilight)",
			top: 0,
			bottom: 0,
			zIndex: 1,
		});
		$resizer.on("pointerdown", (e) => {
			let pointermove, pointerup;
			const getPos = (e) =>
				Math.min($help_window.width() - 100, Math.max(20,
					e.clientX - $help_window.$content.offset().left
				));
			$G.on("pointermove", pointermove = (e) => {
				$resizer.css({
					position: "absolute",
					left: getPos(e)
				});
				$contents.css({
					marginRight: resizer_width,
				});
			});
			$G.on("pointerup", pointerup = (e) => {
				$G.off("pointermove", pointermove);
				$G.off("pointerup", pointerup);
				$resizer.css({
					position: "",
					left: ""
				});
				$contents.css({
					flexBasis: getPos(e) - resizer_width,
					marginRight: "",
				});
			});
		});

		const parse_object_params = $object => {
			// parse an $(<object>) to a plain object of key value pairs
			const object = {};
			for (const param of $object.children("param").get()) {
				object[param.name] = param.value;
			}
			return object;
		};

		let $last_expanded;

		const make_$item = text => {
			const $item = $(E("div")).addClass("item").text(text);
			$item.on("mousedown", () => {
				$contents.find(".item").removeClass("selected");
				$item.addClass("selected");
			});
			$item.on("click", () => {
				const $li = $item.parent();
				if ($li.is(".folder")) {
					if ($last_expanded) {
						$last_expanded.not($li).removeClass("expanded");
					}
					$li.toggleClass("expanded");
					$last_expanded = $li;
				}
			});
			return $item;
		};

		const $default_item_li = $(E("li")).addClass("page");
		$default_item_li.append(make_$item("Welcome to Help").on("click", () => {
			$iframe.attr({ src: "help/default.html" });
		}));
		$contents.append($default_item_li);

		function renderItemFromContents(source_li, $folder_items_ul) {
			const object = parse_object_params($(source_li).children("object"));
			if ($(source_li).find("li").length > 0) {

				const $folder_li = $(E("li")).addClass("folder");
				$folder_li.append(make_$item(object.Name));
				$contents.append($folder_li);

				const $folder_items_ul = $(E("ul"));
				$folder_li.append($folder_items_ul);

				$(source_li).children("ul").children().get().forEach((li) => {
					renderItemFromContents(li, $folder_items_ul);
				});
			} else {
				const $item_li = $(E("li")).addClass("page");
				$item_li.append(make_$item(object.Name).on("click", () => {
					$iframe.attr({ src: `${options.root}/${object.Local}` });
				}));
				if ($folder_items_ul) {
					$folder_items_ul.append($item_li);
				} else {
					$contents.append($item_li);
				}
			}
		}

		$.get(options.contentsFile, hhc => {
			$($.parseHTML(hhc)).filter("ul").children().get().forEach((li) => {
				renderItemFromContents(li, null);
			});
		});

		// @TODO: keyboard accessability
		// $help_window.on("keydown", (e)=> {
		// 	switch(e.keyCode){
		// 		case 37:
		// 			show_error_message("MOVE IT");
		// 			break;
		// 	}
		// });
		var task = new Task($help_window);
		task.$help_window = $help_window;
		return task;
	}

	function Notepad(file_path) {
		// TODO: DRY the default file names and title code (use document.title of the page in the iframe, in make_iframe_window)
		var document_title = file_path ? file_name_from_path(file_path) : "Untitled";
		var win_title = document_title + " - Notepad";
		// TODO: focus existing window if file is currently open?

		var $win = make_iframe_window({
			src: "programs/notepad/index.html" + (file_path ? ("?path=" + file_path) : ""),
			icons: iconsAtTwoSizes("notepad"),
			title: win_title,
			outerWidth: 480,
			outerHeight: 321,
			resizable: true,
		});
		return new Task($win);
	}
	Notepad.acceptsFilePaths = true;

	function Paint(file_path) {
		var $win = make_iframe_window({
			src: "programs/jspaint/index.html",
			icons: iconsAtTwoSizes("paint"),
			// NOTE: in Windows 98, "untitled" is lowercase, but TODO: we should just make it consistent
			title: "untitled - Paint",
			outerWidth: 275,
			outerHeight: 400,
			minOuterWidth: 275,
			minOuterHeight: 400,
		});

		var contentWindow = $win.$iframe[0].contentWindow;

		var waitUntil = function (test, interval, callback) {
			if (test()) {
				callback();
			} else {
				setTimeout(waitUntil, interval, test, interval, callback);
			}
		};

		const systemHooks = {
			readBlobFromHandle: (file_path) => {
				return new Promise((resolve, reject) => {
					FilesystemSetup.withFilesystem(() => {
						var fs = BrowserFS.BFSRequire("fs");
						fs.readFile(file_path, (err, buffer) => {
							if (err) {
								return reject(err);
							}
							const byte_array = new Uint8Array(buffer);
							const blob = new Blob([byte_array]);
							const file_name = file_path.replace(/.*\//g, "");
							const file = new File([blob], file_name);
							resolve(file);
						});
					});
				});
			},
			writeBlobToHandle: async (file_path, blob) => {
				const arrayBuffer = await blob.arrayBuffer();
				return new Promise((resolve, reject) => {
					FilesystemSetup.withFilesystem(()=> {
						const fs = BrowserFS.BFSRequire("fs");
						const { Buffer } = BrowserFS.BFSRequire("buffer");
						const buffer = Buffer.from(arrayBuffer);
						fs.writeFile(file_path, buffer, (err)=> {
							if (err) {
								return reject(err);
							}
							resolve();
						});
					});
				});
			},
			setWallpaperCentered: (canvas) => {
				canvas.toBlob((blob) => {
					setDesktopWallpaper(blob, "no-repeat", true);
				});
			},
			setWallpaperTiled: (canvas) => {
				canvas.toBlob((blob) => {
					setDesktopWallpaper(blob, "repeat", true);
				});
			},
		};

		// it seems like I should be able to use onload here, but when it works (overrides the function),
		// it for some reason *breaks the scrollbar styling* in jspaint
		// I don't know what's going on there

		// contentWindow.addEventListener("load", function(){
		// $(contentWindow).on("load", function(){
		// $win.$iframe.load(function(){
		// $win.$iframe[0].addEventListener("load", function(){
		waitUntil(()=> contentWindow.systemHooks, 500, ()=> {
			Object.assign(contentWindow.systemHooks, systemHooks);

			let $help_window;
			contentWindow.show_help = () => {
				if ($help_window) {
					$help_window.focus();
					return;
				}
				$help_window = show_help({
					title: "Paint Help",
					contentsFile: "programs/jspaint/help/mspaint.hhc",
					root: "programs/jspaint/help",
				}).$help_window;
				$help_window.on("close", () => {
					$help_window = null;
				});
			};

			if (file_path) {
				// window.initial_system_file_handle = ...; is too late to set this here
				// contentWindow.open_from_file_handle(...); doesn't exist
				systemHooks.readBlobFromHandle(file_path).then(file => {
					if (file) {
						contentWindow.open_from_file(file, file_path);
					}
				}, (error) => {
					// this handler may not always called for errors, sometimes error message is shown via readBlobFromHandle
					contentWindow.show_error_message(`Failed to open file ${file_path}`, error);
				});
			}

			var old_update_title = contentWindow.update_title;
			contentWindow.update_title = () => {
				old_update_title();
				$win.title(contentWindow.document.title);
			};
		});

		return new Task($win);
	}
	Paint.acceptsFilePaths = true;

	function Minesweeper() {
		var $win = make_iframe_window({
			src: "programs/minesweeper/index.html",
			icons: iconsAtTwoSizes("minesweeper"),
			title: "Minesweeper",
			innerWidth: 280,
			innerHeight: 320 + 21,
			resizable: false,
		});
		return new Task($win);
	}

	function SoundRecorder(file_path) {
		// TODO: DRY the default file names and title code (use document.title of the page in the iframe, in make_iframe_window)
		var document_title = file_path ? file_name_from_path(file_path) : "Sound";
		var win_title = document_title + " - Sound Recorder";
		// TODO: focus existing window if file is currently open?
		var $win = make_iframe_window({
			src: "programs/sound-recorder/index.html" + (file_path ? ("?path=" + file_path) : ""),
			icons: iconsAtTwoSizes("speaker"),
			title: win_title,
			innerWidth: 270,
			innerHeight: 108 + 21,
			minInnerWidth: 270,
			minInnerHeight: 108 + 21,
		});
		return new Task($win);
	}
	SoundRecorder.acceptsFilePaths = true;

	function Solitaire() {
		var $win = make_iframe_window({
			src: "programs/js-solitaire/index.html",
			icons: iconsAtTwoSizes("solitaire"),
			title: "Solitaire",
			innerWidth: 585,
			innerHeight: 384 + 21,
		});
		return new Task($win);
	}

	function showScreensaver(iframeSrc) {
		const mouseDistanceToExit = 15;
		const $iframe = $("<iframe>").attr("src", iframeSrc);
		const $backing = $("<div>");
		$backing.css({
			position: "fixed",
			left: 0,
			top: 0,
			width: "100%",
			height: "100%",
			zIndex: $Window.Z_INDEX + 9998,
			cursor: "none",
			backgroundColor: "black",
		});
		$iframe.css({
			position: "fixed",
			left: 0,
			top: 0,
			width: "100%",
			height: "100%",
			zIndex: $Window.Z_INDEX + 9999,
			border: 0,
			pointerEvents: "none",
		});
		$backing.appendTo("body");
		$iframe.appendTo("body");
		const cleanUp = () => {
			$backing.remove();
			$iframe.remove();
			const prevent = (event) => {
				event.preventDefault();
			};
			$(window).on("contextmenu", prevent);
			setTimeout(() => {
				$(window).off("contextmenu", prevent);
				window.removeEventListener("keydown", keydownHandler, true);
			}, 500);
		};
		const keydownHandler = (event) => {
			// Trying to let you change the display or capture the output
			// not allowing Ctrl+PrintScreen etc. because no modifiers
			if (!(["F11", "F12", "ZoomToggle", "PrintScreen", "MediaRecord", "BrightnessDown", "BrightnessUp", "Dimmer"].includes(event.key))) {
				event.preventDefault();
				event.stopPropagation();
				cleanUp();
			}
		};
		let startMouseX, startMouseY;
		$backing.on("mousemove pointermove", (event) => {
			if (startMouseX === undefined) {
				startMouseX = event.pageX;
				startMouseY = event.pageY;
			}
			if (Math.hypot(startMouseX - event.pageX, startMouseY - event.pageY) > mouseDistanceToExit) {
				cleanUp();
			}
		});
		$backing.on("mousedown pointerdown touchstart", (event) => {
			event.preventDefault();
			cleanUp();
		});
		// useCapture needed for scenario where you hit Enter, with a desktop icon selected
		// (If it relaunches the screensaver, it's like you can't exit it!)
		window.addEventListener("keydown", keydownHandler, true);
	}

	function Pipes() {
		const options = { hideUI: true };
		showScreensaver(`programs/pipes/index.html#${encodeURIComponent(JSON.stringify(options))}`);
	}

	function FlowerBox() {
		showScreensaver("programs/3D-FlowerBox/index.html");
	}

	function CommandPrompt() {
		var $win = make_iframe_window({
			src: "programs/command/index.html",
			icons: iconsAtTwoSizes("msdos"),
			title: "MS-DOS Prompt",
			// TODO: default dimensions
			innerWidth: 640,
			innerHeight: 400,
			constrainRect(rect, x_axis, y_axis) {
				const char_width = 8;
				const char_height = 16;
				const border = ($win.outerWidth() - $win.$content.outerWidth()) / 2;
				const inner_rect = {
					x: rect.x + border,
					y: rect.y + border + $win.$titlebar.outerHeight(),
					width: rect.width - $win.outerWidth() + $win.$content.outerWidth(),
					height: rect.height - $win.outerHeight() + $win.$content.outerHeight(),
				};
				const new_inner_rect = {
					width: Math.floor(inner_rect.width / char_width) * char_width,
					height: Math.floor(inner_rect.height / char_height) * char_height,
				};
				const new_rect = {
					x: inner_rect.x - border,
					y: inner_rect.y - border - $win.$titlebar.outerHeight(),
					width: new_inner_rect.width + $win.outerWidth() - $win.$content.outerWidth(),
					height: new_inner_rect.height + $win.outerHeight() - $win.$content.outerHeight(),
				};
				if (x_axis === -1) {
					new_rect.x = rect.x + rect.width - new_rect.width;
				}
				if (y_axis === -1) {
					new_rect.y = rect.y + rect.height - new_rect.height;
				}
				return new_rect;
			},
			// TODO: make the API simpler / more flexible like:
			// constrainDimensions({ innerWidth, innerHeight }) {
			// 	const charWidth = 8;
			// 	const charHeight = 16;
			// 	innerWidth = Math.floor(innerWidth / charWidth) * charWidth;
			// 	innerHeight = Math.floor(innerHeight / charHeight) * charHeight;
			// 	return { innerWidth, innerHeight };
			// },
		});
		return new Task($win);
	}

	function Calculator() {
		var $win = make_iframe_window({
			src: "programs/calculator/index.html",
			icons: iconsAtTwoSizes("calculator"),
			title: "Calculator",
			innerWidth: 256,
			innerHeight: 208 + 21,
			minInnerWidth: 256,
			minInnerHeight: 208 + 21,
		});
		return new Task($win);
	}

	function Pinball() {
		var $win = make_iframe_window({
			src: "programs/pinball/space-cadet.html",
			icons: iconsAtTwoSizes("pinball"),
			title: "3D Pinball for Windows - Space Cadet",
			innerWidth: 600,
			innerHeight: 416 + 20, // @TODO: where's this 20 coming from?
			minInnerWidth: 600,
			minInnerHeight: 416 + 20,
			// resizable: false, // @TODO (maybe) once gray maximized button is implemented
			override_alert: false, // to handle the alert as a fatal error, and to compensate for overzealous preventDefault()
		});
		const $splash = $("<div>").css({
			position: "fixed",
			top: 0,
			left: 0,
			width: "100%",
			height: "100%",
			background: "url(images/pinball-splash.png) no-repeat center center",
			backgroundColor: "black",
			zIndex: $Window.Z_INDEX + 6000,
		}).appendTo("body");
		setTimeout(() => {
			$splash.remove(); // just in case
		}, 5000);
		$win.$content.find("iframe").on("game-loaded", () => { // custom event dispatched from within the iframe
			$splash.remove();
		});
		$win.$content.find("iframe").on("game-load-failed", () => { // custom event dispatched from within the iframe
			$splash.remove();
			// on some systems, if the game fails to load,
			// it may result in the canvas showing through to the desktop behind the browser window
			// let's call it a feature, tie it in thematically,
			// and pretend like we did it on purpose, to baffle and amuse.
			// This happens for me on Chrome on Ubuntu with Xfce, when coming out of suspend.
			// It says "Could not create renderer / Couldn't find matching render driver"
			// It keeps happening with live reload, but stops on a regular reload, or duplicating the tab.
			$win.title("Wormhole Window - Space Cadet");
		});
		return new Task($win);
	}

	function Explorer(address) {
		// TODO: DRY the default file names and title code (use document.title of the page in the iframe, in make_iframe_window)
		var document_title = address;
		var win_title = document_title;
		// TODO: focus existing window if folder is currently open
		var $win = make_iframe_window({
			src: "programs/explorer/index.html" + (address ? ("?address=" + encodeURIComponent(address)) : ""),
			icons: iconsAtTwoSizes("folder-open"),
			title: win_title,
			// this is based on one measurement, but it uses different sizes depending on the screen resolution,
			// and may be different for different Explorer window types (Microsoft Internet Explorer, "Exploring", normal Windows Explorer*),
			// and may store the window positions, even for different types or folders, so I might have a non-standard default size measurement.
			// *See different types (resized for posing this screenshot): https://imgur.com/nxAcT9C
			innerWidth: Math.min(856, innerWidth * 0.9),
			innerHeight: Math.min(547, innerHeight * 0.7),
		});
		return new Task($win);
	}
	Explorer.acceptsFilePaths = true;

	var webamp_bundle_loaded = false;
	var load_winamp_bundle_if_not_loaded = function (includeButterchurn, callback) {
		// FIXME: webamp_bundle_loaded not actually set to true when loaded
		// TODO: also maybe handle already-loading-but-not-done
		if (webamp_bundle_loaded) {
			callback();
		} else {
			// TODO: parallelize (if possible)
			$.getScript("programs/winamp/lib/webamp.bundle.min.js", () => {
				if (includeButterchurn) {
					$.getScript("programs/winamp/lib/butterchurn.min.js", () => {
						$.getScript("programs/winamp/lib/butterchurnPresets.min.js", () => {
							callback();
						});
					});
				} else {
					callback();
				}
			});
		}
	}

	// from https://github.com/jberg/butterchurn/blob/master/src/isSupported.js
	const isButterchurnSupported = () => {
		const canvas = document.createElement('canvas');
		let gl;
		try {
			gl = canvas.getContext('webgl2');
		} catch (x) {
			gl = null;
		}

		const webGL2Supported = !!gl;
		const audioApiSupported = !!(window.AudioContext || window.webkitAudioContext);

		return webGL2Supported && audioApiSupported;
	};

	let webamp;
	let $webamp;
	let winamp_task;
	let winamp_interface;
	let winamp_loading = false;
	// TODO: support opening multiple files at once
	function openWinamp(file_path) {
		const filePathToBlob = (file_path) => {
			return new Promise((resolve, reject) => {
				FilesystemSetup.withFilesystem(function () {
					var fs = BrowserFS.BFSRequire("fs");
					fs.readFile(file_path, function (err, buffer) {
						if (err) {
							return reject(err);
						}
						const byte_array = new Uint8Array(buffer);
						const blob = new Blob([byte_array]);
						resolve(blob);
					});
				});
			});
		};

		const filePathToTrack = async (file_path) => {
			const blob = await filePathToBlob(file_path);
			const blob_url = URL.createObjectURL(blob);
			// TODO: revokeObjectURL
			const track = {
				url: blob_url,
				defaultName: file_name_from_path(file_path).replace(/\.[a-z0-9]+$/i, ""),
			};
			return track;
		};

		const whenLoaded = async () => {
			if ($webamp.css("display") === "none") {
				winamp_interface.unminimize();
			}

			winamp_interface.focus();

			if (file_path) {
				if (file_path.match(/(\.wsz|\.zip)$/i)) {
					const blob = await filePathToBlob(file_path);
					const url = URL.createObjectURL(blob);
					webamp.setSkinFromUrl(url);
				} else if (file_path.match(/(\.m3u|\.pls)$/i)) {
					alert("Sorry, we don't support playlists yet.");
				} else {
					const track = await filePathToTrack(file_path);
					webamp.setTracksToPlay([track]);
				}
			}

			winamp_loading = false;
		}
		if (winamp_task) {
			whenLoaded()
			return;
		}
		if (winamp_loading) {
			return; // TODO: queue up files?
		}
		winamp_loading = true;

		// This check creates a WebGL context, so don't do it if you try to open Winamp while it's opening or open.
		// (Otherwise it will lead to "WARNING: Too many active WebGL contexts. Oldest context will be lost.")
		const includeButterchurn = isButterchurnSupported();

		load_winamp_bundle_if_not_loaded(includeButterchurn, function () {
			const webamp_options = {
				initialTracks: [{
					metaData: {
						artist: "DJ Mike Llama",
						title: "Llama Whippin' Intro",
					},
					url: "programs/winamp/mp3/llama-2.91.mp3",
					duration: 5.322286,
				}],
				// initialSkin: {
				// 	url: "programs/winamp/skins/base-2.91.wsz",
				// },
				enableHotkeys: true,
				handleTrackDropEvent: (event) =>
					Promise.all(
						dragging_file_paths.map(filePathToTrack)
					),
				// TODO: filePickers
			};
			if (includeButterchurn) {
				webamp_options.__butterchurnOptions = {
					importButterchurn: () => Promise.resolve(window.butterchurn),
					getPresets: () => {
						const presets = window.butterchurnPresets.getPresets();
						return Object.keys(presets).map((name) => {
							return {
								name,
								butterchurnPresetObject: presets[name]
							};
						});
					},
					butterchurnOpen: true,
				};
				webamp_options.__initialWindowLayout = {
					main: { position: { x: 0, y: 0 } },
					equalizer: { position: { x: 0, y: 116 } },
					playlist: { position: { x: 0, y: 232 }, size: [0, 4] },
					milkdrop: { position: { x: 275, y: 0 }, size: [7, 12] }
				};
			}
			webamp = new Webamp(webamp_options);

			var visual_container = document.createElement("div");
			visual_container.classList.add("webamp-visual-container");
			visual_container.style.position = "absolute";
			visual_container.style.left = "0";
			visual_container.style.right = "0";
			visual_container.style.top = "0";
			visual_container.style.bottom = "0";
			visual_container.style.pointerEvents = "none";
			document.body.appendChild(visual_container);
			// Render after the skin has loaded.
			webamp.renderWhenReady(visual_container).then(() => {
				window.console && console.log("Webamp rendered");

				$webamp = $("#webamp");
				// Bring window to front, initially and when clicked
				$webamp.css({
					position: "absolute",
					left: 0,
					top: 0,
					zIndex: $Window.Z_INDEX++
				});

				const $eventTarget = $({});
				const makeSimpleListenable = (name) => {
					return (callback) => {
						const fn = () => {
							callback();
						};
						$eventTarget.on(name, fn);
						const dispose = () => {
							$eventTarget.off(name, fn);
						};
						return dispose;
					};
				};

				winamp_interface = {};
				winamp_interface.onFocus = makeSimpleListenable("focus");
				winamp_interface.onBlur = makeSimpleListenable("blur");
				winamp_interface.onClosed = makeSimpleListenable("closed");
				winamp_interface.getIconAtSize = (target_icon_size) => {
					if (target_icon_size !== 32 && target_icon_size !== 16) {
						target_icon_size = 32;
					}
					const img = document.createElement("img");
					img.src = helpers.getIconPath("winamp2", target_icon_size);
					return img;
				};
				winamp_interface.bringToFront = () => {
					$webamp.css({
						zIndex: $Window.Z_INDEX++
					});
				};
				winamp_interface.element = winamp_interface[0] = $webamp[0]; // for checking z-index in window switcher
				winamp_interface.hasClass = (className) => { // also for window switcher (@TODO: clean this stuff up)
					if (className === "focused") {
						return $webamp.hasClass("focused");
					}
					return false;
				};
				winamp_interface.focus = () => {
					if (!$webamp.hasClass("focused")) {
						$webamp.addClass("focused");
						winamp_interface.bringToFront();
						$eventTarget.triggerHandler("focus");
						// @TODO: focus last focused window/control?
						$webamp.find("#main-window [tabindex='-1']").focus();
					}
				};
				winamp_interface.blur = () => {
					if ($webamp.hasClass("focused")) {
						$webamp.removeClass("focused");
						$eventTarget.triggerHandler("blur");
						// TODO: really blur
					}
				};
				winamp_interface.minimize = () => {
					// TODO: are these actually useful or does webamp hide it?
					$webamp.hide();
				};
				winamp_interface.unminimize = () => {
					// more to the point does this work necessarily??
					$webamp.show();
					// $webamp.focus();
				};
				winamp_interface.close = () => {
					// not allowing canceling close event in this case (generally used *by* an application (for "Save changes?"), not outside of it)
					// TODO: probably something like winamp_task.close()
					// winamp_interface.triggerHandler("close");
					// winamp_interface.triggerHandler("closed");
					webamp.dispose();
					$webamp.remove();

					$eventTarget.triggerHandler("closed");

					webamp = null;
					$webamp = null;
					winamp_task = null;
					winamp_interface = null;
				};
				winamp_interface.getTitle = () => {
					let taskTitle = "Winamp 2.91";
					const $cell = $webamp.find(".playlist-track-titles .track-cell.current");
					if ($cell.length) {
						taskTitle = `${$cell.text()} - Winamp`;
						switch (webamp.getMediaStatus()) {
							case "STOPPED":
								taskTitle = `${taskTitle} [Stopped]`
								break;
							case "PAUSED":
								taskTitle = `${taskTitle} [Paused]`
								break;
						}
					}
					return taskTitle;
				};
				winamp_interface.setMinimizeTarget = () => {
					// dummy function; it won't animate to the minimize target anyway
					// (did Winamp on Windows 98 animate minimize/restore?)
				};
				// @TODO: this wasn't supposed to be part of the API, but it's needed for the taskbar
				winamp_interface.on = (event_name, callback) => {
					if (event_name === "title-change") {
						webamp.onTrackDidChange(callback);
					} else if (event_name === "icon-change") {
						// icon will never change
					} else {
						console.warn(`Unsupported event: ${event_name}`);
					}
				};

				helpers.mustHaveMethods(winamp_interface, helpers.windowInterfaceMethods);

				let raf_id;
				let global_pointerdown;

				winamp_task = new Task(winamp_interface);
				webamp.onClose(function () {
					winamp_interface.close();
					cancelAnimationFrame(raf_id);
					visualizerOverlay.fadeOutAndCleanUp();
				});
				webamp.onMinimize(function () {
					winamp_interface.minimize();
				});

				$webamp.on("focusin", () => {
					winamp_interface.focus();
				});
				$webamp.on("focusout", () => {
					// could use relatedTarget, no?
					if (
						!document.activeElement ||
						!document.activeElement.closest ||
						!document.activeElement.closest("#webamp")
					) {
						winamp_interface.blur();
					}
				});

				const visualizerOverlay = new VisualizerOverlay(
					$webamp.find(".gen-window canvas")[0],
					{ mirror: true, stretch: true },
				);

				// TODO: replace with setInterval
				// Note: can't access butterchurn canvas image data during a requestAnimationFrame here
				// because of double buffering
				const animate = () => {
					const windowElements = $(".os-window, .window:not(.gen-window)").toArray();
					windowElements.forEach(windowEl => {
						if (!windowEl.hasOverlayCanvas) {
							visualizerOverlay.makeOverlayCanvas(windowEl);
							windowEl.hasOverlayCanvas = true;
						}
					});

					if (webamp.getMediaStatus() === "PLAYING") {
						visualizerOverlay.fadeIn();
					} else {
						visualizerOverlay.fadeOut();
					}
					raf_id = requestAnimationFrame(animate);
				};
				raf_id = requestAnimationFrame(animate);

				whenLoaded()
			}, (error) => {
				// TODO: show_error_message("Failed to load Webamp:", error);
				alert("Failed to render Webamp:\n\n" + error);
				console.error(error);
			});
		});
	}
	openWinamp.acceptsFilePaths = true;

	/*
	function saveAsDialog(){
		var $win = new $Window();
		$win.title("Save As");
		return $win;
	}
	function openFileDialog(){
		var $win = new $Window();
		$win.title("Open");
		return $win;
	}
	*/

	function openURLFile(file_path) {
		FilesystemSetup.withFilesystem(function () {
			var fs = BrowserFS.BFSRequire("fs");
			fs.readFile(file_path, "utf8", function (err, content) {
				if (err) {
					return alert(err);
				}
				// it's supposed to be an ini-style file, but lets handle files that are literally just a URL as well, just in case
				var match = content.match(/URL\s*=\s*([^\n\r]+)/i);
				var url = match ? match[1] : content;
				Explorer(url);
			});
		});
	}
	openURLFile.acceptsFilePaths = true;

	function openThemeFile(file_path) {
		FilesystemSetup.withFilesystem(function () {
			var fs = BrowserFS.BFSRequire("fs");
			fs.readFile(file_path, "utf8", function (err, content) {
				if (err) {
					return alert(err);
				}
				loadThemeFromText(content);
				try {
					localStorage.setItem("desktop-theme", content);
					localStorage.setItem("desktop-theme-path", file_path);
				} catch (error) {
					// no local storage
				}
			});
		});
	}
	openThemeFile.acceptsFilePaths = true;

	// Note: extensions must be lowercase here. This is used to implement case-insensitive matching.
	var file_extension_associations = {
		// Fonts:
		// - eot (Embedded OpenType)
		// - otf (OpenType)
		// - ttf (TrueType)
		// - woff (Web Open Font Format)
		// - woff2 (Web Open Font Format 2)
		// - (also svg but that's mainly an image format)

		// Misc binary:
		// - wasm (WebAssembly)
		// - o (Object file)
		// - so (Shared Object)
		// - dll (Dynamic Link Library)
		// - exe (Executable file)
		// - a (static library)
		// - lib (static library)
		// - pdb (Program Debug database)
		// - idb (Intermediate Debug file)
		// - bcmap (Binary Character Map)
		// - bin (generic binary file extension)

		// Text:
		"": Notepad, // bare files such as LICENSE, Makefile, CNAME, etc.
		ahk: Notepad,
		ai: Paint,
		bat: Notepad,
		check_cache: Notepad,
		cmake: Notepad,
		cmd: Notepad,
		conf: Notepad,
		cpp: Notepad,
		css: Notepad,
		d: Notepad,
		editorconfig: Notepad,
		filters: Notepad,
		gitattributes: Notepad,
		gitignore: Notepad,
		gitrepo: Notepad,
		h: Notepad,
		hhc: Notepad,
		hhk: Notepad,
		html: Notepad,
		ini: Notepad,
		js: Notepad,
		json: Notepad,
		log: Notepad,
		make: Notepad,
		map: Notepad,
		marks: Notepad,
		md: Notepad,
		prettierignore: Notepad,
		properties: Notepad,
		rc: Notepad,
		rsp: Notepad,
		sh: Notepad,
		ts: Notepad,
		txt: Notepad,
		vcxproj: Notepad,
		webmanifest: Notepad,
		xml: Notepad,
		yml: Notepad,

		// Images:
		bmp: Paint,
		cur: Paint,
		eps: Paint,
		gif: Paint,
		icns: Paint,
		ico: Paint,
		jpeg: Paint,
		jpg: Paint,
		kra: Paint,
		pbm: Paint,
		pdf: Paint, // yes I added PDF support to JS Paint (not all formats listed here are supported though)
		pdn: Paint,
		pgm: Paint,
		png: Paint,
		pnm: Paint,
		ppm: Paint,
		ps: Paint,
		psd: Paint,
		svg: Paint,
		tga: Paint,
		tif: Paint,
		tiff: Paint,
		webp: Paint,
		xbm: Paint,
		xcf: Paint,
		xcfbz2: Paint,
		xcfgz: Paint,
		xpm: Paint,

		// Winamp Skins:
		wsz: openWinamp, // winamp skin zip
		zip: openWinamp, // MIGHT be a winamp skin zip, so might as well for now

		// Audio:
		wav: SoundRecorder,
		mp3: openWinamp,
		ogg: openWinamp,
		wma: openWinamp,
		m4a: openWinamp,
		aac: openWinamp,
		flac: openWinamp,
		mka: openWinamp,
		mpc: openWinamp,
		"mp+": openWinamp,

		// Playlists:
		m3u: openWinamp,
		pls: openWinamp,

		// Misc:
		htm: Explorer,
		html: Explorer,
		url: openURLFile,
		theme: openThemeFile,
		themepack: openThemeFile,
	};

	// Note: global systemExecuteFile called by explorer
	function systemExecuteFile(file_path) {
		// execute file with default handler
		// like the START command in CMD.EXE

		FilesystemSetup.withFilesystem(function () {
			var fs = BrowserFS.BFSRequire("fs");
			fs.stat(file_path, function (err, stats) {
				if (err) {
					return alert("Failed to get info about " + file_path + "\n\n" + err);
				}
				if (stats.isDirectory()) {
					Explorer(file_path);
				} else {
					var file_extension = file_extension_from_path(file_path);
					var program = file_extension_associations[file_extension.toLowerCase()];
					if (program) {
						if (!program.acceptsFilePaths) {
							alert(program.name + " does not support opening files via the virtual filesystem yet");
							return;
						}
						program(file_path);
					} else {
						alert("No program is associated with " + file_extension + " files");
					}
				}
			});
		});
	}



	function initDesktopFolderView(folder_view) {
		// TODO: base all the desktop icons off of the filesystem
		// Note: `C:\Windows\Desktop` doesn't contain My Computer, My Documents, Network Neighborhood, Recycle Bin, or Internet Explorer,
		// or Connect to the Internet, or Setup MSN Internet Access,
		// whereas `Desktop` does (that's the full address it shows; it's one of them "special locations")
		var add_icon_not_via_filesystem = function (options) {
			folder_view.add_item(new FolderViewItem({
				icons: {
					// @TODO: know what sizes are available
					[helpers.DESKTOP_ICON_SIZE]: helpers.getIconPath(options.iconID, helpers.DESKTOP_ICON_SIZE),
				},
				...options,
			}));
		};
		add_icon_not_via_filesystem({
			title: "My Computer",
			iconID: "my-computer",
			open: function () { systemExecuteFile("/"); },
			// file_path: "/",
			is_system_folder: true,
		});
		add_icon_not_via_filesystem({
			title: "My Documents",
			iconID: "my-documents-folder",
			open: function () { systemExecuteFile("/my-documents"); },
			// file_path: "/my-documents/",
			is_system_folder: true,
		});
		add_icon_not_via_filesystem({
			title: "Network Neighborhood",
			iconID: "network",
			open: function () { systemExecuteFile("/network-neighborhood"); },
			// file_path: "/network-neighborhood/",
			is_system_folder: true,
		});
		add_icon_not_via_filesystem({
			title: "Recycle Bin",
			iconID: "recycle-bin",
			open: function () { Explorer("https://www.epa.gov/recycle/"); },
			is_system_folder: true,
		});
		add_icon_not_via_filesystem({
			title: "My Pictures",
			iconID: "folder",
			open: function () { systemExecuteFile("/my-pictures"); },
			// file_path: "/my-pictures/",
			is_system_folder: true,
		});
		add_icon_not_via_filesystem({
			title: "Internet Explorer",
			iconID: "internet-explorer",
			open: function () { Explorer("https://www.google.com/"); }
		});
		add_icon_not_via_filesystem({
			title: "Paint",
			iconID: "paint",
			open: Paint,
			shortcut: true
		});
		add_icon_not_via_filesystem({
			title: "Minesweeper",
			iconID: "minesweeper",
			open: Minesweeper,
			shortcut: true
		});
		add_icon_not_via_filesystem({
			title: "Sound Recorder",
			iconID: "speaker",
			open: SoundRecorder,
			shortcut: true
		});
		add_icon_not_via_filesystem({
			title: "Solitaire",
			iconID: "solitaire",
			open: Solitaire,
			shortcut: true
		});
		add_icon_not_via_filesystem({
			title: "Notepad",
			iconID: "notepad",
			open: Notepad,
			shortcut: true
		});
		add_icon_not_via_filesystem({
			title: "Winamp",
			iconID: "winamp2",
			open: openWinamp,
			shortcut: true
		});
		add_icon_not_via_filesystem({
			title: "3D Pipes",
			iconID: "pipes",
			open: Pipes,
			shortcut: true
		});
		add_icon_not_via_filesystem({
			title: "3D Flower Box",
			iconID: "pipes",
			open: FlowerBox,
			shortcut: true
		});
		add_icon_not_via_filesystem({
			title: "MS-DOS Prompt",
			iconID: "msdos",
			open: CommandPrompt,
			shortcut: true
		});
		add_icon_not_via_filesystem({
			title: "Calculator",
			iconID: "calculator",
			open: Calculator,
			shortcut: true
		});
		add_icon_not_via_filesystem({
			title: "Pinball",
			iconID: "pinball",
			open: Pinball,
			shortcut: true
		});

		folder_view.arrange_icons();

	}


	function iconsAtTwoSizes(iconID) {
		return {
			16: `images/icons/${iconID}-16x16.png`,
			32: `images/icons/${iconID}-32x32.png`,
		};
	}

	return {
		systemExecuteFile,
		initDesktopFolderView
	};

});
define('skylark-98js/$desktop',[
	"skylark-jquery",
	"./win98",
	"./FolderView",
	"./programs"
],function($,win98js,FolderView,programs){
    "use strict";

	const desktop_folder_path = "/desktop/";

	var $desktop = $(".desktop");
	$desktop.css("touch-action", "none"); // TODO: should this be in FolderView, or is it to prevent scrolling the page or what?

	var folder_view = new FolderView(desktop_folder_path, {
		asDesktop: true,
		openFileOrFolder: (path) => { // Note: may not be defined yet, so wrapping with a function.
			programs.systemExecuteFile(path);
		},
	});
	$(folder_view.element).appendTo($desktop);

	function setDesktopWallpaper(file, repeat, saveToLocalStorage) {
		const blob_url = URL.createObjectURL(file);
		$desktop.css({
			backgroundImage: `url(${blob_url})`,
			backgroundRepeat: repeat,
			backgroundPosition: "center",
			backgroundSize: "auto",
		});
		if (saveToLocalStorage) {
			var fr = new FileReader();
			window.fr = fr;
			fr.onload = () => {
				localStorage.setItem("wallpaper-data-url", fr.result);
				localStorage.setItem("wallpaper-repeat", repeat);
			};
			fr.onerror = () => {
				console.error("Error reading file (for setting wallpaper)", file);
			};
			fr.readAsDataURL(file);
		}
	}
	try {
		var wallpaper_data_url = localStorage.getItem("wallpaper-data-url");
		var wallpaper_repeat = localStorage.getItem("wallpaper-repeat");
		var theme_file_content = localStorage.getItem("desktop-theme");
		if (wallpaper_data_url) {
			fetch(wallpaper_data_url).then(r => r.blob()).then(file => {
				setDesktopWallpaper(file, wallpaper_repeat, false);
			});
		}
		if (theme_file_content) {
			loadThemeFromText(theme_file_content);
		}
	} catch (error) {
		console.error(error);
	}

	// Prevent drag and drop from redirecting the page (the browser default behavior for files)
	// TODO: only prevent if there are actually files; there's nothing that uses text inputs atm that's not in an iframe, so it doesn't matter YET (afaik)
	// $G.on("dragover", function(e){
	// 	e.preventDefault();
	// });
	// $G.on("drop", function(e){
	// 	e.preventDefault();
	// });

	function loadThemeFile(file) {
		var reader = new FileReader();
		reader.onload = () => {
			loadThemeFromText(reader.result);
		};
		reader.readAsText(file);
	}
	function applyTheme(cssProperties, documentElement = document.documentElement) {
		applyCSSProperties(cssProperties, { element: documentElement, recurseIntoIframes: true });
	}
	function loadThemeFromText(fileText) {
		var cssProperties = parseThemeFileString(fileText);
		applyTheme(cssProperties);
		window.themeCSSProperties = cssProperties;
	}

	$("html").on("dragover", function (event) {
		event.preventDefault();
		event.stopPropagation();
	});
	$("html").on("dragleave", function (event) {
		event.preventDefault();
		event.stopPropagation();
	});
	$("html").on("drop", function (event) {
		event.preventDefault();
		event.stopPropagation();
		var files = [...event.originalEvent.dataTransfer.files];
		for (var file of files) {
			if (file.name.match(/\.theme(pack)?$/i)) {
				loadThemeFile(file);
			}
		}
	});

	// Despite overflow:hidden on html and body,
	// focusing elements that are partially offscreen can still scroll the page.
	// For example, with opening Paint and moving it partially offscreen and opening Image > Attributes,
	// the default focused button can scroll the entire desktop.
	// We need to prevent (reset) scroll, and also avoid scrollIntoView().
	$(window).on("scroll focusin", () => {
		window.scrollTo(0, 0);
	});


	programs.initDesktopFolderView(folder_view);


	$desktop.reflow();

	return win98js.$desktop = $desktop;
});
define('skylark-98js/$start-menu',[
	"skylark-jquery",
	"./win98",
	"./os-gui/$Window"
],function($,win98js,$Window){
	// TODO: start menu

	/*
	// if running from file: protocol, try to sniff the username >:)
	var username_match = location.href.match(/\/(Users|home)\/(\w+)\//);
	var username = username_match && username_match[1] || "Admin";
	*/

	var $start_menu = $(".start-menu");
	$start_menu.hide();
	// TODO: legitimate contents or whatever
	var open_start_menu = function () {
		$start_button.addClass("selected");
		$start_menu.attr("hidden", null);
		$start_menu.slideDown(100); // DOWN AS IN UP (stupid jQuery)
		$start_menu.css({ zIndex: ++$Window.Z_INDEX + 5001 });
	};
	var close_start_menu = function () {
		$start_button.removeClass("selected");
		$start_menu.attr("hidden", "hidden");
		$start_menu.hide();
	};
	var toggle_start_menu = function () {
		if ($start_menu.is(":hidden")) {
			open_start_menu();
		} else {
			close_start_menu();
		}
	};

	var $start_button = $(".start-button");
	$start_button.on("pointerdown", function () {
		toggle_start_menu();
	});

	$("body").on("pointerdown", function (e) {
		if ($(e.target).closest(".start-menu, .start-button").length === 0) {
			close_start_menu();
		}
	});
	// Note: A lot of the time it's good to use focusout (in jQuery, or else blur with useCapture?[1]) as opposed to 
	// That might be the case here as well, but maybe not since programs opening might grab focus and that probably shouldn't close the start menu
	// Although at the operating system level it would probably prevent focus switching in the first place, so maybe we could do that
	// The point being this is an operating system control and so it may warrant special handling,
	// but generally I'd recommend making a control focusable and detecting loss of focus as in this answer:
	// [1]: https://stackoverflow.com/a/38317768/2624876

	$(window).on("keydown", function (e) {
		if (e.which === 27) { // Esc to close
			close_start_menu();
		}
	});

	return $start_menu;
});
define('skylark-98js/$taskbar-time',[
	"skylark-jquery",
	"./win98"
],function($,win98js){
	var $time = $(".taskbar-time");
	var update_time = function () {
		$time.text(new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }));
		$time.attr("title", new Date().toLocaleString([], { weekday: 'long', month: 'long', day: '2-digit', minute: '2-digit', hour: '2-digit' }));
		setTimeout(update_time, 1000);
	};
	update_time();

	return $time;
});

define('skylark-98js/msgbox',[
	"skylark-jquery",
	"./win98",
	"./os-gui/$Window"
],function($,win98js,$Window){
	// Prefer a function injected from outside an iframe,
	// which will make dialogs that can go outside the iframe.
	// Note that this API must be kept in sync with the version in jspaint.

	// Note `defaultMessageBoxTitle` handling in make_iframe_window
	// Any other default parameters need to be handled there (as it works now)

	var chord_audio = new Audio("/audio/CHORD.WAV");

	window.showMessageBox = window.showMessageBox || (({
		title = window.defaultMessageBoxTitle /*??*/ ||  "Alert",
		message,
		messageHTML,
		buttons = [{ label: "OK", value: "ok", default: true }],
		iconID = "warning", // "error", "warning", "info", or "nuke" for deleting files/folders
		windowOptions = {}, // for controlling width, etc.
	}) => {
		let $window, $message;
		const promise = new Promise((resolve, reject) => {
			$window = new $Window(Object.assign({
				title,
				resizable: false,
				innerWidth: 400,
				maximizeButton: false,
				minimizeButton: false,
			}, windowOptions));
			// $window.addClass("dialog-window horizontal-buttons");
			$message =
				$("<div>").css({
					textAlign: "left",
					fontFamily: "MS Sans Serif, Arial, sans-serif",
					fontSize: "14px",
					marginTop: "22px",
					flex: 1,
					minWidth: 0, // Fixes hidden overflow, see https://css-tricks.com/flexbox-truncated-text/
					whiteSpace: "normal", // overriding .window:not(.squish)
				});
			if (messageHTML) {
				$message.html(messageHTML);
			} else if (message) { // both are optional because you may populate later with dynamic content
				$message.text(message).css({
					whiteSpace: "pre-wrap",
					wordWrap: "break-word",
				});
			}
			$("<div>").append(
				$("<img width='32' height='32'>").attr("src", `../../images/icons/${iconID}-32x32-8bpp.png`).css({
					margin: "16px",
					display: "block",
				}),
				$message
			).css({
				display: "flex",
				flexDirection: "row",
			}).appendTo($window.$content);

			$window.$content.css({
				textAlign: "center",
			});
			for (const button of buttons) {
				const $button = $window.$Button(button.label, () => {
					button.action && button.action(); // API may be required for using user gesture requiring APIs
					resolve(button.value);
					$window.close(); // actually happens automatically
				});
				if (button.default) {
					$button.addClass("default");
					$button.focus();
					setTimeout(() => $button.focus(), 0); // @TODO: why is this needed? does it have to do with the iframe window handling?
				}
				$button.css({
					minWidth: 75,
					height: 23,
					margin: "16px 2px",
				});
			}
			$window.on("focusin", "button", (event) => {
				$(event.currentTarget).addClass("default");
			});
			$window.on("focusout", "button", (event) => {
				$(event.currentTarget).removeClass("default");
			});
			$window.on("closed", () => {
				resolve("closed"); // or "cancel"? do you need to distinguish?
			});
			$window.center();
		});
		promise.$window = $window;
		promise.$message = $message;
		promise.promise = promise; // for easy destructuring
		try {
			chord_audio.play();
		} catch (error) {
			console.log(`Failed to play ${chord_audio.src}: `, error);
		}
		return promise;
	});

	window.alert = (message) => {
		showMessageBox({ message });
	};

});
define('skylark-clippy/Queue',['skylark-jquery'], function ($) {
    'use strict';
    class Queue {
        constructor(onEmptyCallback) {
            this._queue = [];
            this._onEmptyCallback = onEmptyCallback;
        }
        queue(func) {
            this._queue.push(func);
            if (this._queue.length === 1 && !this._active) {
                this._progressQueue();
            }
        }
        _progressQueue() {
            if (!this._queue.length) {
                this._onEmptyCallback();
                return;
            }
            let f = this._queue.shift();
            this._active = true;
            let completeFunction = $.proxy(this.next, this);
            f(completeFunction);
        }
        clear() {
            this._queue = [];
        }
        next() {
            this._active = false;
            this._progressQueue();
        }
    }

    return Queue;
});
define('skylark-clippy/Animator',['skylark-jquery'], function ($) {
    'use strict';
    class Animator {
        constructor(el, path, data, sounds) {
            this._el = el;
            this._data = data;
            this._path = path;
            this._currentFrameIndex = 0;
            this._currentFrame = undefined;
            this._exiting = false;
            this._currentAnimation = undefined;
            this._endCallback = undefined;
            this._started = false;
            this._sounds = {};
            this.currentAnimationName = undefined;
            this.preloadSounds(sounds);
            this._overlays = [this._el];
            let curr = this._el;
            this._setupElement(this._el);
            for (let i = 1; i < this._data.overlayCount; i++) {
                let inner = this._setupElement($('<div></div>'));
                curr.append(inner);
                this._overlays.push(inner);
                curr = inner;
            }
        }
        _setupElement(el) {
            let frameSize = this._data.framesize;
            el.css('display', 'none');
            el.css({
                width: frameSize[0],
                height: frameSize[1]
            });
            el.css('background', "url('" + this._path + "/map.png') no-repeat");
            return el;
        }
        animations() {
            let r = [];
            let d = this._data.animations;
            for (let n in d) {
                r.push(n);
            }
            return r;
        }
        preloadSounds(sounds) {
            for (let i = 0; i < this._data.sounds.length; i++) {
                let snd = this._data.sounds[i];
                let uri = sounds[snd];
                if (!uri)
                    continue;
                this._sounds[snd] = new Audio(uri);
            }
        }
        hasAnimation(name) {
            return !!this._data.animations[name];
        }
        exitAnimation() {
            this._exiting = true;
        }
        showAnimation(animationName, stateChangeCallback) {
            this._exiting = false;
            if (!this.hasAnimation(animationName)) {
                return false;
            }
            this._currentAnimation = this._data.animations[animationName];
            this.currentAnimationName = animationName;
            if (!this._started) {
                this._step();
                this._started = true;
            }
            this._currentFrameIndex = 0;
            this._currentFrame = undefined;
            this._endCallback = stateChangeCallback;
            return true;
        }
        _draw() {
            let images = [];
            if (this._currentFrame)
                images = this._currentFrame.images || [];
            for (let i = 0; i < this._overlays.length; i++) {
                if (i < images.length) {
                    let xy = images[i];
                    let bg = -xy[0] + 'px ' + -xy[1] + 'px';
                    this._overlays[i].css({
                        'background-position': bg,
                        'display': 'block'
                    });
                } else {
                    this._overlays[i].css('display', 'none');
                }
            }
        }
        _getNextAnimationFrame() {
            if (!this._currentAnimation)
                return undefined;
            if (!this._currentFrame)
                return 0;
            let currentFrame = this._currentFrame;
            let branching = this._currentFrame.branching;
            if (this._exiting && currentFrame.exitBranch !== undefined) {
                return currentFrame.exitBranch;
            } else if (branching) {
                let rnd = Math.random() * 100;
                for (let i = 0; i < branching.branches.length; i++) {
                    let branch = branching.branches[i];
                    if (rnd <= branch.weight) {
                        return branch.frameIndex;
                    }
                    rnd -= branch.weight;
                }
            }
            return this._currentFrameIndex + 1;
        }
        _playSound() {
            let s = this._currentFrame.sound;
            if (!s)
                return;
            let audio = this._sounds[s];
            if (audio)
                audio.play();
        }
        _atLastFrame() {
            return this._currentFrameIndex >= this._currentAnimation.frames.length - 1;
        }
        _step() {
            if (!this._currentAnimation)
                return;
            let newFrameIndex = Math.min(this._getNextAnimationFrame(), this._currentAnimation.frames.length - 1);
            let frameChanged = !this._currentFrame || this._currentFrameIndex !== newFrameIndex;
            this._currentFrameIndex = newFrameIndex;
            if (!(this._atLastFrame() && this._currentAnimation.useExitBranching)) {
                this._currentFrame = this._currentAnimation.frames[this._currentFrameIndex];
            }
            this._draw();
            this._playSound();
            this._loop = window.setTimeout($.proxy(this._step, this), this._currentFrame.duration);
            if (this._endCallback && frameChanged && this._atLastFrame()) {
                if (this._currentAnimation.useExitBranching && !this._exiting) {
                    this._endCallback(this.currentAnimationName, Animator.States.WAITING);
                } else {
                    this._endCallback(this.currentAnimationName, Animator.States.EXITED);
                }
            }
        }
        pause() {
            window.clearTimeout(this._loop);
        }
        resume() {
            this._step();
        }
    }
    
    Animator.States = {
        WAITING: 1,
        EXITED: 0
    };

    return Animator;
});
define('skylark-clippy/Balloon',['skylark-jquery'], function ($) {
    'use strict';
    class Balloon {
        constructor(targetEl) {
            this._targetEl = targetEl;
            this._hidden = true;
            this._setup();
            this.WORD_SPEAK_TIME = 200;
            this.CLOSE_BALLOON_DELAY = 2000;
            this._BALLOON_MARGIN = 15;
        }
        _setup() {
            this._balloon = $('<div class="clippy-balloon"><div class="clippy-tip"></div><div class="clippy-content"></div></div> ').hide();
            this._content = this._balloon.find('.clippy-content');
            $(document.body).append(this._balloon);
        }
        reposition() {
            let sides = [
                'top-left',
                'top-right',
                'bottom-left',
                'bottom-right'
            ];
            for (let i = 0; i < sides.length; i++) {
                let s = sides[i];
                this._position(s);
                if (!this._isOut())
                    break;
            }
        }
        _position(side) {
            let o = this._targetEl.offset();
            let h = this._targetEl.height();
            let w = this._targetEl.width();
            o.top -= $(window).scrollTop();
            o.left -= $(window).scrollLeft();
            let bH = this._balloon.outerHeight();
            let bW = this._balloon.outerWidth();
            this._balloon.removeClass('clippy-top-left');
            this._balloon.removeClass('clippy-top-right');
            this._balloon.removeClass('clippy-bottom-right');
            this._balloon.removeClass('clippy-bottom-left');
            let left, top;
            switch (side) {
            case 'top-left':
                left = o.left + w - bW;
                top = o.top - bH - this._BALLOON_MARGIN;
                break;
            case 'top-right':
                left = o.left;
                top = o.top - bH - this._BALLOON_MARGIN;
                break;
            case 'bottom-right':
                left = o.left;
                top = o.top + h + this._BALLOON_MARGIN;
                break;
            case 'bottom-left':
                left = o.left + w - bW;
                top = o.top + h + this._BALLOON_MARGIN;
                break;
            }
            this._balloon.css({
                top: top,
                left: left
            });
            this._balloon.addClass('clippy-' + side);
        }
        _isOut() {
            let o = this._balloon.offset();
            let bH = this._balloon.outerHeight();
            let bW = this._balloon.outerWidth();
            let wW = $(window).width();
            let wH = $(window).height();
            let sT = $(document).scrollTop();
            let sL = $(document).scrollLeft();
            let top = o.top - sT;
            let left = o.left - sL;
            let m = 5;
            if (top - m < 0 || left - m < 0)
                return true;
            return top + bH + m > wH || left + bW + m > wW;
        }
        speak(complete, text, hold) {
            this._hidden = false;
            this.show();
            let c = this._content;
            c.height('auto');
            c.width('auto');
            c.text(text);
            c.height(c.height());
            c.width(c.width());
            c.text('');
            this.reposition();
            this._complete = complete;
            this._sayWords(text, hold, complete);
        }
        show() {
            if (this._hidden)
                return;
            this._balloon.show();
        }
        hide(fast) {
            if (fast) {
                this._balloon.hide();
                return;
            }
            this._hiding = window.setTimeout($.proxy(this._finishHideBalloon, this), this.CLOSE_BALLOON_DELAY);
        }
        _finishHideBalloon() {
            if (this._active)
                return;
            this._balloon.hide();
            this._hidden = true;
            this._hiding = null;
        }
        _sayWords(text, hold, complete) {
            this._active = true;
            this._hold = hold;
            let words = text.split(/[^\S-]/);
            let time = this.WORD_SPEAK_TIME;
            let el = this._content;
            let idx = 1;
            this._addWord = $.proxy(function () {
                if (!this._active)
                    return;
                if (idx > words.length) {
                    delete this._addWord;
                    this._active = false;
                    if (!this._hold) {
                        complete();
                        this.hide();
                    }
                } else {
                    el.text(words.slice(0, idx).join(' '));
                    idx++;
                    this._loop = window.setTimeout($.proxy(this._addWord, this), time);
                }
            }, this);
            this._addWord();
        }
        close() {
            if (this._active) {
                this._hold = false;
            } else if (this._hold) {
                this._complete();
            }
        }
        pause() {
            window.clearTimeout(this._loop);
            if (this._hiding) {
                window.clearTimeout(this._hiding);
                this._hiding = null;
            }
        }
        resume() {
            if (this._addWord) {
                this._addWord();
            } else if (!this._hold && !this._hidden) {
                this._hiding = window.setTimeout($.proxy(this._finishHideBalloon, this), this.CLOSE_BALLOON_DELAY);
            }
        }
    }

    return Balloon;
});
define('skylark-clippy/Agent',[
    'skylark-jquery',
    './Queue',
    './Animator',
    './Balloon'
], function ($, Queue, Animator, Balloon) {
    'use strict';
     class Agent {
        constructor(path, data, sounds) {
            this.path = path;
            this._queue = new Queue($.proxy(this._onQueueEmpty, this));
            this._el = $('<div class="clippy"></div>').hide();
            $(document.body).append(this._el);
            this._animator = new Animator(this._el, path, data, sounds);
            this._balloon = new Balloon(this._el);
            this._setupEvents();
        }
        gestureAt(x, y) {
            let d = this._getDirection(x, y);
            let gAnim = 'Gesture' + d;
            let lookAnim = 'Look' + d;
            let animation = this.hasAnimation(gAnim) ? gAnim : lookAnim;
            return this.play(animation);
        }
        hide(fast, callback) {
            this._hidden = true;
            let el = this._el;
            this.stop();
            if (fast) {
                this._el.hide();
                this.stop();
                this.pause();
                if (callback)
                    callback();
                return;
            }
            return this._playInternal('Hide', function () {
                el.hide();
                this.pause();
                if (callback)
                    callback();
            });
        }
        moveTo(x, y, duration) {
            let dir = this._getDirection(x, y);
            let anim = 'Move' + dir;
            if (duration === undefined)
                duration = 1000;
            this._addToQueue(function (complete) {
                if (duration === 0) {
                    this._el.css({
                        top: y,
                        left: x
                    });
                    this.reposition();
                    complete();
                    return;
                }
                if (!this.hasAnimation(anim)) {
                    this._el.animate({
                        top: y,
                        left: x
                    }, duration, complete);
                    return;
                }
                let callback = $.proxy(function (name, state) {
                    if (state === Animator.States.EXITED) {
                        complete();
                    }
                    if (state === Animator.States.WAITING) {
                        this._el.animate({
                            top: y,
                            left: x
                        }, duration, $.proxy(function () {
                            this._animator.exitAnimation();
                        }, this));
                    }
                }, this);
                this._playInternal(anim, callback);
            }, this);
        }
        _playInternal(animation, callback) {
            if (this._isIdleAnimation() && this._idleDfd && this._idleDfd.state() === 'pending') {
                this._idleDfd.done($.proxy(function () {
                    this._playInternal(animation, callback);
                }, this));
            }
            this._animator.showAnimation(animation, callback);
        }
        play(animation, timeout, cb) {
            if (!this.hasAnimation(animation))
                return false;
            if (timeout === undefined)
                timeout = 5000;
            this._addToQueue(function (complete) {
                let completed = false;
                let callback = function (name, state) {
                    if (state === Animator.States.EXITED) {
                        completed = true;
                        if (cb)
                            cb();
                        complete();
                    }
                };
                if (timeout) {
                    window.setTimeout($.proxy(function () {
                        if (completed)
                            return;
                        this._animator.exitAnimation();
                    }, this), timeout);
                }
                this._playInternal(animation, callback);
            }, this);
            return true;
        }
        show(fast) {
            this._hidden = false;
            if (fast) {
                this._el.show();
                this.resume();
                this._onQueueEmpty();
                return;
            }
            if (this._el.css('top') === 'auto' || !this._el.css('left') === 'auto') {
                let left = $(window).width() * 0.8;
                let top = ($(window).height() + $(document).scrollTop()) * 0.8;
                this._el.css({
                    top: top,
                    left: left
                });
            }
            this.resume();
            return this.play('Show');
        }
        speak(text, hold) {
            this._addToQueue(function (complete) {
                this._balloon.speak(complete, text, hold);
            }, this);
        }
        closeBalloon() {
            this._balloon.hide();
        }
        delay(time) {
            time = time || 250;
            this._addToQueue(function (complete) {
                this._onQueueEmpty();
                window.setTimeout(complete, time);
            });
        }
        stopCurrent() {
            this._animator.exitAnimation();
            this._balloon.close();
        }
        stop() {
            this._queue.clear();
            this._animator.exitAnimation();
            this._balloon.hide();
        }
        hasAnimation(name) {
            return this._animator.hasAnimation(name);
        }
        animations() {
            return this._animator.animations();
        }
        animate() {
            let animations = this.animations();
            let anim = animations[Math.floor(Math.random() * animations.length)];
            if (anim.indexOf('Idle') === 0) {
                return this.animate();
            }
            return this.play(anim);
        }
        _getDirection(x, y) {
            let offset = this._el.offset();
            let h = this._el.height();
            let w = this._el.width();
            let centerX = offset.left + w / 2;
            let centerY = offset.top + h / 2;
            let a = centerY - y;
            let b = centerX - x;
            let r = Math.round(180 * Math.atan2(a, b) / Math.PI);
            if (-45 <= r && r < 45)
                return 'Right';
            if (45 <= r && r < 135)
                return 'Up';
            if (135 <= r && r <= 180 || -180 <= r && r < -135)
                return 'Left';
            if (-135 <= r && r < -45)
                return 'Down';
            return 'Top';
        }
        _onQueueEmpty() {
            if (this._hidden || this._isIdleAnimation())
                return;
            let idleAnim = this._getIdleAnimation();
            this._idleDfd = $.Deferred();
            this._animator.showAnimation(idleAnim, $.proxy(this._onIdleComplete, this));
        }
        _onIdleComplete(name, state) {
            if (state === Animator.States.EXITED) {
                this._idleDfd.resolve();
            }
        }
        _isIdleAnimation() {
            let c = this._animator.currentAnimationName;
            return c && c.indexOf('Idle') === 0;
        }
        _getIdleAnimation() {
            let animations = this.animations();
            let r = [];
            for (let i = 0; i < animations.length; i++) {
                let a = animations[i];
                if (a.indexOf('Idle') === 0) {
                    r.push(a);
                }
            }
            let idx = Math.floor(Math.random() * r.length);
            return r[idx];
        }
        _setupEvents() {
            $(window).on('resize', $.proxy(this.reposition, this));
            this._el.on('mousedown', $.proxy(this._onMouseDown, this));
            this._el.on('dblclick', $.proxy(this._onDoubleClick, this));
        }
        _onDoubleClick() {
            if (!this.play('ClickedOn')) {
                this.animate();
            }
        }
        reposition() {
            if (!this._el.is(':visible'))
                return;
            let o = this._el.offset();
            let bH = this._el.outerHeight();
            let bW = this._el.outerWidth();
            let wW = $(window).width();
            let wH = $(window).height();
            let sT = $(window).scrollTop();
            let sL = $(window).scrollLeft();
            let top = o.top - sT;
            let left = o.left - sL;
            let m = 5;
            if (top - m < 0) {
                top = m;
            } else if (top + bH + m > wH) {
                top = wH - bH - m;
            }
            if (left - m < 0) {
                left = m;
            } else if (left + bW + m > wW) {
                left = wW - bW - m;
            }
            this._el.css({
                left: left,
                top: top
            });
            this._balloon.reposition();
        }
        _onMouseDown(e) {
            e.preventDefault();
            this._startDrag(e);
        }
        _startDrag(e) {
            this.pause();
            this._balloon.hide(true);
            this._offset = this._calculateClickOffset(e);
            this._moveHandle = $.proxy(this._dragMove, this);
            this._upHandle = $.proxy(this._finishDrag, this);
            $(window).on('mousemove', this._moveHandle);
            $(window).on('mouseup', this._upHandle);
            this._dragUpdateLoop = window.setTimeout($.proxy(this._updateLocation, this), 10);
        }
        _calculateClickOffset(e) {
            let mouseX = e.pageX;
            let mouseY = e.pageY;
            let o = this._el.offset();
            return {
                top: mouseY - o.top,
                left: mouseX - o.left
            };
        }
        _updateLocation() {
            this._el.css({
                top: this._targetY,
                left: this._targetX
            });
            this._dragUpdateLoop = window.setTimeout($.proxy(this._updateLocation, this), 10);
        }
        _dragMove(e) {
            e.preventDefault();
            let x = e.clientX - this._offset.left;
            let y = e.clientY - this._offset.top;
            this._targetX = x;
            this._targetY = y;
        }
        _finishDrag() {
            window.clearTimeout(this._dragUpdateLoop);
            $(window).off('mousemove', this._moveHandle);
            $(window).off('mouseup', this._upHandle);
            this._balloon.show();
            this.reposition();
            this.resume();
        }
        _addToQueue(func, scope) {
            if (scope)
                func = $.proxy(func, scope);
            this._queue.queue(func);
        }
        pause() {
            this._animator.pause();
            this._balloon.pause();
        }
        resume() {
            this._animator.resume();
            this._balloon.resume();
        }
    }

    return Agent;
});
define('skylark-clippy/loads',[
    'skylark-jquery',
    './Agent'
], function ($, Agent) {
    'use strict';
    class load {
        constructor(name, successCb, failCb, base_path) {
            base_path = base_path || window.CLIPPY_CDN || 'https://gitcdn.xyz/repo/pi0/clippyjs/master/assets/agents/';
            let path = base_path + name;
            let mapDfd = load._loadMap(path);
            let agentDfd = load._loadAgent(name, path);
            let soundsDfd = load._loadSounds(name, path);
            let data;
            agentDfd.done(function (d) {
                data = d;
            });
            let sounds;
            soundsDfd.done(function (d) {
                sounds = d;
            });
            let cb = function () {
                let a = new Agent(path, data, sounds);
                successCb(a);
            };
            $.when(mapDfd, agentDfd, soundsDfd).done(cb).fail(failCb);
        }
        static _loadMap(path) {
            let dfd = load._maps[path];
            if (dfd)
                return dfd;
            dfd = load._maps[path] = $.Deferred();
            let src = path + '/map.png';
            let img = new Image();
            img.onload = dfd.resolve;
            img.onerror = dfd.reject;
            img.setAttribute('src', src);
            return dfd.promise();
        }
        static _loadSounds(name, path) {
            let dfd = load._sounds[name];
            if (dfd)
                return dfd;
            dfd = load._sounds[name] = $.Deferred();
            let audio = document.createElement('audio');
            let canPlayMp3 = !!audio.canPlayType && '' !== audio.canPlayType('audio/mpeg');
            let canPlayOgg = !!audio.canPlayType && '' !== audio.canPlayType('audio/ogg; codecs="vorbis"');
            if (!canPlayMp3 && !canPlayOgg) {
                dfd.resolve({});
            } else {
                let src = path + (canPlayMp3 ? '/sounds-mp3.js' : '/sounds-ogg.js');
                load._loadScript(src);
            }
            return dfd.promise();
        }
        static _loadAgent(name, path) {
            let dfd = load._data[name];
            if (dfd)
                return dfd;
            dfd = load._getAgentDfd(name);
            let src = path + '/agent.js';
            load._loadScript(src);
            return dfd.promise();
        }
        static _loadScript(src) {
            let script = document.createElement('script');
            script.setAttribute('src', src);
            script.setAttribute('async', 'async');
            script.setAttribute('type', 'text/javascript');
            document.head.appendChild(script);
        }
        static _getAgentDfd(name) {
            let dfd = load._data[name];
            if (!dfd) {
                dfd = load._data[name] = $.Deferred();
            }
            return dfd;
        }
    }
    load._maps = {};
    load._sounds = {};
    load._data = {};
    function ready(name, data) {
        let dfd = load._getAgentDfd(name);
        dfd.resolve(data);
    }
    function soundsReady(name, data) {
        let dfd = load._sounds[name];
        if (!dfd) {
            dfd = load._sounds[name] = $.Deferred();
        }
        dfd.resolve(data);
    }
    return {
        load: load,
        ready: ready,
        soundsReady: soundsReady
    };
});
define('skylark-clippy/main',[
    "skylark-langx/skylark",
    './Agent',
    './Animator',
    './Queue',
    './Balloon',
    './loads'
], function (skylark,Agent, Animator, Queue, Balloon, loads) {
    'use strict';

    const clippy = {
        Agent,
        Animator,
        Queue,
        Balloon,
        "load" : loads.load,
        "ready": loads.ready,
        "soundsReady": loads.soundsReady
    };
    return skylark.attach("intg.clippy",clippy);

});
define('skylark-clippy', ['skylark-clippy/main'], function (main) { return main; });

define('skylark-98js/window-switcher',[
	"skylark-jquery",
	"skylark-clippy",
	"./win98",
	"./Task"
],function($,clippy,win98js,Task){
	
	var $window_switcher = $("<div class='window-switcher outset-deep'>");
	var $window_switcher_list = $("<ul class='window-switcher-list'>").appendTo($window_switcher);
	var $window_switcher_window_name = $("<div class='window-switcher-window-name inset-deep'>").appendTo($window_switcher);
	var agent;
	var used_window_switcher = false;

	function activate_window($window) {
		// console.log("Activating window:", $window);
		$window.unminimize();
		$window.bringToFront();
		$window.focus(); // unminimize will focus but only if it was minimized (that's the current behavior anyway)
	}

	function show_window_switcher(cycle_backwards) {
		if ($window_switcher.is(":visible")) {
			cycle_window_switcher(cycle_backwards);
			return;
		}
		$window_switcher_list.empty();
		const tasks = Task.all_tasks;
		if (tasks.length === 1) {
			activate_window(tasks[0].$window);
			if (!used_window_switcher) {
				agent && agent.stopCurrent(); // needed to continue on from the message with `hold` set (speak(message, true))
				agent && agent.speak("If there's only one window, Alt+` will switch to it right away.");
				// used_window_switcher = true; // allow the switching message to be spoken later
			}
			return;
		}
		if (tasks.length < 2) {
			return;
		}
		tasks.sort((a, b) =>
			// using z-index, as it's similar to last-used order
			b.$window[0].style.zIndex - a.$window[0].style.zIndex
		);
		for (const task of tasks) {
			var $window = task.$window;
			var $item = $("<li>").addClass("window-switcher-item");
			$item.append($window.getIconAtSize(32) /*??*/ ||  $("<img>").attr({
				src: "/images/icons/task-32x32.png",
				width: 32,
				height: 32,
				alt: $window.getTitle()
			}));
			$item.data("$window", $window);
			// $item.on("click", function () { // Windows 98 didn't allow clicking items in the window switcher.
			// 	activate_window($window);
			// });
			$window_switcher_list.append($item);
			if ($window.hasClass("focused")) {
				$item.addClass("active");
			}
		}
		cycle_window_switcher(cycle_backwards);
		$window_switcher.appendTo("body");
		// console.log("Showing window switcher", $window_switcher[0]);
		if (!used_window_switcher) {
			agent && agent.stopCurrent(); // needed to continue on from the message with `hold` set (speak(message, true))
			// Um, if you know about Alt+Tab, you can guess about how Alt+` works. But Clippy is supposed to be annoying, right?
			agent && agent.speak("There you go! Press grave accent until you get to the window you want.");
			used_window_switcher = true;
		}
	}
	function cycle_window_switcher(cycle_backwards) {
		const items = $window_switcher.find(".window-switcher-item").toArray();
		const $active = $window_switcher.find(".active");
		const old_index = items.indexOf($active[0]);
		const new_index = ((old_index + (cycle_backwards ? -1 : 1)) + items.length) % items.length;
		$active.removeClass("active");
		const new_item = items[new_index];
		$(new_item).addClass("active");
		$window_switcher_window_name.text($(new_item).data("$window").getTitle());
	}
	function window_switcher_close_and_select() {
		if (!$window_switcher.is(":visible")) {
			return;
		}
		const $active = $window_switcher.find(".active");
		if ($active.length === 0) {
			return;
		}
		activate_window($active.data("$window"));
		$window_switcher.remove(); // must remove only after getting data()
	}
	function window_switcher_cancel() {
		$window_switcher.remove();
	}

	window.addEventListener("keydown", handle_keydown, true);
	window.addEventListener("keyup", handle_keyup, true);
	window.addEventListener("blur", window_switcher_cancel); // this may be from an iframe getting focus (e.g. an app was loading), but in that case we might not be able to get the keyup anyways
	// @TODO: detect if it's an iframe we've integrated with and thus could get the keyup event
	// @TODO: also detect blur inside iframes, to cancel window switching

	var iid;
	var alt_held = false; // for detecting likely Alt+Tab
	var notice_shown = false;
	function handle_keydown(e) {
		if (e.altKey && (e.key === "4" || e.key === "F4")) { // we can't actually intercept Alt+F4, but might as well try, right?
			e.preventDefault();
			const $window = e.target.closest(".os-window") && e.target.closest(".os-window").$window;
			console.log("Alt+4 detected, closing window", $window, e.target);
			$window && $window.close();
		}
		// console.log(e.key, e.code);
		if (e.altKey && (e.code === "Backquote" || e.code === "Tab")) {
			show_window_switcher(e.shiftKey);
		} else {
			window_switcher_cancel();
		}
		if (e.key === "Alt") {
			alt_held = true;
			// console.log("Alt held");
			clearInterval(iid);
			iid = setInterval(look_for_focus_loss, 200);
		}
	}
	function handle_keyup(e) {
		// console.log("keyup", e.key, e.code);
		// if (e.key === "Alt") { // on my Ubuntu XFCE, it's giving "Meta" if Shift is held
		if (!e.altKey) {
			alt_held = false;
			clearInterval(iid);
			// console.log("Alt released");
			window_switcher_close_and_select();
		}
	}
	function look_for_focus_loss() {
		// Welcome to Heuristic Hurdles! I'm your host, Hacky Hairy. Today we're going to be detecting Alt+Tab.
		// Alt+Tab is a common shortcut for switching between windows, but we can't actually intercept it.
		// In fact, the browser doesn't even know about it. It's handled by the window manager directly.
		// We'll have to pick another shortcut, but who's going to know about it? Wouldn't it be nice if we could at least detect Alt+Tab,
		// to inform users of the new shortcut? How are we going to do that, in mere JavaScript?
		// Heuristics! *queue Heuristic Hurdles theme song*

		// console.log("alt_held", alt_held, "!top.document.hasFocus()", !top.document.hasFocus(), "top.document.hasFocus()", top.document.hasFocus(), "top.document", top.document, "top.activeElement", top.document.activeElement);
		if (alt_held && !top.document.hasFocus()) {
			// Some things like closing a window with Alt+4 can cause the document to lose focus, without Alt+Tab.
			// But if the window's really lost focus, we shouldn't be able to focus an element in it to focus the document.
			// So we can use that to refine the heuristic.
			if (
				!top.document.activeElement ||
				top.document.activeElement === top.document.body ||
				top.document.activeElement === top.document.documentElement
			) {
				// try focusing the document (or window, rather)
				top.focus();
				if (top.document.hasFocus()) {
					// console.log("Focused document");
					return;
				} else {
					// console.log("Couldn't focus document, so you've probably Alt+Tabbed");
				}
			} else {
				// console.log("Active element is", top.document.activeElement, " despite hasFocus() being false so you've probably Alt+Tabbed");
			}

			// False positives:
			// - Alt+D focuses the address bar in Chrome
			// - Hold Alt and click outside the browser window
			// - Alt+Space shows the system window menu on some platforms, and on Ubuntu XFCE in Firefox this causes a false positive but not in Chrome apparently (weird!)
			// - Alt+(number) focuses a tab in Chrome, but it actually lets us cancel it; @TODO: detect this as not an Alt+Tab (could use a timeout after any key pressed while holding Alt)

			clearInterval(iid);
			alt_held = false;

			if (Task.all_tasks.length < 2) {
				return;
			}
			if (!notice_shown) {
				new clippy.load("Clippy", function (loaded_agent) {
					agent = loaded_agent;
					agent.show();
					const message = "It looks like you're trying to switch windows.\n\nUse Alt+` (grave accent) instead of Alt+Tab within the 98.js desktop.\n\nAlso, use Alt+4 instead of Alt+F4 to close windows.";
					agent.speak(message, true);
					// held message causes double click to not animate Clippy, for some reason (even after message is cleared)
					$(agent._el).one("dblclick", function () {
						agent.stopCurrent();
						agent.animate();
					});
				});
				notice_shown = true;
			}
		}
	}

});

define('skylark-98js/main',[
	"./$desktop",
	"./$start-menu",
	"./$taskbar-time",
	"./filesystem-setup",
	"./FolderView",
	"./FolderViewItem",
	"./msgbox",
	"./Task",
	"./visualizer-overlay",
	"./window-switcher"
],function(){
	
});
define('skylark-98js', ['skylark-98js/main'], function (main) { return main; });


},this);
//# sourceMappingURL=sourcemaps/skylark-98js-all.js.map
