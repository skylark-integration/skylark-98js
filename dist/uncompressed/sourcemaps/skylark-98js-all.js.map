{"version":3,"sources":["skylark-98js-all.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-98js-all.js","sourcesContent":["define('skylark-langx-ns/_attach',[],function(){\r\n    return  function attach(obj1,path,obj2) {\r\n        if (typeof path == \"string\") {\r\n            path = path.split(\".\");//[path]\r\n        };\r\n        var length = path.length,\r\n            ns=obj1,\r\n            i=0,\r\n            name = path[i++];\r\n\r\n        while (i < length) {\r\n            ns = ns[name] = ns[name] || {};\r\n            name = path[i++];\r\n        }\r\n\r\n        if (ns[name]) {\r\n            if (obj2) {\r\n                throw new Error(\"This namespace already exists:\" + path);\r\n            }\r\n\r\n        } else {\r\n            ns[name] = obj2 || {};\r\n        }\r\n        return ns[name];\r\n    }\r\n});\ndefine('skylark-langx-ns/ns',[\r\n    \"./_attach\"\r\n], function(_attach) {\r\n    var root = {\r\n    \tattach : function(path,obj) {\r\n    \t\treturn _attach(root,path,obj);\r\n    \t}\r\n    };\r\n    return root;\r\n});\r\n\ndefine('skylark-langx-ns/main',[\r\n\t\"./ns\"\r\n],function(skylark){\r\n\treturn skylark;\r\n});\ndefine('skylark-langx-ns', ['skylark-langx-ns/main'], function (main) { return main; });\n\ndefine('skylark-langx/skylark',[\r\n    \"skylark-langx-ns\"\r\n], function(ns) {\r\n\treturn ns;\r\n});\r\n\ndefine('skylark-langx-arrays/arrays',[\r\n  \"skylark-langx-ns\"\r\n],function(skylark){\r\n    return skylark.attach(\"langx.arrays\");\r\n});\ndefine('skylark-langx-arrays/base-find-index',[\r\n  \"./arrays\"\r\n],function(arrays){\r\n    /**\r\n     * The base implementation of `_.findIndex` and `_.findLastIndex` without\r\n     * support for iteratee shorthands.\r\n     *\r\n     * @param {Array} array The array to inspect.\r\n     * @param {Function} predicate The function invoked per iteration.\r\n     * @param {number} fromIndex The index to search from.\r\n     * @param {boolean} [fromRight] Specify iterating from right to left.\r\n     * @returns {number} Returns the index of the matched value, else `-1`.\r\n     */\r\n    function baseFindIndex(array, predicate, fromIndex, fromRight) {\r\n      var length = array.length,\r\n          index = fromIndex + (fromRight ? 1 : -1);\r\n\r\n      while ((fromRight ? index-- : ++index < length)) {\r\n        if (predicate(array[index], index, array)) {\r\n          return index;\r\n        }\r\n      }\r\n      return -1;\r\n    }\r\n\r\n    return arrays.baseFindIndex = baseFindIndex;\r\n});\ndefine('skylark-langx-arrays/base-indexof',[\r\n  \"./arrays\",\r\n  \"./base-find-index\"\r\n],function(arrays,baseFindIndex){\r\n\r\n    /**\r\n     * The base implementation of `isNaN` without support for number objects.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\r\n     */\r\n    function baseIsNaN(value) {\r\n      return value !== value;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\r\n     *\r\n     * @param {Array} array The array to inspect.\r\n     * @param {*} value The value to search for.\r\n     * @param {number} fromIndex The index to search from.\r\n     * @returns {number} Returns the index of the matched value, else `-1`.\r\n     */\r\n    function baseIndexOf(array, value, fromIndex) {\r\n      if (value !== value) {\r\n        return baseFindIndex(array, baseIsNaN, fromIndex);\r\n      }\r\n      var index = fromIndex - 1,\r\n          length = array.length;\r\n\r\n      while (++index < length) {\r\n        if (array[index] === value) {\r\n          return index;\r\n        }\r\n      }\r\n      return -1;\r\n    }\r\n\t\r\n\treturn arrays.baseIndexOf = baseIndexOf;\r\n});\ndefine('skylark-langx-arrays/filter',[\r\n  \"./arrays\"\r\n],function(arrays){\r\n   var _filter = Array.prototype.filter;\r\n \r\n    function filter(array,func) {\r\n      return _filter.call(array,func);\r\n    }\r\n\r\n    return arrays.filter = filter;\r\n\t\r\n});\ndefine('skylark-langx-arrays/compact',[\r\n  \"./arrays\",\r\n  \"./filter\"\r\n],function(arrays,filter){\r\n\r\n    function compact(array) {\r\n        return filter(array, function(item) {\r\n            return item != null;\r\n        });\r\n    }\r\n\r\n    return arrays.compact = compact;\r\n});\ndefine('skylark-langx-arrays/in-array',[\r\n  \"./arrays\"\r\n],function(arrays){\r\n    function inArray(item, array) {\r\n        if (!array) {\r\n            return -1;\r\n        }\r\n        var i;\r\n\r\n        if (array.indexOf) {\r\n            return array.indexOf(item);\r\n        }\r\n\r\n        i = array.length;\r\n        while (i--) {\r\n            if (array[i] === item) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    return arrays.inArray = inArray;\r\n\t\r\n});\ndefine('skylark-langx-arrays/contains',[\r\n  \"./arrays\",\r\n  \"./in-array\"\r\n],function(arrays,inArray){\r\n\r\n    function contains(array,item) {\r\n      return inArray(item,array);\r\n    }\r\n\t\r\n\treturn arrays.contains = contains;\r\n});\ndefine('skylark-langx-funcs/funcs',[\r\n  \"skylark-langx-ns\",\r\n],function(skylark,types,objects){\r\n        \r\n\r\n\r\n\r\n    function noop() {\r\n    }\r\n\r\n\r\n\r\n\r\n    return skylark.attach(\"langx.funcs\",{\r\n        noop : noop,\r\n\r\n        returnTrue: function() {\r\n            return true;\r\n        },\r\n\r\n        returnFalse: function() {\r\n            return false;\r\n        }\r\n\r\n    });\r\n});\ndefine('skylark-langx-funcs/rest-arguments',[\r\n\t\"./funcs\"\r\n],function(funcs){\r\n\r\n  // Some functions take a variable number of arguments, or a few expected\r\n  // arguments at the beginning and then a variable number of values to operate\r\n  // on. This helper accumulates all remaining arguments past the function’s\r\n  // argument length (or an explicit `startIndex`), into an array that becomes\r\n  // the last argument. Similar to ES6’s \"rest parameter\".\r\n  function restArguments(func, startIndex) {\r\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\r\n    return function() {\r\n      var length = Math.max(arguments.length - startIndex, 0),\r\n          rest = Array(length),\r\n          index = 0;\r\n      for (; index < length; index++) {\r\n        rest[index] = arguments[index + startIndex];\r\n      }\r\n      switch (startIndex) {\r\n        case 0: return func.call(this, rest);\r\n        case 1: return func.call(this, arguments[0], rest);\r\n        case 2: return func.call(this, arguments[0], arguments[1], rest);\r\n      }\r\n      var args = Array(startIndex + 1);\r\n      for (index = 0; index < startIndex; index++) {\r\n        args[index] = arguments[index];\r\n      }\r\n      args[startIndex] = rest;\r\n      return func.apply(this, args);\r\n    };\r\n  }\r\n\r\n  return funcs.restArguments = restArguments;\t\r\n});\ndefine('skylark-langx-funcs/bind-all',[\r\n\t\"./funcs\",\r\n\t\"./rest-arguments\"\r\n],function(funcs,restArguments){\r\n\r\n  // Bind a number of an object's methods to that object. Remaining arguments\r\n  // are the method names to be bound. Useful for ensuring that all callbacks\r\n  // defined on an object belong to it.\r\n  return funcs.bindAll = restArguments(function(obj, keys) {\r\n    ///keys = flatten(keys, false, false);\r\n    var index = keys.length;\r\n    if (index < 1) throw new Error('bindAll must be passed function names');\r\n    while (index--) {\r\n      var key = keys[index];\r\n      obj[key] = obj[key].bind(obj);\r\n    }\r\n  });\r\n\r\n});\r\n\ndefine('skylark-langx-types/types',[\r\n    \"skylark-langx-ns\"\r\n],function(skylark){\r\n    var nativeIsArray = Array.isArray, \r\n        toString = {}.toString;\r\n    \r\n    var type = (function() {\r\n        var class2type = {};\r\n\r\n        // Populate the class2type map\r\n        \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \").forEach(function(name) {\r\n            class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\r\n        });\r\n\r\n        return function type(obj) {\r\n            return obj == null ? String(obj) :\r\n                class2type[toString.call(obj)] || \"object\";\r\n        };\r\n    })();\r\n\r\n \r\n    var  isArray = nativeIsArray || function(obj) {\r\n        return object && object.constructor === Array;\r\n    };\r\n\r\n\r\n    /**\r\n     * Checks if `value` is array-like. A value is considered array-like if it's\r\n     * not a function/string/element and has a `value.length` that's an integer greater than or\r\n     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\r\n     *\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\r\n     * @example\r\n     *\r\n     * isArrayLike([1, 2, 3])\r\n     * // => true\r\n     *\r\n     * isArrayLike(document.body.children)\r\n     * // => false\r\n     *\r\n     * isArrayLike('abc')\r\n     * // => true\r\n     *\r\n     * isArrayLike(Function)\r\n     * // => false\r\n     */    \r\n    function isArrayLike(obj) {\r\n        return !isString(obj) && !isHtmlNode(obj) && typeof obj.length == 'number' && !isFunction(obj);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is classified as a boolean primitive or object.\r\n     *\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\r\n     * @example\r\n     *\r\n     * isBoolean(false)\r\n     * // => true\r\n     *\r\n     * isBoolean(null)\r\n     * // => false\r\n     */\r\n    function isBoolean(obj) {\r\n       return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\r\n       //return typeof(obj) === \"boolean\";\r\n    }\r\n\r\n    function isDefined(obj) {\r\n        return typeof obj !== 'undefined';\r\n    }\r\n\r\n    function isDocument(obj) {\r\n        return obj != null && obj.nodeType == obj.DOCUMENT_NODE;\r\n    }\r\n\r\n   // Is a given value a DOM element?\r\n    function isElement(obj) {\r\n        return !!(obj && obj.nodeType === 1);\r\n    }   \r\n\r\n    function isEmptyObject(obj) {\r\n        var name;\r\n        for (name in obj) {\r\n            if (obj[name] !== null) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Checks if `value` is classified as a `Function` object.\r\n     *\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\r\n     * @example\r\n     *\r\n     * isFunction(parseInt)\r\n     * // => true\r\n     *\r\n     * isFunction(/abc/)\r\n     * // => false\r\n     */\r\n    function isFunction(value) {\r\n        return type(value) == \"function\";\r\n    }\r\n\r\n\r\n\r\n    function isHtmlNode(obj) {\r\n        return obj && obj.nodeType; // obj instanceof Node; //Consider the elements in IFRAME\r\n    }\r\n\r\n    function isInstanceOf( /*Object*/ value, /*Type*/ type) {\r\n        //Tests whether the value is an instance of a type.\r\n        if (value === undefined) {\r\n            return false;\r\n        } else if (value === null || type == Object) {\r\n            return true;\r\n        } else if (typeof value === \"number\") {\r\n            return type === Number;\r\n        } else if (typeof value === \"string\") {\r\n            return type === String;\r\n        } else if (typeof value === \"boolean\") {\r\n            return type === Boolean;\r\n        } else if (typeof value === \"string\") {\r\n            return type === String;\r\n        } else {\r\n            return (value instanceof type) || (value && value.isInstanceOf ? value.isInstanceOf(type) : false);\r\n        }\r\n    }\r\n\r\n    function isNull(obj) {\r\n        return obj === null;\r\n    }\r\n\r\n    function isNumber(obj) {\r\n        return typeof obj == 'number';\r\n    }\r\n\r\n    function isObject(obj) {\r\n        var type = typeof obj;\r\n        return type === 'function' || type === 'object' && !!obj;        \r\n        //return type(obj) == \"object\";\r\n    }\r\n\r\n    function isPlainObject(obj) {\r\n        return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype;\r\n    }\r\n\r\n    function isString(obj) {\r\n        return typeof obj === 'string';\r\n    }\r\n\r\n    function isWindow(obj) {\r\n        return obj && obj == obj.window;\r\n    }\r\n\r\n    function isSameOrigin(href) {\r\n        if (href) {\r\n            var origin = location.protocol + '//' + location.hostname;\r\n            if (location.port) {\r\n                origin += ':' + location.port;\r\n            }\r\n            return href.startsWith(origin);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is classified as a `Symbol` primitive or object.\r\n     *\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\r\n     * @example\r\n     *\r\n     * _.isSymbol(Symbol.iterator);\r\n     * // => true\r\n     *\r\n     * _.isSymbol('abc');\r\n     * // => false\r\n     */\r\n    function isSymbol(value) {\r\n      return typeof value == 'symbol' ;\r\n       //|| (isObjectLike(value) && objectToString.call(value) == symbolTag); // modified by lwf\r\n    }\r\n\r\n    // Is a given variable undefined?\r\n    function isUndefined(obj) {\r\n        return obj === void 0;\r\n    }\r\n\r\n\r\n    var INFINITY = 1 / 0,\r\n        MAX_SAFE_INTEGER = 9007199254740991,\r\n        MAX_INTEGER = 1.7976931348623157e+308,\r\n        NAN = 0 / 0;\r\n\r\n    /** Used to match leading and trailing whitespace. */\r\n    var reTrim = /^\\s+|\\s+$/g;\r\n\r\n    /** Used to detect bad signed hexadecimal string values. */\r\n    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\r\n\r\n    /** Used to detect binary string values. */\r\n    var reIsBinary = /^0b[01]+$/i;\r\n\r\n    /** Used to detect octal string values. */\r\n    var reIsOctal = /^0o[0-7]+$/i;\r\n\r\n    /** Used to detect unsigned integer values. */\r\n    var reIsUint = /^(?:0|[1-9]\\d*)$/;\r\n\r\n    /** Built-in method references without a dependency on `root`. */\r\n    var freeParseInt = parseInt;\r\n\r\n    /**\r\n     * Converts `value` to a finite number.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.12.0\r\n     * @category Lang\r\n     * @param {*} value The value to convert.\r\n     * @returns {number} Returns the converted number.\r\n     * @example\r\n     *\r\n     * _.toFinite(3.2);\r\n     * // => 3.2\r\n     *\r\n     * _.toFinite(Number.MIN_VALUE);\r\n     * // => 5e-324\r\n     *\r\n     * _.toFinite(Infinity);\r\n     * // => 1.7976931348623157e+308\r\n     *\r\n     * _.toFinite('3.2');\r\n     * // => 3.2\r\n     */\r\n    function toFinite(value) {\r\n      if (!value) {\r\n        return value === 0 ? value : 0;\r\n      }\r\n      value = toNumber(value);\r\n      if (value === INFINITY || value === -INFINITY) {\r\n        var sign = (value < 0 ? -1 : 1);\r\n        return sign * MAX_INTEGER;\r\n      }\r\n      return value === value ? value : 0;\r\n    }\r\n\r\n    /**\r\n     * Converts `value` to an integer.\r\n     *\r\n     * **Note:** This method is loosely based on\r\n     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @param {*} value The value to convert.\r\n     * @returns {number} Returns the converted integer.\r\n     * @example\r\n     *\r\n     * _.toInteger(3.2);\r\n     * // => 3\r\n     *\r\n     * _.toInteger(Number.MIN_VALUE);\r\n     * // => 0\r\n     *\r\n     * _.toInteger(Infinity);\r\n     * // => 1.7976931348623157e+308\r\n     *\r\n     * _.toInteger('3.2');\r\n     * // => 3\r\n     */\r\n    function toInteger(value) {\r\n      var result = toFinite(value),\r\n          remainder = result % 1;\r\n\r\n      return result === result ? (remainder ? result - remainder : result) : 0;\r\n    }   \r\n\r\n    /**\r\n     * Converts `value` to a number.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to process.\r\n     * @returns {number} Returns the number.\r\n     * @example\r\n     *\r\n     * _.toNumber(3.2);\r\n     * // => 3.2\r\n     *\r\n     * _.toNumber(Number.MIN_VALUE);\r\n     * // => 5e-324\r\n     *\r\n     * _.toNumber(Infinity);\r\n     * // => Infinity\r\n     *\r\n     * _.toNumber('3.2');\r\n     * // => 3.2\r\n     */\r\n    function toNumber(value) {\r\n      if (typeof value == 'number') {\r\n        return value;\r\n      }\r\n      if (isSymbol(value)) {\r\n        return NAN;\r\n      }\r\n      if (isObject(value)) {\r\n        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\r\n        value = isObject(other) ? (other + '') : other;\r\n      }\r\n      if (typeof value != 'string') {\r\n        return value === 0 ? value : +value;\r\n      }\r\n      value = value.replace(reTrim, '');\r\n      var isBinary = reIsBinary.test(value);\r\n      return (isBinary || reIsOctal.test(value))\r\n        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\r\n        : (reIsBadHex.test(value) ? NAN : +value);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    return skylark.attach(\"langx.types\",{\r\n\r\n        isArray: isArray,\r\n\r\n        isArrayLike: isArrayLike,\r\n\r\n        isBoolean: isBoolean,\r\n\r\n        isDefined: isDefined,\r\n\r\n        isDocument: isDocument,\r\n\r\n        isElement,\r\n\r\n        isEmpty : isEmptyObject,\r\n\r\n        isEmptyObject: isEmptyObject,\r\n\r\n        isFunction: isFunction,\r\n\r\n        isHtmlNode: isHtmlNode,\r\n\r\n        isNaN : function (obj) {\r\n            return isNaN(obj);\r\n        },\r\n\r\n        isNull: isNull,\r\n\r\n\r\n        isNumber: isNumber,\r\n\r\n        isNumeric: isNumber,\r\n\r\n        isObject: isObject,\r\n\r\n        isPlainObject: isPlainObject,\r\n\r\n        isString: isString,\r\n\r\n        isSameOrigin: isSameOrigin,\r\n\r\n        isSymbol : isSymbol,\r\n\r\n        isUndefined: isUndefined,\r\n\r\n        isWindow: isWindow,\r\n\r\n        type: type,\r\n\r\n        toFinite : toFinite,\r\n        toNumber : toNumber,\r\n        toInteger : toInteger\r\n        \r\n    });\r\n\r\n});\ndefine('skylark-langx-types/main',[\r\n\t\"./types\"\r\n],function(types){\r\n\treturn types;\r\n});\ndefine('skylark-langx-types', ['skylark-langx-types/main'], function (main) { return main; });\n\ndefine('skylark-langx-funcs/defer',[\r\n    \"skylark-langx-types\",\r\n    \"./funcs\"\r\n],function(types,funcs){\r\n\r\n    function defer(fn,trigger,args,context) {\r\n        var ret = {\r\n            cancel : null\r\n        },\r\n        fn1 = fn;\r\n\r\n        if (!types.isNumber(trigger) && !types.isFunction(trigger)) {\r\n            context = args;\r\n            args = trigger;\r\n            trigger = 0;\r\n        }\r\n\r\n        if (args) {\r\n            fn1 = function() {\r\n                fn.apply(context,args);\r\n            };\r\n        }\r\n\r\n        if (types.isFunction(trigger)) {\r\n            var canceled = false;\r\n            trigger(function(){\r\n                if (!canceled) {\r\n                    fn1();\r\n                }\r\n            });\r\n\r\n            ret.cancel = function() {\r\n                canceled = true;\r\n            }\r\n\r\n        } else {\r\n            var  id;\r\n            if (trigger == 0 && requestAnimationFrame) {\r\n                id = requestAnimationFrame(fn1);\r\n                ret.cancel = function() {\r\n                    return cancelAnimationFrame(id);\r\n                };\r\n            } else {\r\n                id = setTimeout(fn1,trigger);\r\n                ret.cancel = function() {\r\n                    return clearTimeout(id);\r\n                };\r\n            }            \r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    return funcs.defer = defer;\r\n});\ndefine('skylark-langx-funcs/debounce',[\r\n\t\"./funcs\",\r\n    \"./defer\"\r\n],function(funcs,defer){\r\n   \r\n    function debounce(fn, wait,useAnimationFrame) {\r\n        var timeout,\r\n            defered,\r\n            debounced = function () {\r\n                var context = this, args = arguments;\r\n                var later = function () {\r\n                    timeout = null;\r\n                    if (useAnimationFrame) {\r\n                        defered = defer(fn,args,context);\r\n                    } else {\r\n                        fn.apply(context, args);\r\n                    }\r\n                };\r\n\r\n                cancel();\r\n                timeout = setTimeout(later, wait);\r\n\r\n                return {\r\n                    cancel \r\n                };\r\n            },\r\n            cancel = debounced.cancel = function () {\r\n                if (timeout) {\r\n                    clearTimeout(timeout);\r\n                }\r\n                if (defered) {\r\n                    defered.cancel();\r\n                }\r\n                timeout = void 0;\r\n                defered = void 0;\r\n            };\r\n\r\n        return debounced;\r\n    }\r\n\r\n    return funcs.debounce = debounce;\r\n\r\n});\ndefine('skylark-langx-objects/objects',[\r\n    \"skylark-langx-ns\",\r\n    \"skylark-langx-types\"\r\n],function(skylark,types){\r\n\r\n    return skylark.attach(\"langx.objects\",{\r\n        attach : skylark.attach\r\n    });\r\n\r\n});\ndefine('skylark-langx-objects/all-keys',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\"\r\n],function(types,objects){\r\n\r\n    // Retrieve all the property names of an object.\r\n    function allKeys(obj) {\r\n        if (!types.isObject(obj)) return [];\r\n        var keys = [];\r\n        for (var key in obj) keys.push(key);\r\n        return keys;\r\n    }\r\n\r\n    return objects.allKeys = allKeys;\r\n\r\n});\ndefine('skylark-langx-objects/assign',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\"\r\n],function(types,objects) {\r\n\r\n\treturn objects.assign = Object.assign;\r\n});\ndefine('skylark-langx-objects/to-key',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\"\r\n],function(types,objects) {\r\n\r\n\tconst isSymbol = types.isSymbol,\r\n\t\t  isString = types.isString;\r\n\r\n\t/** Used as references for various `Number` constants. */\r\n\tconst INFINITY = 1 / 0\r\n\r\n\t/**\r\n\t * Converts `value` to a string key if it's not a string or symbol.\r\n\t *\r\n\t * @private\r\n\t * @param {*} value The value to inspect.\r\n\t * @returns {string|symbol} Returns the key.\r\n\t */\r\n\tfunction toKey(value) {\r\n\t  if (isString(value) || isSymbol(value)) {\r\n\t    return value\r\n\t  }\r\n\t  const result = `${value}`\r\n\t  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result\r\n\t}\r\n\r\n\treturn objects.toKey = toKey;\r\n\r\n});\ndefine('skylark-langx-objects/is-key',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\"\r\n],function(types,objects) {\r\n\r\n\tconst isSymbol = types.isSymbol,\r\n\t\t  isArray = types.isArray;\r\n\r\n\t/** Used to match property names within property paths. */\r\n\tconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/\r\n\tconst reIsPlainProp = /^\\w*$/\r\n\r\n\t/**\r\n\t * Checks if `value` is a property name and not a property path.\r\n\t *\r\n\t * @private\r\n\t * @param {*} value The value to check.\r\n\t * @param {Object} [object] The object to query keys on.\r\n\t * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\r\n\t */\r\n\tfunction isKey(value, object) {\r\n\t  if (isArray(value)) {\r\n\t    return false\r\n\t  }\r\n\t  const type = typeof value\r\n\t  if (type === 'number' || type === 'boolean' || value == null || isSymbol(value)) {\r\n\t    return true\r\n\t  }\r\n\t  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\r\n\t    (object != null && value in Object(object))\r\n\t}\r\n\r\n\treturn objects.isKey = isKey;\r\n});\ndefine('skylark-langx-objects/_cast_path',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\",\r\n\t\"./is-key\"\r\n],function(types,objects,isKey) {\r\n\tconst charCodeOfDot = '.'.charCodeAt(0)\r\n\tconst reEscapeChar = /\\\\(\\\\)?/g\r\n\tconst rePropName = RegExp(\r\n\t  // Match anything that isn't a dot or bracket.\r\n\t  '[^.[\\\\]]+' + '|' +\r\n\t  // Or match property names within brackets.\r\n\t  '\\\\[(?:' +\r\n\t    // Match a non-string expression.\r\n\t    '([^\"\\'][^[]*)' + '|' +\r\n\t    // Or match strings (supports escaping characters).\r\n\t    '([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' +\r\n\t  ')\\\\]'+ '|' +\r\n\t  // Or match \"\" as the space between consecutive dots or empty brackets.\r\n\t  '(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))'\r\n\t  , 'g')\r\n\r\n\t/**\r\n\t * Converts `string` to a property path array.\r\n\t *\r\n\t * @private\r\n\t * @param {string} string The string to convert.\r\n\t * @returns {Array} Returns the property path array.\r\n\t */\r\n\tconst stringToPath = ((string) => {\r\n\t  const result = []\r\n\t  if (string.charCodeAt(0) === charCodeOfDot) {\r\n\t    result.push('')\r\n\t  }\r\n\t  string.replace(rePropName, (match, expression, quote, subString) => {\r\n\t    let key = match\r\n\t    if (quote) {\r\n\t      key = subString.replace(reEscapeChar, '$1')\r\n\t    }\r\n\t    else if (expression) {\r\n\t      key = expression.trim()\r\n\t    }\r\n\t    result.push(key)\r\n\t  })\r\n\t  return result\r\n\t});\r\n\r\n\t/**\r\n\t * Casts `value` to a path array if it's not one.\r\n\t *\r\n\t * @private\r\n\t * @param {*} value The value to inspect.\r\n\t * @param {Object} [object] The object to query keys on.\r\n\t * @returns {Array} Returns the cast property path array.\r\n\t */\r\n\tfunction castPath(value, object) {\r\n\t  if (types.isArray(value)) {\r\n\t    return value\r\n\t  }\r\n\t  return isKey(value, object) ? [value] : stringToPath(value)\r\n\t}\r\n\r\n\treturn castPath;\r\n});\ndefine('skylark-langx-objects/get',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\",\r\n\t\"./to-key\",\r\n\t\"./_cast_path\"\r\n],function(types,objects,toKey,castPath) {\r\n\r\n\t/**\r\n\t * The base implementation of `get` without support for default values.\r\n\t *\r\n\t * @private\r\n\t * @param {Object} object The object to query.\r\n\t * @param {Array|string} path The path of the property to get.\r\n\t * @returns {*} Returns the resolved value.\r\n\t */\r\n\tfunction baseGet(object, path) {\r\n\t  path = castPath(path, object)\r\n\r\n\t  let index = 0\r\n\t  const length = path.length\r\n\r\n\t  while (object != null && index < length) {\r\n\t    object = object[toKey(path[index++])]\r\n\t  }\r\n\t  return (index && index == length) ? object : undefined\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Gets the value at `path` of `object`. If the resolved value is\r\n\t * `undefined`, the `defaultValue` is returned in its place.\r\n\t *\r\n\t * @since 3.7.0\r\n\t * @category Object\r\n\t * @param {Object} object The object to query.\r\n\t * @param {Array|string} path The path of the property to get.\r\n\t * @param {*} [defaultValue] The value returned for `undefined` resolved values.\r\n\t * @returns {*} Returns the resolved value.\r\n\t * @see has, hasIn, set, unset\r\n\t * @example\r\n\t *\r\n\t * const object = { 'a': [{ 'b': { 'c': 3 } }] }\r\n\t *\r\n\t * get(object, 'a[0].b.c')\r\n\t * // => 3\r\n\t *\r\n\t * get(object, ['a', '0', 'b', 'c'])\r\n\t * // => 3\r\n\t *\r\n\t * get(object, 'a.b.c', 'default')\r\n\t * // => 'default'\r\n\t */\r\n\tfunction get(object, path, defaultValue) {\r\n\t  const result = object == null ? undefined : baseGet(object, path)\r\n\t  return result === undefined ? defaultValue : result\r\n\t}\r\n\r\n\treturn objects.get = get;\r\n});\ndefine('skylark-langx-objects/base-at',[\r\n\t\"./objects\",\r\n\t\"./get\"\r\n],function(objects,get) {\r\n\r\n\t/**\r\n\t * The base implementation of `at` without support for individual paths.\r\n\t *\r\n\t * @param {Object} object The object to iterate over.\r\n\t * @param {string[]} paths The property paths to pick.\r\n\t * @returns {Array} Returns the picked elements.\r\n\t */\r\n\tfunction baseAt(object, paths) {\r\n\t  let index = -1\r\n\t  const length = paths.length\r\n\t  const result = new Array(length)\r\n\t  const skip = object == null\r\n\r\n\t  while (++index < length) {\r\n\t    result[index] = skip ? undefined : get(object, paths[index])\r\n\t  }\r\n\t  return result\r\n\t}\r\n\r\n\treturn objects.baseAt = baseAt;\r\n});\ndefine('skylark-langx-objects/clone',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\"\r\n],function(types,objects) {\r\n    var isPlainObject = types.isPlainObject,\r\n        isArray = types.isArray;\r\n\r\n    function clone( /*anything*/ src,checkCloneMethod) {\r\n        var copy;\r\n        if (src === undefined || src === null) {\r\n            copy = src;\r\n        } else if (checkCloneMethod && src.clone) {\r\n            copy = src.clone();\r\n        } else if (isArray(src)) {\r\n            copy = [];\r\n            for (var i = 0; i < src.length; i++) {\r\n                copy.push(clone(src[i]));\r\n            }\r\n        } else if (isPlainObject(src)) {\r\n            copy = {};\r\n            for (var key in src) {\r\n                copy[key] = clone(src[key]);\r\n            }\r\n        } else {\r\n            copy = src;\r\n        }\r\n\r\n        return copy;\r\n\r\n    }\r\n\r\n    return objects.clone = clone;\r\n});\ndefine('skylark-langx-objects/defaults',[\r\n    \"./objects\",\r\n    \"./all-keys\"\r\n],function(objects,allKeys){\r\n  // An internal function for creating assigner functions.\r\n  function createAssigner(keysFunc, defaults) {\r\n      return function(obj) {\r\n        var length = arguments.length;\r\n        if (defaults) obj = Object(obj);  \r\n        if (length < 2 || obj == null) return obj;\r\n        for (var index = 1; index < length; index++) {\r\n          var source = arguments[index],\r\n              keys = keysFunc(source),\r\n              l = keys.length;\r\n          for (var i = 0; i < l; i++) {\r\n            var key = keys[i];\r\n            if (!defaults || obj[key] === void 0) obj[key] = source[key];\r\n          }\r\n        }\r\n        return obj;\r\n     };\r\n  }\r\n  \r\n  return objects.defaults = createAssigner(allKeys, true);\r\n});\ndefine('skylark-langx-objects/each',[\r\n    \"./objects\"\r\n],function(objects) {\r\n\r\n    function each(obj, callback,isForEach) {\r\n        var length, key, i, undef, value;\r\n\r\n        if (obj) {\r\n            length = obj.length;\r\n\r\n            if (length === undef) {\r\n                // Loop object items\r\n                for (key in obj) {\r\n                    if (obj.hasOwnProperty(key)) {\r\n                        value = obj[key];\r\n                        if ((isForEach ? callback.call(value, value, key) : callback.call(value, key, value) ) === false) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // Loop array items\r\n                for (i = 0; i < length; i++) {\r\n                    value = obj[i];\r\n                    if ((isForEach ? callback.call(value, value, i) : callback.call(value, i, value) )=== false) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    return objects.each = each;\r\n});\ndefine('skylark-langx-objects/_mixin',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\"\r\n],function(types,objects) {\r\n\r\n    var isPlainObject = types.isPlainObject;\r\n\r\n    function _mixin(target, source, deep, safe) {\r\n        for (var key in source) {\r\n            //if (!source.hasOwnProperty(key)) {\r\n            //    continue;\r\n            //}\r\n            if (safe && target[key] !== undefined) {\r\n                continue;\r\n            }\r\n            // if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\r\n            //    if (isPlainObject(source[key]) && !isPlainObject(target[key])) {\r\n            if (deep && isPlainObject(source[key])) {\r\n                if (!isPlainObject(target[key])) {\r\n                    target[key] = {};\r\n                }\r\n                //if (isArray(source[key]) && !isArray(target[key])) {\r\n                //    target[key] = [];\r\n                //}\r\n                _mixin(target[key], source[key], deep, safe);\r\n            } else if (source[key] !== undefined) {\r\n                target[key] = source[key]\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n\r\n    return _mixin;\r\n});\ndefine('skylark-langx-objects/_parse_mixin_args',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\"\r\n],function(types,objects) {\r\n\r\n    var slice = Array.prototype.slice,\r\n        isBoolean = types.isBoolean;\r\n\r\n    function _parseMixinArgs(args) {\r\n        var params = slice.call(arguments, 0),\r\n            target = params.shift(),\r\n            deep = false;\r\n        if (isBoolean(params[params.length - 1])) {\r\n            deep = params.pop();\r\n        }\r\n\r\n        return {\r\n            target: target,\r\n            sources: params,\r\n            deep: deep\r\n        };\r\n    }\r\n    \r\n    return _parseMixinArgs;\r\n});\ndefine('skylark-langx-objects/mixin',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\",\r\n  \"./_mixin\",\r\n  \"./_parse_mixin_args\"\r\n],function(types,objects,_mixin,_parseMixinArgs) {\r\n\r\n\r\n    function mixin() {\r\n        var args = _parseMixinArgs.apply(this, arguments);\r\n\r\n        args.sources.forEach(function(source) {\r\n            _mixin(args.target, source, args.deep, false);\r\n        });\r\n        return args.target;\r\n    }\r\n\r\n\r\n    return objects.mixin = mixin;\r\n\t\r\n});\ndefine('skylark-langx-objects/extend',[\r\n    \"./objects\",\r\n    \"./mixin\"\r\n],function(objects,mixin) {\r\n    var slice = Array.prototype.slice;\r\n\r\n    function extend(target) {\r\n        var deep, args = slice.call(arguments, 1);\r\n        if (typeof target == 'boolean') {\r\n            deep = target\r\n            target = args.shift()\r\n        }\r\n        if (args.length == 0) {\r\n            args = [target];\r\n            target = this;\r\n        }\r\n        args.forEach(function(arg) {\r\n            mixin(target, arg, deep);\r\n        });\r\n        return target;\r\n    }\r\n\r\n    return objects.extend = extend;\r\n});\ndefine('skylark-langx-objects/for-each',[\r\n \t\"./objects\",\r\n \t\"./each\"\r\n],function(objects,each){\r\n\r\n    function forEach (obj, fn) {\r\n    \tif (!obj) {\r\n    \t\treturn;\r\n    \t}\r\n     \tif (obj.forEach) {\r\n     \t\tobj.forEach(fn);\r\n     \t} else {\r\n     \t\teach(obj,fn,true);\r\n     \t}\r\n    }\r\n\r\n\treturn objects.forEach = forEach;\r\n});\ndefine('skylark-langx-objects/has',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\"\r\n],function(types,objects){\r\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\n    function has(obj, path) {\r\n        if (!types.isArray(path)) {\r\n            return obj != null && hasOwnProperty.call(obj, path);\r\n        }\r\n        var length = path.length;\r\n        for (var i = 0; i < length; i++) {\r\n            var key = path[i];\r\n            if (obj == null || !hasOwnProperty.call(obj, key)) {\r\n                return false;\r\n            }\r\n            obj = obj[key];\r\n        }\r\n        return !!length;\r\n    }\r\n\r\n    return objects.has = has;\r\n});\ndefine('skylark-langx-objects/includes',[\r\n    \"./objects\"\r\n],function(objects) {\r\n\r\n    /**\r\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\r\n     * checked for a substring of `value`, otherwise\r\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\r\n     * the offset from the end of `collection`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to inspect.\r\n     * @param {*} value The value to search for.\r\n     * @param {number} [fromIndex=0] The index to search from.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\r\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\r\n     * @example\r\n     *\r\n     * _.includes([1, 2, 3], 1);\r\n     * // => true\r\n     *\r\n     * _.includes([1, 2, 3], 1, 2);\r\n     * // => false\r\n     *\r\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\r\n     * // => true\r\n     *\r\n     * _.includes('abcd', 'bc');\r\n     * // => true\r\n     */\r\n    function includes(collection, value, fromIndex, guard) {\r\n      collection = isArrayLike(collection) ? collection : values(collection);\r\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\r\n\r\n      var length = collection.length;\r\n      if (fromIndex < 0) {\r\n        fromIndex = nativeMax(length + fromIndex, 0);\r\n      }\r\n      return isString(collection)\r\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\r\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\r\n    }\r\n\r\n\r\n\r\n    return objects.includes = includes;\r\n});\ndefine('skylark-langx-objects/is-equal',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\"\r\n],function(types,objects) {\r\n    var isFunction = types.isFunction;\r\n\r\n\r\n    // Internal recursive comparison function for `isEqual`.\r\n    var eq, deepEq;\r\n    var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\r\n\r\n    eq = function(a, b, aStack, bStack) {\r\n        // Identical objects are equal. `0 === -0`, but they aren't identical.\r\n        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\r\n        if (a === b) return a !== 0 || 1 / a === 1 / b;\r\n        // `null` or `undefined` only equal to itself (strict comparison).\r\n        if (a == null || b == null) return false;\r\n        // `NaN`s are equivalent, but non-reflexive.\r\n        if (a !== a) return b !== b;\r\n        // Exhaust primitive checks\r\n        var type = typeof a;\r\n        if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;\r\n        return deepEq(a, b, aStack, bStack);\r\n    };\r\n\r\n    // Internal recursive comparison function for `isEqual`.\r\n    deepEq = function(a, b, aStack, bStack) {\r\n        // Unwrap any wrapped objects.\r\n        //if (a instanceof _) a = a._wrapped;\r\n        //if (b instanceof _) b = b._wrapped;\r\n        // Compare `[[Class]]` names.\r\n        var className = toString.call(a);\r\n        if (className !== toString.call(b)) return false;\r\n        switch (className) {\r\n            // Strings, numbers, regular expressions, dates, and booleans are compared by value.\r\n            case '[object RegExp]':\r\n            // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\r\n            case '[object String]':\r\n                // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\r\n                // equivalent to `new String(\"5\")`.\r\n                return '' + a === '' + b;\r\n            case '[object Number]':\r\n                // `NaN`s are equivalent, but non-reflexive.\r\n                // Object(NaN) is equivalent to NaN.\r\n                if (+a !== +a) return +b !== +b;\r\n                // An `egal` comparison is performed for other numeric values.\r\n                return +a === 0 ? 1 / +a === 1 / b : +a === +b;\r\n            case '[object Date]':\r\n            case '[object Boolean]':\r\n                // Coerce dates and booleans to numeric primitive values. Dates are compared by their\r\n                // millisecond representations. Note that invalid dates with millisecond representations\r\n                // of `NaN` are not equivalent.\r\n                return +a === +b;\r\n            case '[object Symbol]':\r\n                return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);\r\n        }\r\n\r\n        var areArrays = className === '[object Array]';\r\n        if (!areArrays) {\r\n            if (typeof a != 'object' || typeof b != 'object') return false;\r\n            // Objects with different constructors are not equivalent, but `Object`s or `Array`s\r\n            // from different frames are.\r\n            var aCtor = a.constructor, bCtor = b.constructor;\r\n            if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor &&\r\n                               isFunction(bCtor) && bCtor instanceof bCtor)\r\n                          && ('constructor' in a && 'constructor' in b)) {\r\n                return false;\r\n            }\r\n        }\r\n        // Assume equality for cyclic structures. The algorithm for detecting cyclic\r\n        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\r\n\r\n        // Initializing stack of traversed objects.\r\n        // It's done here since we only need them for objects and arrays comparison.\r\n        aStack = aStack || [];\r\n        bStack = bStack || [];\r\n        var length = aStack.length;\r\n        while (length--) {\r\n            // Linear search. Performance is inversely proportional to the number of\r\n            // unique nested structures.\r\n            if (aStack[length] === a) return bStack[length] === b;\r\n        }\r\n\r\n        // Add the first object to the stack of traversed objects.\r\n        aStack.push(a);\r\n        bStack.push(b);\r\n\r\n        // Recursively compare objects and arrays.\r\n        if (areArrays) {\r\n            // Compare array lengths to determine if a deep comparison is necessary.\r\n            length = a.length;\r\n            if (length !== b.length) return false;\r\n            // Deep compare the contents, ignoring non-numeric properties.\r\n            while (length--) {\r\n                if (!eq(a[length], b[length], aStack, bStack)) return false;\r\n            }\r\n        } else {\r\n            // Deep compare objects.\r\n            var keys = Object.keys(a), key;\r\n            length = keys.length;\r\n            // Ensure that both objects contain the same number of properties before comparing deep equality.\r\n            if (Object.keys(b).length !== length) return false;\r\n            while (length--) {\r\n                // Deep compare each member\r\n                key = keys[length];\r\n                if (!(b[key]!==undefined && eq(a[key], b[key], aStack, bStack))) return false;\r\n            }\r\n        }\r\n        // Remove the first object from the stack of traversed objects.\r\n        aStack.pop();\r\n        bStack.pop();\r\n        return true;\r\n    };\r\n\r\n\r\n   // Perform a deep comparison to check if two objects are equal.\r\n    function isEqual(a, b) {\r\n        return eq(a, b);\r\n    }\r\n\r\n    return objects.isEqual = isEqual;\r\n\t\r\n});\ndefine('skylark-langx-objects/keys',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\",\r\n    \"./has\"\r\n],function(types,objects,has){\r\n\r\n    // Retrieve the names of an object's own properties.\r\n    // Delegates to **ECMAScript 5**'s native `Object.keys`.\r\n    function keys(obj) {\r\n        if (!types.isObject(obj)) return [];  \r\n        var keys = [];\r\n        for (var key in obj) if (has(obj, key)) keys.push(key);\r\n        return keys;\r\n    }\r\n\r\n    return objects.keys = keys;\r\n});\ndefine('skylark-langx-objects/is-match',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\",\r\n    \"./keys\"\r\n],function(types,objects,keys) {\r\n\r\n    // Returns whether an object has a given set of `key:value` pairs.\r\n    function isMatch(object, attrs) {\r\n        var keys = keys(attrs), length = keys.length;\r\n        if (object == null) return !length;\r\n        var obj = Object(object);\r\n        for (var i = 0; i < length; i++) {\r\n          var key = keys[i];\r\n          if (attrs[key] !== obj[key] || !(key in obj)) return false;\r\n        }\r\n        return true;\r\n    }    \r\n\r\n    return objects.isMatch = isMatch;\r\n});\ndefine('skylark-langx-objects/omit',[\r\n    \"./objects\",\r\n    \"./mixin\"\r\n],function(objects,mixin) {\r\n\r\n   // Return a copy of the object without the blacklisted properties.\r\n    function omit(obj, prop1,prop2) {\r\n        if (!obj) {\r\n            return null;\r\n        }\r\n        var result = mixin({},obj);\r\n        for(var i=1;i<arguments.length;i++) {\r\n            var pn = arguments[i];\r\n            if (pn in obj) {\r\n                delete result[pn];\r\n            }\r\n        }\r\n        return result;\r\n\r\n    }\r\n    \r\n    return objects.omit = omit;\r\n});\ndefine('skylark-langx-objects/pick',[\r\n    \"./objects\"\r\n],function(objects) {\r\n\r\n   // Return a copy of the object only containing the whitelisted properties.\r\n    function pick(obj,prop1,prop2) {\r\n        if (!obj) {\r\n            return null;\r\n        }\r\n        var result = {};\r\n        for(var i=1;i<arguments.length;i++) {\r\n            var pn = arguments[i];\r\n            if (pn in obj) {\r\n                result[pn] = obj[pn];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    return objects.pick = pick;\r\n});\ndefine('skylark-langx-objects/remove-items',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\"\r\n],function(types,objects){\r\n    function removeItem(items, item) {\r\n        if (types.isArray(items)) {\r\n            var idx = items.indexOf(item);\r\n            if (idx != -1) {\r\n                items.splice(idx, 1);\r\n            }\r\n        } else if (types.isPlainObject(items)) {\r\n            for (var key in items) {\r\n                if (items[key] == item) {\r\n                    delete items[key];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    return objects.removeItem = removeItem;\r\n});\ndefine('skylark-langx-objects/result',[\r\n  \"skylark-langx-types\",\r\n  \"./objects\",\r\n  \"./to-key\",\r\n  \"./_cast_path\"\r\n],function(types,objects,toKey,castPath) {\r\n\tvar isArray = types.isArray,\r\n\t\tisFunction = types.isFunction;\r\n\r\n  /**\r\n   * This method is like `get` except that if the resolved value is a\r\n   * function it's invoked with the `this` binding of its parent object and\r\n   * its result is returned.\r\n   *\r\n   * @since 0.1.0\r\n   * @category Object\r\n   * @param {Object} object The object to query.\r\n   * @param {Array|string} path The path of the property to resolve.\r\n   * @param {*} [defaultValue] The value returned for `undefined` resolved values.\r\n   * @returns {*} Returns the resolved value.\r\n   * @example\r\n   *\r\n   * const object = { 'a': [{ 'b': { 'c1': 3, 'c2': () => 4 } }] }\r\n   *\r\n   * result(object, 'a[0].b.c1')\r\n   * // => 3\r\n   *\r\n   * result(object, 'a[0].b.c2')\r\n   * // => 4\r\n   *\r\n   * result(object, 'a[0].b.c3', 'default')\r\n   * // => 'default'\r\n   *\r\n   * result(object, 'a[0].b.c3', () => 'default')\r\n   * // => 'default'\r\n   */\r\n  function result(object, path, defaultValue) {\r\n    path = castPath(path, object)\r\n\r\n    let index = -1\r\n    let length = path.length\r\n\r\n    // Ensure the loop is entered when path is empty.\r\n    if (!length) {\r\n      length = 1\r\n      object = undefined\r\n    }\r\n    while (++index < length) {\r\n      let value = object == null ? undefined : object[toKey(path[index])]\r\n      if (value === undefined) {\r\n        index = length\r\n        value = defaultValue\r\n      }\r\n      object = isFunction(value) ? value.call(object) : value\r\n    }\r\n    return object\r\n  }\r\n\r\n  return objects.result = result;\t\r\n});\ndefine('skylark-langx-objects/safe-mixin',[\r\n\t\"./objects\",\r\n  \"./_mixin\",\r\n  \"./_parse_mixin_args\"\r\n],function(objects,_mixin,_parseMixinArgs) {\r\n\r\n    function safeMixin() {\r\n        var args = _parseMixinArgs.apply(this, arguments);\r\n\r\n        args.sources.forEach(function(source) {\r\n            _mixin(args.target, source, args.deep, true);\r\n        });\r\n        return args.target;\r\n    }\r\n\r\n    return objects.safeMixin = safeMixin;\r\n});\ndefine('skylark-langx-objects/scall',[\r\n    \"./objects\"\r\n],function(objects) {\r\n    const  slice = Array.prototype.slice;\r\n\r\n    function scall(obj,method,arg1,arg2) {\r\n        if (obj && obj[method]) {\r\n            var args = slice.call(arguments, 2);\r\n\r\n            return obj[method].apply(obj,args);\r\n        }\r\n    }\r\n\r\n    return objects.scall = scall;\r\n});\ndefine('skylark-langx-objects/is-index',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\"\r\n],function(types,objects) {\r\n\t/** Used as references for various `Number` constants. */\r\n\tconst MAX_SAFE_INTEGER = 9007199254740991\r\n\r\n\t/** Used to detect unsigned integer values. */\r\n\tconst reIsUint = /^(?:0|[1-9]\\d*)$/\r\n\r\n\t/**\r\n\t * Checks if `value` is a valid array-like index.\r\n\t *\r\n\t * @private\r\n\t * @param {*} value The value to check.\r\n\t * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\r\n\t * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\r\n\t */\r\n\tfunction isIndex(value, length) {\r\n\t  const type = typeof value\r\n\t  length = length == null ? MAX_SAFE_INTEGER : length\r\n\r\n\t  return !!length &&\r\n\t    (type === 'number' ||\r\n\t      (type !== 'symbol' && reIsUint.test(value))) &&\r\n\t        (value > -1 && value % 1 == 0 && value < length)\r\n\t}\r\n\r\n\treturn objects.isIndex = isIndex;\r\n});\ndefine('skylark-langx-objects/set',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\",\r\n\t\"./_cast_path\",\r\n\t\"./is-index\",\r\n\t\"./to-key\"\r\n],function(types,objects,castPath,isIndex,toKey) {\r\n\t/**\r\n\t * The base implementation of `set`.\r\n\t *\r\n\t * @private\r\n\t * @param {Object} object The object to modify.\r\n\t * @param {Array|string} path The path of the property to set.\r\n\t * @param {*} value The value to set.\r\n\t * @param {Function} [customizer] The function to customize path creation.\r\n\t * @returns {Object} Returns `object`.\r\n\t */\r\n\tfunction baseSet(object, path, value, customizer) {\r\n\t  if (!types.isObject(object)) {\r\n\t    return object\r\n\t  }\r\n\t  path = castPath(path, object)\r\n\r\n\t  const length = path.length\r\n\t  const lastIndex = length - 1\r\n\r\n\t  let index = -1\r\n\t  let nested = object\r\n\r\n\t  while (nested != null && ++index < length) {\r\n\t    const key = toKey(path[index])\r\n\t    let newValue = value\r\n\r\n\t    if (index != lastIndex) {\r\n\t      const objValue = nested[key]\r\n\t      newValue = customizer ? customizer(objValue, key, nested) : undefined\r\n\t      if (newValue === undefined) {\r\n\t        newValue = types.isObject(objValue)\r\n\t          ? objValue\r\n\t          : (isIndex(path[index + 1]) ? [] : {})\r\n\t      }\r\n\t    }\r\n\t    nested[key] = newValue; //  assignValues() lwf\r\n\t    nested = nested[key];\r\n\t  }\r\n\t  return object\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\r\n\t * it's created. Arrays are created for missing index properties while objects\r\n\t * are created for all other missing properties. Use `setWith` to customize\r\n\t * `path` creation.\r\n\t *\r\n\t * **Note:** This method mutates `object`.\r\n\t *\r\n\t * @since 3.7.0\r\n\t * @category Object\r\n\t * @param {Object} object The object to modify.\r\n\t * @param {Array|string} path The path of the property to set.\r\n\t * @param {*} value The value to set.\r\n\t * @returns {Object} Returns `object`.\r\n\t * @see has, hasIn, get, unset\r\n\t * @example\r\n\t *\r\n\t * const object = { 'a': [{ 'b': { 'c': 3 } }] }\r\n\t *\r\n\t * set(object, 'a[0].b.c', 4)\r\n\t * console.log(object.a[0].b.c)\r\n\t * // => 4\r\n\t *\r\n\t * set(object, ['x', '0', 'y', 'z'], 5)\r\n\t * console.log(object.x[0].y.z)\r\n\t * // => 5\r\n\t */\r\n\tfunction set(object, path, value) {\r\n\t  return object == null ? object : baseSet(object, path, value)\r\n\t}\r\n\r\n\r\n\treturn objects.set = set;\r\n\r\n});\n define('skylark-langx-objects/shadow',[\r\n\t\"./objects\"\r\n],function(objects) {\r\n\r\n    function shadow(obj, prop, value) {\r\n        Object.defineProperty(obj, prop, {\r\n            value,\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: false\r\n        });\r\n        return value;\r\n    }\r\n\r\n    return objects.shadow = shadow;\r\n});\ndefine('skylark-langx-objects/unset',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\",\r\n\t\"./set\"\r\n],function(types,objects,set) {\r\n\r\n\t/**\r\n\t * Removes the property at `path` of `object`.\r\n\t *\r\n\t * **Note:** This method mutates `object`.\r\n\t *\r\n\t * @since 4.0.0\r\n\t * @category Object\r\n\t * @param {Object} object The object to modify.\r\n\t * @param {Array|string} path The path of the property to unset.\r\n\t * @returns {boolean} Returns `true` if the property is deleted, else `false`.\r\n\t * @see get, has, set\r\n\t * @example\r\n\t *\r\n\t * const object = { 'a': [{ 'b': { 'c': 7 } }] }\r\n\t * unset(object, 'a[0].b.c')\r\n\t * // => true\r\n\t *\r\n\t * console.log(object)\r\n\t * // => { 'a': [{ 'b': {} }] }\r\n\t *\r\n\t * unset(object, ['a', '0', 'b', 'c'])\r\n\t * // => true\r\n\t *\r\n\t * console.log(object)\r\n\t * // => { 'a': [{ 'b': {} }] }\r\n\t */\r\n\tfunction unset(object, path) {\r\n\t  return object == null ? true : set(object, path,undefined)\r\n\t}\r\n\r\n\treturn objects.unset = unset;\r\n});\ndefine('skylark-langx-objects/values',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\",\r\n    \"./all-keys\"\r\n],function(types,objects,allKeys){\r\n    // Retrieve the values of an object's properties.\r\n    function values(obj) {\r\n        var keys = allKeys(obj);\r\n        var length = keys.length;\r\n        var values = Array(length);\r\n        for (var i = 0; i < length; i++) {\r\n            values[i] = obj[keys[i]];\r\n        }\r\n        return values;\r\n    }\r\n\r\n    return objects.values = values;\r\n});\ndefine('skylark-langx-objects/main',[\r\n\t\"./objects\",\r\n\t\"./all-keys\",\r\n\t\"./assign\",\r\n\t\"./base-at\",\r\n\t\"./clone\",\r\n\t\"./defaults\",\r\n\t\"./each\",\r\n\t\"./extend\",\r\n\t\"./for-each\",\r\n\t\"./get\",\r\n\t\"./has\",\r\n\t\"./includes\",\r\n\t\"./is-equal\",\r\n\t\"./is-key\",\r\n\t\"./is-match\",\r\n\t\"./keys\",\r\n\t\"./mixin\",\r\n\t\"./omit\",\r\n\t\"./pick\",\r\n\t\"./remove-items\",\r\n\t\"./result\",\r\n\t\"./safe-mixin\",\r\n\t\"./scall\",\r\n\t\"./set\",\r\n\t\"./shadow\",\r\n\t\"./to-key\",\r\n\t\"./unset\",\r\n\t\"./values\"\r\n],function(objects){\r\n\treturn objects;\r\n});\ndefine('skylark-langx-objects', ['skylark-langx-objects/main'], function (main) { return main; });\n\ndefine('skylark-langx-funcs/delegate',[\r\n  \"skylark-langx-objects\",\r\n  \"./funcs\"\r\n],function(objects,funcs){\r\n\tvar mixin = objects.mixin;\r\n\r\n    var delegate = (function() {\r\n        // boodman/crockford delegation w/ cornford optimization\r\n        function TMP() {}\r\n        return function(obj, props) {\r\n            TMP.prototype = obj;\r\n            var tmp = new TMP();\r\n            TMP.prototype = null;\r\n            if (props) {\r\n                mixin(tmp, props);\r\n            }\r\n            return tmp; // Object\r\n        };\r\n    })();\r\n\r\n    return funcs.delegate = delegate;\r\n\r\n});\ndefine('skylark-langx-funcs/loop',[\r\n\t\"./funcs\"\r\n],function(funcs){\r\n\r\n\t/**\r\n\t * Animation timer is a special type of timer that uses the requestAnimationFrame method.\r\n\t *\r\n\t * This timer calls the method with the same rate as the screen refesh rate.\r\n\t * \r\n\t * Loop time can be changed dinamically.\r\n\t *\r\n\t * @class AnimationTimer\r\n\t * @param {Function} callback Timer callback function.\r\n\t */\r\n\tfunction AnimationTimer(callback)\r\n\t{\r\n\t\tthis.callback = callback;\r\n\r\n\t\tthis.running = false;\r\n\t\tthis.id = -1;\r\n\t}\r\n\r\n\t/**\r\n\t * Start timer, is the timer is already running dosen't do anything.\r\n\t * \r\n\t * @method start\r\n\t */\r\n\tAnimationTimer.prototype.start = function()\r\n\t{\r\n\t\tif(this.running)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.running = true;\r\n\r\n\t\tvar self = this;\r\n\t\tfunction run()\r\n\t\t{\r\n\t\t\tself.callback();\r\n\r\n\t\t\tif(self.running)\r\n\t\t\t{\r\n\t\t\t\tself.id = requestAnimationFrame(run);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\trun();\r\n\t};\r\n\r\n\t/**\r\n\t * Stop animation timer.\r\n\t * \r\n\t * @method stop\r\n\t */\r\n\tAnimationTimer.prototype.stop = function()\r\n\t{\r\n\t\tthis.running = false;\r\n\t\tcancelAnimationFrame(this.id);\r\n\t};\r\n\r\n\tfunction loop(fn) {\r\n\t\treturn new AnimationTimer(fn);\r\n    }\r\n\r\n    return funcs.loop = loop;\r\n});\ndefine('skylark-langx-funcs/negate',[\r\n\t\"./funcs\"\r\n],function(funcs){\r\n   \r\n    /**\r\n     * Creates a function that negates the result of the predicate `func`. The\r\n     * `func` predicate is invoked with the `this` binding and arguments of the\r\n     * created function.\r\n     * @category Function\r\n     * @param {Function} predicate The predicate to negate.\r\n     * @returns {Function} Returns the new negated function.\r\n     * @example\r\n     *\r\n     * function isEven(n) {\r\n     *   return n % 2 == 0\r\n     * }\r\n     *\r\n     * filter([1, 2, 3, 4, 5, 6], negate(isEven))\r\n     * // => [1, 3, 5]\r\n     */\r\n    function negate(predicate) {\r\n      if (typeof predicate !== 'function') {\r\n        throw new TypeError('Expected a function')\r\n      }\r\n      return function(...args) {\r\n        return !predicate.apply(this, args)\r\n      }\r\n    }\r\n\r\n\r\n    return funcs.negate = negate;\r\n\r\n});\ndefine('skylark-langx-funcs/proxy',[\r\n  \"skylark-langx-types\",\r\n\t\"./funcs\"\r\n],function(types,funcs){\r\n    var slice = Array.prototype.slice,\r\n        isFunction = types.isFunction,\r\n        isString = types.isString;\r\n\r\n    function proxy(fn, context) {\r\n        var args = (2 in arguments) && slice.call(arguments, 2)\r\n        if (isFunction(fn)) {\r\n            var proxyFn = function() {\r\n                return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments);\r\n            }\r\n            return proxyFn;\r\n        } else if (isString(context)) {\r\n            if (args) {\r\n                args.unshift(fn[context], fn)\r\n                return proxy.apply(null, args)\r\n            } else {\r\n                return proxy(fn[context], fn);\r\n            }\r\n        } else {\r\n            throw new TypeError(\"expected function\");\r\n        }\r\n    }\r\n\r\n    return funcs.bind = funcs.proxy = proxy;\r\n\r\n});\ndefine('skylark-langx-funcs/template',[\r\n  \"skylark-langx-objects\",\r\n  \"./funcs\",\r\n  \"./proxy\"\r\n],function(objects,funcs,proxy){\r\n    //ref : underscore\r\n    var slice = Array.prototype.slice;\r\n   \r\n    // By default, Underscore uses ERB-style template delimiters, change the\r\n    // following template settings to use alternative delimiters.\r\n    var templateSettings = {\r\n        evaluate: /<%([\\s\\S]+?)%>/g,\r\n        interpolate: /<%=([\\s\\S]+?)%>/g,\r\n        escape: /<%-([\\s\\S]+?)%>/g\r\n    };\r\n\r\n    // When customizing `templateSettings`, if you don't want to define an\r\n    // interpolation, evaluation or escaping regex, we need one that is\r\n    // guaranteed not to match.\r\n    var noMatch = /(.)^/;\r\n\r\n\r\n    // Certain characters need to be escaped so that they can be put into a\r\n    // string literal.\r\n    var escapes = {\r\n      \"'\":      \"'\",\r\n      '\\\\':     '\\\\',\r\n      '\\r':     'r',\r\n      '\\n':     'n',\r\n      '\\t':     't',\r\n      '\\u2028': 'u2028',\r\n      '\\u2029': 'u2029'\r\n    };\r\n\r\n    var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\r\n\r\n\r\n    function template(text, data, settings) {\r\n        var render;\r\n        settings = objects.defaults({}, settings,templateSettings);\r\n\r\n        // Combine delimiters into one regular expression via alternation.\r\n        var matcher = RegExp([\r\n          (settings.escape || noMatch).source,\r\n          (settings.interpolate || noMatch).source,\r\n          (settings.evaluate || noMatch).source\r\n        ].join('|') + '|$', 'g');\r\n\r\n        // Compile the template source, escaping string literals appropriately.\r\n        var index = 0;\r\n        var source = \"__p+='\";\r\n        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\r\n          source += text.slice(index, offset)\r\n              .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\r\n\r\n          if (escape) {\r\n            source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\r\n          }\r\n          if (interpolate) {\r\n            source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\r\n          }\r\n          if (evaluate) {\r\n            source += \"';\\n\" + evaluate + \"\\n__p+='\";\r\n          }\r\n          index = offset + match.length;\r\n          return match;\r\n        });\r\n        source += \"';\\n\";\r\n\r\n        // If a variable is not specified, place data values in local scope.\r\n        if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\r\n\r\n        source = \"var __t,__p='',__j=Array.prototype.join,\" +\r\n          \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\r\n          source + 'return __p;\\n';\r\n\r\n        try {\r\n          render = new Function(settings.variable || 'obj', '_', source);\r\n        } catch (e) {\r\n          e.source = source;\r\n          throw e;\r\n        }\r\n\r\n        if (data) {\r\n          return render(data,this)\r\n        }\r\n        var template = proxy(function(data) {\r\n          return render.call(this, data,this);\r\n        },this);\r\n\r\n        // Provide the compiled source as a convenience for precompilation.\r\n        var argument = settings.variable || 'obj';\r\n        template.source = 'function(' + argument + '){\\n' + source + '}';\r\n\r\n        return template;\r\n    }\r\n\r\n    template.templateSettings = funcs.templateSettings = templateSettings;\r\n\r\n    return funcs.template = template;\r\n\r\n});\ndefine('skylark-langx-funcs/throttle',[\r\n  \"./funcs\"\r\n],function(funcs){\r\n\r\n    const throttle = function (fn, wait) {\r\n        let last = window.performance.now();\r\n        const throttled = function (...args) {\r\n            const now = window.performance.now();\r\n            if (now - last >= wait) {\r\n                fn(...args);\r\n                last = now;\r\n            }\r\n        };\r\n        return throttled;\r\n    };\r\n\r\n    /*\r\n    function throttle(func, delay) {\r\n        var timer = null;\r\n\r\n        return function() {\r\n            var context = this,\r\n                args = arguments;\r\n\r\n            if ( timer === null ) {\r\n                timer = setTimeout(function() {\r\n                    func.apply(context, args);\r\n                    timer = null;\r\n                }, delay);\r\n            }\r\n        };\r\n    }\r\n    */\r\n\r\n\r\n    return funcs.throttle = throttle;\r\n});\ndefine('skylark-langx-funcs/main',[\r\n\t\"./funcs\",\r\n\t\"./bind-all\",\r\n\t\"./debounce\",\r\n\t\"./defer\",\r\n\t\"./delegate\",\r\n\t\"./loop\",\r\n\t\"./negate\",\r\n\t\"./proxy\",\r\n\t\"./rest-arguments\",\r\n\t\"./template\",\r\n\t\"./throttle\"\r\n],function(funcs){\r\n\treturn funcs;\r\n});\ndefine('skylark-langx-funcs', ['skylark-langx-funcs/main'], function (main) { return main; });\n\ndefine('skylark-langx-arrays/flatten',[\r\n  \"skylark-langx-types\",\r\n  \"./arrays\"\r\n],function(types,arrays){\r\n\r\n    function flatten(array) {\r\n        if (types.isArrayLike(array)) {\r\n            var result = [];\r\n            for (var i = 0; i < array.length; i++) {\r\n                var item = array[i];\r\n                if (types.isArrayLike(item)) {\r\n                    for (var j = 0; j < item.length; j++) {\r\n                        result.push(item[j]);\r\n                    }\r\n                } else {\r\n                    result.push(item);\r\n                }\r\n            }\r\n            return result;\r\n        } else {\r\n            return array;\r\n        }\r\n        //return array.length > 0 ? concat.apply([], array) : array;\r\n    }\r\n\r\n    return arrays.flatten = flatten;\r\n});\ndefine('skylark-langx-arrays/difference',[\r\n  \"skylark-langx-funcs\",\r\n  \"./arrays\",\r\n  \"./flatten\",\r\n  \"./filter\",\r\n  \"./contains\"\r\n],function(funcs,arrays,flatten,filter,contains){\r\n   // Take the difference between one array and a number of other arrays.\r\n    // Only the elements present in just the first array will remain.\r\n    var difference  = funcs.restArguments(function(array, rest) {\r\n      rest = flatten(rest, true, true);\r\n      return filter(array, function(value){\r\n        return !contains(rest, value);\r\n      });\r\n    });\r\n\r\n    return arrays.difference = difference;\r\n\t\r\n});\ndefine('skylark-langx-arrays/find',[\r\n  \"./arrays\"\r\n],function(arrays){\r\n    var _find = Array.prototype.find;\r\n\r\n    function find(array,func) {\r\n      return _find.call(array,func);\r\n    }\r\n\r\n    return arrays.find = find;\r\n});\ndefine('skylark-langx-arrays/first',[\r\n  \"./arrays\"\r\n],function(arrays){\r\n    function first(items,n) {\r\n      if (n) {\r\n          return items.slice(0,n);\r\n      } else {\r\n          return items[0];\r\n      }\r\n    }\r\n\r\n    return arrays.first = first;\r\n});\ndefine('skylark-langx-arrays/grep',[\r\n  \"skylark-langx-objects\",\r\n  \"./arrays\"\r\n],function(objects,arrays){\r\n    function grep(array, callback) {\r\n        var out = [];\r\n\r\n        objects.each(array, function(i, item) {\r\n            if (callback(item, i)) {\r\n                out.push(item);\r\n            }\r\n        });\r\n\r\n        return out;\r\n    }\r\n\r\n    return arrays.grep = grep;\r\n});\ndefine('skylark-langx-arrays/indexof',[\r\n  \"./arrays\"\r\n],function(arrays){\r\n\r\n    function indexOf(array,item) {\r\n      return array.indexOf(item);\r\n    }\r\n\r\n    return arrays.indexOf = indexOf;\r\n});\ndefine('skylark-langx-arrays/last',[\r\n  \"./arrays\"\r\n],function(arrays){\r\n    // Get the last element of an array. \r\n    function last(arr) {\r\n        return arr[arr.length - 1];     \r\n    }\r\n\r\n    return arrays.last = last;\r\n});\ndefine('skylark-langx-arrays/make-array',[\r\n\t\"skylark-langx-types\",\r\n \t\"./arrays\"\r\n],function(types,arrays){\r\n    function makeArray(obj, offset, startWith) {\r\n       if (types.isArrayLike(obj) ) {\r\n        return (startWith || []).concat(Array.prototype.slice.call(obj, offset || 0));\r\n      }\r\n\r\n      // array of single index\r\n      return [ obj ];             \r\n    }\r\n\r\n\treturn arrays.makeArray = makeArray;\t\r\n});\ndefine('skylark-langx-arrays/map',[\r\n\t\"skylark-langx-types\",\r\n  \t\"./arrays\",\r\n  \t\"./flatten\"\r\n],function(types,arrays,flatten){\r\n    function map(elements, callback) {\r\n        var value, values = [],\r\n            i, key\r\n        if (types.isArrayLike(elements))\r\n            for (i = 0; i < elements.length; i++) {\r\n                value = callback.call(elements[i], elements[i], i);\r\n                if (value != null) values.push(value)\r\n            }\r\n        else\r\n            for (key in elements) {\r\n                value = callback.call(elements[key], elements[key], key);\r\n                if (value != null) values.push(value)\r\n            }\r\n        return flatten(values)\r\n    }\r\n\r\n    return arrays.map = map;\r\n});\ndefine('skylark-langx-arrays/merge',[\r\n  \"./arrays\"\r\n],function(arrays){\r\n\r\n    function merge( first, second ) {\r\n      var l = second.length,\r\n          i = first.length,\r\n          j = 0;\r\n\r\n      if ( typeof l === \"number\" ) {\r\n        for ( ; j < l; j++ ) {\r\n          first[ i++ ] = second[ j ];\r\n        }\r\n      } else {\r\n        while ( second[j] !== undefined ) {\r\n          first[ i++ ] = second[ j++ ];\r\n        }\r\n      }\r\n\r\n      first.length = i;\r\n\r\n      return first;\r\n    }\r\n\r\n    return arrays.merge = merge;\r\n\t\r\n});\ndefine('skylark-langx-arrays/pull-at',[\r\n  \"skylark-langx-types\",\r\n  \"skylark-langx-objects\",\r\n  \"./arrays\"\r\n],function(types,objects,arrays){\r\n\r\n\t/**\r\n\t * Removes elements from `array` corresponding to `indexes` and returns an\r\n\t * array of removed elements.\r\n\t *\r\n\t * **Note:** Unlike `at`, this method mutates `array`.\r\n\t *\r\n\t * @category Array\r\n\t * @param {Array} array The array to modify.\r\n\t * @param {...(number|number[])} [indexes] The indexes of elements to remove.\r\n\t * @returns {Array} Returns the new array of removed elements.\r\n\t * @see pull, pullAll, pullAllBy, pullAllWith, remove, reject\r\n\t * @example\r\n\t *\r\n\t * const array = ['a', 'b', 'c', 'd']\r\n\t * const pulled = pullAt(array, [1, 3])\r\n\t *\r\n\t * console.log(array)\r\n\t * // => ['a', 'c']\r\n\t *\r\n\t * console.log(pulled)\r\n\t * // => ['b', 'd']\r\n\t */\r\n\tfunction pullAt(array, ...indexes) {\r\n\t  const length = array == null ? 0 : array.length\r\n\t  const result = objects.baseAt(array, indexes)\r\n\r\n\t  indexes.sort(function(a, b) {\r\n  \t\treturn a - b;\r\n\t  });\r\n\r\n\t  for (let i= indexes.length-1;i>=0;i--) {\r\n\t  \tarray.slice(indexes[i],1);\r\n\t  }\r\n\r\n\t  return result\r\n\t}\r\n\r\n\treturn arrays.pullAt = pullAt;\r\n});\r\n\ndefine('skylark-langx-arrays/reduce',[\r\n  \"./arrays\"\r\n],function(arrays){\r\n\r\n    function reduce(array,callback,initialValue) {\r\n        return Array.prototype.reduce.call(array,callback,initialValue);\r\n    }\r\n\r\n    return arrays.reduce = reduce;\t\r\n});\ndefine('skylark-langx-arrays/uniq',[\r\n  \"./arrays\",\r\n  \"./filter\"\r\n],function(arrays,filter){\r\n\r\n    function uniq(array) {\r\n        return filter(array, function(item, idx) {\r\n            return array.indexOf(item) == idx;\r\n        })\r\n    }\r\n\t\r\n\treturn arrays.uniq = uniq;\r\n});\ndefine('skylark-langx-arrays/without',[\r\n\t\"skylark-langx-funcs\",\r\n  \"./arrays\",\r\n  \"./difference\"\r\n],function(funcs,arrays,difference){\r\n\r\n    // Return a version of the array that does not contain the specified value(s).\r\n    var without = funcs.restArguments(function(array, otherArrays) {\r\n      return difference(array, otherArrays);\r\n    });\r\n\r\n    return arrays.without = without;\r\n});\ndefine('skylark-langx-arrays/main',[\r\n\t\"./arrays\",\r\n\t\"./base-find-index\",\r\n\t\"./base-indexof\",\r\n\t\"./compact\",\r\n\t\"./contains\",\r\n\t\"./difference\",\r\n\t\"./filter\",\r\n\t\"./find\",\r\n\t\"./first\",\r\n\t\"./flatten\",\r\n\t\"./grep\",\r\n\t\"./in-array\",\r\n\t\"./indexof\",\r\n\t\"./last\",\r\n\t\"./make-array\",\r\n\t\"./map\",\r\n\t\"./merge\",\r\n\t\"./pull-at\",\r\n\t\"./reduce\",\r\n\t\"./uniq\",\r\n\t\"./without\"\r\n],function(arrays){\r\n\treturn arrays;\r\n});\ndefine('skylark-langx-arrays', ['skylark-langx-arrays/main'], function (main) { return main; });\n\ndefine('skylark-langx/arrays',[\r\n\t\"skylark-langx-arrays\"\r\n],function(arrays){\r\n  return arrays;\r\n});\ndefine('skylark-langx-constructs/constructs',[\r\n  \"skylark-langx-ns\"\r\n],function(skylark){\r\n\r\n    return skylark.attach(\"langx.constructs\",{});\r\n});\ndefine('skylark-langx-constructs/inherit',[\r\n\t\"./constructs\"\r\n],function(constructs){\r\n\r\n    function inherit(ctor,base) {\r\n        ///var f = function() {};\r\n        ///f.prototype = base.prototype;\r\n        ///\r\n        ///ctor.prototype = new f();\r\n\r\n\t    if ((typeof base !== \"function\") && base) {\r\n\t      throw new TypeError(\"Super expression must either be null or a function\");\r\n\t    }\r\n\r\n\t    ctor.prototype = Object.create(base && base.prototype, {\r\n\t      constructor: {\r\n\t        value: ctor,\r\n\t        writable: true,\r\n\t        configurable: true\r\n\t      }\r\n\t    });\r\n\r\n\t    if (base) {\r\n\t    \t//tor.__proto__ = base;\r\n\t    \tObject.setPrototypeOf(ctor, base);\r\n\t    } \r\n    }\r\n\r\n    return constructs.inherit = inherit\r\n});\ndefine('skylark-langx-constructs/klass',[\r\n  \"skylark-langx-ns\",\r\n  \"skylark-langx-types\",\r\n  \"skylark-langx-objects\",\r\n  \"skylark-langx-arrays\",\r\n  \"./constructs\",\r\n  \"./inherit\"\r\n],function(skylark,types,objects,arrays,constructs,inherit){\r\n    var uniq = arrays.uniq,\r\n        has = objects.has,\r\n        mixin = objects.mixin,\r\n        isArray = types.isArray,\r\n        isDefined = types.isDefined;\r\n\r\n/* for reference \r\n function klass(props,parent) {\r\n    var ctor = function(){\r\n        this._construct();\r\n    };\r\n    ctor.prototype = props;\r\n    if (parent) {\r\n        ctor._proto_ = parent;\r\n        props.__proto__ = parent.prototype;\r\n    }\r\n    return ctor;\r\n}\r\n\r\n// Type some JavaScript code here.\r\nlet animal = klass({\r\n  _construct(){\r\n      this.name = this.name + \",hi\";\r\n  },\r\n    \r\n  name: \"Animal\",\r\n  eat() {         // [[HomeObject]] == animal\r\n    alert(`${this.name} eats.`);\r\n  }\r\n    \r\n    \r\n});\r\n\r\n\r\nlet rabbit = klass({\r\n  name: \"Rabbit\",\r\n  _construct(){\r\n      super._construct();\r\n  },\r\n  eat() {         // [[HomeObject]] == rabbit\r\n    super.eat();\r\n  }\r\n},animal);\r\n\r\nlet longEar = klass({\r\n  name: \"Long Ear\",\r\n  eat() {         // [[HomeObject]] == longEar\r\n    super.eat();\r\n  }\r\n},rabbit);\r\n*/\r\n    \r\n\r\n\r\n    var f1 = function() {\r\n        function extendClass(ctor, props, options) {\r\n            // Copy the properties to the prototype of the class.\r\n            var proto = ctor.prototype,\r\n                _super = ctor.superclass.prototype,\r\n                noOverrided = options && options.noOverrided,\r\n                overrides = options && options.overrides || {};\r\n\r\n            for (var name in props) {\r\n                if (name === \"constructor\") {\r\n                    continue;\r\n                }\r\n\r\n                // Check if we're overwriting an existing function\r\n                var prop = props[name];\r\n                if (typeof props[name] == \"function\") {\r\n                    proto[name] =  !prop._constructor && !noOverrided && typeof _super[name] == \"function\" ?\r\n                          (function(name, fn, superFn) {\r\n                            return function() {\r\n                                var tmp = this.overrided;\r\n\r\n                                // Add a new ._super() method that is the same method\r\n                                // but on the super-class\r\n                                this.overrided = superFn;\r\n\r\n                                // The method only need to be bound temporarily, so we\r\n                                // remove it when we're done executing\r\n                                var ret = fn.apply(this, arguments);\r\n\r\n                                this.overrided = tmp;\r\n\r\n                                return ret;\r\n                            };\r\n                        })(name, prop, _super[name]) :\r\n                        prop;\r\n                } else if (types.isPlainObject(prop) && prop!==null && (prop.get)) {\r\n                    Object.defineProperty(proto,name,prop);\r\n                } else {\r\n                    proto[name] = prop;\r\n                }\r\n            }\r\n            return ctor;\r\n        }\r\n\r\n        function serialMixins(ctor,mixins) {\r\n            var result = [];\r\n\r\n            mixins.forEach(function(mixin){\r\n                if (has(mixin,\"__mixins__\")) {\r\n                     throw new Error(\"nested mixins\");\r\n                }\r\n                var clss = [];\r\n                while (mixin) {\r\n                    clss.unshift(mixin);\r\n                    mixin = mixin.superclass;\r\n                }\r\n                result = result.concat(clss);\r\n            });\r\n\r\n            result = uniq(result);\r\n\r\n            result = result.filter(function(mixin){\r\n                var cls = ctor;\r\n                while (cls) {\r\n                    if (mixin === cls) {\r\n                        return false;\r\n                    }\r\n                    if (has(cls,\"__mixins__\")) {\r\n                        var clsMixines = cls[\"__mixins__\"];\r\n                        for (var i=0; i<clsMixines.length;i++) {\r\n                            if (clsMixines[i]===mixin) {\r\n                                return false;\r\n                            }\r\n                        }\r\n                    }\r\n                    cls = cls.superclass;\r\n                }\r\n                return true;\r\n            });\r\n\r\n            if (result.length>0) {\r\n                return result;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        function mergeMixins(ctor,mixins) {\r\n            var newCtor =ctor;\r\n            for (var i=0;i<mixins.length;i++) {\r\n                var xtor = new Function();\r\n\r\n                inherit(xtor,newCtor)\r\n                //xtor.prototype = Object.create(newCtor.prototype);\r\n                //xtor.__proto__ = newCtor;\r\n                xtor.superclass = null;\r\n                mixin(xtor.prototype,mixins[i].prototype);\r\n                xtor.prototype.__mixin__ = mixins[i];\r\n                newCtor = xtor;\r\n            }\r\n\r\n            return newCtor;\r\n        }\r\n\r\n        function _constructor ()  {\r\n            if (this._construct) {\r\n                return this._construct.apply(this, arguments);\r\n            } else  if (this.init) {\r\n                return this.init.apply(this, arguments);\r\n            }\r\n        }\r\n\r\n        return function createClass(props, parent, mixins,options) {\r\n            if (isArray(parent)) {\r\n                options = mixins;\r\n                mixins = parent;\r\n                parent = null;\r\n            }\r\n            parent = parent || Object;\r\n\r\n            if (isDefined(mixins) && !isArray(mixins)) {\r\n                options = mixins;\r\n                mixins = false;\r\n            }\r\n\r\n            var innerParent = parent;\r\n\r\n            if (mixins) {\r\n                mixins = serialMixins(innerParent,mixins);\r\n            }\r\n\r\n            if (mixins) {\r\n                innerParent = mergeMixins(innerParent,mixins);\r\n            }\r\n\r\n            var klassName = props.klassName || \"\",\r\n                ctor = new Function(\r\n                    \"return function \" + klassName + \"() {\" +\r\n                    \"var inst = this,\" +\r\n                    \" ctor = arguments.callee;\" +\r\n                    \"if (!(inst instanceof ctor)) {\" +\r\n                    \"inst = Object.create(ctor.prototype);\" +\r\n                    \"}\" +\r\n                    \"return ctor._constructor.apply(inst, arguments) || inst;\" + \r\n                    \"}\"\r\n                )();\r\n\r\n\r\n            // Populate our constructed prototype object\r\n            ///ctor.prototype = Object.create(innerParent.prototype);\r\n\r\n            // Enforce the constructor to be what we expect\r\n            ///ctor.prototype.constructor = ctor;\r\n  \r\n            // And make this class extendable\r\n            ///ctor.__proto__ = innerParent;\r\n\r\n            inherit(ctor,innerParent);\r\n\r\n            ctor.superclass = parent;\r\n\r\n            if (!ctor._constructor) {\r\n                ctor._constructor = _constructor;\r\n            } \r\n\r\n            if (mixins) {\r\n                ctor.__mixins__ = mixins;\r\n            }\r\n\r\n            if (!ctor.partial) {\r\n                ctor.partial = function(props, options) {\r\n                    return extendClass(this, props, options);\r\n                };\r\n            }\r\n            if (!ctor.inherit) {\r\n                ctor.inherit = function(props, mixins,options) {\r\n                    return createClass(props, this, mixins,options);\r\n                };\r\n            }\r\n\r\n            ctor.partial(props, options);\r\n\r\n            return ctor;\r\n        };\r\n    }\r\n\r\n    var createClass = f1();\r\n\r\n    return constructs.klass = createClass;\r\n});\ndefine('skylark-langx-constructs/main',[\r\n\t\"./constructs\",\r\n\t\"./inherit\",\r\n\t\"./klass\"\r\n],function(constructs){\r\n\treturn constructs;\r\n});\ndefine('skylark-langx-constructs', ['skylark-langx-constructs/main'], function (main) { return main; });\n\ndefine('skylark-langx-klass/klass',[\r\n  \"skylark-langx-ns\",\r\n  \"skylark-langx-constructs\"\r\n],function(skylark,constructs){\r\n\r\n    return skylark.attach(\"langx.klass\",constructs.klass);\r\n});\ndefine('skylark-langx-klass/main',[\r\n\t\"./klass\"\r\n],function(klass){\r\n\treturn klass;\r\n});\ndefine('skylark-langx-klass', ['skylark-langx-klass/main'], function (main) { return main; });\n\ndefine('skylark-langx/klass',[\r\n    \"skylark-langx-klass\"\r\n],function(klass){\r\n    return klass;\r\n});\ndefine('skylark-langx/array-store',[\r\n    \"./klass\"\r\n],function(klass){\r\n    var SimpleQueryEngine = function(query, options){\r\n        // summary:\r\n        //      Simple query engine that matches using filter functions, named filter\r\n        //      functions or objects by name-value on a query object hash\r\n        //\r\n        // description:\r\n        //      The SimpleQueryEngine provides a way of getting a QueryResults through\r\n        //      the use of a simple object hash as a filter.  The hash will be used to\r\n        //      match properties on data objects with the corresponding value given. In\r\n        //      other words, only exact matches will be returned.\r\n        //\r\n        //      This function can be used as a template for more complex query engines;\r\n        //      for example, an engine can be created that accepts an object hash that\r\n        //      contains filtering functions, or a string that gets evaluated, etc.\r\n        //\r\n        //      When creating a new dojo.store, simply set the store's queryEngine\r\n        //      field as a reference to this function.\r\n        //\r\n        // query: Object\r\n        //      An object hash with fields that may match fields of items in the store.\r\n        //      Values in the hash will be compared by normal == operator, but regular expressions\r\n        //      or any object that provides a test() method are also supported and can be\r\n        //      used to match strings by more complex expressions\r\n        //      (and then the regex's or object's test() method will be used to match values).\r\n        //\r\n        // options: dojo/store/api/Store.QueryOptions?\r\n        //      An object that contains optional information such as sort, start, and count.\r\n        //\r\n        // returns: Function\r\n        //      A function that caches the passed query under the field \"matches\".  See any\r\n        //      of the \"query\" methods on dojo.stores.\r\n        //\r\n        // example:\r\n        //      Define a store with a reference to this engine, and set up a query method.\r\n        //\r\n        //  |   var myStore = function(options){\r\n        //  |       //  ...more properties here\r\n        //  |       this.queryEngine = SimpleQueryEngine;\r\n        //  |       //  define our query method\r\n        //  |       this.query = function(query, options){\r\n        //  |           return QueryResults(this.queryEngine(query, options)(this.data));\r\n        //  |       };\r\n        //  |   };\r\n\r\n        // create our matching query function\r\n        switch(typeof query){\r\n            default:\r\n                throw new Error(\"Can not query with a \" + typeof query);\r\n            case \"object\": case \"undefined\":\r\n                var queryObject = query;\r\n                query = function(object){\r\n                    for(var key in queryObject){\r\n                        var required = queryObject[key];\r\n                        if(required && required.test){\r\n                            // an object can provide a test method, which makes it work with regex\r\n                            if(!required.test(object[key], object)){\r\n                                return false;\r\n                            }\r\n                        }else if(required != object[key]){\r\n                            return false;\r\n                        }\r\n                    }\r\n                    return true;\r\n                };\r\n                break;\r\n            case \"string\":\r\n                // named query\r\n                if(!this[query]){\r\n                    throw new Error(\"No filter function \" + query + \" was found in store\");\r\n                }\r\n                query = this[query];\r\n                // fall through\r\n            case \"function\":\r\n                // fall through\r\n        }\r\n        \r\n        function filter(arr, callback, thisObject){\r\n            // summary:\r\n            //      Returns a new Array with those items from arr that match the\r\n            //      condition implemented by callback.\r\n            // arr: Array\r\n            //      the array to iterate over.\r\n            // callback: Function|String\r\n            //      a function that is invoked with three arguments (item,\r\n            //      index, array). The return of this function is expected to\r\n            //      be a boolean which determines whether the passed-in item\r\n            //      will be included in the returned array.\r\n            // thisObject: Object?\r\n            //      may be used to scope the call to callback\r\n            // returns: Array\r\n            // description:\r\n            //      This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when\r\n            //      run over sparse arrays, this implementation passes the \"holes\" in the sparse array to\r\n            //      the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.\r\n            //      For more details, see:\r\n            //      https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter\r\n            // example:\r\n            //  | // returns [2, 3, 4]\r\n            //  | array.filter([1, 2, 3, 4], function(item){ return item>1; });\r\n\r\n            // TODO: do we need \"Ctr\" here like in map()?\r\n            var i = 0, l = arr && arr.length || 0, out = [], value;\r\n            if(l && typeof arr == \"string\") arr = arr.split(\"\");\r\n            if(typeof callback == \"string\") callback = cache[callback] || buildFn(callback);\r\n            if(thisObject){\r\n                for(; i < l; ++i){\r\n                    value = arr[i];\r\n                    if(callback.call(thisObject, value, i, arr)){\r\n                        out.push(value);\r\n                    }\r\n                }\r\n            }else{\r\n                for(; i < l; ++i){\r\n                    value = arr[i];\r\n                    if(callback(value, i, arr)){\r\n                        out.push(value);\r\n                    }\r\n                }\r\n            }\r\n            return out; // Array\r\n        }\r\n\r\n        function execute(array){\r\n            // execute the whole query, first we filter\r\n            var results = filter(array, query);\r\n            // next we sort\r\n            var sortSet = options && options.sort;\r\n            if(sortSet){\r\n                results.sort(typeof sortSet == \"function\" ? sortSet : function(a, b){\r\n                    for(var sort, i=0; sort = sortSet[i]; i++){\r\n                        var aValue = a[sort.attribute];\r\n                        var bValue = b[sort.attribute];\r\n                        // valueOf enables proper comparison of dates\r\n                        aValue = aValue != null ? aValue.valueOf() : aValue;\r\n                        bValue = bValue != null ? bValue.valueOf() : bValue;\r\n                        if (aValue != bValue){\r\n                            // modified by lwf 2016/07/09\r\n                            //return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;\r\n                            return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;\r\n                        }\r\n                    }\r\n                    return 0;\r\n                });\r\n            }\r\n            // now we paginate\r\n            if(options && (options.start || options.count)){\r\n                var total = results.length;\r\n                results = results.slice(options.start || 0, (options.start || 0) + (options.count || Infinity));\r\n                results.total = total;\r\n            }\r\n            return results;\r\n        }\r\n        execute.matches = query;\r\n        return execute;\r\n    };\r\n\r\n    var QueryResults = function(results){\r\n        // summary:\r\n        //      A function that wraps the results of a store query with additional\r\n        //      methods.\r\n        // description:\r\n        //      QueryResults is a basic wrapper that allows for array-like iteration\r\n        //      over any kind of returned data from a query.  While the simplest store\r\n        //      will return a plain array of data, other stores may return deferreds or\r\n        //      promises; this wrapper makes sure that *all* results can be treated\r\n        //      the same.\r\n        //\r\n        //      Additional methods include `forEach`, `filter` and `map`.\r\n        // results: Array|dojo/promise/Promise\r\n        //      The result set as an array, or a promise for an array.\r\n        // returns:\r\n        //      An array-like object that can be used for iterating over.\r\n        // example:\r\n        //      Query a store and iterate over the results.\r\n        //\r\n        //  |   store.query({ prime: true }).forEach(function(item){\r\n        //  |       //  do something\r\n        //  |   });\r\n\r\n        if(!results){\r\n            return results;\r\n        }\r\n\r\n        var isPromise = !!results.then;\r\n        // if it is a promise it may be frozen\r\n        if(isPromise){\r\n            results = Object.delegate(results);\r\n        }\r\n        function addIterativeMethod(method){\r\n            // Always add the iterative methods so a QueryResults is\r\n            // returned whether the environment is ES3 or ES5\r\n            results[method] = function(){\r\n                var args = arguments;\r\n                var result = Deferred.when(results, function(results){\r\n                    //Array.prototype.unshift.call(args, results);\r\n                    return QueryResults(Array.prototype[method].apply(results, args));\r\n                });\r\n                // forEach should only return the result of when()\r\n                // when we're wrapping a promise\r\n                if(method !== \"forEach\" || isPromise){\r\n                    return result;\r\n                }\r\n            };\r\n        }\r\n\r\n        addIterativeMethod(\"forEach\");\r\n        addIterativeMethod(\"filter\");\r\n        addIterativeMethod(\"map\");\r\n        if(results.total == null){\r\n            results.total = Deferred.when(results, function(results){\r\n                return results.length;\r\n            });\r\n        }\r\n        return results; // Object\r\n    };\r\n\r\n    var ArrayStore = klass({\r\n        \"klassName\": \"ArrayStore\",\r\n\r\n        \"queryEngine\": SimpleQueryEngine,\r\n        \r\n        \"idProperty\": \"id\",\r\n\r\n\r\n        get: function(id){\r\n            // summary:\r\n            //      Retrieves an object by its identity\r\n            // id: Number\r\n            //      The identity to use to lookup the object\r\n            // returns: Object\r\n            //      The object in the store that matches the given id.\r\n            return this.data[this.index[id]];\r\n        },\r\n\r\n        getIdentity: function(object){\r\n            return object[this.idProperty];\r\n        },\r\n\r\n        put: function(object, options){\r\n            var data = this.data,\r\n                index = this.index,\r\n                idProperty = this.idProperty;\r\n            var id = object[idProperty] = (options && \"id\" in options) ? options.id : idProperty in object ? object[idProperty] : Math.random();\r\n            if(id in index){\r\n                // object exists\r\n                if(options && options.overwrite === false){\r\n                    throw new Error(\"Object already exists\");\r\n                }\r\n                // replace the entry in data\r\n                data[index[id]] = object;\r\n            }else{\r\n                // add the new object\r\n                index[id] = data.push(object) - 1;\r\n            }\r\n            return id;\r\n        },\r\n\r\n        add: function(object, options){\r\n            (options = options || {}).overwrite = false;\r\n            // call put with overwrite being false\r\n            return this.put(object, options);\r\n        },\r\n\r\n        remove: function(id){\r\n            // summary:\r\n            //      Deletes an object by its identity\r\n            // id: Number\r\n            //      The identity to use to delete the object\r\n            // returns: Boolean\r\n            //      Returns true if an object was removed, falsy (undefined) if no object matched the id\r\n            var index = this.index;\r\n            var data = this.data;\r\n            if(id in index){\r\n                data.splice(index[id], 1);\r\n                // now we have to reindex\r\n                this.setData(data);\r\n                return true;\r\n            }\r\n        },\r\n        query: function(query, options){\r\n            // summary:\r\n            //      Queries the store for objects.\r\n            // query: Object\r\n            //      The query to use for retrieving objects from the store.\r\n            // options: dojo/store/api/Store.QueryOptions?\r\n            //      The optional arguments to apply to the resultset.\r\n            // returns: dojo/store/api/Store.QueryResults\r\n            //      The results of the query, extended with iterative methods.\r\n            //\r\n            // example:\r\n            //      Given the following store:\r\n            //\r\n            //  |   var store = new Memory({\r\n            //  |       data: [\r\n            //  |           {id: 1, name: \"one\", prime: false },\r\n            //  |           {id: 2, name: \"two\", even: true, prime: true},\r\n            //  |           {id: 3, name: \"three\", prime: true},\r\n            //  |           {id: 4, name: \"four\", even: true, prime: false},\r\n            //  |           {id: 5, name: \"five\", prime: true}\r\n            //  |       ]\r\n            //  |   });\r\n            //\r\n            //  ...find all items where \"prime\" is true:\r\n            //\r\n            //  |   var results = store.query({ prime: true });\r\n            //\r\n            //  ...or find all items where \"even\" is true:\r\n            //\r\n            //  |   var results = store.query({ even: true });\r\n            return QueryResults(this.queryEngine(query, options)(this.data));\r\n        },\r\n\r\n        setData: function(data){\r\n            // summary:\r\n            //      Sets the given data as the source for this store, and indexes it\r\n            // data: Object[]\r\n            //      An array of objects to use as the source of data.\r\n            if(data.items){\r\n                // just for convenience with the data format IFRS expects\r\n                this.idProperty = data.identifier || this.idProperty;\r\n                data = this.data = data.items;\r\n            }else{\r\n                this.data = data;\r\n            }\r\n            this.index = {};\r\n            for(var i = 0, l = data.length; i < l; i++){\r\n                this.index[data[i][this.idProperty]] = i;\r\n            }\r\n        },\r\n\r\n        init: function(options) {\r\n            for(var i in options){\r\n                this[i] = options[i];\r\n            }\r\n            this.setData(this.data || []);\r\n        }\r\n\r\n    });\r\n\r\n\treturn ArrayStore;\r\n});\ndefine('skylark-langx-aspect/aspect',[\n    \"skylark-langx-ns\"\n],function(skylark){\n\n  var undefined, nextId = 0;\n    function advise(dispatcher, type, advice, receiveArguments){\n        var previous = dispatcher[type];\n        var around = type == \"around\";\n        var signal;\n        if(around){\n            var advised = advice(function(){\n                return previous.advice(this, arguments);\n            });\n            signal = {\n                remove: function(){\n                    if(advised){\n                        advised = dispatcher = advice = null;\n                    }\n                },\n                advice: function(target, args){\n                    return advised ?\n                        advised.apply(target, args) :  // called the advised function\n                        previous.advice(target, args); // cancelled, skip to next one\n                }\n            };\n        }else{\n            // create the remove handler\n            signal = {\n                remove: function(){\n                    if(signal.advice){\n                        var previous = signal.previous;\n                        var next = signal.next;\n                        if(!next && !previous){\n                            delete dispatcher[type];\n                        }else{\n                            if(previous){\n                                previous.next = next;\n                            }else{\n                                dispatcher[type] = next;\n                            }\n                            if(next){\n                                next.previous = previous;\n                            }\n                        }\n\n                        // remove the advice to signal that this signal has been removed\n                        dispatcher = advice = signal.advice = null;\n                    }\n                },\n                id: nextId++,\n                advice: advice,\n                receiveArguments: receiveArguments\n            };\n        }\n        if(previous && !around){\n            if(type == \"after\"){\n                // add the listener to the end of the list\n                // note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug\n                while(previous.next && (previous = previous.next)){}\n                previous.next = signal;\n                signal.previous = previous;\n            }else if(type == \"before\"){\n                // add to beginning\n                dispatcher[type] = signal;\n                signal.next = previous;\n                previous.previous = signal;\n            }\n        }else{\n            // around or first one just replaces\n            dispatcher[type] = signal;\n        }\n        return signal;\n    }\n    function aspect(type){\n        return function(target, methodName, advice, receiveArguments){\n            var existing = target[methodName], dispatcher;\n            if(!existing || existing.target != target){\n                // no dispatcher in place\n                target[methodName] = dispatcher = function(){\n                    var executionId = nextId;\n                    // before advice\n                    var args = arguments;\n                    var before = dispatcher.before;\n                    while(before){\n                        args = before.advice.apply(this, args) || args;\n                        before = before.next;\n                    }\n                    // around advice\n                    if(dispatcher.around){\n                        var results = dispatcher.around.advice(this, args);\n                    }\n                    // after advice\n                    var after = dispatcher.after;\n                    while(after && after.id < executionId){\n                        if(after.receiveArguments){\n                            var newResults = after.advice.apply(this, args);\n                            // change the return value only if a new value was returned\n                            results = newResults === undefined ? results : newResults;\n                        }else{\n                            results = after.advice.call(this, results, args);\n                        }\n                        after = after.next;\n                    }\n                    return results;\n                };\n                if(existing){\n                    dispatcher.around = {advice: function(target, args){\n                        return existing.apply(target, args);\n                    }};\n                }\n                dispatcher.target = target;\n            }\n            var results = advise((dispatcher || existing), type, advice, receiveArguments);\n            advice = null;\n            return results;\n        };\n    }\n\n    return skylark.attach(\"langx.aspect\",{\n        after: aspect(\"after\"),\n \n        around: aspect(\"around\"),\n        \n        before: aspect(\"before\")\n    });\n});\ndefine('skylark-langx-aspect/main',[\n\t\"./aspect\"\n],function(aspect){\n\treturn aspect;\n});\ndefine('skylark-langx-aspect', ['skylark-langx-aspect/main'], function (main) { return main; });\n\ndefine('skylark-langx/aspect',[\r\n    \"skylark-langx-aspect\"\r\n],function(aspect){\r\n  return aspect;\r\n});\ndefine('skylark-langx-async/async',[\r\n    \"skylark-langx-ns\"\r\n],function(skylark){\r\n\treturn skylark.attach(\"langx.async\");\t\r\n});\ndefine('skylark-langx-async/deferred',[\r\n    \"skylark-langx-arrays\",\r\n\t\"skylark-langx-funcs\",\r\n    \"skylark-langx-objects\",\r\n    \"./async\"\r\n],function(arrays,funcs,objects,async){\r\n    \"use strict\";\r\n\r\n    var slice = Array.prototype.slice,\r\n        proxy = funcs.proxy,\r\n        makeArray = arrays.makeArray,\r\n        result = objects.result,\r\n        mixin = objects.mixin;\r\n\r\n    mixin(Promise.prototype,{\r\n        always: function(handler) {\r\n            //this.done(handler);\r\n            //this.fail(handler);\r\n            this.then(handler,handler);\r\n            return this;\r\n        },\r\n        done : function() {\r\n            for (var i = 0;i<arguments.length;i++) {\r\n                this.then(arguments[i]);\r\n            }\r\n            return this;\r\n        },\r\n        fail : function(handler) { \r\n            //return mixin(Promise.prototype.catch.call(this,handler),added);\r\n            //return this.then(null,handler);\r\n            this.catch(handler);\r\n            return this;\r\n         }\r\n    });\r\n\r\n\r\n    var Deferred = function() {\r\n        var self = this,\r\n            p = this.promise = makePromise2(new Promise(function(resolve, reject) {\r\n                self._resolve = resolve;\r\n                self._reject = reject;\r\n            }));\r\n\r\n        //wrapPromise(p,self);\r\n\r\n        //this[PGLISTENERS] = [];\r\n        //this[PGNOTIFIES] = [];\r\n\r\n        //this.resolve = Deferred.prototype.resolve.bind(this);\r\n        //this.reject = Deferred.prototype.reject.bind(this);\r\n        //this.progress = Deferred.prototype.progress.bind(this);\r\n\r\n    };\r\n\r\n   \r\n    function makePromise2(promise) {\r\n        // Don't modify any promise that has been already modified.\r\n        if (promise.isResolved) return promise;\r\n\r\n        // Set initial state\r\n        var isPending = true;\r\n        var isRejected = false;\r\n        var isResolved = false;\r\n\r\n        // Observe the promise, saving the fulfillment in a closure scope.\r\n        var result = promise.then(\r\n            function(v) {\r\n                isResolved = true;\r\n                isPending = false;\r\n                return v; \r\n            }, \r\n            function(e) {\r\n                isRejected = true;\r\n                isPending = false;\r\n                throw e; \r\n            }\r\n        );\r\n\r\n        result.isResolved = function() { return isResolved; };\r\n        result.isPending = function() { return isPending; };\r\n        result.isRejected = function() { return isRejected; };\r\n\r\n        result.state = function() {\r\n            if (isResolved) {\r\n                return 'resolved';\r\n            }\r\n            if (isRejected) {\r\n                return 'rejected';\r\n            }\r\n            return 'pending';\r\n        };\r\n\r\n        var notified = [],\r\n            listeners = [];\r\n\r\n          \r\n        result.then = function(onResolved,onRejected,onProgress) {\r\n            if (onProgress) {\r\n                this.progress(onProgress);\r\n            }\r\n            return makePromise2(Promise.prototype.then.call(this,\r\n                onResolved && function(args) {\r\n                    if (args && args.__ctx__ !== undefined) {\r\n                        return onResolved.apply(args.__ctx__,args);\r\n                    } else {\r\n                        return onResolved(args);\r\n                    }\r\n                },\r\n                onRejected && function(args){\r\n                    if (args && args.__ctx__ !== undefined) {\r\n                        return onRejected.apply(args.__ctx__,args);\r\n                    } else {\r\n                        return onRejected(args);\r\n                    }\r\n                }\r\n            ));\r\n        };\r\n\r\n        result.progress = function(handler) {\r\n            notified.forEach(function (value) {\r\n                handler(value);\r\n            });\r\n            listeners.push(handler);\r\n            return this;\r\n        };\r\n\r\n        result.pipe = result.then;\r\n\r\n        result.notify = function(value) {\r\n            try {\r\n                notified.push(value);\r\n\r\n                return listeners.forEach(function (listener) {\r\n                    return listener(value);\r\n                });\r\n            } catch (error) {\r\n            this.reject(error);\r\n            }\r\n            return this;\r\n        };\r\n\r\n        return result;\r\n    }\r\n\r\n \r\n    Deferred.prototype.resolve = function(value) {\r\n        var args = slice.call(arguments);\r\n        return this.resolveWith(null,args);\r\n    };\r\n\r\n    Deferred.prototype.resolveWith = function(context,args) {\r\n        args = args ? makeArray(args) : []; \r\n        args.__ctx__ = context;\r\n        this._resolve(args);\r\n        this._resolved = true;\r\n        return this;\r\n    };\r\n\r\n    Deferred.prototype.notify = function(value) {\r\n        var p = result(this,\"promise\");\r\n        p.notify(value);\r\n        return this;\r\n    };\r\n\r\n    Deferred.prototype.reject = function(reason) {\r\n        var args = slice.call(arguments);\r\n        return this.rejectWith(null,args);\r\n    };\r\n\r\n    Deferred.prototype.rejectWith = function(context,args) {\r\n        args = args ? makeArray(args) : []; \r\n        args.__ctx__ = context;\r\n        this._reject(args);\r\n        this._rejected = true;\r\n        return this;\r\n    };\r\n\r\n    Deferred.prototype.isResolved = function() {\r\n        var p = result(this,\"promise\");\r\n        return p.isResolved();\r\n    };\r\n\r\n    Deferred.prototype.isRejected = function() {\r\n        var p = result(this,\"promise\");\r\n        return p.isRejected();\r\n    };\r\n\r\n    Deferred.prototype.state = function() {\r\n        var p = result(this,\"promise\");\r\n        return p.state();\r\n    };\r\n\r\n    Deferred.prototype.then = function(callback, errback, progback) {\r\n        var p = result(this,\"promise\");\r\n        return p.then(callback, errback, progback);\r\n    };\r\n\r\n    Deferred.prototype.progress = function(progback){\r\n        var p = result(this,\"promise\");\r\n        return p.progress(progback);\r\n    };\r\n   \r\n    Deferred.prototype.catch = function(errback) {\r\n        var p = result(this,\"promise\");\r\n        return p.catch(errback);\r\n    };\r\n\r\n\r\n    Deferred.prototype.always  = function() {\r\n        var p = result(this,\"promise\");\r\n        p.always.apply(p,arguments);\r\n        return this;\r\n    };\r\n\r\n    Deferred.prototype.done  = function() {\r\n        var p = result(this,\"promise\");\r\n        p.done.apply(p,arguments);\r\n        return this;\r\n    };\r\n\r\n    Deferred.prototype.fail = function(errback) {\r\n        var p = result(this,\"promise\");\r\n        p.fail(errback);\r\n        return this;\r\n    };\r\n\r\n\r\n    Deferred.all = function(array) {\r\n        //return wrapPromise(Promise.all(array));\r\n        var d = new Deferred();\r\n        Promise.all(array).then(d.resolve.bind(d),d.reject.bind(d));\r\n        return result(d,\"promise\");\r\n    };\r\n\r\n    Deferred.first = function(array) {\r\n        return makePromise2(Promise.race(array));\r\n    };\r\n\r\n\r\n    Deferred.when = function(valueOrPromise, callback, errback, progback) {\r\n        var receivedPromise = valueOrPromise && typeof valueOrPromise.then === \"function\";\r\n        var nativePromise = receivedPromise && valueOrPromise instanceof Promise;\r\n\r\n        if (!receivedPromise) {\r\n            if (arguments.length > 1) {\r\n                return callback ? callback(valueOrPromise) : valueOrPromise;\r\n            } else {\r\n                return new Deferred().resolve(valueOrPromise);\r\n            }\r\n        } else if (!nativePromise) {\r\n            var deferred = new Deferred(valueOrPromise.cancel);\r\n            valueOrPromise.then(proxy(deferred.resolve,deferred), proxy(deferred.reject,deferred), deferred.notify);\r\n            valueOrPromise = deferred.promise;\r\n        }\r\n\r\n        if (callback || errback || progback) {\r\n            return valueOrPromise.then(callback, errback, progback);\r\n        }\r\n        return valueOrPromise;\r\n    };\r\n\r\n    Deferred.reject = function(err) {\r\n        var d = new Deferred();\r\n        d.reject(err);\r\n        return d.promise;\r\n    };\r\n\r\n    Deferred.resolve = function(data) {\r\n        var d = new Deferred();\r\n        d.resolve.apply(d,arguments);\r\n        return d.promise;\r\n    };\r\n\r\n    Deferred.immediate = Deferred.resolve;\r\n\r\n\r\n    Deferred.promise = function(callback) {\r\n        var d = new Deferred();\r\n\r\n        callback(d.resolve.bind(d),d.reject.bind(d),d.progress.bind(d));\r\n\r\n        return d.promise;\r\n    };\r\n\r\n    return async.Deferred = Deferred;\r\n});\ndefine('skylark-langx-async/each',[\r\n\t\"./async\"\r\n],function(async){\r\n\r\n\tfunction each(items, next, callback) {\r\n\t\tif (items.length === 0) return callback(undefined, items);\r\n\r\n\t\tvar transformed = new Array(items.length);\r\n\t\tvar count = 0;\r\n\t\tvar returned = false;\r\n\r\n\t\titems.forEach(function(item, index) {\r\n\t\t\tnext(item, function(error, transformedItem) {\r\n\t\t    \tif (returned) return;\r\n\t\t    \tif (error) {\r\n\t\t      \t\treturned = true;\r\n\t\t      \t\treturn callback(error);\r\n\t\t    \t}\r\n\t\t    \ttransformed[index] = transformedItem;\r\n\t\t    \tcount += 1;\r\n\t\t    \tif (count === items.length) {\r\n\t\t    \t\treturn callback(undefined, transformed);\r\n\t\t    \t}\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\r\n\treturn async.each = each;\r\n\r\n});\ndefine('skylark-langx-async/parallel',[\r\n    \"skylark-langx-objects\",\r\n    \"./async\",\r\n    \"./deferred\"\r\n],function(objects,async,Deferred){\r\n    function parallel(arr,args,ctx) {\r\n        var rets = [];\r\n        ctx = ctx || null;\r\n        args = args || [];\r\n\r\n        objects.each(arr,function(i,func){\r\n            rets.push(func.apply(ctx,args));\r\n        });\r\n\r\n        return Deferred.all(rets);\r\n    }\r\n\r\n\treturn async.parallel = parallel;\r\n});\ndefine('skylark-langx-async/series',[\r\n    \"skylark-langx-objects\",\r\n    \"./async\",\r\n    \"./deferred\"\r\n],function(objects,async,Deferred){\r\n     function series(arr,args,ctx) {\r\n        var rets = [],\r\n            d = new Deferred(),\r\n            p = d.promise;\r\n\r\n        ctx = ctx || null;\r\n        args = args || [];\r\n\r\n        d.resolve();\r\n        objects.each(arr,function(i,func){\r\n            p = p.then(function(){\r\n                return func.apply(ctx,args);\r\n            });\r\n            rets.push(p);\r\n        });\r\n\r\n        return Deferred.all(rets);\r\n    }\r\n\r\n\treturn async.series = series;\r\n});\ndefine('skylark-langx-async/waterful',[\r\n    \"skylark-langx-objects\",\r\n    \"./async\",\r\n    \"./deferred\"\r\n],function(objects,async,Deferred){\r\n    function waterful(arr,args,ctx) {\r\n        var d = new Deferred(),\r\n            p = d.promise;\r\n\r\n        ctx = ctx || null;\r\n        args = args || [];\r\n\r\n        d.resolveWith(ctx,args);\r\n\r\n        objects.each(arr,function(i,func){\r\n            p = p.then(func);\r\n        });\r\n        return p;\r\n    }\r\n\r\n\treturn async.waterful = waterful;\r\n});\ndefine('skylark-langx-async/main',[\r\n\t\"./async\",\r\n\t\"./deferred\",\r\n\t\"./each\",\r\n\t\"./parallel\",\r\n\t\"./series\",\r\n\t\"./waterful\"\r\n],function(async){\r\n\treturn async;\r\n});\ndefine('skylark-langx-async', ['skylark-langx-async/main'], function (main) { return main; });\n\ndefine('skylark-langx/async',[\r\n    \"skylark-langx-async\"\r\n],function(async){\r\n    return async;\r\n});\ndefine('skylark-langx-binary/binary',[\r\n  \"skylark-langx-ns\",\r\n],function(skylark){\r\n\t\"use strict\";\r\n\r\n\r\n\t/**\r\n\t * Create arraybuffer from binary string\r\n\t *\r\n\t * @method fromBinaryString\r\n\t * @param {String} str\r\n\t * @return {Arraybuffer} data\r\n\t */\r\n\tfunction fromBinaryString(str) {\r\n\t\tvar length = str.length;\r\n\t\tvar arraybuffer = new ArrayBuffer(length);\r\n\t\tvar view = new Uint8Array(arraybuffer);\r\n\r\n\t\tfor(var i = 0; i < length; i++)\r\n\t\t{\r\n\t\t\tview[i] = str.charCodeAt(i);\r\n\t\t}\r\n\r\n\t\treturn arraybuffer;\r\n\t}\r\n\r\n\t/**\r\n\t * Create arraybuffer from base64 string\r\n\t *\r\n\t * @method fromBase64\r\n\t * @param {String} base64\r\n\t * @return {Arraybuffer} data\r\n\t */\r\n\tfunction fromBase64(str){\r\n\t\tvar encoding = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n\t\tvar length = str.length / 4 * 3;\r\n\t\tvar arraybuffer = new ArrayBuffer(length);\r\n\t\tvar view = new Uint8Array(arraybuffer);\r\n\r\n\t\tvar a, b, c, d;\r\n\r\n\t\tfor(var i = 0, j = 0; i < length; i += 3)\r\n\t\t{\r\n\t\t\ta = encoding.indexOf(str.charAt(j++));\r\n\t\t\tb = encoding.indexOf(str.charAt(j++));\r\n\t\t\tc = encoding.indexOf(str.charAt(j++));\r\n\t\t\td = encoding.indexOf(str.charAt(j++));\r\n\r\n\t\t\tview[i] = (a << 2) | (b >> 4);\r\n\t\t\tif(c !== 64)\r\n\t\t\t{\r\n\t\t\t\tview[i+1] = ((b & 15) << 4) | (c >> 2);\r\n\t\t\t}\r\n\t\t\tif(d !== 64)\r\n\t\t\t{\r\n\t\t\t\tview[i+2] = ((c & 3) << 6) | d;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn arraybuffer;\r\n\t}\r\n\r\n\t/**\r\n\t * Create arraybuffer from Nodejs buffer\r\n\t *\r\n\t * @method fromBuffer\r\n\t * @param {Buffer} buffer\r\n\t * @return {Arraybuffer} data\r\n\t */\r\n\tfunction fromBuffer(buffer)\t{\r\n\t\tvar array = new ArrayBuffer(buffer.length);\r\n\t\tvar view = new Uint8Array(array);\r\n\r\n\t\tfor(var i = 0; i < buffer.length; i++)\r\n\t\t{\r\n\t\t\tview[i] = buffer[i];\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\r\n\t\t//Faster but the results is failing the \"instanceof ArrayBuffer\" test\r\n\t\t//return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\r\n\t}\r\n\r\n    function readInt8(data, offset) {\r\n        return data[offset] << 24 >> 24;\r\n    }\r\n    function readUint16(data, offset) {\r\n        return data[offset] << 8 | data[offset + 1];\r\n    }\r\n    function readUint32(data, offset) {\r\n        return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;\r\n    }\r\n\r\n\r\n\treturn skylark.attach(\"langx.binary\",{\r\n\t\tfromBase64,\r\n\t\tfromBinaryString,\r\n\t\tfromBuffer,\r\n\t\treadInt8,\r\n\t\treadUint16,\r\n\t\treadUint32\r\n\t});\r\n});\ndefine('skylark-langx-binary/main',[\r\n\t\"./binary\"\r\n],function(binary){\r\n\treturn binary;\r\n});\ndefine('skylark-langx-binary', ['skylark-langx-binary/main'], function (main) { return main; });\n\ndefine('skylark-langx/binary',[\r\n\t\"skylark-langx-binary\"\r\n],function(binary){\r\n  return binary;\r\n});\ndefine('skylark-langx/constructs',[\r\n\t\"skylark-langx-constructs\"\r\n],function(constructs){\r\n  return constructs;\r\n});\ndefine('skylark-langx-datetimes/datetimes',[\r\n    \"skylark-langx-ns\"\r\n],function(skylark){\r\n     function parseMilliSeconds(str) {\r\n\r\n        var strs = str.split(' ');\r\n        var number = parseInt(strs[0]);\r\n\r\n        if (isNaN(number)){\r\n            return 0;\r\n        }\r\n\r\n        var min = 60000 * 60;\r\n\r\n        switch (strs[1].trim().replace(/\\./g, '')) {\r\n            case 'minutes':\r\n            case 'minute':\r\n            case 'min':\r\n            case 'mm':\r\n            case 'm':\r\n                return 60000 * number;\r\n            case 'hours':\r\n            case 'hour':\r\n            case 'HH':\r\n            case 'hh':\r\n            case 'h':\r\n            case 'H':\r\n                return min * number;\r\n            case 'seconds':\r\n            case 'second':\r\n            case 'sec':\r\n            case 'ss':\r\n            case 's':\r\n                return 1000 * number;\r\n            case 'days':\r\n            case 'day':\r\n            case 'DD':\r\n            case 'dd':\r\n            case 'd':\r\n                return (min * 24) * number;\r\n            case 'months':\r\n            case 'month':\r\n            case 'MM':\r\n            case 'M':\r\n                return (min * 24 * 28) * number;\r\n            case 'weeks':\r\n            case 'week':\r\n            case 'W':\r\n            case 'w':\r\n                return (min * 24 * 7) * number;\r\n            case 'years':\r\n            case 'year':\r\n            case 'yyyy':\r\n            case 'yy':\r\n            case 'y':\r\n                return (min * 24 * 365) * number;\r\n            default:\r\n                return 0;\r\n        }\r\n    };\r\n\t\r\n\treturn skylark.attach(\"langx.datetimes\",{\r\n\t\tparseMilliSeconds\r\n\t});\r\n});\ndefine('skylark-langx-datetimes/to_date',[\r\n\t\"skylark-langx-types\",\r\n    \"./datetimes\"\r\n],function(types,datetimes){\r\n\r\n//original :pdf.js-2.7.750/src/display/display_utils.js\r\n\r\n  /**\r\nclass PDFDateString {\r\n   * Convert a PDF date string to a JavaScript `Date` object.\r\n   *\r\n   * The PDF date string format is described in section 7.9.4 of the official\r\n   * PDF 32000-1:2008 specification. However, in the PDF 1.7 reference (sixth\r\n   * edition) Adobe describes the same format including a trailing apostrophe.\r\n   * This syntax in incorrect, but Adobe Acrobat creates PDF files that contain\r\n   * them. We ignore all apostrophes as they are not necessary for date parsing.\r\n   *\r\n   * Moreover, Adobe Acrobat doesn't handle changing the date to universal time\r\n   * and doesn't use the user's time zone (effectively ignoring the HH' and mm'\r\n   * parts of the date string).\r\n   *\r\n   * @param {string} input\r\n   * @returns {Date|null}\r\n   *\r\n  static toDateObject(input) {\r\n   **/\r\n\r\n\r\n\tlet pdfDateStringRegex;\r\n\r\n\tfunction toDate(input) {\r\n    if (!input || !types.isString(input)) {\r\n      return null;\r\n    }\r\n\r\n    // Lazily initialize the regular expression.\r\n    if (!pdfDateStringRegex) {\r\n      pdfDateStringRegex = new RegExp(\r\n        \"^D:\" + // Prefix (required)\r\n          \"(\\\\d{4})\" + // Year (required)\r\n          \"(\\\\d{2})?\" + // Month (optional)\r\n          \"(\\\\d{2})?\" + // Day (optional)\r\n          \"(\\\\d{2})?\" + // Hour (optional)\r\n          \"(\\\\d{2})?\" + // Minute (optional)\r\n          \"(\\\\d{2})?\" + // Second (optional)\r\n          \"([Z|+|-])?\" + // Universal time relation (optional)\r\n          \"(\\\\d{2})?\" + // Offset hour (optional)\r\n          \"'?\" + // Splitting apostrophe (optional)\r\n          \"(\\\\d{2})?\" + // Offset minute (optional)\r\n          \"'?\" // Trailing apostrophe (optional)\r\n      );\r\n    }\r\n\r\n    // Optional fields that don't satisfy the requirements from the regular\r\n    // expression (such as incorrect digit counts or numbers that are out of\r\n    // range) will fall back the defaults from the specification.\r\n    const matches = pdfDateStringRegex.exec(input);\r\n    if (!matches) {\r\n      return null;\r\n    }\r\n\r\n    // JavaScript's `Date` object expects the month to be between 0 and 11\r\n    // instead of 1 and 12, so we have to correct for that.\r\n    const year = parseInt(matches[1], 10);\r\n    let month = parseInt(matches[2], 10);\r\n    month = month >= 1 && month <= 12 ? month - 1 : 0;\r\n    let day = parseInt(matches[3], 10);\r\n    day = day >= 1 && day <= 31 ? day : 1;\r\n    let hour = parseInt(matches[4], 10);\r\n    hour = hour >= 0 && hour <= 23 ? hour : 0;\r\n    let minute = parseInt(matches[5], 10);\r\n    minute = minute >= 0 && minute <= 59 ? minute : 0;\r\n    let second = parseInt(matches[6], 10);\r\n    second = second >= 0 && second <= 59 ? second : 0;\r\n    const universalTimeRelation = matches[7] || \"Z\";\r\n    let offsetHour = parseInt(matches[8], 10);\r\n    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\r\n    let offsetMinute = parseInt(matches[9], 10) || 0;\r\n    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\r\n\r\n    // Universal time relation 'Z' means that the local time is equal to the\r\n    // universal time, whereas the relations '+'/'-' indicate that the local\r\n    // time is later respectively earlier than the universal time. Every date\r\n    // is normalized to universal time.\r\n    if (universalTimeRelation === \"-\") {\r\n      hour += offsetHour;\r\n      minute += offsetMinute;\r\n    } else if (universalTimeRelation === \"+\") {\r\n      hour -= offsetHour;\r\n      minute -= offsetMinute;\r\n    }\r\n\r\n    return new Date(Date.UTC(year, month, day, hour, minute, second));\r\n  }\r\n\r\n  return datetimes.toDate = toDate;\r\n\r\n});\ndefine('skylark-langx-datetimes/main',[\r\n\t\"./datetimes\",\r\n\t\"./to_date\"\r\n],function(datetimes){\r\n\treturn datetimes;\r\n});\ndefine('skylark-langx-datetimes', ['skylark-langx-datetimes/main'], function (main) { return main; });\n\ndefine('skylark-langx/datetimes',[\r\n    \"skylark-langx-datetimes\"\r\n],function(datetimes){\r\n    return datetimes;\r\n});\ndefine('skylark-langx/deferred',[\r\n    \"skylark-langx-async\"\r\n],function(async){\r\n    return async.Deferred;\r\n});\ndefine('skylark-langx-events/events',[\r\n\t\"skylark-langx-ns\"\r\n],function(skylark){\r\n\treturn skylark.attach(\"langx.events\",{});\r\n});\ndefine('skylark-langx-hoster/hoster',[\r\n    \"skylark-langx-ns\"\r\n],function(skylark){\r\n\t// The javascript host environment, brower and nodejs are supported.\r\n\tvar hoster = {\r\n\t\t\"isBrowser\" : true, // default\r\n\t\t\"isNode\" : null,\r\n\t\t\"global\" : this,\r\n\t\t\"browser\" : null,\r\n\t\t\"node\" : null\r\n\t};\r\n\r\n\tif (typeof process == \"object\" && process.versions && process.versions.node && process.versions.v8) {\r\n\t\thoster.isNode = true;\r\n\t\thoster.isBrowser = false;\r\n\t}\r\n\r\n\thoster.global = (function(){\r\n\t\tif (typeof global !== 'undefined' && typeof global !== 'function') {\r\n\t\t\t// global spec defines a reference to the global object called 'global'\r\n\t\t\t// https://github.com/tc39/proposal-global\r\n\t\t\t// `global` is also defined in NodeJS\r\n\t\t\treturn global;\r\n\t\t} else if (typeof window !== 'undefined') {\r\n\t\t\t// window is defined in browsers\r\n\t\t\treturn window;\r\n\t\t}\r\n\t\telse if (typeof self !== 'undefined') {\r\n\t\t\t// self is defined in WebWorkers\r\n\t\t\treturn self;\r\n\t\t}\r\n\t\treturn this;\r\n\t})();\r\n\r\n\tvar _document = null;\r\n\r\n\tObject.defineProperty(hoster,\"document\",function(){\r\n\t\tif (!_document) {\r\n\t\t\tvar w = typeof window === 'undefined' ? require('html-element') : window;\r\n\t\t\t_document = w.document;\r\n\t\t}\r\n\r\n\t\treturn _document;\r\n\t});\r\n\r\n\tif (hoster.global.CustomEvent === undefined) {\r\n\t\thoster.global.CustomEvent = function(type,props) {\r\n\t\t\tthis.type = type;\r\n\t\t\tthis.props = props;\r\n\t\t};\r\n\t}\r\n\r\n\tif (hoster.isBrowser) {\r\n\t    function uaMatch( ua ) {\r\n\t\t    ua = ua.toLowerCase();\r\n\r\n\t\t\t//IE11OrLess = !!navigator.userAgent.match(/(?:Trident.*rv[ :]?11\\.|msie|iemobile)/i),\r\n\t\t\t//Edge = !!navigator.userAgent.match(/Edge/i),\r\n\t\t\t//FireFox = !!navigator.userAgent.match(/firefox/i),\r\n\t\t\t//Safari = !!(navigator.userAgent.match(/safari/i) && !navigator.userAgent.match(/chrome/i) && !navigator.userAgent.match(/android/i)),\r\n\t\t\t//IOS = !!(navigator.userAgent.match(/iP(ad|od|hone)/i)),\r\n\r\n\t\t    var match = /(chrome)[ \\/]([\\w.]+)/.exec( ua ) ||\r\n\t\t      /(webkit)[ \\/]([\\w.]+)/.exec( ua ) ||\r\n\t\t      /(opera)(?:.*version|)[ \\/]([\\w.]+)/.exec( ua ) ||\r\n\t\t      /(msie) ([\\w.]+)/.exec( ua ) ||\r\n\t\t      ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\\w.]+)|)/.exec( ua ) ||\r\n\t\t      [];\r\n\r\n\t\t    return {\r\n\t\t      browser: match[ 1 ] || '',\r\n\t\t      version: match[ 2 ] || '0'\r\n\t\t    };\r\n\t  \t};\r\n\r\n\t    var matched = uaMatch( navigator.userAgent );\r\n\r\n\t    var browser = hoster.browser = {};\r\n\r\n\t    if ( matched.browser ) {\r\n\t      browser[ matched.browser ] = true;\r\n\t      browser.version = matched.version;\r\n\t    }\r\n\r\n\t    // Chrome is Webkit, but Webkit is also Safari.\r\n\t    if ( browser.chrome ) {\r\n\t      browser.webkit = true;\r\n\t    } else if ( browser.webkit ) {\r\n\t      browser.safari = true;\r\n\t    }\r\n\t}\r\n\r\n\thoster.detects = {};\r\n\r\n\treturn  skylark.attach(\"langx.hoster\",hoster);\r\n});\ndefine('skylark-langx-hoster/detects/mobile',[\r\n    \"../hoster\"\r\n],function(hoster){\r\n    //refer : https://github.com/kaimallea/isMobile\r\n\r\n    var appleIphone = /iPhone/i;\r\n    var appleIpod = /iPod/i;\r\n    var appleTablet = /iPad/i;\r\n    var appleUniversal = /\\biOS-universal(?:.+)Mac\\b/i;\r\n    var androidPhone = /\\bAndroid(?:.+)Mobile\\b/i;\r\n    var androidTablet = /Android/i;\r\n    var amazonPhone = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i;\r\n    var amazonTablet = /Silk/i;\r\n    var windowsPhone = /Windows Phone/i;\r\n    var windowsTablet = /\\bWindows(?:.+)ARM\\b/i;\r\n    var otherBlackBerry = /BlackBerry/i;\r\n    var otherBlackBerry10 = /BB10/i;\r\n    var otherOpera = /Opera Mini/i;\r\n    var otherChrome = /\\b(CriOS|Chrome)(?:.+)Mobile/i;\r\n    var otherFirefox = /Mobile(?:.+)Firefox\\b/i;\r\n    var isAppleTabletOnIos13 = function (navigator) {\r\n        return (typeof navigator !== 'undefined' &&\r\n            navigator.platform === 'MacIntel' &&\r\n            typeof navigator.maxTouchPoints === 'number' &&\r\n            navigator.maxTouchPoints > 1 &&\r\n            typeof MSStream === 'undefined');\r\n    };\r\n    function createMatch(userAgent) {\r\n        return function (regex) { return regex.test(userAgent); };\r\n    }\r\n    \r\n    function detectMobile(param) {\r\n        var nav = {\r\n            userAgent: '',\r\n            platform: '',\r\n            maxTouchPoints: 0\r\n        };\r\n        if (!param && typeof navigator !== 'undefined') {\r\n            nav = {\r\n                userAgent: navigator.userAgent,\r\n                platform: navigator.platform,\r\n                maxTouchPoints: navigator.maxTouchPoints || 0\r\n            };\r\n        }\r\n        else if (typeof param === 'string') {\r\n            nav.userAgent = param;\r\n        }\r\n        else if (param && param.userAgent) {\r\n            nav = {\r\n                userAgent: param.userAgent,\r\n                platform: param.platform,\r\n                maxTouchPoints: param.maxTouchPoints || 0\r\n            };\r\n        }\r\n        var userAgent = nav.userAgent;\r\n        var tmp = userAgent.split('[FBAN');\r\n        if (typeof tmp[1] !== 'undefined') {\r\n            userAgent = tmp[0];\r\n        }\r\n        tmp = userAgent.split('Twitter');\r\n        if (typeof tmp[1] !== 'undefined') {\r\n            userAgent = tmp[0];\r\n        }\r\n        var match = createMatch(userAgent);\r\n        var result = {\r\n            apple: {\r\n                phone: match(appleIphone) && !match(windowsPhone),\r\n                ipod: match(appleIpod),\r\n                tablet: !match(appleIphone) &&\r\n                    (match(appleTablet) || isAppleTabletOnIos13(nav)) &&\r\n                    !match(windowsPhone),\r\n                universal: match(appleUniversal),\r\n                device: (match(appleIphone) ||\r\n                    match(appleIpod) ||\r\n                    match(appleTablet) ||\r\n                    match(appleUniversal) ||\r\n                    isAppleTabletOnIos13(nav)) &&\r\n                    !match(windowsPhone)\r\n            },\r\n            amazon: {\r\n                phone: match(amazonPhone),\r\n                tablet: !match(amazonPhone) && match(amazonTablet),\r\n                device: match(amazonPhone) || match(amazonTablet)\r\n            },\r\n            android: {\r\n                phone: (!match(windowsPhone) && match(amazonPhone)) ||\r\n                    (!match(windowsPhone) && match(androidPhone)),\r\n                tablet: !match(windowsPhone) &&\r\n                    !match(amazonPhone) &&\r\n                    !match(androidPhone) &&\r\n                    (match(amazonTablet) || match(androidTablet)),\r\n                device: (!match(windowsPhone) &&\r\n                    (match(amazonPhone) ||\r\n                        match(amazonTablet) ||\r\n                        match(androidPhone) ||\r\n                        match(androidTablet))) ||\r\n                    match(/\\bokhttp\\b/i)\r\n            },\r\n            windows: {\r\n                phone: match(windowsPhone),\r\n                tablet: match(windowsTablet),\r\n                device: match(windowsPhone) || match(windowsTablet)\r\n            },\r\n            other: {\r\n                blackberry: match(otherBlackBerry),\r\n                blackberry10: match(otherBlackBerry10),\r\n                opera: match(otherOpera),\r\n                firefox: match(otherFirefox),\r\n                chrome: match(otherChrome),\r\n                device: match(otherBlackBerry) ||\r\n                    match(otherBlackBerry10) ||\r\n                    match(otherOpera) ||\r\n                    match(otherFirefox) ||\r\n                    match(otherChrome)\r\n            },\r\n            any: false,\r\n            phone: false,\r\n            tablet: false\r\n        };\r\n        result.any =\r\n            result.apple.device ||\r\n                result.android.device ||\r\n                result.windows.device ||\r\n                result.other.device;\r\n        result.phone =\r\n            result.apple.phone || result.android.phone || result.windows.phone;\r\n        result.tablet =\r\n            result.apple.tablet || result.android.tablet || result.windows.tablet;\r\n        return result;\r\n    }\r\n\r\n    return hoster.detects.mobile = detectMobile;\r\n});\r\n\ndefine('skylark-langx-hoster/is-mobile',[\r\n    \"./hoster\",\r\n    \"./detects/mobile\"\r\n],function(hoster,detectMobile){\r\n    if (hoster.isMobile == undefined) {\r\n        hoster.isMobile = detectMobile();\r\n    }\r\n\r\n    return hoster.isMobile;\r\n});\r\n\ndefine('skylark-langx-hoster/main',[\r\n\t\"./hoster\",\r\n\t\"./is-mobile\"\r\n],function(hoster){\r\n\treturn hoster;\r\n});\ndefine('skylark-langx-hoster', ['skylark-langx-hoster/main'], function (main) { return main; });\n\ndefine('skylark-langx-events/event',[\r\n  \"skylark-langx-objects\",\r\n  \"skylark-langx-funcs\",\r\n  \"skylark-langx-klass\",\r\n  \"skylark-langx-hoster\",\r\n    \"./events\"\r\n],function(objects,funcs,klass,events){\r\n    var eventMethods = {\r\n        preventDefault: \"isDefaultPrevented\",\r\n        stopImmediatePropagation: \"isImmediatePropagationStopped\",\r\n        stopPropagation: \"isPropagationStopped\"\r\n     };\r\n        \r\n\r\n    function compatible(event, source) {\r\n        if (source || !event.isDefaultPrevented) {\r\n            if (!source) {\r\n                source = event;\r\n            }\r\n\r\n            objects.each(eventMethods, function(name, predicate) {\r\n                var sourceMethod = source[name];\r\n                event[name] = function() {\r\n                    this[predicate] = funcs.returnTrue;\r\n                    return sourceMethod && sourceMethod.apply(source, arguments);\r\n                }\r\n                event[predicate] = funcs.returnFalse;\r\n            });\r\n        }\r\n        return event;\r\n    }\r\n\r\n\r\n    /*\r\n    var Event = klass({\r\n        _construct : function(type,props) {\r\n            CustomEvent.call(this,type.props);\r\n            objects.safeMixin(this, props);\r\n            compatible(this);\r\n        }\r\n    },CustomEvent);\r\n    */\r\n\r\n    class Event extends CustomEvent {\r\n        constructor(type,props) {\r\n            super(type,props);\r\n            objects.safeMixin(this, props);\r\n            compatible(this);\r\n        } \r\n    }\r\n\r\n\r\n    Event.compatible = compatible;\r\n\r\n    return events.Event = Event;\r\n    \r\n});\ndefine('skylark-langx-events/listener',[\r\n  \"skylark-langx-types\",\r\n  \"skylark-langx-objects\",\r\n  \"skylark-langx-arrays\",\r\n  \"skylark-langx-klass\",\r\n  \"./events\",\r\n  \"./event\"\r\n],function(types,objects,arrays,klass,events,Event){\r\n    var slice = Array.prototype.slice,\r\n        compact = arrays.compact,\r\n        isDefined = types.isDefined,\r\n        isUndefined = types.isUndefined,\r\n        isPlainObject = types.isPlainObject,\r\n        isFunction = types.isFunction,\r\n        isBoolean = types.isBoolean,\r\n        isString = types.isString,\r\n        isEmptyObject = types.isEmptyObject,\r\n        mixin = objects.mixin,\r\n        safeMixin = objects.safeMixin;\r\n\r\n\r\n    var Listener = klass({\r\n\r\n        listenTo: function(obj, event, selector,callback, /*used internally*/ one) {\r\n            if (!obj) {\r\n                return this;\r\n            }\r\n\r\n            if (types.isPlainObject(event)){\r\n                //listenTo(obj,callbacks,one)\r\n                if (types.isBoolean(selector)) {\r\n                    one = selector;\r\n                    selector = null;\r\n                } else if (types.isBoolean(callback)) {\r\n                    one = callback;\r\n                }\r\n                var callbacks = event;\r\n                for (var name in callbacks) {\r\n\r\n                    var match = name.match( /^([\\w:-]*)\\s*(.*)$/ );\r\n                    var name1 = match[ 1 ];\r\n                    var selector1 = match[ 2 ] || selector;\r\n\r\n                    if (selector1) {\r\n                        this.listenTo(obj,name1,selector1,callbacks[name],one);\r\n                    } else {\r\n                        this.listenTo(obj,name1,callbacks[name],one);\r\n                    }\r\n\r\n                }\r\n                return this;\r\n            }\r\n\r\n            if (isBoolean(callback)) {\r\n                one = callback;\r\n                callback = selector;\r\n                selector = null;\r\n            } else if (isBoolean(selector)) {\r\n                one = selector;\r\n                callback = selector = null;\r\n            } else if (isUndefined(callback)){\r\n                one = false;\r\n                callback = selector;\r\n                selector = null;\r\n            }\r\n\r\n\r\n\r\n            if (!callback) {\r\n                callback = \"handleEvent\";\r\n            }\r\n            \r\n            // Bind callbacks on obj,\r\n            if (isString(callback)) {\r\n                callback = this[callback];\r\n            }\r\n\r\n            if (one) {\r\n                if (selector) {\r\n                    obj.one(event, selector,callback, this);\r\n                } else {\r\n                    obj.one(event, callback, this);\r\n                }\r\n            } else {\r\n                 if (selector) {\r\n                    obj.on(event, selector, callback, this);\r\n                } else {\r\n                    obj.on(event, callback, this);\r\n                }\r\n            }\r\n\r\n            //keep track of them on listening.\r\n            var listeningTo = this._listeningTo || (this._listeningTo = []),\r\n                listening;\r\n\r\n            for (var i = 0; i < listeningTo.length; i++) {\r\n                if (listeningTo[i].obj == obj) {\r\n                    listening = listeningTo[i];\r\n                    break;\r\n                }\r\n            }\r\n            if (!listening) {\r\n                listeningTo.push(\r\n                    listening = {\r\n                        obj: obj,\r\n                        events: {}\r\n                    }\r\n                );\r\n            }\r\n            var listeningEvents = listening.events,\r\n                listeningEvent = listeningEvents[event] = listeningEvents[event] || [];\r\n            if (listeningEvent.indexOf(callback) == -1) {\r\n                listeningEvent.push(callback);\r\n            }\r\n\r\n            return this;\r\n        },\r\n\r\n        listenToOnce: function(obj, event,selector, callback) {\r\n            return this.listenTo(obj, event,selector, callback, 1);\r\n        },\r\n\r\n        unlistenTo: function(obj, event, callback) {\r\n            var listeningTo = this._listeningTo;\r\n            if (!listeningTo) {\r\n                return this;\r\n            }\r\n\r\n            if (isString(callback)) {\r\n                callback = this[callback];\r\n            }\r\n\r\n            for (var i = 0; i < listeningTo.length; i++) {\r\n                var listening = listeningTo[i];\r\n\r\n                if (obj && obj != listening.obj) {\r\n                    continue;\r\n                }\r\n\r\n                var listeningEvents = listening.events;\r\n\r\n                for (var eventName in listeningEvents) {\r\n                    if (event && event != eventName) {\r\n                        continue;\r\n                    }\r\n\r\n                    var listeningEvent = listeningEvents[eventName];\r\n\r\n                    if (!listeningEvent) { \r\n                        continue;\r\n                    }\r\n\r\n                    for (var j = 0; j < listeningEvent.length; j++) {\r\n                        if (!callback || callback == listeningEvent[i]) {\r\n                            listening.obj.off(eventName, listeningEvent[i], this);\r\n                            listeningEvent[i] = null;\r\n                        }\r\n                    }\r\n\r\n                    listeningEvent = listeningEvents[eventName] = compact(listeningEvent);\r\n\r\n                    if (isEmptyObject(listeningEvent)) {\r\n                        listeningEvents[eventName] = null;\r\n                    }\r\n\r\n                }\r\n\r\n                if (isEmptyObject(listeningEvents)) {\r\n                    listeningTo[i] = null;\r\n                }\r\n            }\r\n\r\n            listeningTo = this._listeningTo = compact(listeningTo);\r\n            if (isEmptyObject(listeningTo)) {\r\n                this._listeningTo = null;\r\n            }\r\n\r\n            return this;\r\n        }\r\n    });\r\n\r\n    return events.Listener = Listener;\r\n\r\n});\ndefine('skylark-langx-events/emitter',[\r\n  \"skylark-langx-types\",\r\n  \"skylark-langx-objects\",\r\n  \"skylark-langx-arrays\",\r\n  \"skylark-langx-klass\",\r\n  \"./events\",\r\n  \"./event\",\r\n  \"./listener\"\r\n],function(types,objects,arrays,klass,events,Event,Listener){\r\n    var slice = Array.prototype.slice,\r\n        compact = arrays.compact,\r\n        isDefined = types.isDefined,\r\n        isPlainObject = types.isPlainObject,\r\n        isFunction = types.isFunction,\r\n        isString = types.isString,\r\n        isEmptyObject = types.isEmptyObject,\r\n        mixin = objects.mixin,\r\n        safeMixin = objects.safeMixin;\r\n\r\n    function parse(event) {\r\n        var segs = (\"\" + event).split(\".\");\r\n        return {\r\n            name: segs[0],\r\n            ns: segs.slice(1).join(\" \")\r\n        };\r\n    }\r\n\r\n    \r\n    var queues  = new Map();\r\n\r\n\r\n    var Emitter = Listener.inherit({\r\n        _prepareArgs : function(e,args) {\r\n            if (isDefined(args)) {\r\n                args = [e].concat(args);\r\n            } else {\r\n                args = [e];\r\n            }\r\n            return args;\r\n        },\r\n\r\n        on: function(events, selector, data, callback, ctx, /*used internally*/ one) {\r\n            var self = this,\r\n                _hub = this._hub || (this._hub = {});\r\n\r\n            if (isPlainObject(events)) {\r\n                ctx = callback;\r\n                each(events, function(type, fn) {\r\n                    self.on(type, selector, data, fn, ctx, one);\r\n                });\r\n                return this;\r\n            }\r\n\r\n            if (!isString(selector) && !isFunction(callback)) {\r\n                ctx = callback;\r\n                callback = data;\r\n                data = selector;\r\n                selector = undefined;\r\n            }\r\n\r\n            if (isFunction(data)) {\r\n                ctx = callback;\r\n                callback = data;\r\n                data = null;\r\n            }\r\n\r\n            if (!callback ) {\r\n                throw new Error(\"No callback function\");\r\n            } else if (!isFunction(callback)) {\r\n                throw new Error(\"The callback  is not afunction\");\r\n            }\r\n\r\n            if (isString(events)) {\r\n                events = events.split(/\\s/)\r\n            }\r\n\r\n            events.forEach(function(event) {\r\n                var parsed = parse(event),\r\n                    name = parsed.name,\r\n                    ns = parsed.ns;\r\n\r\n                (_hub[name] || (_hub[name] = [])).push({\r\n                    fn: callback,\r\n                    selector: selector,\r\n                    data: data,\r\n                    ctx: ctx,\r\n                    ns : ns,\r\n                    one: one\r\n                });\r\n            });\r\n\r\n            return this;\r\n        },\r\n\r\n        one: function(events, selector, data, callback, ctx) {\r\n            return this.on(events, selector, data, callback, ctx, 1);\r\n        },\r\n\r\n        emit: function(e /*,argument list*/ ) {\r\n            if (!this._hub) {\r\n                return this;\r\n            }\r\n\r\n            var self = this;\r\n\r\n            if (isString(e)) {\r\n                e = new Event(e); //new CustomEvent(e);\r\n            }\r\n\r\n            Object.defineProperty(e,\"target\",{\r\n                value : this\r\n            });\r\n\r\n            var args = slice.call(arguments, 1);\r\n\r\n            args = this._prepareArgs(e,args);\r\n\r\n            [e.type || e.name, \"all\"].forEach(function(eventName) {\r\n                var parsed = parse(eventName),\r\n                    name = parsed.name,\r\n                    ns = parsed.ns;\r\n\r\n                var listeners = self._hub[name];\r\n                if (!listeners) {\r\n                    return;\r\n                }\r\n\r\n                var len = listeners.length,\r\n                    reCompact = false;\r\n\r\n                for (var i = 0; i < len; i++) {\r\n                    if (e.isImmediatePropagationStopped && e.isImmediatePropagationStopped()) {\r\n                        return this;\r\n                    }\r\n                    var listener = listeners[i];\r\n                    if (ns && (!listener.ns ||  !listener.ns.startsWith(ns))) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (listener.data) {\r\n                        e.data = mixin({}, listener.data, e.data);\r\n                    }\r\n                    if (args.length == 2 && isPlainObject(args[1])) {\r\n                        e.data = e.data || {};\r\n                        mixin(e.data,args[1]);\r\n                    }\r\n\r\n                    listener.fn.apply(listener.ctx, args);\r\n                    if (listener.one) {\r\n                        listeners[i] = null;\r\n                        reCompact = true;\r\n                    }\r\n                }\r\n\r\n                if (reCompact) {\r\n                    self._hub[eventName] = compact(listeners);\r\n                }\r\n\r\n            });\r\n            return this;\r\n        },\r\n\r\n        queueEmit : function (event) {\r\n            const type = event.type || event;\r\n            let map = queues.get(this);\r\n            if (!map) {\r\n                map = new Map();\r\n                queues.set(this, map);\r\n            }\r\n            const oldTimeout = map.get(type);\r\n            map.delete(type);\r\n            window.clearTimeout(oldTimeout);\r\n            const timeout = window.setTimeout(() => {\r\n                if (map.size === 0) {\r\n                    map = null;\r\n                    queues.delete(this);\r\n                }\r\n                this.trigger(event);\r\n            }, 0);\r\n            map.set(type, timeout);\r\n        },\r\n\r\n        listened: function(event) {\r\n            var evtArr = ((this._hub || (this._events = {}))[event] || []);\r\n            return evtArr.length > 0;\r\n        },\r\n\r\n        off: function(events, callback) {\r\n            if (!events) {\r\n              this._hub = null;\r\n              return;\r\n            }\r\n            var _hub = this._hub || (this._hub = {});\r\n            if (isString(events)) {\r\n                events = events.split(/\\s/)\r\n            }\r\n\r\n            events.forEach(function(event) {\r\n                var parsed = parse(event),\r\n                    name = parsed.name,\r\n                    ns = parsed.ns;\r\n\r\n                var evts = _hub[name];\r\n\r\n                if (evts) {\r\n                    var liveEvents = [];\r\n\r\n                    if (callback || ns) {\r\n                        for (var i = 0, len = evts.length; i < len; i++) {\r\n                            \r\n                            if (callback && evts[i].fn !== callback && evts[i].fn._ !== callback) {\r\n                                liveEvents.push(evts[i]);\r\n                                continue;\r\n                            } \r\n\r\n                            if (ns && (!evts[i].ns || evts[i].ns.indexOf(ns)!=0)) {\r\n                                liveEvents.push(evts[i]);\r\n                                continue;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (liveEvents.length) {\r\n                        _hub[name] = liveEvents;\r\n                    } else {\r\n                        delete _hub[name];\r\n                    }\r\n\r\n                }\r\n            });\r\n\r\n            return this;\r\n        },\r\n\r\n        trigger  : function() {\r\n            return this.emit.apply(this,arguments);\r\n        },\r\n\r\n        queueTrigger : function (event) {\r\n            return this.queueEmit.apply(this,arguments);\r\n        }\r\n\r\n    });\r\n\r\n\r\n    return events.Emitter = Emitter;\r\n\r\n});\ndefine('skylark-langx-events/create-event',[\r\n\t\"./events\",\r\n\t\"./event\"\r\n],function(events,Event){\r\n    function createEvent(type,props) {\r\n        //var e = new CustomEvent(type,props);\r\n        //return safeMixin(e, props);\r\n        return new Event(type,props);\r\n    };\r\n\r\n    return events.createEvent = createEvent;\t\r\n});\ndefine('skylark-langx-events/main',[\r\n\t\"./events\",\r\n\t\"./event\",\r\n\t\"./listener\",\r\n\t\"./emitter\",\r\n\t\"./create-event\"\r\n],function(events){\r\n\treturn events;\r\n});\ndefine('skylark-langx-events', ['skylark-langx-events/main'], function (main) { return main; });\n\ndefine('skylark-langx/emitter',[\r\n    \"skylark-langx-events\"\r\n],function(events){\r\n    return events.Emitter;\r\n});\ndefine('skylark-langx/evented',[\r\n    \"./emitter\"\r\n],function(Emitter){\r\n    return Emitter;\r\n});\ndefine('skylark-langx/events',[\r\n\t\"skylark-langx-events\"\r\n],function(events){\r\n\treturn events;\r\n});\ndefine('skylark-langx/funcs',[\r\n    \"skylark-langx-funcs\"\r\n],function(funcs){\r\n    return funcs;\r\n});\ndefine('skylark-langx-globals/globals',[\r\n\t\"skylark-langx-ns\"\r\n],function(ns) {\r\n\tvar globals = (function(){\r\n\t\tif (typeof global !== 'undefined' && typeof global !== 'function') {\r\n\t\t\t// global spec defines a reference to the global object called 'global'\r\n\t\t\t// https://github.com/tc39/proposal-global\r\n\t\t\t// `global` is also defined in NodeJS\r\n\t\t\treturn global;\r\n\t\t} else if (typeof window !== 'undefined') {\r\n\t\t\t// window is defined in browsers\r\n\t\t\treturn window;\r\n\t\t}\r\n\t\telse if (typeof self !== 'undefined') {\r\n\t\t\t// self is defined in WebWorkers\r\n\t\t\treturn self;\r\n\t\t}\r\n\t\treturn this;\r\n\t})();\r\n\r\n\treturn ns.attach(\"langx.globals\",globals);\r\n\r\n});\ndefine('skylark-langx-globals/console',[\n\t\"./globals\"\n], function(globals) {\n\treturn globals.console = console;\n});\ndefine('skylark-langx-globals/document',[\n\t\"./globals\"\n], function(globals) {\n\tvar topLevel = typeof global !== 'undefined' ? global :\n\t    typeof window !== 'undefined' ? window : {};\n\n\tvar doccy;\n\n\tif (typeof document !== 'undefined') {\n\t    doccy = document;\n\t} else {\n        try {\n            doccy  = require('min-document');\n        } catch(e) {\n            console.warn(\"min-document is not finded!\",e);\n        }\n   \t}\n\n\n\treturn globals.document = doccy;\n});\n\n\n\n\ndefine('skylark-langx-globals/window',[\n\t\"./globals\"\n], function(globals) {\n\n\tvar win = (function() {\n\t\tif (typeof window !== \"undefined\") {\n\t\t    return window;\n\t\t} else {\n\t\t    return {};\n\t\t}\n\t})();\n\n\treturn globals.window = win;\n});\n\ndefine('skylark-langx-globals/main',[\r\n\t\"./globals\",\r\n\t\"./console\",\r\n\t\"./document\",\r\n\t\"./window\"\r\n],function(globals){\r\n\r\n\treturn globals;\r\n});\ndefine('skylark-langx-globals', ['skylark-langx-globals/main'], function (main) { return main; });\n\ndefine('skylark-langx/globals',[\r\n    \"skylark-langx-globals\"\r\n],function(globals){\r\n    return globals;\r\n});\ndefine('skylark-langx/hoster',[\r\n\t\"skylark-langx-hoster\"\r\n],function(hoster){\r\n\treturn hoster;\r\n});\ndefine('skylark-langx-maths/maths',[\n    \"skylark-langx-ns\",\n    \"skylark-langx-types\"\n],function(skylark,types){\n\n\n\tvar _lut = [];\n\n\tfor ( var i = 0; i < 256; i ++ ) {\n\n\t\t_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );\n\n\t}\n\n\tvar maths = {\n\n\t\tDEG2RAD: Math.PI / 180,\n\t\tRAD2DEG: 180 / Math.PI,\n\n\n\n\t\tclamp: function ( value, min, max ) {\n\n\t\t\treturn Math.max( min, Math.min( max, value ) );\n\n\t\t},\n\n\t\t// compute euclidian modulo of m % n\n\t\t// https://en.wikipedia.org/wiki/Modulo_operation\n\n\t\teuclideanModulo: function ( n, m ) {\n\n\t\t\treturn ( ( n % m ) + m ) % m;\n\n\t\t},\n\n\t\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\n\t\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\n\t\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n\t\t},\n\n\t\t// https://en.wikipedia.org/wiki/Linear_interpolation\n\n\t\tlerp: function ( x, y, t ) {\n\n\t\t\treturn ( 1 - t ) * x + t * y;\n\n\t\t},\n\n\t\t// http://en.wikipedia.org/wiki/Smoothstep\n\n\t\tsmoothstep: function ( x, min, max ) {\n\n\t\t\tif ( x <= min ) return 0;\n\t\t\tif ( x >= max ) return 1;\n\n\t\t\tx = ( x - min ) / ( max - min );\n\n\t\t\treturn x * x * ( 3 - 2 * x );\n\n\t\t},\n\n\t\tsmootherstep: function ( x, min, max ) {\n\n\t\t\tif ( x <= min ) return 0;\n\t\t\tif ( x >= max ) return 1;\n\n\t\t\tx = ( x - min ) / ( max - min );\n\n\t\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n\t\t},\n\n\t\t// Random integer from <low, high> interval\n\n\t\trandInt: function ( low, high ) {\n\n\t\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n\t\t},\n\n\t\t// Random float from <low, high> interval\n\n\t\trandFloat: function ( low, high ) {\n\n\t\t\treturn low + Math.random() * ( high - low );\n\n\t\t},\n\n\t\t// Random float from <-range/2, range/2> interval\n\n\t\trandFloatSpread: function ( range ) {\n\n\t\t\treturn range * ( 0.5 - Math.random() );\n\n\t\t},\n\n\t\tdegToRad: function ( degrees ) {\n\n\t\t\treturn degrees * maths.DEG2RAD;\n\n\t\t},\n\n\t\tradToDeg: function ( radians ) {\n\n\t\t\treturn radians * maths.RAD2DEG;\n\n\t\t},\n\n\t\tisPowerOfTwo: function ( value ) {\n\n\t\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n\t\t},\n\n\t\tceilPowerOfTwo: function ( value ) {\n\n\t\t\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\n\t\t},\n\n\t\tfloorPowerOfTwo: function ( value ) {\n\n\t\t\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\n\t\t},\n\n\t\tsetQuaternionFromProperEuler: function ( q, a, b, c, order ) {\n\n\t\t\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\n\t\t\t// rotations are applied to the axes in the order specified by 'order'\n\t\t\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n\t\t\t// angles are in radians\n\n\t\t\tvar cos = Math.cos;\n\t\t\tvar sin = Math.sin;\n\n\t\t\tvar c2 = cos( b / 2 );\n\t\t\tvar s2 = sin( b / 2 );\n\n\t\t\tvar c13 = cos( ( a + c ) / 2 );\n\t\t\tvar s13 = sin( ( a + c ) / 2 );\n\n\t\t\tvar c1_3 = cos( ( a - c ) / 2 );\n\t\t\tvar s1_3 = sin( ( a - c ) / 2 );\n\n\t\t\tvar c3_1 = cos( ( c - a ) / 2 );\n\t\t\tvar s3_1 = sin( ( c - a ) / 2 );\n\n\t\t\tif ( order === 'XYX' ) {\n\n\t\t\t\tq.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );\n\n\t\t\t} else if ( order === 'YZY' ) {\n\n\t\t\t\tq.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );\n\n\t\t\t} else if ( order === 'ZXZ' ) {\n\n\t\t\t\tq.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );\n\n\t\t\t} else if ( order === 'XZX' ) {\n\n\t\t\t\tq.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );\n\n\t\t\t} else if ( order === 'YXY' ) {\n\n\t\t\t\tq.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );\n\n\t\t\t} else if ( order === 'ZYZ' ) {\n\n\t\t\t\tq.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.' );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\n\n\treturn  skylark.attach(\"langx.maths\",maths);\n});\ndefine('skylark-langx-maths/main',[\n\t\"./maths\"\n],function(maths){\n\treturn maths;\n});\ndefine('skylark-langx-maths', ['skylark-langx-maths/main'], function (main) { return main; });\n\ndefine('skylark-langx/maths',[\r\n    \"skylark-langx-maths\"\r\n],function(maths){\r\n    return maths;\r\n});\ndefine('skylark-langx-numerics/numerics',[\r\n    \"skylark-langx-ns\",\r\n    \"skylark-langx-types\"\r\n],function(skylark,types){\r\n\r\n\treturn  skylark.attach(\"langx.numerics\",{\r\n\t\ttoFinite : types.toFinite,\r\n\t\ttoNumber : types.toNumber,\r\n\t\ttoInteger : types.toInteger\r\n\t});\r\n});\ndefine('skylark-langx-numerics/maths',[\r\n    \"skylark-langx-ns\",\r\n    \"skylark-langx-types\",\r\n    \"./numerics\"\r\n],function(skylark,types,numerics){\r\n\r\n\r\n\tvar _lut = [];\r\n\r\n\tfor ( var i = 0; i < 256; i ++ ) {\r\n\r\n\t\t_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );\r\n\r\n\t}\r\n\r\n\tvar maths = {\r\n\r\n\t\tDEG2RAD: Math.PI / 180,\r\n\t\tRAD2DEG: 180 / Math.PI,\r\n\r\n\r\n\r\n\t\tclamp: function ( value, min, max ) {\r\n\r\n\t\t\treturn Math.max( min, Math.min( max, value ) );\r\n\r\n\t\t},\r\n\r\n\t\t// compute euclidian modulo of m % n\r\n\t\t// https://en.wikipedia.org/wiki/Modulo_operation\r\n\r\n\t\teuclideanModulo: function ( n, m ) {\r\n\r\n\t\t\treturn ( ( n % m ) + m ) % m;\r\n\r\n\t\t},\r\n\r\n\t\t// Linear mapping from range <a1, a2> to range <b1, b2>\r\n\r\n\t\tmapLinear: function ( x, a1, a2, b1, b2 ) {\r\n\r\n\t\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\r\n\r\n\t\t},\r\n\r\n\t\t// https://en.wikipedia.org/wiki/Linear_interpolation\r\n\r\n\t\tlerp: function ( x, y, t ) {\r\n\r\n\t\t\treturn ( 1 - t ) * x + t * y;\r\n\r\n\t\t},\r\n\r\n\t\t// http://en.wikipedia.org/wiki/Smoothstep\r\n\r\n\t\tsmoothstep: function ( x, min, max ) {\r\n\r\n\t\t\tif ( x <= min ) return 0;\r\n\t\t\tif ( x >= max ) return 1;\r\n\r\n\t\t\tx = ( x - min ) / ( max - min );\r\n\r\n\t\t\treturn x * x * ( 3 - 2 * x );\r\n\r\n\t\t},\r\n\r\n\t\tsmootherstep: function ( x, min, max ) {\r\n\r\n\t\t\tif ( x <= min ) return 0;\r\n\t\t\tif ( x >= max ) return 1;\r\n\r\n\t\t\tx = ( x - min ) / ( max - min );\r\n\r\n\t\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\r\n\r\n\t\t},\r\n\r\n\t\t// Random integer from <low, high> interval\r\n\r\n\t\trandInt: function ( low, high ) {\r\n\r\n\t\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\r\n\r\n\t\t},\r\n\r\n\t\t// Random float from <low, high> interval\r\n\r\n\t\trandFloat: function ( low, high ) {\r\n\r\n\t\t\treturn low + Math.random() * ( high - low );\r\n\r\n\t\t},\r\n\r\n\t\t// Random float from <-range/2, range/2> interval\r\n\r\n\t\trandFloatSpread: function ( range ) {\r\n\r\n\t\t\treturn range * ( 0.5 - Math.random() );\r\n\r\n\t\t},\r\n\r\n\t\tdegToRad: function ( degrees ) {\r\n\r\n\t\t\treturn degrees * maths.DEG2RAD;\r\n\r\n\t\t},\r\n\r\n\t\tradToDeg: function ( radians ) {\r\n\r\n\t\t\treturn radians * maths.RAD2DEG;\r\n\r\n\t\t},\r\n\r\n\t\tisPowerOfTwo: function ( value ) {\r\n\r\n\t\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\r\n\r\n\t\t},\r\n\r\n\t\tceilPowerOfTwo: function ( value ) {\r\n\r\n\t\t\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\r\n\r\n\t\t},\r\n\r\n\t\tfloorPowerOfTwo: function ( value ) {\r\n\r\n\t\t\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\r\n\r\n\t\t},\r\n\r\n\t\tsetQuaternionFromProperEuler: function ( q, a, b, c, order ) {\r\n\r\n\t\t\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\r\n\r\n\t\t\t// rotations are applied to the axes in the order specified by 'order'\r\n\t\t\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\r\n\t\t\t// angles are in radians\r\n\r\n\t\t\tvar cos = Math.cos;\r\n\t\t\tvar sin = Math.sin;\r\n\r\n\t\t\tvar c2 = cos( b / 2 );\r\n\t\t\tvar s2 = sin( b / 2 );\r\n\r\n\t\t\tvar c13 = cos( ( a + c ) / 2 );\r\n\t\t\tvar s13 = sin( ( a + c ) / 2 );\r\n\r\n\t\t\tvar c1_3 = cos( ( a - c ) / 2 );\r\n\t\t\tvar s1_3 = sin( ( a - c ) / 2 );\r\n\r\n\t\t\tvar c3_1 = cos( ( c - a ) / 2 );\r\n\t\t\tvar s3_1 = sin( ( c - a ) / 2 );\r\n\r\n\t\t\tif ( order === 'XYX' ) {\r\n\r\n\t\t\t\tq.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );\r\n\r\n\t\t\t} else if ( order === 'YZY' ) {\r\n\r\n\t\t\t\tq.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );\r\n\r\n\t\t\t} else if ( order === 'ZXZ' ) {\r\n\r\n\t\t\t\tq.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );\r\n\r\n\t\t\t} else if ( order === 'XZX' ) {\r\n\r\n\t\t\t\tq.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );\r\n\r\n\t\t\t} else if ( order === 'YXY' ) {\r\n\r\n\t\t\t\tq.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );\r\n\r\n\t\t\t} else if ( order === 'ZYZ' ) {\r\n\r\n\t\t\t\tq.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\r\n\treturn  numerics.maths = maths;\r\n});\ndefine('skylark-langx-numerics/quaternion',[\r\n\t\"skylark-langx-klass\",\r\n\t\"./numerics\",\r\n\t\"./maths\"\r\n] ,function(klass,numerics,maths) {\r\n\r\n\tvar Quaternion = klass({\r\n\t\t\"klassName\" : \"Quaternion\",\r\n\r\n\t\tx: {\r\n\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this._x;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis._x = value;\r\n\t\t\t\tthis._onChangeCallback();\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\ty: {\r\n\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this._y;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis._y = value;\r\n\t\t\t\tthis._onChangeCallback();\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tz: {\r\n\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this._z;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis._z = value;\r\n\t\t\t\tthis._onChangeCallback();\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tw: {\r\n\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this._w;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis._w = value;\r\n\t\t\t\tthis._onChangeCallback();\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( x, y, z, w ) {\r\n\r\n\t\t\tthis._x = x;\r\n\t\t\tthis._y = y;\r\n\t\t\tthis._z = z;\r\n\t\t\tthis._w = w;\r\n\r\n\t\t\tthis._onChangeCallback();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tclone: function () {\r\n\r\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\r\n\r\n\t\t},\r\n\r\n\t\tcopy: function ( quaternion ) {\r\n\r\n\t\t\tthis._x = quaternion.x;\r\n\t\t\tthis._y = quaternion.y;\r\n\t\t\tthis._z = quaternion.z;\r\n\t\t\tthis._w = quaternion.w;\r\n\r\n\t\t\tthis._onChangeCallback();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetFromEuler: function ( euler, update ) {\r\n\r\n\t\t\tif ( ! ( euler && euler.isEuler ) ) {\r\n\r\n\t\t\t\tthrow new Error( 'mathsQuaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar x = euler._x, y = euler._y, z = euler._z, order = euler.order;\r\n\r\n\t\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\r\n\t\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\r\n\t\t\t//\tcontent/SpinCalc.m\r\n\r\n\t\t\tvar cos = Math.cos;\r\n\t\t\tvar sin = Math.sin;\r\n\r\n\t\t\tvar c1 = cos( x / 2 );\r\n\t\t\tvar c2 = cos( y / 2 );\r\n\t\t\tvar c3 = cos( z / 2 );\r\n\r\n\t\t\tvar s1 = sin( x / 2 );\r\n\t\t\tvar s2 = sin( y / 2 );\r\n\t\t\tvar s3 = sin( z / 2 );\r\n\r\n\t\t\tif ( order === 'XYZ' ) {\r\n\r\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t\t} else if ( order === 'YXZ' ) {\r\n\r\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( update !== false ) this._onChangeCallback();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetFromAxisAngle: function ( axis, angle ) {\r\n\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\r\n\t\t\t// assumes axis is normalized\r\n\r\n\t\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\r\n\r\n\t\t\tthis._x = axis.x * s;\r\n\t\t\tthis._y = axis.y * s;\r\n\t\t\tthis._z = axis.z * s;\r\n\t\t\tthis._w = Math.cos( halfAngle );\r\n\r\n\t\t\tthis._onChangeCallback();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetFromRotationMatrix: function ( m ) {\r\n\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n\r\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\t\tvar te = m.elements,\r\n\r\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\r\n\r\n\t\t\t\ttrace = m11 + m22 + m33,\r\n\t\t\t\ts;\r\n\r\n\t\t\tif ( trace > 0 ) {\r\n\r\n\t\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\r\n\r\n\t\t\t\tthis._w = 0.25 / s;\r\n\t\t\t\tthis._x = ( m32 - m23 ) * s;\r\n\t\t\t\tthis._y = ( m13 - m31 ) * s;\r\n\t\t\t\tthis._z = ( m21 - m12 ) * s;\r\n\r\n\t\t\t} else if ( m11 > m22 && m11 > m33 ) {\r\n\r\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\r\n\r\n\t\t\t\tthis._w = ( m32 - m23 ) / s;\r\n\t\t\t\tthis._x = 0.25 * s;\r\n\t\t\t\tthis._y = ( m12 + m21 ) / s;\r\n\t\t\t\tthis._z = ( m13 + m31 ) / s;\r\n\r\n\t\t\t} else if ( m22 > m33 ) {\r\n\r\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\r\n\r\n\t\t\t\tthis._w = ( m13 - m31 ) / s;\r\n\t\t\t\tthis._x = ( m12 + m21 ) / s;\r\n\t\t\t\tthis._y = 0.25 * s;\r\n\t\t\t\tthis._z = ( m23 + m32 ) / s;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\r\n\r\n\t\t\t\tthis._w = ( m21 - m12 ) / s;\r\n\t\t\t\tthis._x = ( m13 + m31 ) / s;\r\n\t\t\t\tthis._y = ( m23 + m32 ) / s;\r\n\t\t\t\tthis._z = 0.25 * s;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._onChangeCallback();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetFromUnitVectors: function ( vFrom, vTo ) {\r\n\r\n\t\t\t// assumes direction vectors vFrom and vTo are normalized\r\n\r\n\t\t\tvar EPS = 0.000001;\r\n\r\n\t\t\tvar r = vFrom.dot( vTo ) + 1;\r\n\r\n\t\t\tif ( r < EPS ) {\r\n\r\n\t\t\t\tr = 0;\r\n\r\n\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\r\n\r\n\t\t\t\t\tthis._x = - vFrom.y;\r\n\t\t\t\t\tthis._y = vFrom.x;\r\n\t\t\t\t\tthis._z = 0;\r\n\t\t\t\t\tthis._w = r;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis._x = 0;\r\n\t\t\t\t\tthis._y = - vFrom.z;\r\n\t\t\t\t\tthis._z = vFrom.y;\r\n\t\t\t\t\tthis._w = r;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\r\n\r\n\t\t\t\tthis._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\r\n\t\t\t\tthis._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\r\n\t\t\t\tthis._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\r\n\t\t\t\tthis._w = r;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.normalize();\r\n\r\n\t\t},\r\n\r\n\t\tangleTo: function ( q ) {\r\n\r\n\t\t\treturn 2 * Math.acos( Math.abs( maths.clamp( this.dot( q ), - 1, 1 ) ) );\r\n\r\n\t\t},\r\n\r\n\t\trotateTowards: function ( q, step ) {\r\n\r\n\t\t\tvar angle = this.angleTo( q );\r\n\r\n\t\t\tif ( angle === 0 ) return this;\r\n\r\n\t\t\tvar t = Math.min( 1, step / angle );\r\n\r\n\t\t\tthis.slerp( q, t );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tinverse: function () {\r\n\r\n\t\t\t// quaternion is assumed to have unit length\r\n\r\n\t\t\treturn this.conjugate();\r\n\r\n\t\t},\r\n\r\n\t\tconjugate: function () {\r\n\r\n\t\t\tthis._x *= - 1;\r\n\t\t\tthis._y *= - 1;\r\n\t\t\tthis._z *= - 1;\r\n\r\n\t\t\tthis._onChangeCallback();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tdot: function ( v ) {\r\n\r\n\t\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\r\n\r\n\t\t},\r\n\r\n\t\tlengthSq: function () {\r\n\r\n\t\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\r\n\r\n\t\t},\r\n\r\n\t\tlength: function () {\r\n\r\n\t\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\r\n\r\n\t\t},\r\n\r\n\t\tnormalize: function () {\r\n\r\n\t\t\tvar l = this.length();\r\n\r\n\t\t\tif ( l === 0 ) {\r\n\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._y = 0;\r\n\t\t\t\tthis._z = 0;\r\n\t\t\t\tthis._w = 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tl = 1 / l;\r\n\r\n\t\t\t\tthis._x = this._x * l;\r\n\t\t\t\tthis._y = this._y * l;\r\n\t\t\t\tthis._z = this._z * l;\r\n\t\t\t\tthis._w = this._w * l;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._onChangeCallback();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmultiply: function ( q, p ) {\r\n\r\n\t\t\tif ( p !== undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'mathsQuaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\r\n\t\t\t\treturn this.multiplyQuaternions( q, p );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.multiplyQuaternions( this, q );\r\n\r\n\t\t},\r\n\r\n\t\tpremultiply: function ( q ) {\r\n\r\n\t\t\treturn this.multiplyQuaternions( q, this );\r\n\r\n\t\t},\r\n\r\n\t\tmultiplyQuaternions: function ( a, b ) {\r\n\r\n\t\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n\r\n\t\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\r\n\t\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\r\n\r\n\t\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n\t\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n\t\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n\t\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n\r\n\t\t\tthis._onChangeCallback();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tslerp: function ( qb, t ) {\r\n\r\n\t\t\tif ( t === 0 ) return this;\r\n\t\t\tif ( t === 1 ) return this.copy( qb );\r\n\r\n\t\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\r\n\r\n\t\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\r\n\t\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\r\n\r\n\t\t\tif ( cosHalfTheta < 0 ) {\r\n\r\n\t\t\t\tthis._w = - qb._w;\r\n\t\t\t\tthis._x = - qb._x;\r\n\t\t\t\tthis._y = - qb._y;\r\n\t\t\t\tthis._z = - qb._z;\r\n\r\n\t\t\t\tcosHalfTheta = - cosHalfTheta;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.copy( qb );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( cosHalfTheta >= 1.0 ) {\r\n\r\n\t\t\t\tthis._w = w;\r\n\t\t\t\tthis._x = x;\r\n\t\t\t\tthis._y = y;\r\n\t\t\t\tthis._z = z;\r\n\r\n\t\t\t\treturn this;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\r\n\r\n\t\t\tif ( sqrSinHalfTheta <= Number.EPSILON ) {\r\n\r\n\t\t\t\tvar s = 1 - t;\r\n\t\t\t\tthis._w = s * w + t * this._w;\r\n\t\t\t\tthis._x = s * x + t * this._x;\r\n\t\t\t\tthis._y = s * y + t * this._y;\r\n\t\t\t\tthis._z = s * z + t * this._z;\r\n\r\n\t\t\t\tthis.normalize();\r\n\t\t\t\tthis._onChangeCallback();\r\n\r\n\t\t\t\treturn this;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar sinHalfTheta = Math.sqrt( sqrSinHalfTheta );\r\n\t\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\r\n\t\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\r\n\t\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\r\n\r\n\t\t\tthis._w = ( w * ratioA + this._w * ratioB );\r\n\t\t\tthis._x = ( x * ratioA + this._x * ratioB );\r\n\t\t\tthis._y = ( y * ratioA + this._y * ratioB );\r\n\t\t\tthis._z = ( z * ratioA + this._z * ratioB );\r\n\r\n\t\t\tthis._onChangeCallback();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tequals: function ( quaternion ) {\r\n\r\n\t\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\r\n\r\n\t\t},\r\n\r\n\t\tfromArray: function ( array, offset ) {\r\n\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\t\tthis._x = array[ offset ];\r\n\t\t\tthis._y = array[ offset + 1 ];\r\n\t\t\tthis._z = array[ offset + 2 ];\r\n\t\t\tthis._w = array[ offset + 3 ];\r\n\r\n\t\t\tthis._onChangeCallback();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\ttoArray: function ( array, offset ) {\r\n\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\t\tarray[ offset ] = this._x;\r\n\t\t\tarray[ offset + 1 ] = this._y;\r\n\t\t\tarray[ offset + 2 ] = this._z;\r\n\t\t\tarray[ offset + 3 ] = this._w;\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t},\r\n\r\n\t\tfromBufferAttribute: function ( attribute, index ) {\r\n\r\n\t\t\tthis._x = attribute.getX( index );\r\n\t\t\tthis._y = attribute.getY( index );\r\n\t\t\tthis._z = attribute.getZ( index );\r\n\t\t\tthis._w = attribute.getW( index );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t_onChange: function ( callback ) {\r\n\r\n\t\t\tthis._onChangeCallback = callback;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t_onChangeCallback: function () {},\r\n\r\n\r\n\t\t\"_construct\" : function ( x, y, z, w ) {\r\n\r\n\t\t\tthis._x = x || 0;\r\n\t\t\tthis._y = y || 0;\r\n\t\t\tthis._z = z || 0;\r\n\t\t\tthis._w = ( w !== undefined ) ? w : 1;\r\n\r\n\t\t}\r\n\r\n\r\n\t})\r\n\r\n\r\n\tObject.assign( Quaternion, {\r\n\r\n\t\tslerp: function ( qa, qb, qm, t ) {\r\n\r\n\t\t\treturn qm.copy( qa ).slerp( qb, t );\r\n\r\n\t\t},\r\n\r\n\t\tslerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\r\n\r\n\t\t\t// fuzz-free, array-based Quaternion SLERP operation\r\n\r\n\t\t\tvar x0 = src0[ srcOffset0 + 0 ],\r\n\t\t\t\ty0 = src0[ srcOffset0 + 1 ],\r\n\t\t\t\tz0 = src0[ srcOffset0 + 2 ],\r\n\t\t\t\tw0 = src0[ srcOffset0 + 3 ],\r\n\r\n\t\t\t\tx1 = src1[ srcOffset1 + 0 ],\r\n\t\t\t\ty1 = src1[ srcOffset1 + 1 ],\r\n\t\t\t\tz1 = src1[ srcOffset1 + 2 ],\r\n\t\t\t\tw1 = src1[ srcOffset1 + 3 ];\r\n\r\n\t\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\r\n\r\n\t\t\t\tvar s = 1 - t,\r\n\r\n\t\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\r\n\r\n\t\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\r\n\t\t\t\t\tsqrSin = 1 - cos * cos;\r\n\r\n\t\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\r\n\t\t\t\tif ( sqrSin > Number.EPSILON ) {\r\n\r\n\t\t\t\t\tvar sin = Math.sqrt( sqrSin ),\r\n\t\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\r\n\r\n\t\t\t\t\ts = Math.sin( s * len ) / sin;\r\n\t\t\t\t\tt = Math.sin( t * len ) / sin;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar tDir = t * dir;\r\n\r\n\t\t\t\tx0 = x0 * s + x1 * tDir;\r\n\t\t\t\ty0 = y0 * s + y1 * tDir;\r\n\t\t\t\tz0 = z0 * s + z1 * tDir;\r\n\t\t\t\tw0 = w0 * s + w1 * tDir;\r\n\r\n\t\t\t\t// Normalize in case we just did a lerp:\r\n\t\t\t\tif ( s === 1 - t ) {\r\n\r\n\t\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\r\n\r\n\t\t\t\t\tx0 *= f;\r\n\t\t\t\t\ty0 *= f;\r\n\t\t\t\t\tz0 *= f;\r\n\t\t\t\t\tw0 *= f;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdst[ dstOffset ] = x0;\r\n\t\t\tdst[ dstOffset + 1 ] = y0;\r\n\t\t\tdst[ dstOffset + 2 ] = z0;\r\n\t\t\tdst[ dstOffset + 3 ] = w0;\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\tObject.assign( Quaternion.prototype, {\r\n\r\n\r\n\t} );\r\n\r\n\r\n\treturn numerics.Quaternion = Quaternion;\r\n\r\n\r\n});\ndefine('skylark-langx-numerics/vector3',[\r\n\t\"skylark-langx-klass\",\r\n\t\"./numerics\",\r\n\t\"./maths\",\r\n\t\"./quaternion\"\r\n] ,function(\r\n\tklass,\r\n\tnumerics,\r\n\tmaths,\r\n\tQuaternion\r\n) {\r\n\r\n\tvar _quaternion = new Quaternion();\r\n\r\n\tvar Vector3 = klass({\r\n\t\t\"klassName\" : \"Vector3\",\r\n\r\n\t\tset: function ( x, y, z ) {\r\n\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tthis.z = z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetScalar: function ( scalar ) {\r\n\r\n\t\t\tthis.x = scalar;\r\n\t\t\tthis.y = scalar;\r\n\t\t\tthis.z = scalar;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetX: function ( x ) {\r\n\r\n\t\t\tthis.x = x;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetY: function ( y ) {\r\n\r\n\t\t\tthis.y = y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetZ: function ( z ) {\r\n\r\n\t\t\tthis.z = z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetComponent: function ( index, value ) {\r\n\r\n\t\t\tswitch ( index ) {\r\n\r\n\t\t\t\tcase 0: this.x = value; break;\r\n\t\t\t\tcase 1: this.y = value; break;\r\n\t\t\t\tcase 2: this.z = value; break;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tgetComponent: function ( index ) {\r\n\r\n\t\t\tswitch ( index ) {\r\n\r\n\t\t\t\tcase 0: return this.x;\r\n\t\t\t\tcase 1: return this.y;\r\n\t\t\t\tcase 2: return this.z;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tclone: function () {\r\n\r\n\t\t\treturn new this.constructor( this.x, this.y, this.z );\r\n\r\n\t\t},\r\n\r\n\t\tcopy: function ( v ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\t\t\tthis.z = v.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tadd: function ( v, w ) {\r\n\r\n\t\t\tif ( w !== undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'mathsVector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\t\t\tthis.z += v.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\taddScalar: function ( s ) {\r\n\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\t\t\tthis.z += s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\taddVectors: function ( a, b ) {\r\n\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\t\t\tthis.z = a.z + b.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\taddScaledVector: function ( v, s ) {\r\n\r\n\t\t\tthis.x += v.x * s;\r\n\t\t\tthis.y += v.y * s;\r\n\t\t\tthis.z += v.z * s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsub: function ( v, w ) {\r\n\r\n\t\t\tif ( w !== undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'mathsVector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\t\t\tthis.z -= v.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsubScalar: function ( s ) {\r\n\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\t\t\tthis.z -= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsubVectors: function ( a, b ) {\r\n\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\t\t\tthis.z = a.z - b.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmultiply: function ( v, w ) {\r\n\r\n\t\t\tif ( w !== undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'mathsVector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.multiplyVectors( v, w );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.x *= v.x;\r\n\t\t\tthis.y *= v.y;\r\n\t\t\tthis.z *= v.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\t\tthis.x *= scalar;\r\n\t\t\tthis.y *= scalar;\r\n\t\t\tthis.z *= scalar;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmultiplyVectors: function ( a, b ) {\r\n\r\n\t\t\tthis.x = a.x * b.x;\r\n\t\t\tthis.y = a.y * b.y;\r\n\t\t\tthis.z = a.z * b.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tapplyEuler: function ( euler ) {\r\n\r\n\t\t\tif ( ! ( euler && euler.isEuler ) ) {\r\n\r\n\t\t\t\tconsole.error( 'mathsVector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.applyQuaternion( _quaternion.setFromEuler( euler ) );\r\n\r\n\t\t},\r\n\r\n\t\tapplyAxisAngle: function ( axis, angle ) {\r\n\r\n\t\t\treturn this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );\r\n\r\n\t\t},\r\n\r\n\t\tapplyMatrix3: function ( m ) {\r\n\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\t\tvar e = m.elements;\r\n\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\r\n\t\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tapplyNormalMatrix: function ( m ) {\r\n\r\n\t\t\treturn this.applyMatrix3( m ).normalize();\r\n\r\n\t\t},\r\n\r\n\t\tapplyMatrix4: function ( m ) {\r\n\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\t\tvar e = m.elements;\r\n\r\n\t\t\tvar w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\r\n\r\n\t\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\r\n\t\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\r\n\t\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tapplyQuaternion: function ( q ) {\r\n\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\r\n\r\n\t\t\t// calculate quat * vector\r\n\r\n\t\t\tvar ix = qw * x + qy * z - qz * y;\r\n\t\t\tvar iy = qw * y + qz * x - qx * z;\r\n\t\t\tvar iz = qw * z + qx * y - qy * x;\r\n\t\t\tvar iw = - qx * x - qy * y - qz * z;\r\n\r\n\t\t\t// calculate result * inverse quat\r\n\r\n\t\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\r\n\t\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\r\n\t\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tproject: function ( camera ) {\r\n\r\n\t\t\treturn this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );\r\n\r\n\t\t},\r\n\r\n\t\tunproject: function ( camera ) {\r\n\r\n\t\t\treturn this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );\r\n\r\n\t\t},\r\n\r\n\t\ttransformDirection: function ( m ) {\r\n\r\n\t\t\t// input: mathsMatrix4 affine matrix\r\n\t\t\t// vector interpreted as a direction\r\n\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\t\tvar e = m.elements;\r\n\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\r\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\r\n\r\n\t\t\treturn this.normalize();\r\n\r\n\t\t},\r\n\r\n\t\tdivide: function ( v ) {\r\n\r\n\t\t\tthis.x /= v.x;\r\n\t\t\tthis.y /= v.y;\r\n\t\t\tthis.z /= v.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tdivideScalar: function ( scalar ) {\r\n\r\n\t\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t\t},\r\n\r\n\t\tmin: function ( v ) {\r\n\r\n\t\t\tthis.x = Math.min( this.x, v.x );\r\n\t\t\tthis.y = Math.min( this.y, v.y );\r\n\t\t\tthis.z = Math.min( this.z, v.z );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmax: function ( v ) {\r\n\r\n\t\t\tthis.x = Math.max( this.x, v.x );\r\n\t\t\tthis.y = Math.max( this.y, v.y );\r\n\t\t\tthis.z = Math.max( this.z, v.z );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tclamp: function ( min, max ) {\r\n\r\n\t\t\t// assumes min < max, componentwise\r\n\r\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tclampScalar: function ( minVal, maxVal ) {\r\n\r\n\t\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\r\n\t\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\r\n\t\t\tthis.z = Math.max( minVal, Math.min( maxVal, this.z ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tclampLength: function ( min, max ) {\r\n\r\n\t\t\tvar length = this.length();\r\n\r\n\t\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\r\n\r\n\t\t},\r\n\r\n\t\tfloor: function () {\r\n\r\n\t\t\tthis.x = Math.floor( this.x );\r\n\t\t\tthis.y = Math.floor( this.y );\r\n\t\t\tthis.z = Math.floor( this.z );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tceil: function () {\r\n\r\n\t\t\tthis.x = Math.ceil( this.x );\r\n\t\t\tthis.y = Math.ceil( this.y );\r\n\t\t\tthis.z = Math.ceil( this.z );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tround: function () {\r\n\r\n\t\t\tthis.x = Math.round( this.x );\r\n\t\t\tthis.y = Math.round( this.y );\r\n\t\t\tthis.z = Math.round( this.z );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\troundToZero: function () {\r\n\r\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tnegate: function () {\r\n\r\n\t\t\tthis.x = - this.x;\r\n\t\t\tthis.y = - this.y;\r\n\t\t\tthis.z = - this.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tdot: function ( v ) {\r\n\r\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\r\n\r\n\t\t},\r\n\r\n\t\t// TODO lengthSquared?\r\n\r\n\t\tlengthSq: function () {\r\n\r\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\r\n\r\n\t\t},\r\n\r\n\t\tlength: function () {\r\n\r\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\r\n\r\n\t\t},\r\n\r\n\t\tmanhattanLength: function () {\r\n\r\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\r\n\r\n\t\t},\r\n\r\n\t\tnormalize: function () {\r\n\r\n\t\t\treturn this.divideScalar( this.length() || 1 );\r\n\r\n\t\t},\r\n\r\n\t\tsetLength: function ( length ) {\r\n\r\n\t\t\treturn this.normalize().multiplyScalar( length );\r\n\r\n\t\t},\r\n\r\n\t\tlerp: function ( v, alpha ) {\r\n\r\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t\t},\r\n\r\n\t\tcross: function ( v, w ) {\r\n\r\n\t\t\tif ( w !== undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'mathsVector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.crossVectors( v, w );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.crossVectors( this, v );\r\n\r\n\t\t},\r\n\r\n\t\tcrossVectors: function ( a, b ) {\r\n\r\n\t\t\tvar ax = a.x, ay = a.y, az = a.z;\r\n\t\t\tvar bx = b.x, by = b.y, bz = b.z;\r\n\r\n\t\t\tthis.x = ay * bz - az * by;\r\n\t\t\tthis.y = az * bx - ax * bz;\r\n\t\t\tthis.z = ax * by - ay * bx;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tprojectOnVector: function ( v ) {\r\n\r\n\t\t\tvar denominator = v.lengthSq();\r\n\r\n\t\t\tif ( denominator === 0 ) return this.set( 0, 0, 0 );\r\n\r\n\t\t\tvar scalar = v.dot( this ) / denominator;\r\n\r\n\t\t\treturn this.copy( v ).multiplyScalar( scalar );\r\n\r\n\t\t},\r\n\r\n\t\tprojectOnPlane: function ( planeNormal ) {\r\n\r\n\t\t\t_vector.copy( this ).projectOnVector( planeNormal );\r\n\r\n\t\t\treturn this.sub( _vector );\r\n\r\n\t\t},\r\n\r\n\t\treflect: function ( normal ) {\r\n\r\n\t\t\t// reflect incident vector off plane orthogonal to normal\r\n\t\t\t// normal is assumed to have unit length\r\n\r\n\t\t\treturn this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\r\n\r\n\t\t},\r\n\r\n\t\tangleTo: function ( v ) {\r\n\r\n\t\t\tvar denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\r\n\r\n\t\t\tif ( denominator === 0 ) return Math.PI / 2;\r\n\r\n\t\t\tvar theta = this.dot( v ) / denominator;\r\n\r\n\t\t\t// clamp, to handle numerical problems\r\n\r\n\t\t\treturn Math.acos( MathUtils.clamp( theta, - 1, 1 ) );\r\n\r\n\t\t},\r\n\r\n\t\tdistanceTo: function ( v ) {\r\n\r\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t\t},\r\n\r\n\t\tdistanceToSquared: function ( v ) {\r\n\r\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\r\n\r\n\t\t\treturn dx * dx + dy * dy + dz * dz;\r\n\r\n\t\t},\r\n\r\n\t\tmanhattanDistanceTo: function ( v ) {\r\n\r\n\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\r\n\r\n\t\t},\r\n\r\n\t\tsetFromSpherical: function ( s ) {\r\n\r\n\t\t\treturn this.setFromSphericalCoords( s.radius, s.phi, s.theta );\r\n\r\n\t\t},\r\n\r\n\t\tsetFromSphericalCoords: function ( radius, phi, theta ) {\r\n\r\n\t\t\tvar sinPhiRadius = Math.sin( phi ) * radius;\r\n\r\n\t\t\tthis.x = sinPhiRadius * Math.sin( theta );\r\n\t\t\tthis.y = Math.cos( phi ) * radius;\r\n\t\t\tthis.z = sinPhiRadius * Math.cos( theta );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetFromCylindrical: function ( c ) {\r\n\r\n\t\t\treturn this.setFromCylindricalCoords( c.radius, c.theta, c.y );\r\n\r\n\t\t},\r\n\r\n\t\tsetFromCylindricalCoords: function ( radius, theta, y ) {\r\n\r\n\t\t\tthis.x = radius * Math.sin( theta );\r\n\t\t\tthis.y = y;\r\n\t\t\tthis.z = radius * Math.cos( theta );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetFromMatrixPosition: function ( m ) {\r\n\r\n\t\t\tvar e = m.elements;\r\n\r\n\t\t\tthis.x = e[ 12 ];\r\n\t\t\tthis.y = e[ 13 ];\r\n\t\t\tthis.z = e[ 14 ];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetFromMatrixScale: function ( m ) {\r\n\r\n\t\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\r\n\t\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\r\n\t\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\r\n\r\n\t\t\tthis.x = sx;\r\n\t\t\tthis.y = sy;\r\n\t\t\tthis.z = sz;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetFromMatrixColumn: function ( m, index ) {\r\n\r\n\t\t\treturn this.fromArray( m.elements, index * 4 );\r\n\r\n\t\t},\r\n\r\n\t\tsetFromMatrix3Column: function ( m, index ) {\r\n\r\n\t\t\treturn this.fromArray( m.elements, index * 3 );\r\n\r\n\t\t},\r\n\r\n\t\tequals: function ( v ) {\r\n\r\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\r\n\r\n\t\t},\r\n\r\n\t\tfromArray: function ( array, offset ) {\r\n\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\t\tthis.x = array[ offset ];\r\n\t\t\tthis.y = array[ offset + 1 ];\r\n\t\t\tthis.z = array[ offset + 2 ];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\ttoArray: function ( array, offset ) {\r\n\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\t\tarray[ offset ] = this.x;\r\n\t\t\tarray[ offset + 1 ] = this.y;\r\n\t\t\tarray[ offset + 2 ] = this.z;\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t},\r\n\r\n\t\tfromBufferAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\t\tif ( offset !== undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'mathsVector3: offset has been removed from .fromBufferAttribute().' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.x = attribute.getX( index );\r\n\t\t\tthis.y = attribute.getY( index );\r\n\t\t\tthis.z = attribute.getZ( index );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\r\n\t\t\"_construct\" : function ( x, y, z ) {\r\n\r\n\t\t\tthis.x = x || 0;\r\n\t\t\tthis.y = y || 0;\r\n\t\t\tthis.z = z || 0;\r\n\r\n\t\t}\r\n\r\n\t});\r\n\r\n\tvar _vector = new Vector3();\r\n\r\n\r\n\treturn numerics.Vector3 = Vector3;\r\n});\ndefine('skylark-langx-numerics/matrix4',[\r\n\t\"skylark-langx-klass\",\r\n\t\"./numerics\",\r\n\t\"./vector3\"\r\n] ,function(\r\n\tklass,\r\n\tnumerics,\r\n\tVector3\r\n) {\r\n\r\n\tvar _v1 = new Vector3();\r\n\tvar _zero = new Vector3( 0, 0, 0 );\r\n\tvar _one = new Vector3( 1, 1, 1 );\r\n\tvar _x = new Vector3();\r\n\tvar _y = new Vector3();\r\n\tvar _z = new Vector3();\r\n\r\n\tvar Matrix4 = klass({\r\n\t\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\r\n\t\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\r\n\t\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\r\n\t\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tidentity: function () {\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\t1, 0, 0, 0,\r\n\t\t\t\t0, 1, 0, 0,\r\n\t\t\t\t0, 0, 1, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tclone: function () {\r\n\r\n\t\t\treturn new Matrix4().fromArray( this.elements );\r\n\r\n\t\t},\r\n\r\n\t\tcopy: function ( m ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = m.elements;\r\n\r\n\t\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\r\n\t\t\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\r\n\t\t\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\r\n\t\t\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tcopyPosition: function ( m ) {\r\n\r\n\t\t\tvar te = this.elements, me = m.elements;\r\n\r\n\t\t\tte[ 12 ] = me[ 12 ];\r\n\t\t\tte[ 13 ] = me[ 13 ];\r\n\t\t\tte[ 14 ] = me[ 14 ];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\textractBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n\t\t\txAxis.setFromMatrixColumn( this, 0 );\r\n\t\t\tyAxis.setFromMatrixColumn( this, 1 );\r\n\t\t\tzAxis.setFromMatrixColumn( this, 2 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n\t\t\tthis.set(\r\n\t\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\r\n\t\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\r\n\t\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\textractRotation: function ( m ) {\r\n\r\n\t\t\t// this method does not support reflection matrices\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = m.elements;\r\n\r\n\t\t\tvar scaleX = 1 / _v1.setFromMatrixColumn( m, 0 ).length();\r\n\t\t\tvar scaleY = 1 / _v1.setFromMatrixColumn( m, 1 ).length();\r\n\t\t\tvar scaleZ = 1 / _v1.setFromMatrixColumn( m, 2 ).length();\r\n\r\n\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\r\n\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\r\n\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\r\n\t\t\tte[ 3 ] = 0;\r\n\r\n\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\r\n\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\r\n\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\r\n\t\t\tte[ 7 ] = 0;\r\n\r\n\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\r\n\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\r\n\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\r\n\t\t\tte[ 11 ] = 0;\r\n\r\n\t\t\tte[ 12 ] = 0;\r\n\t\t\tte[ 13 ] = 0;\r\n\t\t\tte[ 14 ] = 0;\r\n\t\t\tte[ 15 ] = 1;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmakeRotationFromEuler: function ( euler ) {\r\n\r\n\t\t\tif ( ! ( euler && euler.isEuler ) ) {\r\n\r\n\t\t\t\tconsole.error( 'mathsMatrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tvar x = euler.x, y = euler.y, z = euler.z;\r\n\t\t\tvar a = Math.cos( x ), b = Math.sin( x );\r\n\t\t\tvar c = Math.cos( y ), d = Math.sin( y );\r\n\t\t\tvar e = Math.cos( z ), f = Math.sin( z );\r\n\r\n\t\t\tif ( euler.order === 'XYZ' ) {\r\n\r\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = - c * f;\r\n\t\t\t\tte[ 8 ] = d;\r\n\r\n\t\t\t\tte[ 1 ] = af + be * d;\r\n\t\t\t\tte[ 5 ] = ae - bf * d;\r\n\t\t\t\tte[ 9 ] = - b * c;\r\n\r\n\t\t\t\tte[ 2 ] = bf - ae * d;\r\n\t\t\t\tte[ 6 ] = be + af * d;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t\t} else if ( euler.order === 'YXZ' ) {\r\n\r\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\t\tte[ 0 ] = ce + df * b;\r\n\t\t\t\tte[ 4 ] = de * b - cf;\r\n\t\t\t\tte[ 8 ] = a * d;\r\n\r\n\t\t\t\tte[ 1 ] = a * f;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = - b;\r\n\r\n\t\t\t\tte[ 2 ] = cf * b - de;\r\n\t\t\t\tte[ 6 ] = df + ce * b;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t\t} else if ( euler.order === 'ZXY' ) {\r\n\r\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\t\tte[ 0 ] = ce - df * b;\r\n\t\t\t\tte[ 4 ] = - a * f;\r\n\t\t\t\tte[ 8 ] = de + cf * b;\r\n\r\n\t\t\t\tte[ 1 ] = cf + de * b;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = df - ce * b;\r\n\r\n\t\t\t\tte[ 2 ] = - a * d;\r\n\t\t\t\tte[ 6 ] = b;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t\t} else if ( euler.order === 'ZYX' ) {\r\n\r\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = be * d - af;\r\n\t\t\t\tte[ 8 ] = ae * d + bf;\r\n\r\n\t\t\t\tte[ 1 ] = c * f;\r\n\t\t\t\tte[ 5 ] = bf * d + ae;\r\n\t\t\t\tte[ 9 ] = af * d - be;\r\n\r\n\t\t\t\tte[ 2 ] = - d;\r\n\t\t\t\tte[ 6 ] = b * c;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t\t} else if ( euler.order === 'YZX' ) {\r\n\r\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = bd - ac * f;\r\n\t\t\t\tte[ 8 ] = bc * f + ad;\r\n\r\n\t\t\t\tte[ 1 ] = f;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = - b * e;\r\n\r\n\t\t\t\tte[ 2 ] = - d * e;\r\n\t\t\t\tte[ 6 ] = ad * f + bc;\r\n\t\t\t\tte[ 10 ] = ac - bd * f;\r\n\r\n\t\t\t} else if ( euler.order === 'XZY' ) {\r\n\r\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = - f;\r\n\t\t\t\tte[ 8 ] = d * e;\r\n\r\n\t\t\t\tte[ 1 ] = ac * f + bd;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = ad * f - bc;\r\n\r\n\t\t\t\tte[ 2 ] = bc * f - ad;\r\n\t\t\t\tte[ 6 ] = b * e;\r\n\t\t\t\tte[ 10 ] = bd * f + ac;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// bottom row\r\n\t\t\tte[ 3 ] = 0;\r\n\t\t\tte[ 7 ] = 0;\r\n\t\t\tte[ 11 ] = 0;\r\n\r\n\t\t\t// last column\r\n\t\t\tte[ 12 ] = 0;\r\n\t\t\tte[ 13 ] = 0;\r\n\t\t\tte[ 14 ] = 0;\r\n\t\t\tte[ 15 ] = 1;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmakeRotationFromQuaternion: function ( q ) {\r\n\r\n\t\t\treturn this.compose( _zero, q, _one );\r\n\r\n\t\t},\r\n\r\n\t\tlookAt: function ( eye, target, up ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\t_z.subVectors( eye, target );\r\n\r\n\t\t\tif ( _z.lengthSq() === 0 ) {\r\n\r\n\t\t\t\t// eye and target are in the same position\r\n\r\n\t\t\t\t_z.z = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_z.normalize();\r\n\t\t\t_x.crossVectors( up, _z );\r\n\r\n\t\t\tif ( _x.lengthSq() === 0 ) {\r\n\r\n\t\t\t\t// up and z are parallel\r\n\r\n\t\t\t\tif ( Math.abs( up.z ) === 1 ) {\r\n\r\n\t\t\t\t\t_z.x += 0.0001;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_z.z += 0.0001;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_z.normalize();\r\n\t\t\t\t_x.crossVectors( up, _z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_x.normalize();\r\n\t\t\t_y.crossVectors( _z, _x );\r\n\r\n\t\t\tte[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;\r\n\t\t\tte[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;\r\n\t\t\tte[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmultiply: function ( m, n ) {\r\n\r\n\t\t\tif ( n !== undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'mathsMatrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\r\n\t\t\t\treturn this.multiplyMatrices( m, n );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.multiplyMatrices( this, m );\r\n\r\n\t\t},\r\n\r\n\t\tpremultiply: function ( m ) {\r\n\r\n\t\t\treturn this.multiplyMatrices( m, this );\r\n\r\n\t\t},\r\n\r\n\t\tmultiplyMatrices: function ( a, b ) {\r\n\r\n\t\t\tvar ae = a.elements;\r\n\t\t\tvar be = b.elements;\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\r\n\t\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\r\n\t\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\r\n\t\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\r\n\r\n\t\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\r\n\t\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\r\n\t\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\r\n\t\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\r\n\r\n\t\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n\t\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n\t\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n\t\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n\r\n\t\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n\t\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n\t\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n\t\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n\r\n\t\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n\t\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n\t\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n\t\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n\r\n\t\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n\t\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n\t\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n\t\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmultiplyScalar: function ( s ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\r\n\t\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\r\n\t\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\r\n\t\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tdeterminant: function () {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\r\n\t\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\r\n\t\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\r\n\t\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\r\n\r\n\t\t\t//TODO: make this more efficient\r\n\t\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n\r\n\t\t\treturn (\r\n\t\t\t\tn41 * (\r\n\t\t\t\t\t+ n14 * n23 * n32\r\n\t\t\t\t\t - n13 * n24 * n32\r\n\t\t\t\t\t - n14 * n22 * n33\r\n\t\t\t\t\t + n12 * n24 * n33\r\n\t\t\t\t\t + n13 * n22 * n34\r\n\t\t\t\t\t - n12 * n23 * n34\r\n\t\t\t\t) +\r\n\t\t\t\tn42 * (\r\n\t\t\t\t\t+ n11 * n23 * n34\r\n\t\t\t\t\t - n11 * n24 * n33\r\n\t\t\t\t\t + n14 * n21 * n33\r\n\t\t\t\t\t - n13 * n21 * n34\r\n\t\t\t\t\t + n13 * n24 * n31\r\n\t\t\t\t\t - n14 * n23 * n31\r\n\t\t\t\t) +\r\n\t\t\t\tn43 * (\r\n\t\t\t\t\t+ n11 * n24 * n32\r\n\t\t\t\t\t - n11 * n22 * n34\r\n\t\t\t\t\t - n14 * n21 * n32\r\n\t\t\t\t\t + n12 * n21 * n34\r\n\t\t\t\t\t + n14 * n22 * n31\r\n\t\t\t\t\t - n12 * n24 * n31\r\n\t\t\t\t) +\r\n\t\t\t\tn44 * (\r\n\t\t\t\t\t- n13 * n22 * n31\r\n\t\t\t\t\t - n11 * n23 * n32\r\n\t\t\t\t\t + n11 * n22 * n33\r\n\t\t\t\t\t + n13 * n21 * n32\r\n\t\t\t\t\t - n12 * n21 * n33\r\n\t\t\t\t\t + n12 * n23 * n31\r\n\t\t\t\t)\r\n\r\n\t\t\t);\r\n\r\n\t\t},\r\n\r\n\t\ttranspose: function () {\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar tmp;\r\n\r\n\t\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\r\n\t\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\r\n\t\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\r\n\r\n\t\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\r\n\t\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\r\n\t\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetPosition: function ( x, y, z ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tif ( x.isVector3 ) {\r\n\r\n\t\t\t\tte[ 12 ] = x.x;\r\n\t\t\t\tte[ 13 ] = x.y;\r\n\t\t\t\tte[ 14 ] = x.z;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tte[ 12 ] = x;\r\n\t\t\t\tte[ 13 ] = y;\r\n\t\t\t\tte[ 14 ] = z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tgetInverse: function ( m, throwOnDegenerate ) {\r\n\r\n\t\t\tif ( throwOnDegenerate !== undefined ) {\r\n\r\n\t\t\t\tconsole.warn( \"mathsMatrix4: .getInverse() can no longer be configured to throw on degenerate.\" );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n\t\t\tvar te = this.elements,\r\n\t\t\t\tme = m.elements,\r\n\r\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\r\n\t\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\r\n\t\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\r\n\t\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\r\n\r\n\t\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\r\n\t\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\r\n\t\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\r\n\t\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\r\n\r\n\t\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\r\n\r\n\t\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );\r\n\r\n\t\t\tvar detInv = 1 / det;\r\n\r\n\t\t\tte[ 0 ] = t11 * detInv;\r\n\t\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\r\n\t\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\r\n\t\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\r\n\r\n\t\t\tte[ 4 ] = t12 * detInv;\r\n\t\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\r\n\t\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\r\n\t\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\r\n\r\n\t\t\tte[ 8 ] = t13 * detInv;\r\n\t\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\r\n\t\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\r\n\t\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\r\n\r\n\t\t\tte[ 12 ] = t14 * detInv;\r\n\t\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\r\n\t\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\r\n\t\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tscale: function ( v ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar x = v.x, y = v.y, z = v.z;\r\n\r\n\t\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\r\n\t\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\r\n\t\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\r\n\t\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tgetMaxScaleOnAxis: function () {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\r\n\t\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\r\n\t\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\r\n\r\n\t\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\r\n\r\n\t\t},\r\n\r\n\t\tmakeTranslation: function ( x, y, z ) {\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\t1, 0, 0, x,\r\n\t\t\t\t0, 1, 0, y,\r\n\t\t\t\t0, 0, 1, z,\r\n\t\t\t\t0, 0, 0, 1\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmakeRotationX: function ( theta ) {\r\n\r\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\t1, 0, 0, 0,\r\n\t\t\t\t0, c, - s, 0,\r\n\t\t\t\t0, s, c, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmakeRotationY: function ( theta ) {\r\n\r\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\t c, 0, s, 0,\r\n\t\t\t\t 0, 1, 0, 0,\r\n\t\t\t\t- s, 0, c, 0,\r\n\t\t\t\t 0, 0, 0, 1\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmakeRotationZ: function ( theta ) {\r\n\r\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\tc, - s, 0, 0,\r\n\t\t\t\ts, c, 0, 0,\r\n\t\t\t\t0, 0, 1, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmakeRotationAxis: function ( axis, angle ) {\r\n\r\n\t\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\r\n\t\t\tvar c = Math.cos( angle );\r\n\t\t\tvar s = Math.sin( angle );\r\n\t\t\tvar t = 1 - c;\r\n\t\t\tvar x = axis.x, y = axis.y, z = axis.z;\r\n\t\t\tvar tx = t * x, ty = t * y;\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n\t\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n\t\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\r\n\t\t\t);\r\n\r\n\t\t\t return this;\r\n\r\n\t\t},\r\n\r\n\t\tmakeScale: function ( x, y, z ) {\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\tx, 0, 0, 0,\r\n\t\t\t\t0, y, 0, 0,\r\n\t\t\t\t0, 0, z, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmakeShear: function ( x, y, z ) {\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\t1, y, z, 0,\r\n\t\t\t\tx, 1, z, 0,\r\n\t\t\t\tx, y, 1, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tcompose: function ( position, quaternion, scale ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tvar x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\r\n\t\t\tvar x2 = x + x,\ty2 = y + y, z2 = z + z;\r\n\t\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\r\n\t\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\r\n\t\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\r\n\r\n\t\t\tvar sx = scale.x, sy = scale.y, sz = scale.z;\r\n\r\n\t\t\tte[ 0 ] = ( 1 - ( yy + zz ) ) * sx;\r\n\t\t\tte[ 1 ] = ( xy + wz ) * sx;\r\n\t\t\tte[ 2 ] = ( xz - wy ) * sx;\r\n\t\t\tte[ 3 ] = 0;\r\n\r\n\t\t\tte[ 4 ] = ( xy - wz ) * sy;\r\n\t\t\tte[ 5 ] = ( 1 - ( xx + zz ) ) * sy;\r\n\t\t\tte[ 6 ] = ( yz + wx ) * sy;\r\n\t\t\tte[ 7 ] = 0;\r\n\r\n\t\t\tte[ 8 ] = ( xz + wy ) * sz;\r\n\t\t\tte[ 9 ] = ( yz - wx ) * sz;\r\n\t\t\tte[ 10 ] = ( 1 - ( xx + yy ) ) * sz;\r\n\t\t\tte[ 11 ] = 0;\r\n\r\n\t\t\tte[ 12 ] = position.x;\r\n\t\t\tte[ 13 ] = position.y;\r\n\t\t\tte[ 14 ] = position.z;\r\n\t\t\tte[ 15 ] = 1;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tdecompose: function ( position, quaternion, scale ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tvar sx = _v1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\r\n\t\t\tvar sy = _v1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\r\n\t\t\tvar sz = _v1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\r\n\r\n\t\t\t// if determine is negative, we need to invert one scale\r\n\t\t\tvar det = this.determinant();\r\n\t\t\tif ( det < 0 ) sx = - sx;\r\n\r\n\t\t\tposition.x = te[ 12 ];\r\n\t\t\tposition.y = te[ 13 ];\r\n\t\t\tposition.z = te[ 14 ];\r\n\r\n\t\t\t// scale the rotation part\r\n\t\t\t_m1.copy( this );\r\n\r\n\t\t\tvar invSX = 1 / sx;\r\n\t\t\tvar invSY = 1 / sy;\r\n\t\t\tvar invSZ = 1 / sz;\r\n\r\n\t\t\t_m1.elements[ 0 ] *= invSX;\r\n\t\t\t_m1.elements[ 1 ] *= invSX;\r\n\t\t\t_m1.elements[ 2 ] *= invSX;\r\n\r\n\t\t\t_m1.elements[ 4 ] *= invSY;\r\n\t\t\t_m1.elements[ 5 ] *= invSY;\r\n\t\t\t_m1.elements[ 6 ] *= invSY;\r\n\r\n\t\t\t_m1.elements[ 8 ] *= invSZ;\r\n\t\t\t_m1.elements[ 9 ] *= invSZ;\r\n\t\t\t_m1.elements[ 10 ] *= invSZ;\r\n\r\n\t\t\tquaternion.setFromRotationMatrix( _m1 );\r\n\r\n\t\t\tscale.x = sx;\r\n\t\t\tscale.y = sy;\r\n\t\t\tscale.z = sz;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmakePerspective: function ( left, right, top, bottom, near, far ) {\r\n\r\n\t\t\tif ( far === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'mathsMatrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar x = 2 * near / ( right - left );\r\n\t\t\tvar y = 2 * near / ( top - bottom );\r\n\r\n\t\t\tvar a = ( right + left ) / ( right - left );\r\n\t\t\tvar b = ( top + bottom ) / ( top - bottom );\r\n\t\t\tvar c = - ( far + near ) / ( far - near );\r\n\t\t\tvar d = - 2 * far * near / ( far - near );\r\n\r\n\t\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\r\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\r\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\r\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar w = 1.0 / ( right - left );\r\n\t\t\tvar h = 1.0 / ( top - bottom );\r\n\t\t\tvar p = 1.0 / ( far - near );\r\n\r\n\t\t\tvar x = ( right + left ) * w;\r\n\t\t\tvar y = ( top + bottom ) * h;\r\n\t\t\tvar z = ( far + near ) * p;\r\n\r\n\t\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\r\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\r\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\r\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tequals: function ( matrix ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = matrix.elements;\r\n\r\n\t\t\tfor ( var i = 0; i < 16; i ++ ) {\r\n\r\n\t\t\t\tif ( te[ i ] !== me[ i ] ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t},\r\n\r\n\t\tfromArray: function ( array, offset ) {\r\n\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\t\tfor ( var i = 0; i < 16; i ++ ) {\r\n\r\n\t\t\t\tthis.elements[ i ] = array[ i + offset ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\ttoArray: function ( array, offset ) {\r\n\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tarray[ offset ] = te[ 0 ];\r\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\r\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\r\n\t\t\tarray[ offset + 8 ] = te[ 8 ];\r\n\t\t\tarray[ offset + 9 ] = te[ 9 ];\r\n\t\t\tarray[ offset + 10 ] = te[ 10 ];\r\n\t\t\tarray[ offset + 11 ] = te[ 11 ];\r\n\r\n\t\t\tarray[ offset + 12 ] = te[ 12 ];\r\n\t\t\tarray[ offset + 13 ] = te[ 13 ];\r\n\t\t\tarray[ offset + 14 ] = te[ 14 ];\r\n\t\t\tarray[ offset + 15 ] = te[ 15 ];\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t},\r\n\r\n\t\t\"_construct\" : function() {\r\n\r\n\t\t\tthis.elements = [\r\n\r\n\t\t\t\t1, 0, 0, 0,\r\n\t\t\t\t0, 1, 0, 0,\r\n\t\t\t\t0, 0, 1, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\r\n\t\t\t];\r\n\r\n\t\t\tif ( arguments.length > 0 ) {\r\n\r\n\t\t\t\tconsole.error( 'mathsMatrix4: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t});\r\n\r\n\tvar _m1 = new Matrix4();\r\n\r\n\treturn numerics.Matrix4 =  Matrix4 ;\r\n\r\n});\ndefine('skylark-langx-numerics/euler',[\r\n\t\"skylark-langx-klass\",\r\n\t\"./numerics\",\r\n\t\"./maths\",\r\n\t\"./quaternion\",\r\n\t\"./vector3\",\r\n\t\"./matrix4\"\r\n] ,function(\r\n\tklass,\r\n\tnumerics,\r\n\tmaths,\r\n\tQuaternion,\r\n\tVector3,\r\n\tMatrix4\r\n) {\r\n\r\n\tvar _matrix = new Matrix4();\r\n\tvar _quaternion = new Quaternion();\r\n\r\n\tvar Euler = klass({\r\n\t\tx: {\r\n\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this._x;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis._x = value;\r\n\t\t\t\tthis._onChangeCallback();\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\ty: {\r\n\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this._y;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis._y = value;\r\n\t\t\t\tthis._onChangeCallback();\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tz: {\r\n\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this._z;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis._z = value;\r\n\t\t\t\tthis._onChangeCallback();\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\torder: {\r\n\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this._order;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis._order = value;\r\n\t\t\t\tthis._onChangeCallback();\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tisEuler: true,\r\n\r\n\t\tset: function ( x, y, z, order ) {\r\n\r\n\t\t\tthis._x = x;\r\n\t\t\tthis._y = y;\r\n\t\t\tthis._z = z;\r\n\t\t\tthis._order = order || this._order;\r\n\r\n\t\t\tthis._onChangeCallback();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tclone: function () {\r\n\r\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\r\n\r\n\t\t},\r\n\r\n\t\tcopy: function ( euler ) {\r\n\r\n\t\t\tthis._x = euler._x;\r\n\t\t\tthis._y = euler._y;\r\n\t\t\tthis._z = euler._z;\r\n\t\t\tthis._order = euler._order;\r\n\r\n\t\t\tthis._onChangeCallback();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetFromRotationMatrix: function ( m, order, update ) {\r\n\r\n\t\t\tvar clamp = maths.clamp;\r\n\r\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\t\tvar te = m.elements;\r\n\t\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\r\n\t\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\r\n\t\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n\t\t\torder = order || this._order;\r\n\r\n\t\t\tif ( order === 'XYZ' ) {\r\n\r\n\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\r\n\r\n\t\t\t\tif ( Math.abs( m13 ) < 0.9999999 ) {\r\n\r\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\t\tthis._z = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( order === 'YXZ' ) {\r\n\r\n\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\r\n\r\n\t\t\t\tif ( Math.abs( m23 ) < 0.9999999 ) {\r\n\r\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\t\t\t\t\tthis._z = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\r\n\r\n\t\t\t\tif ( Math.abs( m32 ) < 0.9999999 ) {\r\n\r\n\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis._y = 0;\r\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\r\n\r\n\t\t\t\tif ( Math.abs( m31 ) < 0.9999999 ) {\r\n\r\n\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis._x = 0;\r\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\r\n\r\n\t\t\t\tif ( Math.abs( m21 ) < 0.9999999 ) {\r\n\r\n\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\r\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis._x = 0;\r\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\r\n\r\n\t\t\t\tif ( Math.abs( m12 ) < 0.9999999 ) {\r\n\r\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\t\tthis._y = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( 'skylark-nunustudio/editor/gui/element/RendererCanvasEuler: .setFromRotationMatrix() given unsupported order: ' + order );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._order = order;\r\n\r\n\t\t\tif ( update !== false ) this._onChangeCallback();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetFromQuaternion: function ( q, order, update ) {\r\n\r\n\t\t\t_matrix.makeRotationFromQuaternion( q );\r\n\r\n\t\t\treturn this.setFromRotationMatrix( _matrix, order, update );\r\n\r\n\t\t},\r\n\r\n\t\tsetFromVector3: function ( v, order ) {\r\n\r\n\t\t\treturn this.set( v.x, v.y, v.z, order || this._order );\r\n\r\n\t\t},\r\n\r\n\t\treorder: function ( newOrder ) {\r\n\r\n\t\t\t// WARNING: this discards revolution information -bhouston\r\n\r\n\t\t\t_quaternion.setFromEuler( this );\r\n\r\n\t\t\treturn this.setFromQuaternion( _quaternion, newOrder );\r\n\r\n\t\t},\r\n\r\n\t\tequals: function ( euler ) {\r\n\r\n\t\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\r\n\r\n\t\t},\r\n\r\n\t\tfromArray: function ( array ) {\r\n\r\n\t\t\tthis._x = array[ 0 ];\r\n\t\t\tthis._y = array[ 1 ];\r\n\t\t\tthis._z = array[ 2 ];\r\n\t\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\r\n\r\n\t\t\tthis._onChangeCallback();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\ttoArray: function ( array, offset ) {\r\n\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\t\tarray[ offset ] = this._x;\r\n\t\t\tarray[ offset + 1 ] = this._y;\r\n\t\t\tarray[ offset + 2 ] = this._z;\r\n\t\t\tarray[ offset + 3 ] = this._order;\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t},\r\n\r\n\t\ttoVector3: function ( optionalResult ) {\r\n\r\n\t\t\tif ( optionalResult ) {\r\n\r\n\t\t\t\treturn optionalResult.set( this._x, this._y, this._z );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn new Vector3( this._x, this._y, this._z );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t_onChange: function ( callback ) {\r\n\r\n\t\t\tthis._onChangeCallback = callback;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t_onChangeCallback: function () {},\r\n\r\n\r\n\t\t\"_construct\" : function ( x, y, z, order ) {\r\n\r\n\t\t\tthis._x = x || 0;\r\n\t\t\tthis._y = y || 0;\r\n\t\t\tthis._z = z || 0;\r\n\t\t\tthis._order = order || Euler.DefaultOrder;\r\n\r\n\t\t}\r\n\r\n\r\n\t});\r\n\r\n\r\n\tEuler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\r\n\r\n\tEuler.DefaultOrder = 'XYZ';\r\n\r\n\r\n\treturn numerics.Euler = Euler ;\r\n});\r\n\ndefine('skylark-langx-numerics/matrix3',[\r\n\t\"skylark-langx-klass\",\r\n\t\"./numerics\"\r\n] ,function(klass,numerics) {\r\n\r\n\tvar Matrix3 = klass({\r\n\t\t\"klassName\" : \"Matrix3\",\r\n\r\n\t\tisMatrix3: true,\r\n\r\n\t\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\r\n\t\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\r\n\t\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tidentity: function () {\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\t1, 0, 0,\r\n\t\t\t\t0, 1, 0,\r\n\t\t\t\t0, 0, 1\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tclone: function () {\r\n\r\n\t\t\treturn new this.constructor().fromArray( this.elements );\r\n\r\n\t\t},\r\n\r\n\t\tcopy: function ( m ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = m.elements;\r\n\r\n\t\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\r\n\t\t\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\r\n\t\t\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\textractBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n\t\t\txAxis.setFromMatrix3Column( this, 0 );\r\n\t\t\tyAxis.setFromMatrix3Column( this, 1 );\r\n\t\t\tzAxis.setFromMatrix3Column( this, 2 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetFromMatrix4: function ( m ) {\r\n\r\n\t\t\tvar me = m.elements;\r\n\r\n\t\t\tthis.set(\r\n\r\n\t\t\t\tme[ 0 ], me[ 4 ], me[ 8 ],\r\n\t\t\t\tme[ 1 ], me[ 5 ], me[ 9 ],\r\n\t\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmultiply: function ( m ) {\r\n\r\n\t\t\treturn this.multiplyMatrices( this, m );\r\n\r\n\t\t},\r\n\r\n\t\tpremultiply: function ( m ) {\r\n\r\n\t\t\treturn this.multiplyMatrices( m, this );\r\n\r\n\t\t},\r\n\r\n\t\tmultiplyMatrices: function ( a, b ) {\r\n\r\n\t\t\tvar ae = a.elements;\r\n\t\t\tvar be = b.elements;\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tvar a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\r\n\t\t\tvar a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\r\n\t\t\tvar a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\r\n\r\n\t\t\tvar b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\r\n\t\t\tvar b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\r\n\t\t\tvar b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\r\n\r\n\t\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\r\n\t\t\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\r\n\t\t\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\r\n\r\n\t\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\r\n\t\t\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\r\n\t\t\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\r\n\r\n\t\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\r\n\t\t\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\r\n\t\t\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmultiplyScalar: function ( s ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\r\n\t\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\r\n\t\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tdeterminant: function () {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\r\n\t\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\r\n\t\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\r\n\r\n\t\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\r\n\r\n\t\t},\r\n\r\n\t\tgetInverse: function ( matrix, throwOnDegenerate ) {\r\n\r\n\t\t\tif ( throwOnDegenerate !== undefined ) {\r\n\r\n\t\t\t\tconsole.warn( \"mathsMatrix3: .getInverse() can no longer be configured to throw on degenerate.\" );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar me = matrix.elements,\r\n\t\t\t\tte = this.elements,\r\n\r\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\r\n\t\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\r\n\t\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\r\n\r\n\t\t\t\tt11 = n33 * n22 - n32 * n23,\r\n\t\t\t\tt12 = n32 * n13 - n33 * n12,\r\n\t\t\t\tt13 = n23 * n12 - n22 * n13,\r\n\r\n\t\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\r\n\r\n\t\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\r\n\r\n\t\t\tvar detInv = 1 / det;\r\n\r\n\t\t\tte[ 0 ] = t11 * detInv;\r\n\t\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\r\n\t\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\r\n\r\n\t\t\tte[ 3 ] = t12 * detInv;\r\n\t\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\r\n\t\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\r\n\r\n\t\t\tte[ 6 ] = t13 * detInv;\r\n\t\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\r\n\t\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\ttranspose: function () {\r\n\r\n\t\t\tvar tmp, m = this.elements;\r\n\r\n\t\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\r\n\t\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\r\n\t\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tgetNormalMatrix: function ( matrix4 ) {\r\n\r\n\t\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\r\n\r\n\t\t},\r\n\r\n\t\ttransposeIntoArray: function ( r ) {\r\n\r\n\t\t\tvar m = this.elements;\r\n\r\n\t\t\tr[ 0 ] = m[ 0 ];\r\n\t\t\tr[ 1 ] = m[ 3 ];\r\n\t\t\tr[ 2 ] = m[ 6 ];\r\n\t\t\tr[ 3 ] = m[ 1 ];\r\n\t\t\tr[ 4 ] = m[ 4 ];\r\n\t\t\tr[ 5 ] = m[ 7 ];\r\n\t\t\tr[ 6 ] = m[ 2 ];\r\n\t\t\tr[ 7 ] = m[ 5 ];\r\n\t\t\tr[ 8 ] = m[ 8 ];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {\r\n\r\n\t\t\tvar c = Math.cos( rotation );\r\n\t\t\tvar s = Math.sin( rotation );\r\n\r\n\t\t\tthis.set(\r\n\t\t\t\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\r\n\t\t\t\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\r\n\t\t\t\t0, 0, 1\r\n\t\t\t);\r\n\r\n\t\t},\r\n\r\n\t\tscale: function ( sx, sy ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tte[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;\r\n\t\t\tte[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\trotate: function ( theta ) {\r\n\r\n\t\t\tvar c = Math.cos( theta );\r\n\t\t\tvar s = Math.sin( theta );\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tvar a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];\r\n\t\t\tvar a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];\r\n\r\n\t\t\tte[ 0 ] = c * a11 + s * a21;\r\n\t\t\tte[ 3 ] = c * a12 + s * a22;\r\n\t\t\tte[ 6 ] = c * a13 + s * a23;\r\n\r\n\t\t\tte[ 1 ] = - s * a11 + c * a21;\r\n\t\t\tte[ 4 ] = - s * a12 + c * a22;\r\n\t\t\tte[ 7 ] = - s * a13 + c * a23;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\ttranslate: function ( tx, ty ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tte[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];\r\n\t\t\tte[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tequals: function ( matrix ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = matrix.elements;\r\n\r\n\t\t\tfor ( var i = 0; i < 9; i ++ ) {\r\n\r\n\t\t\t\tif ( te[ i ] !== me[ i ] ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t},\r\n\r\n\t\tfromArray: function ( array, offset ) {\r\n\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\t\tfor ( var i = 0; i < 9; i ++ ) {\r\n\r\n\t\t\t\tthis.elements[ i ] = array[ i + offset ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\ttoArray: function ( array, offset ) {\r\n\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tarray[ offset ] = te[ 0 ];\r\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\r\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\r\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\t\t\tarray[ offset + 8 ] = te[ 8 ];\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t},\r\n\r\n\r\n\t\t\"_construct\" : function () {\r\n\r\n\t\t\tthis.elements = [\r\n\r\n\t\t\t\t1, 0, 0,\r\n\t\t\t\t0, 1, 0,\r\n\t\t\t\t0, 0, 1\r\n\r\n\t\t\t];\r\n\r\n\t\t\tif ( arguments.length > 0 ) {\r\n\r\n\t\t\t\tconsole.error( 'Matrix3: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t});\r\n\r\n\r\n\treturn numerics.Matrix3 = Matrix3;\r\n});\ndefine('skylark-langx-numerics/transform',[\r\n\t\"skylark-langx-klass\",\t\r\n    \"./numerics\",\r\n], function(klass,numerics) {\r\n\r\n    var Transform =  klass({\r\n        \"klassName\": \"Transform\",\r\n\t\t\"value\": {\r\n\t\t\tget : function(){\r\n\t\t\t\treturn this._.value;\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\treturn numerics.Transform =Transform;\r\n});\r\n\ndefine('skylark-langx-numerics/matrix-transform',[\r\n    \"./numerics\",\r\n\t\"./transform\"\r\n],function(numerics,Transform) {\r\n\r\n    var MatrixTransform =  Transform.inherit({\r\n        \"klassName\": \"MatrixTransform\",\r\n\r\n\t\t\"value\"\t:\t{\r\n\t\t\tget : function(){\r\n\t\t\t\treturn this.matrix.clone();\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t\"matrix\" : {\r\n\t\t\tget : function(){\r\n\t\t\t\treturn this._.matrix;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tclone : /*ScaleTransform*/function() {\r\n\t\t},\r\n\t\t\r\n\t\ttransform : /*Point*/function(/*Point*/point) {\r\n\t\t},\r\n\t\t\r\n\t\t//�w�肳�ꂽ���E�{�b�N�X��ϊ����A��������傤�Ǌi�[�ł���傫���̎����s���E�{�b�N�X��Ԃ��܂��B\r\n\t\ttransformBounds : /*Rect*/function(/*Rect*/rect) {\r\n\t\t},\t\t\r\n\t\t\"_construct\" : function(/*Martix*/matrix) {\r\n            var _ = this._ = {};\r\n\t\t\t\r\n\t\t\t_.matrix = matrix;\r\n\t\t}\r\n\t\t\t\t\r\n\t});\r\n\r\n\treturn numerics.MatrixTransform = MatrixTransform;\r\n\t\r\n});\t\r\n\ndefine('skylark-langx-numerics/plane',[\r\n\t\"skylark-langx-klass\",\r\n\t\"./numerics\",\r\n\t\"./matrix3\",\r\n\t\"./vector3\"\r\n] ,function(\r\n\tklass,\r\n\tnumerics,\r\n\tMatrix3,\r\n\tVector3\r\n) {\r\n\r\n\r\n\tvar _vector1 = new Vector3();\r\n\tvar _vector2 = new Vector3();\r\n\tvar _normalMatrix = new Matrix3();\r\n\r\n\tvar Plane = klass({\r\n\t\t\"klassName\" : \"Plane\",\r\n\r\n\t\tset: function ( normal, constant ) {\r\n\r\n\t\t\tthis.normal.copy( normal );\r\n\t\t\tthis.constant = constant;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetComponents: function ( x, y, z, w ) {\r\n\r\n\t\t\tthis.normal.set( x, y, z );\r\n\t\t\tthis.constant = w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\r\n\r\n\t\t\tthis.normal.copy( normal );\r\n\t\t\tthis.constant = - point.dot( this.normal );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetFromCoplanarPoints: function ( a, b, c ) {\r\n\r\n\t\t\tvar normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();\r\n\r\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\r\n\r\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tclone: function () {\r\n\r\n\t\t\treturn new this.constructor().copy( this );\r\n\r\n\t\t},\r\n\r\n\t\tcopy: function ( plane ) {\r\n\r\n\t\t\tthis.normal.copy( plane.normal );\r\n\t\t\tthis.constant = plane.constant;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tnormalize: function () {\r\n\r\n\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\r\n\r\n\t\t\tvar inverseNormalLength = 1.0 / this.normal.length();\r\n\t\t\tthis.normal.multiplyScalar( inverseNormalLength );\r\n\t\t\tthis.constant *= inverseNormalLength;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tnegate: function () {\r\n\r\n\t\t\tthis.constant *= - 1;\r\n\t\t\tthis.normal.negate();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tdistanceToPoint: function ( point ) {\r\n\r\n\t\t\treturn this.normal.dot( point ) + this.constant;\r\n\r\n\t\t},\r\n\r\n\t\tdistanceToSphere: function ( sphere ) {\r\n\r\n\t\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\r\n\r\n\t\t},\r\n\r\n\t\tprojectPoint: function ( point, target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'mathsPlane: .projectPoint() target is now required' );\r\n\t\t\t\ttarget = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );\r\n\r\n\t\t},\r\n\r\n\t\tintersectLine: function ( line, target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'mathsPlane: .intersectLine() target is now required' );\r\n\t\t\t\ttarget = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar direction = line.delta( _vector1 );\r\n\r\n\t\t\tvar denominator = this.normal.dot( direction );\r\n\r\n\t\t\tif ( denominator === 0 ) {\r\n\r\n\t\t\t\t// line is coplanar, return origin\r\n\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\r\n\r\n\t\t\t\t\treturn target.copy( line.start );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Unsure if this is the correct method to handle this case.\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\r\n\r\n\t\t\tif ( t < 0 || t > 1 ) {\r\n\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn target.copy( direction ).multiplyScalar( t ).add( line.start );\r\n\r\n\t\t},\r\n\r\n\t\tintersectsLine: function ( line ) {\r\n\r\n\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\r\n\r\n\t\t\tvar startSign = this.distanceToPoint( line.start );\r\n\t\t\tvar endSign = this.distanceToPoint( line.end );\r\n\r\n\t\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\r\n\r\n\t\t},\r\n\r\n\t\tintersectsBox: function ( box ) {\r\n\r\n\t\t\treturn box.intersectsPlane( this );\r\n\r\n\t\t},\r\n\r\n\t\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\t\treturn sphere.intersectsPlane( this );\r\n\r\n\t\t},\r\n\r\n\t\tcoplanarPoint: function ( target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'mathsPlane: .coplanarPoint() target is now required' );\r\n\t\t\t\ttarget = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\r\n\r\n\t\t},\r\n\r\n\t\tapplyMatrix4: function ( matrix, optionalNormalMatrix ) {\r\n\r\n\t\t\tvar normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );\r\n\r\n\t\t\tvar referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );\r\n\r\n\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\tthis.constant = - referencePoint.dot( normal );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\ttranslate: function ( offset ) {\r\n\r\n\t\t\tthis.constant -= offset.dot( this.normal );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tequals: function ( plane ) {\r\n\r\n\t\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\r\n\r\n\t\t},\r\n\r\n\r\n\t\t\"_construct\" : function( normal, constant ) {\r\n\r\n\t\t\t// normal is assumed to be normalized\r\n\r\n\t\t\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\r\n\t\t\tthis.constant = ( constant !== undefined ) ? constant : 0;\r\n\r\n\t\t}\r\n\r\n\t});\r\n\r\n\r\n\treturn numerics.Plane = Plane;\r\n});\ndefine('skylark-langx-numerics/rotate-transform',[\r\n    \"./numerics\",\r\n\t\"./transform\",\r\n\t\"./matrix-transform\"\r\n],function(numerics,Transform,Matrix) {\r\n\r\n\r\n    var RotateTransform = numerics.RotateTransform = Transform.inherit({\r\n        \"klassName\": \"RotateTransform\",\r\n\r\n        \"value\": {\r\n            get: function() {\r\n                return Matrix.rotateAt(this.angle, this.centerX, this.centerY);\r\n            }\r\n        },\r\n\r\n        \"angle\": {\r\n            get : function() {\r\n                return this._.angle;\r\n            }\r\n        },\r\n        // cy: Number\r\n        //\t\tThe Y coordinate of the center of the circle, default value 0.\r\n        \"centerX\": {\r\n            get : function() {\r\n                return this._.centerX;\r\n            }\r\n        },\r\n        // r: Number\r\n        //\t\tThe radius, default value 100.\r\n        \"centerY\": {\r\n            get : function() {\r\n                return this._.centerY;\r\n            }\r\n        },\r\n\r\n\t\tclone : /*ScaleTransform*/function() {\r\n\t\t},\r\n\t\t\r\n\t\ttransform : /*Point*/function(/*Point*/point) {\r\n\t\t},\r\n\t\t\r\n\t\ttransformBounds : /*Rect*/function(/*Rect*/rect) {\r\n\t\t},\r\n\t\t\r\n\t\t\"init\" : function(/*Number*/angle,/*Number*/centerX,/*Number*/centerY) {\r\n\t\t\tvar _ = this._ = {};\r\n\t\t\t_.angle = angle ? angle :0;\r\n\t\t\t_.centerX = centerX ? centerX :0;\r\n\t\t\t_.centerY = centerY ? centerY :0;\r\n\t\t}\r\n\t});\r\n\r\n\treturn RotateTransform;\r\n\t\r\n});\t\r\n\ndefine('skylark-langx-numerics/scale-transform',[\r\n    \"./numerics\",\r\n    \"./transform\",\r\n    \"./matrix-transform\"\r\n], function(numerics, Transform, Matrix) {\r\n\r\n   var ScaleTransform =  Transform.inherit({\r\n        \"klassName\": \"ScaleTransform\",\r\n\r\n        \"value\": {\r\n            get: function() {\r\n                    return Matrix.scaleAt(this.scaleX, this.scaleY, this.centerX, this.centerY);\r\n            }\r\n        },\r\n\r\n        \"scaleX\": {\r\n            get : function() {\r\n                return this._.scaleX;\r\n            }\r\n        },\r\n\r\n        \"scaleY\": {\r\n            get : function() {\r\n                return this._.scaleY;\r\n            }\r\n        },\r\n\r\n        // cy: Number\r\n        //      The Y coordinate of the center of the circle, default value 0.\r\n        \"centerX\": {\r\n            get : function() {\r\n                return this._.centerX;\r\n            }\r\n        },\r\n        // r: Number\r\n        //      The radius, default value 100.\r\n        \"centerY\": {\r\n            get : function() {\r\n                return this._.centerY;\r\n            }\r\n        },\r\n\r\n        clone: /*ScaleTransform*/ function() {},\r\n\r\n        transform: /*Point*/ function( /*Point*/ point) {},\r\n\r\n        transformBounds: /*Rect*/ function( /*Rect*/ rect) {},\r\n\r\n        \"_construct\": function( /*Number*/ scaleX, /*Number*/ scaleY, /*Number*/ centerX, /*Number*/ centerY) {\r\n            var _ = this._ = {};\r\n\r\n            _.scaleX = scaleX ? scaleX : 1;\r\n            _.scaleY = scaleY ? scaleY : 1;\r\n            _.centerX = centerX ? centerX : 0;\r\n            _.centerY = centerY ? centerY : 0;\r\n        }\r\n    });\r\n\r\n    return numerics.ScaleTransform = ScaleTransform;\r\n\r\n});\r\n\ndefine('skylark-langx-numerics/skew-transform',[\r\n    \"./numerics\",\r\n    \"./transform\",\r\n    \"./matrix-transform\"\r\n], function(numerics, Transform, Matrix) {\r\n\r\n   var SkewTransform = Transform.inherit({\r\n        \"klassName\": \"SkewTransform\",\r\n\r\n        \"value\": {\r\n            get: function() {\r\n                    return Matrix.scaleAt(this.skewX, this.skewY);\r\n            }\r\n        },\r\n\r\n        \"skewX\": {\r\n            get : function() {\r\n                return this._.skewX;\r\n            }\r\n        },\r\n\r\n        \"skewY\": {\r\n            get : function() {\r\n                return this._.skewY;\r\n            }\r\n        },\r\n\r\n        clone: /*SkewTransform*/ function() {},\r\n\r\n        transform: /*Point*/ function( /*Point*/ point) {},\r\n\r\n        transformBounds: /*Rect*/ function( /*Rect*/ rect) {},\r\n\r\n        \"_construct\": function( /*Number*/ skewX, /*Number*/ skewY) {\r\n            var _ = this._ = {};\r\n\r\n            _.skewX = skewX ? skewX : 0;\r\n            _.skewY = skewY ? skewY : 0;\r\n        }\r\n    });\r\n\r\n    return numerics.SkewTransform = SkewTransform;\r\n\r\n});\r\n\ndefine('skylark-langx-numerics/vector2',[\r\n\t\"skylark-langx-klass\",\r\n\t\"./numerics\"\r\n] ,function(klass,numerics) {\r\n\r\n\tvar Vector2 = klass({\r\n\t\t\"klassName\" : \"Vector2\",\r\n\r\n\t\tset: function ( x, y ) {\r\n\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetScalar: function ( scalar ) {\r\n\r\n\t\t\tthis.x = scalar;\r\n\t\t\tthis.y = scalar;\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\tsetX: function ( x ) {\r\n\r\n\t\t\tthis.x = x;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetY: function ( y ) {\r\n\r\n\t\t\tthis.y = y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\r\n\t\tclone: function () {\r\n\r\n\t\t\treturn new this.constructor( this.x, this.y );\r\n\r\n\t\t},\r\n\r\n\t\tcopy: function ( v ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tadd: function ( v, w ) {\r\n\r\n\t\t\tif ( w !== undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\taddScalar: function ( s ) {\r\n\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\taddVectors: function ( a, b ) {\r\n\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\taddScaledVector: function ( v, s ) {\r\n\r\n\t\t\tthis.x += v.x * s;\r\n\t\t\tthis.y += v.y * s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsub: function ( v, w ) {\r\n\r\n\t\t\tif ( w !== undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsubScalar: function ( s ) {\r\n\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsubVectors: function ( a, b ) {\r\n\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmultiply: function ( v ) {\r\n\r\n\t\t\tthis.x *= v.x;\r\n\t\t\tthis.y *= v.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\t\tthis.x *= scalar;\r\n\t\t\tthis.y *= scalar;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tdivide: function ( v ) {\r\n\r\n\t\t\tthis.x /= v.x;\r\n\t\t\tthis.y /= v.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tdivideScalar: function ( scalar ) {\r\n\r\n\t\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t\t},\r\n\r\n\t\tapplyMatrix3: function ( m ) {\r\n\r\n\t\t\tvar x = this.x, y = this.y;\r\n\t\t\tvar e = m.elements;\r\n\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmin: function ( v ) {\r\n\r\n\t\t\tthis.x = Math.min( this.x, v.x );\r\n\t\t\tthis.y = Math.min( this.y, v.y );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmax: function ( v ) {\r\n\r\n\t\t\tthis.x = Math.max( this.x, v.x );\r\n\t\t\tthis.y = Math.max( this.y, v.y );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tclamp: function ( min, max ) {\r\n\r\n\t\t\t// assumes min < max, componentwise\r\n\r\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tclampScalar: function ( minVal, maxVal ) {\r\n\r\n\t\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\r\n\t\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tclampLength: function ( min, max ) {\r\n\r\n\t\t\tvar length = this.length();\r\n\r\n\t\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\r\n\r\n\t\t},\r\n\r\n\t\tfloor: function () {\r\n\r\n\t\t\tthis.x = Math.floor( this.x );\r\n\t\t\tthis.y = Math.floor( this.y );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tceil: function () {\r\n\r\n\t\t\tthis.x = Math.ceil( this.x );\r\n\t\t\tthis.y = Math.ceil( this.y );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tround: function () {\r\n\r\n\t\t\tthis.x = Math.round( this.x );\r\n\t\t\tthis.y = Math.round( this.y );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\troundToZero: function () {\r\n\r\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tnegate: function () {\r\n\r\n\t\t\tthis.x = - this.x;\r\n\t\t\tthis.y = - this.y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tdot: function ( v ) {\r\n\r\n\t\t\treturn this.x * v.x + this.y * v.y;\r\n\r\n\t\t},\r\n\r\n\t\tcross: function ( v ) {\r\n\r\n\t\t\treturn this.x * v.y - this.y * v.x;\r\n\r\n\t\t},\r\n\r\n\t\tlengthSq: function () {\r\n\r\n\t\t\treturn this.x * this.x + this.y * this.y;\r\n\r\n\t\t},\r\n\r\n\t\tlength: function () {\r\n\r\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\r\n\r\n\t\t},\r\n\r\n\t\tmanhattanLength: function () {\r\n\r\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y );\r\n\r\n\t\t},\r\n\r\n\t\tnormalize: function () {\r\n\r\n\t\t\treturn this.divideScalar( this.length() || 1 );\r\n\r\n\t\t},\r\n\r\n\t\tangle: function () {\r\n\r\n\t\t\t// computes the angle in radians with respect to the positive x-axis\r\n\r\n\t\t\tvar angle = Math.atan2( - this.y, - this.x ) + Math.PI;\r\n\r\n\t\t\treturn angle;\r\n\r\n\t\t},\r\n\r\n\t\tdistanceTo: function ( v ) {\r\n\r\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t\t},\r\n\r\n\t\tdistanceToSquared: function ( v ) {\r\n\r\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y;\r\n\t\t\treturn dx * dx + dy * dy;\r\n\r\n\t\t},\r\n\r\n\t\tmanhattanDistanceTo: function ( v ) {\r\n\r\n\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\r\n\r\n\t\t},\r\n\r\n\t\tsetLength: function ( length ) {\r\n\r\n\t\t\treturn this.normalize().multiplyScalar( length );\r\n\r\n\t\t},\r\n\r\n\t\tlerp: function ( v, alpha ) {\r\n\r\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t\t},\r\n\r\n\t\tequals: function ( v ) {\r\n\r\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\r\n\r\n\t\t},\r\n\r\n\t\tfromArray: function ( array, offset ) {\r\n\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\t\tthis.x = array[ offset ];\r\n\t\t\tthis.y = array[ offset + 1 ];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\ttoArray: function ( array, offset ) {\r\n\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\t\tarray[ offset ] = this.x;\r\n\t\t\tarray[ offset + 1 ] = this.y;\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t},\r\n\r\n\r\n\t\trotateAround: function ( center, angle ) {\r\n\r\n\t\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\r\n\r\n\t\t\tvar x = this.x - center.x;\r\n\t\t\tvar y = this.y - center.y;\r\n\r\n\t\t\tthis.x = x * c - y * s + center.x;\r\n\t\t\tthis.y = x * s + y * c + center.y;\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t\"_construct\" : function ( x, y ) {\r\n\r\n\t\t\tthis.x = x || 0;\r\n\t\t\tthis.y = y || 0;\r\n\r\n\t\t}\r\n\r\n\r\n\t});\r\n\r\n\r\n\t/*\r\n\tObject.defineProperties( Vector2.prototype, {\r\n\r\n\t\t\"width\": {\r\n\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this.x;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis.x = value;\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t\"height\": {\r\n\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this.y;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis.y = value;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\t*/\r\n\r\n\r\n\r\n\r\n\treturn numerics.Vector2 = Vector2 ;\r\n});\r\n\ndefine( 'skylark-langx-numerics/transform-matrix',[\r\n    \"skylark-langx-klass\",\r\n    \"./numerics\",\r\n    \"./vector2\"\r\n], function(klass,numerics,Vector2){\r\n\t// reference easeljs/numerics/Matrix2D  and dojox/gfx/matrix\r\n\t\r\n\tvar DEG_TO_RAD = Math.PI/180;\r\n\tvar _degToRadCache = {};\r\n\tvar degToRad = function(degree){\r\n\t\treturn _degToRadCache[degree] || (_degToRadCache[degree] = (Math.PI * degree / 180));\r\n\t};\r\n\tvar radToDeg = function(radian){ return radian / Math.PI * 180; };\r\n\t\r\n\r\n\t//Represents a 3 x 3 affine transformation matrix used for transformation in 2-D space.\r\n\t//|----------|\r\n\t//|m11|m21|dx| \r\n\t//|----------|\r\n\t//|m12|m22|dy|\r\n\t//|----------|\r\n\t//|  0|  0| 1|\r\n\t//|----------|\r\n\t\r\n    var TransformMatrix =  klass({\r\n        \"klassName\": \"TransformMatrix\",\r\n\r\n\t\t\"_multiplyPoint\"\t: \tfunction(p){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tapplies the matrix to a point\r\n\t\t\t// p: Point\r\n\t\t\t//\t\ta point\r\n\t\t\t// returns: Point\r\n\t\t\tvar _ = this._,\r\n\t\t\t\tx = p.x * _.m11 + p.y * _.m21  + _.dx,\r\n\t\t\t    y = p.x * _.m12 +  p.y * _.m22 + _.dy;\r\n\r\n\t\t\treturn new Vector2(x,y); // Point\r\n\t\t},\r\n\r\n       \"m11\": {\r\n       \t\t//Position (0, 0) in a 3x3 affine transformation matrix.\r\n            get : function() {\r\n                return this._.m11;\r\n            }\r\n        },\r\n\r\n       \"m12\": {\r\n       \t\t//Position (0, 1) in a 3x3 affine transformation matrix.\r\n            get : function() {\r\n                return this._.m12;\r\n            }\r\n        },\r\n\r\n       \"m21\": {\r\n       \t\t//Position (1, 0) in a 3x3 affine transformation matrix.\r\n            get : function() {\r\n                return this._.m21;\r\n            }\r\n        },\r\n\r\n       \"m22\": {\r\n       \t\t//Position (1, 1) in a 3x3 affine transformation matrix.\r\n            get : function() {\r\n                return this._.m22;\r\n            }\r\n        },\r\n\r\n       \"dx\": {\r\n       \t\t// Position (2, 1) in a 3x3 affine transformation matrix.\r\n            get : function() {\r\n                return this._.dx;\r\n            }\r\n        },\r\n\r\n       \"dy\": {\r\n       \t\t// Position (2, 1) in a 3x3 affine transformation matrix.\r\n            get : function() {\r\n                return this._.dy;\r\n            }\r\n        },\r\n\r\n       \"alpha\": {\r\n       \t\t// Property representing the alpha that will be applied to a display object. This is not part of matrix\r\n       \t\t// operations, but is used for operations like getConcatenatedMatrix to provide concatenated alpha values.\r\n            get : function() {\r\n                return this._.alpha;\r\n            }\r\n        },\r\n\r\n       \"shadow\": {\r\n       \t\t// Property representing the shadow that will be applied to a display object. This is not part of matrix\r\n       \t\t// operations, but is used for operations like getConcatenatedMatrix to provide concatenated shadow values..\r\n            get : function() {\r\n                return this._.shadow;\r\n            }\r\n        },\r\n\r\n       \"compositeOperation\": {\r\n\t\t\t/**\r\n\t\t\t * Property representing the compositeOperation that will be applied to a display object. This is not part of\r\n\t\t\t * matrix operations, but is used for operations like getConcatenatedMatrix to provide concatenated\r\n\t\t\t * compositeOperation values. You can find a list of valid composite operations at:\r\n\t\t\t * <a href=\"https://developer.mozilla.org/en/Canvas_tutorial/Compositing\">https://developer.mozilla.org/en/Canvas_tutorial/Compositing</a>\r\n\t\t\t * @property compositeOperation\r\n\t\t\t * @type String\r\n\t\t\t **/\r\n            get : function() {\r\n                return this._.compositeOperation;\r\n            }\r\n        },\r\n\r\n        //Converts the specified point with TransformMatrix and returns the result.\r\n\t\tmultiplyPoint: /*Vector2*/function(/*Vector2 */ p){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tapplies the matrix to a point\r\n\t\t\treturn this._multiplyPoint(p); // Vector2\r\n\t\t},\r\n\t\t\t\t/**\r\n\t\t\t\t * 指定した矩形を TransformMatrix で変換し、その結果を返します。\r\n\t\t\t\t */\r\n\t\tmultiplyRectangle: /*Rect*/function(/*Rect*/ rect){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tApplies the matrix to a rectangle.\r\n\t\t\t// returns: Rect\r\n\t\t\tif(this.isIdentity())\r\n\t\t\t\treturn rect.clone(); // Rect\r\n\t\t\tvar p0 = this.multiplyPoint(rect.leftTop),\r\n\t\t\t\tp1 = this.multiplyPoint(rect.leftBottom),\r\n\t\t\t\tp2 = this.multiplyPoint(rect.right),\r\n\t\t\t\tp3 = this.multiplyPoint(rect.rightBottom),\r\n\t\t\t\tminx = Math.min(p0.x, p1.x, p2.x, p3.x),\r\n\t\t\t\tminy = Math.min(p0.y, p1.y, p2.y, p3.y),\r\n\t\t\t\tmaxx = Math.max(p0.x, p1.x, p2.x, p3.x),\r\n\t\t\t\tmaxy = Math.max(p0.y, p1.y, p2.y, p3.y);\r\n\t\t\treturn new Rect(minx,miny,maxx-minx,maxy-miny);  // Rect\r\n\t\t},\r\n\t\t/**\r\n\t\t * Concatenates the specified matrix properties with this matrix. All parameters are required.\r\n\t\t * @method prepend\r\n\t\t * @param {Number} m11\r\n\t\t * @param {Number} m12\r\n\t\t * @param {Number} m21\r\n\t\t * @param {Number} m22\r\n\t\t * @param {Number} dx\r\n\t\t * @param {Number} dy\r\n\t\t * @return {TransformMatrix} This matrix. Useful for chaining method calls.\r\n\t\t **/\r\n\t\tprepend : function(m11, m12, m21, m22, dx, dy) {\r\n\t\t\tvar tx1 = this.dx;\r\n\t\t\tif (m11 != 1 || m12 != 0 || m21 != 0 || m22 != 1) {\r\n\t\t\t\tvar a1 = this.m11;\r\n\t\t\t\tvar c1 = this.m21;\r\n\t\t\t\tthis.m11  = a1*m11+this.m12*m21;\r\n\t\t\t\tthis.m12  = a1*m12+this.m12*m22;\r\n\t\t\t\tthis.m21  = c1*m11+this.m22*m21;\r\n\t\t\t\tthis.m22  = c1*m12+this.m22*m22;\r\n\t\t\t}\r\n\t\t\tthis.dx = tx1*m11+this.dy*m21+dx;\r\n\t\t\tthis.dy = tx1*m12+this.dy*m22+dy;\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Appends the specified matrix properties with this matrix. All parameters are required.\r\n\t\t * 指定した Matrixをこの Matrixに追加します。\r\n\t\t * @method append\r\n\t\t * @param {Number} m11\r\n\t\t * @param {Number} m12\r\n\t\t * @param {Number} m21\r\n\t\t * @param {Number} m22\r\n\t\t * @param {Number} dx\r\n\t\t * @param {Number} dy\r\n\t\t * @return {TransformMatrix} This matrix. Useful for chaining method calls.\r\n\t\t **/\r\n\t\tappend : function(m11, m12, m21, m22, dx, dy) {\r\n\t\t\tvar a1 = this.m11;\r\n\t\t\tvar b1 = this.m12;\r\n\t\t\tvar c1 = this.m21;\r\n\t\t\tvar d1 = this.m22;\r\n\r\n\t\t\tthis.m11  = m11*a1+m12*c1;\r\n\t\t\tthis.m12  = m11*b1+m12*d1;\r\n\t\t\tthis.m21  = m21*a1+m22*c1;\r\n\t\t\tthis.m22  = m21*b1+m22*d1;\r\n\t\t\tthis.dx = dx*a1+dy*c1+this.dx;\r\n\t\t\tthis.dy = dx*b1+dy*d1+this.dy;\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Prepends the specified matrix with this matrix.\r\n\t\t * @method prependMatrix\r\n\t\t * @param {TransformMatrix} matrix\r\n\t\t **/\r\n\t\tprependMatrix : function(matrix) {\r\n\t\t\tthis.prepend(matrix.m11, matrix.m12, matrix.m21, matrix.m22, matrix.dx, matrix.dy);\r\n\t\t\tthis.prependProperties(matrix.alpha, matrix.shadow,  matrix.compositeOperation);\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Appends the specified matrix with this matrix.\r\n\t\t * 指定した Matrixをこの Matrixに追加します。\r\n\t\t * @method appendMatrix\r\n\t\t * @param {TransformMatrix} matrix\r\n\t\t * @return {TransformMatrix} This matrix. Useful for chaining method calls.\r\n\t\t **/\r\n\t\tappendMatrix : function(matrix) {\r\n\t\t\tthis.append(matrix.m11, matrix.m12, matrix.m21, matrix.m22, matrix.dx, matrix.dy);\r\n\t\t\tthis.appendProperties(matrix.alpha, matrix.shadow,  matrix.compositeOperation);\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Generates matrix properties from the specified display object transform properties, and prepends them with this matrix.\r\n\t\t * For example, you can use this to generate a matrix from a display object: var mtx = new TransformMatrix();\r\n\t\t * mtx.prependTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);\r\n\t\t * @method prependTransform\r\n\t\t * @param {Number} x\r\n\t\t * @param {Number} y\r\n\t\t * @param {Number} scaleX\r\n\t\t * @param {Number} scaleY\r\n\t\t * @param {Number} rotation\r\n\t\t * @param {Number} skewX\r\n\t\t * @param {Number} skewY\r\n\t\t * @param {Number} regX Optional.\r\n\t\t * @param {Number} regY Optional.\r\n\t\t * @return {TransformMatrix} This matrix. Useful for chaining method calls.\r\n\t\t **/\r\n\t\tprependTransform : function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {\r\n\t\t\tif (rotation%360) {\r\n\t\t\t\tvar r = rotation*DEG_TO_RAD;\r\n\t\t\t\tvar cos = Math.cos(r);\r\n\t\t\t\tvar sin = Math.sin(r);\r\n\t\t\t} else {\r\n\t\t\t\tcos = 1;\r\n\t\t\t\tsin = 0;\r\n\t\t\t}\r\n\r\n\t\t\tif (regX || regY) {\r\n\t\t\t\t// append the registration offset:\r\n\t\t\t\tthis.dx -= regX; this.dy -= regY;\r\n\t\t\t}\r\n\t\t\tif (skewX || skewY) {\r\n\t\t\t\t// TODO: can this be combined into a single prepend operation?\r\n\t\t\t\tskewX *= DEG_TO_RAD;\r\n\t\t\t\tskewY *= DEG_TO_RAD;\r\n\t\t\t\tthis.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);\r\n\t\t\t\tthis.prepend(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);\r\n\t\t\t} else {\r\n\t\t\t\tthis.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Generates matrix properties from the specified display object transform properties, and appends them with this matrix.\r\n\t\t * For example, you can use this to generate a matrix from a display object: var mtx = new TransformMatrix();\r\n\t\t * mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);\r\n\t\t * @method appendTransform\r\n\t\t * @param {Number} x\r\n\t\t * @param {Number} y\r\n\t\t * @param {Number} scaleX\r\n\t\t * @param {Number} scaleY\r\n\t\t * @param {Number} rotation\r\n\t\t * @param {Number} skewX\r\n\t\t * @param {Number} skewY\r\n\t\t * @param {Number} regX Optional.\r\n\t\t * @param {Number} regY Optional.\r\n\t\t * @return {TransformMatrix} This matrix. Useful for chaining method calls.\r\n\t\t **/\r\n\t\tappendTransform : function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {\r\n\t\t\tif (rotation%360) {\r\n\t\t\t\tvar r = rotation*DEG_TO_RAD;\r\n\t\t\t\tvar cos = Math.cos(r);\r\n\t\t\t\tvar sin = Math.sin(r);\r\n\t\t\t} else {\r\n\t\t\t\tcos = 1;\r\n\t\t\t\tsin = 0;\r\n\t\t\t}\r\n\r\n\t\t\tif (skewX || skewY) {\r\n\t\t\t\t// TODO: can this be combined into a single append?\r\n\t\t\t\tskewX *= DEG_TO_RAD;\r\n\t\t\t\tskewY *= DEG_TO_RAD;\r\n\t\t\t\tthis.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);\r\n\t\t\t\tthis.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);\r\n\t\t\t} else {\r\n\t\t\t\tthis.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);\r\n\t\t\t}\r\n\r\n\t\t\tif (regX || regY) {\r\n\t\t\t\t// prepend the registration offset:\r\n\t\t\t\tthis.dx -= regX*this.m11+regY*this.m21; \r\n\t\t\t\tthis.dy -= regX*this.m12+regY*this.m22;\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Applies a rotation transformation to the matrix.\r\n\t\t * @method rotate\r\n\t\t * @param {Number} angle The angle in degrees.\r\n\t\t * @return {TransformMatrix} This matrix. Useful for chaining method calls.\r\n\t\t **/\r\n\t\trotate : function(angle) {\r\n\t\t\tvar cos = Math.cos(angle);\r\n\t\t\tvar sin = Math.sin(angle);\r\n\r\n\t\t\tvar a1 = this.m11;\r\n\t\t\tvar c1 = this.m21;\r\n\t\t\tvar tx1 = this.dx;\r\n\r\n\t\t\tthis.m11 = a1*cos-this.m12*sin;\r\n\t\t\tthis.m12 = a1*sin+this.m12*cos;\r\n\t\t\tthis.m21 = c1*cos-this.m22*sin;\r\n\t\t\tthis.m22 = c1*sin+this.m22*cos;\r\n\t\t\tthis.dx = tx1*cos-this.dy*sin;\r\n\t\t\tthis.dy = tx1*sin+this.dy*cos;\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Applies a skew transformation to the matrix.\r\n\t\t * @method skew\r\n\t\t * @param {Number} skewX The amount to skew horizontally in degrees.\r\n\t\t * @param {Number} skewY The amount to skew vertically in degrees.\r\n\t\t * @return {TransformMatrix} This matrix. Useful for chaining method calls.\r\n\t\t*/\r\n\t\tskew : function(skewX, skewY) {\r\n\t\t\tskewX = skewX*DEG_TO_RAD;\r\n\t\t\tskewY = skewY*DEG_TO_RAD;\r\n\t\t\tthis.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), 0, 0);\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Applies a scale transformation to the matrix.\r\n\t\t * @method scale\r\n\t\t * @param {Number} x\r\n\t\t * @param {Number} y\r\n\t\t * @return {TransformMatrix} This matrix. Useful for chaining method calls.\r\n\t\t **/\r\n\t\tscale : function(x, y) {\r\n\t\t\tthis.m11 *= x;\r\n\t\t\tthis.m22 *= y;\r\n\t\t\tthis.dx *= x;\r\n\t\t\tthis.dy *= y;\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Translates the matrix on the x and y axes.\r\n\t\t * @method translate\r\n\t\t * @param {Number} x\r\n\t\t * @param {Number} y\r\n\t\t * @return {TransformMatrix} This matrix. Useful for chaining method calls.\r\n\t\t **/\r\n\t\ttranslate : function(x, y) {\r\n\t\t\tthis.dx += x;\r\n\t\t\tthis.dy += y;\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Sets the properties of the matrix to those of an identity matrix (one that applies a null transformation).\r\n\t\t * @method identity\r\n\t\t * @return {TransformMatrix} This matrix. Useful for chaining method calls.\r\n\t\t **/\r\n\t\tidentity : function() {\r\n\t\t\tthis.alpha = this.m11 = this.m22 = 1;\r\n\t\t\tthis.m12 = this.m21 = this.dx = this.dy = 0;\r\n\t\t\tthis.shadow = this.compositeOperation = null;\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Inverts the matrix, causing it to perform the opposite transformation.\r\n\t\t * @method invert\r\n\t\t * @return {TransformMatrix} This matrix. Useful for chaining method calls.\r\n\t\t **/\r\n\t\tinvert : function() {\r\n\t\t\tvar a1 = this.m11;\r\n\t\t\tvar b1 = this.m12;\r\n\t\t\tvar c1 = this.m21;\r\n\t\t\tvar d1 = this.m22;\r\n\t\t\tvar tx1 = this.dx;\r\n\t\t\tvar n = a1*d1-b1*c1;\r\n\r\n\t\t\tthis.m11 = d1/n;\r\n\t\t\tthis.m12 = -b1/n;\r\n\t\t\tthis.m21 = -c1/n;\r\n\t\t\tthis.m22 = a1/n;\r\n\t\t\tthis.dx = (c1*this.dy-d1*tx1)/n;\r\n\t\t\tthis.dy = -(a1*this.dy-b1*tx1)/n;\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns true if the matrix is an identity matrix.\r\n\t\t * @method isIdentity\r\n\t\t * @return {Boolean}\r\n\t\t **/\r\n\t\tisIdentity : function() {\r\n\t\t\treturn this.dx == 0 && this.dy == 0 && this.m11 == 1 && this.m12 == 0 && this.m21 == 0 && this.m22 == 1;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Decomposes the matrix into transform properties (x, y, scaleX, scaleY, and rotation). Note that this these values\r\n\t\t * may not match the transform properties you used to generate the matrix, though they will produce the same visual\r\n\t\t * results.\r\n\t\t * @method decompose\r\n\t\t * @param {Object} target The object to apply the transform properties to. If null, then a new object will be returned.\r\n\t\t * @return {TransformMatrix} This matrix. Useful for chaining method calls.\r\n\t\t*/\r\n\t\tdecompose : function(target) {\r\n\t\t\t// TODO: it would be nice to be able to solve for whether the matrix can be decomposed into only scale/rotation\r\n\t\t\t// even when scale is negative\r\n\t\t\tif (target == null) { target = {}; }\r\n\t\t\ttarget.x = this.dx;\r\n\t\t\ttarget.y = this.dy;\r\n\t\t\ttarget.scaleX = Math.sqrt(this.m11 * this.m11 + this.m12 * this.m12);\r\n\t\t\ttarget.scaleY = Math.sqrt(this.m21 * this.m21 + this.m22 * this.m22);\r\n\r\n\t\t\tvar skewX = Math.atan2(-this.m21, this.m22);\r\n\t\t\tvar skewY = Math.atan2(this.m12, this.m11);\r\n\r\n\t\t\tif (skewX == skewY) {\r\n\t\t\t\ttarget.rotation = skewY/DEG_TO_RAD;\r\n\t\t\t\tif (this.m11 < 0 && this.m22 >= 0) {\r\n\t\t\t\t\ttarget.rotation += (target.rotation <= 0) ? 180 : -180;\r\n\t\t\t\t}\r\n\t\t\t\ttarget.skewX = target.skewY = 0;\r\n\t\t\t} else {\r\n\t\t\t\ttarget.skewX = skewX/DEG_TO_RAD;\r\n\t\t\t\ttarget.skewY = skewY/DEG_TO_RAD;\r\n\t\t\t}\r\n\t\t\treturn target;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Reinitializes all matrix properties to those specified.\r\n\t\t * @method appendProperties\r\n\t\t * @param {Number} m11\r\n\t\t * @param {Number} m12\r\n\t\t * @param {Number} m21\r\n\t\t * @param {Number} m22\r\n\t\t * @param {Number} dx\r\n\t\t * @param {Number} dy\r\n\t\t * @param {Number} alpha desired alpha value\r\n\t\t * @param {Shadow} shadow desired shadow value\r\n\t\t * @param {String} compositeOperation desired composite operation value\r\n\t\t * @return {TransformMatrix} This matrix. Useful for chaining method calls.\r\n\t\t*/\r\n\t\treinitialize : function(m11,m12,m21,m22,dx,dy,alpha,shadow,compositeOperation) {\r\n\t\t\tthis._initialize(m11,m12,m21,m22,dx,dy);\r\n\t\t\tthis.alpha = alpha || 1;\r\n\t\t\tthis.shadow = shadow;\r\n\t\t\tthis.compositeOperation = compositeOperation;\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Appends the specified visual properties to the current matrix.\r\n\t\t * @method appendProperties\r\n\t\t * @param {Number} alpha desired alpha value\r\n\t\t * @param {Shadow} shadow desired shadow value\r\n\t\t * @param {String} compositeOperation desired composite operation value\r\n\t\t * @return {TransformMatrix} This matrix. Useful for chaining method calls.\r\n\t\t*/\r\n\t\tappendProperties : function(alpha, shadow, compositeOperation) {\r\n\t\t\tthis.alpha *= alpha;\r\n\t\t\tthis.shadow = shadow || this.shadow;\r\n\t\t\tthis.compositeOperation = compositeOperation || this.compositeOperation;\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Prepends the specified visual properties to the current matrix.\r\n\t\t * @method prependProperties\r\n\t\t * @param {Number} alpha desired alpha value\r\n\t\t * @param {Shadow} shadow desired shadow value\r\n\t\t * @param {String} compositeOperation desired composite operation value\r\n\t\t * @return {TransformMatrix} This matrix. Useful for chaining method calls.\r\n\t\t*/\r\n\t\tprependProperties : function(alpha, shadow, compositeOperation) {\r\n\t\t\tthis.alpha *= alpha;\r\n\t\t\tthis.shadow = this.shadow || shadow;\r\n\t\t\tthis.compositeOperation = this.compositeOperation || compositeOperation;\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t *Multiply TransformMatrix by another TransformMatrix.\r\n\t\t */\r\n\t\tmultiply: function(matrix){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tcombines matrices by multiplying them sequentially in the given order\r\n\t\t\t// matrix: TransformMatrix\r\n\t\t\t//\t\ta 2D matrix-like object,\r\n\t\t\t//\t\tall subsequent arguments are matrix-like objects too\r\n\r\n\t\t\t// combine matrices\r\n\t\t\tvar m11 = this.m11,m12 = this.m12,m21 = this.m21,m22=this.m22,dx=this.dx,dy=this.dy;\r\n\t\t\tvar r = matrix;\r\n\t\t\tthis.m11 = m11 * r.m11 + m21 * r.m12;\r\n\t\t\tthis.m12 = m12 * r.m11 + m22 * r.m12;\r\n\t\t\tthis.m21 = m11 * r.m21 + m21 * r.m22;\r\n\t\t\tthis.m22 = m12 * r.m21 + m22 * r.m22;\r\n\t\t\tthis.dx =  m11 * r.dx + m21 * r.dy + dx;\r\n\t\t\tthis.dy =  m12 * r.dx + m22 * r.dy + dy;\r\n\t\t\treturn this // TransformMatrix\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a clone of the TransformMatrix instance.\r\n\t\t * @method clone\r\n\t\t * @return {TransformMatrix} a clone of the TransformMatrix instance.\r\n\t\t **/\r\n\t\tclone : function() {\r\n\r\n\t\t\tvar _ = this._,\r\n\t\t\t\tmtx = new TransformMatrix(_.m11, _.m12, _.m21, _.m22, _.dx, _.dy);\r\n\t\t\tmtx.shadow = this.shadow;\r\n\t\t\tmtx.alpha = this.alpha;\r\n\t\t\tmtx.compositeOperation = this.compositeOperation;\r\n\t\t\treturn mtx;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a string representation of this object.\r\n\t\t * @method toString\r\n\t\t * @return {String} a string representation of the instance.\r\n\t\t **/\r\n\t\ttoString : function() {\r\n\t\t\tvar _ = this._;\r\n\t\t\treturn \"[TransformMatrix (m11=\"+_.m11+\" m12=\"+_.m12+\" m21=\"+_.m21+\" m22=\"+_.m22+\" dx=\"+_.dx+\" dy=\"+_.dy+\")]\";\r\n\t\t},\r\n\t\t\r\n\t\t\"_construct\" : function(m11, m12, m21, m22, dx, dy) {\r\n\t\t\tvar _ = this._ = {};\r\n\t\t\t_.m11 = m11 || 1;\r\n\t\t\t_.m12 = m12 || 0;\r\n\t\t\t_.m21 = m21 || 0;\r\n\t\t\t_.m22 = m22 || 1;\r\n\t\t\t_.dx = dx || 0;\r\n\t\t\t_.dy = dy || 0;\r\n\t\t}\r\n\r\n\t});\r\n\t\r\n\tObject.assign(TransformMatrix,{\r\n\t\ttranslate: function(a, b){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tforms a translation matrix\r\n\t\t\t// description:\r\n\t\t\t//\t\tThe resulting matrix is used to translate (move) points by specified offsets.\r\n\t\t\t// a: Number\r\n\t\t\t//\t\tan x coordinate value\r\n\t\t\t// b: Number\r\n\t\t\t//\t\ta y coordinate value\r\n\t\t\t// returns: TransformMatrix\r\n\t\t\t//|----------| |-----------|\r\n\t\t\t//|m11|m21|dx| |  1|   0| a|\r\n\t\t\t//|----------| |-----------|\r\n\t\t\t//|m12|m22|dy| |  0|   1| b|\r\n\t\t\t//|----------| |-----------|\r\n\t\t\t//|  0|  0| 1| |  0|   0| 1|\r\n\t\t\t//|----------| |-----------|\r\n\r\n\t\t\treturn new TransformMatrix(1,0,0,1,a,b); // TransformMatrix\r\n\t\t},\r\n\t\tscale: function(a, b){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tforms a scaling matrix\r\n\t\t\t// description:\r\n\t\t\t//\t\tThe resulting matrix is used to scale (magnify) points by specified offsets.\r\n\t\t\t// a: Number\r\n\t\t\t//\t\ta scaling factor used for the x coordinate\r\n\t\t\t// b: Number?\r\n\t\t\t//\t\ta scaling factor used for the y coordinate\r\n\t\t\t// returns: TransformMatrix\r\n\t\t\t//|----------| |-----------|\r\n\t\t\t//|m11|m21|dx| |  a|   0| 0|\r\n\t\t\t//|----------| |-----------|\r\n\t\t\t//|m12|m22|dy| |  0|   b| 0|\r\n\t\t\t//|----------| |-----------|\r\n\t\t\t//|  0|  0| 1| |  0|   0| 1|\r\n\t\t\t//|----------| |-----------|\r\n\t\t\treturn new TransformMatrix(a,0,0,b?b:a,0,0); // TransformMatrix\r\n\t\t},\r\n\t\trotate: function(angle){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tforms a rotating matrix\r\n\t\t\t// description:\r\n\t\t\t//\t\tThe resulting matrix is used to rotate points\r\n\t\t\t//\t\taround the origin of coordinates (0, 0) by specified angle.\r\n\t\t\t// angle: Number\r\n\t\t\t//\t\tan angle of rotation in radians (>0 for CW)\r\n\t\t\t// returns: TransformMatrix\r\n\t\t\t//|----------| |-----------|\r\n\t\t\t//|m11|m21|dx| |cos|-sin| 0|\r\n\t\t\t//|----------| |-----------|\r\n\t\t\t//|m12|m22|dy| |sin| cos| 0|\r\n\t\t\t//|----------| |-----------|\r\n\t\t\t//|  0|  0| 1| |  0|   0| 1|\r\n\t\t\t//|----------| |-----------|\r\n\t\t\tvar cos = Math.cos(angle);\r\n\t\t\tvar sin = Math.sin(angle);\r\n\t\t\treturn new TransformMatrix(cos,sin,-sin,cos,0,0); // TransformMatrix\r\n\t\t},\r\n\t\trotateg: function(degree){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tforms a rotating matrix\r\n\t\t\t// description:\r\n\t\t\t//\t\tThe resulting matrix is used to rotate points\r\n\t\t\t//\t\taround the origin of coordinates (0, 0) by specified degree.\r\n\t\t\t//\t\tSeerotate() for comparison.\r\n\t\t\t// degree: Number\r\n\t\t\t//\t\tan angle of rotation in degrees (>0 for CW)\r\n\t\t\t// returns: TransformMatrix\r\n\t\t\treturn this.rotate(degToRad(degree)); // TransformMatrix\r\n\t\t},\r\n\t\tskewX: function(angle) {\r\n\t\t\t//TODO : will be modified\r\n\t\t\t// summary:\r\n\t\t\t//\t\tforms an x skewing matrix\r\n\t\t\t// description:\r\n\t\t\t//\t\tThe resulting matrix is used to skew points in the x dimension\r\n\t\t\t//\t\taround the origin of coordinates (0, 0) by specified angle.\r\n\t\t\t// angle: Number\r\n\t\t\t//\t\ta skewing angle in radians\r\n\t\t\t// returns: TransformMatrix\r\n\t\t\t//|----------| |-----------|\r\n\t\t\t//|m11|m21|dx| |  1| tan| 0|\r\n\t\t\t//|----------| |-----------|\r\n\t\t\t//|m12|m22|dy| |  0|   1| 0|\r\n\t\t\t//|----------| |-----------|\r\n\t\t\t//|  0|  0| 1| |  0|   0| 1|\r\n\t\t\t//|----------| |-----------|\r\n\t\t\tvar tan = Math.tan(angle);\r\n\t\t\treturn new TransformMatrix(1,0,tan,1); // TransformMatrix\r\n\t\t},\r\n\t\tskewXg: function(degree){\r\n\t\t\t//TODO : will be modified\r\n\t\t\t// summary:\r\n\t\t\t//\t\tforms an x skewing matrix\r\n\t\t\t// description:\r\n\t\t\t//\t\tThe resulting matrix is used to skew points in the x dimension\r\n\t\t\t//\t\taround the origin of coordinates (0, 0) by specified degree.\r\n\t\t\t//\t\tSee dojox/gfx/matrix.skewX() for comparison.\r\n\t\t\t// degree: Number\r\n\t\t\t//\t\ta skewing angle in degrees\r\n\t\t\t// returns: TransformMatrix\r\n\t\t\treturn this.skewX(degToRad(degree)); // dojox/gfx/matrix.TransformMatrix\r\n\t\t},\r\n\t\tskewY: function(angle){\r\n\t\t\t//TODO : will be modified\r\n\t\t\t// summary:\r\n\t\t\t//\t\tforms a y skewing matrix\r\n\t\t\t// description:\r\n\t\t\t//\t\tThe resulting matrix is used to skew points in the y dimension\r\n\t\t\t//\t\taround the origin of coordinates (0, 0) by specified angle.\r\n\t\t\t// angle: Number\r\n\t\t\t//\t\ta skewing angle in radians\r\n\t\t\t// returns: TransformMatrix\r\n\t\t\t//|----------| |-----------|\r\n\t\t\t//|m11|m21|dx| |  1|   0| 0|\r\n\t\t\t//|----------| |-----------|\r\n\t\t\t//|m12|m22|dy| |tan|   1| 0|\r\n\t\t\t//|----------| |-----------|\r\n\t\t\t//|  0|  0| 1| |  0|   0| 1|\r\n\t\t\t//|----------| |-----------|\r\n\t\t\tvar tan = Math.tan(angle);\r\n\r\n\t\t\treturn new TransformMatrix(1,tan,0,1); // TransformMatrix\r\n\t\t},\r\n\t\tskewYg: function(degree){\r\n\t\t\t//TODO : will be modified\r\n\t\t\t// summary:\r\n\t\t\t//\t\tforms a y skewing matrix\r\n\t\t\t// description:\r\n\t\t\t//\t\tThe resulting matrix is used to skew points in the y dimension\r\n\t\t\t//\t\taround the origin of coordinates (0, 0) by specified degree.\r\n\t\t\t//\t\tSee skewY() for comparison.\r\n\t\t\t// degree: Number\r\n\t\t\t//\t\ta skewing angle in degrees\r\n\t\t\t// returns: TransformMatrix\r\n\t\t\treturn this.skewY(degToRad(degree)); // TransformMatrix\r\n\t\t},\r\n\t\treflect: function(a, b){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tforms a reflection matrix\r\n\t\t\t// description:\r\n\t\t\t//\t\tThe resulting matrix is used to reflect points around a vector,\r\n\t\t\t//\t\twhich goes through the origin.\r\n\t\t\t// a: dojox/gfx.Point|Number\r\n\t\t\t//\t\ta point-like object, which specifies a vector of reflection, or an X value\r\n\t\t\t// b: Number?\r\n\t\t\t//\t\ta Y value\r\n\t\t\t// returns: TransformMatrix\r\n\t\t\tif(arguments.length == 1){\r\n\t\t\t\tb = a.y;\r\n\t\t\t\ta = a.x;\r\n\t\t\t}\r\n\t\t\t// make a unit vector\r\n\t\t\tvar a2 = a * a, b2 = b * b, n2 = a2 + b2, \r\n\t\t\t\txx=2 * a2 / n2 - 1, \r\n\t\t\t\txy = 2 * a * b / n2,\r\n\t\t\t\tyx = xy,\r\n\t\t\t\tyy = 2 * b2 / n2 - 1;\r\n\t\t\treturn new TransformMatrix(xx,yx,xy, yy); // TransformMatrix\r\n\t\t},\r\n\t\tproject: function(a, b){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tforms an orthogonal projection matrix\r\n\t\t\t// description:\r\n\t\t\t//\t\tThe resulting matrix is used to project points orthogonally on a vector,\r\n\t\t\t//\t\twhich goes through the origin.\r\n\t\t\t// a:   Number\r\n\t\t\t//\t\tan x coordinate value\r\n\t\t\t// b: Number?\r\n\t\t\t//\t\ta y coordinate value\r\n\t\t\t// returns: TransformMatrix\r\n\r\n\t\t\t// make a unit vector\r\n\t\t\tvar a2 = a * a, b2 = b * b, n2 = a2 + b2, \r\n\t\t\t\txx = a2 / n2,\r\n\t\t\t\txy = a * b / n2\r\n\t\t\t\tyx = xy,\r\n\t\t\t\tyy = b2 / n2;\r\n\t\t\treturn new TransformMatrix(xx,yx,xy,yy); // TransformMatrix\r\n\t\t},\r\n\r\n\t\t// common operations\r\n\r\n\t\t// high level operations\r\n\r\n\t\t_sandwich: function(matrix, x, y){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tapplies a matrix at a central point\r\n\t\t\t// matrix: TransformMatrix\r\n\t\t\t//\t\ta 2D matrix-like object, which is applied at a central point\r\n\t\t\t// x: Number\r\n\t\t\t//\t\tan x component of the central point\r\n\t\t\t// y: Number\r\n\t\t\t//\t\ta y component of the central point\r\n\t\t\treturn this.translate(x, y).multiply(matrix)\r\n\t\t\t                           .multiply(this.translate(-x, -y)); // TransformMatrix\r\n\t\t},\r\n\t\tscaleAt: function(a, b, c, d){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tscales a picture using a specified point as a center of scaling\r\n\t\t\t// description:\r\n\t\t\t//\t\tCompare with scale().\r\n\t\t\t// a: Number\r\n\t\t\t//\t\ta scaling factor used for the x coordinate, or a uniform scaling factor used for both coordinates\r\n\t\t\t// b: Number?\r\n\t\t\t//\t\ta scaling factor used for the y coordinate\r\n\t\t\t// c: Number|Point\r\n\t\t\t//\t\tan x component of a central point, or a central point\r\n\t\t\t// d: Number\r\n\t\t\t//\t\ta y component of a central point\r\n\t\t\t// returns: TransformMatrix\r\n\t\t\tswitch(arguments.length){\r\n\t\t\t\tcase 4:\r\n\t\t\t\t\t// a and b are scale factor components, c and d are components of a point\r\n\t\t\t\t\treturn this._sandwich(this.scale(a, b), c, d); // TransformMatrix\r\n\t\t\t\tcase 3:\r\n\t\t\t\t\tif(typeof c == \"number\"){\r\n\t\t\t\t\t\treturn this._sandwich(this.scale(a), b, c); // TransformMatrix\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn this._sandwich(this.scale(a, b), c.x, c.y); // TransformMatrix\r\n\t\t\t}\r\n\t\t\treturn this._sandwich(this.scale(a), b.x, b.y); // TransformMatrix\r\n\t\t},\r\n\t\trotateAt: function(angle, a, b){\r\n\t\t\t// summary:\r\n\t\t\t//\t\trotates a picture using a specified point as a center of rotation\r\n\t\t\t// description:\r\n\t\t\t//\t\tCompare with rotate().\r\n\t\t\t// angle: Number\r\n\t\t\t//\t\tan angle of rotation in radians (>0 for CW)\r\n\t\t\t// a: Number|dojox/gfx.Point\r\n\t\t\t//\t\tan x component of a central point, or a central point\r\n\t\t\t// b: Number?\r\n\t\t\t//\t\ta y component of a central point\r\n\t\t\t// returns: TransformMatrix\r\n\t\t\tif(arguments.length > 2){\r\n\t\t\t\treturn this._sandwich(this.rotate(angle), a, b); // TransformMatrix\r\n\t\t\t}\r\n\t\t\treturn this._sandwich(this.rotate(angle), a.x, a.y); // TransformMatrix\r\n\t\t},\r\n\t\trotategAt: function(degree, a, b){\r\n\t\t\t// summary:\r\n\t\t\t//\t\trotates a picture using a specified point as a center of rotation\r\n\t\t\t// description:\r\n\t\t\t//\t\tCompare with rotateg().\r\n\t\t\t// degree: Number\r\n\t\t\t//\t\tan angle of rotation in degrees (>0 for CW)\r\n\t\t\t// a: Number|dojox/gfx.Point\r\n\t\t\t//\t\tan x component of a central point, or a central point\r\n\t\t\t// b: Number?\r\n\t\t\t//\t\ta y component of a central point\r\n\t\t\t// returns: TransformMatrix\r\n\t\t\tif(arguments.length > 2){\r\n\t\t\t\treturn this._sandwich(this.rotateg(degree), a, b); // TransformMatrix\r\n\t\t\t}\r\n\t\t\treturn this._sandwich(this.rotateg(degree), a.x, a.y); // TransformMatrix\r\n\t\t},\r\n\t\tskewXAt: function(angle, a, b){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tskews a picture along the x axis using a specified point as a center of skewing\r\n\t\t\t// description:\r\n\t\t\t//\t\tCompare with skewX().\r\n\t\t\t// angle: Number\r\n\t\t\t//\t\ta skewing angle in radians\r\n\t\t\t// a: Number|dojox/gfx.Point\r\n\t\t\t//\t\tan x component of a central point, or a central point\r\n\t\t\t// b: Number?\r\n\t\t\t//\t\ta y component of a central point\r\n\t\t\t// returns: TransformMatrix\r\n\t\t\tif(arguments.length > 2){\r\n\t\t\t\treturn this._sandwich(this.skewX(angle), a, b); // TransformMatrix\r\n\t\t\t}\r\n\t\t\treturn this._sandwich(this.skewX(angle), a.x, a.y); // TransformMatrix\r\n\t\t},\r\n\t\tskewXgAt: function(degree, a, b){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tskews a picture along the x axis using a specified point as a center of skewing\r\n\t\t\t// description:\r\n\t\t\t//\t\tCompare with skewXg().\r\n\t\t\t// degree: Number\r\n\t\t\t//\t\ta skewing angle in degrees\r\n\t\t\t// a: Number|dojox/gfx.Point\r\n\t\t\t//\t\tan x component of a central point, or a central point\r\n\t\t\t// b: Number?\r\n\t\t\t//\t\ta y component of a central point\r\n\t\t\t// returns: TransformMatrix\r\n\t\t\tif(arguments.length > 2){\r\n\t\t\t\treturn this._sandwich(this.skewXg(degree), a, b); // TransformMatrix\r\n\t\t\t}\r\n\t\t\treturn this._sandwich(this.skewXg(degree), a.x, a.y); // TransformMatrix\r\n\t\t},\r\n\t\tskewYAt: function(angle, a, b){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tskews a picture along the y axis using a specified point as a center of skewing\r\n\t\t\t// description:\r\n\t\t\t//\t\tCompare with skewY().\r\n\t\t\t// angle: Number\r\n\t\t\t//\t\ta skewing angle in radians\r\n\t\t\t// a: Number|dojox/gfx.Point\r\n\t\t\t//\t\tan x component of a central point, or a central point\r\n\t\t\t// b: Number?\r\n\t\t\t//\t\ta y component of a central point\r\n\t\t\t// returns: TransformMatrix\r\n\t\t\tif(arguments.length > 2){\r\n\t\t\t\treturn this._sandwich(this.skewY(angle), a, b); // TransformMatrix\r\n\t\t\t}\r\n\t\t\treturn this._sandwich(this.skewY(angle), a.x, a.y); // TransformMatrix\r\n\t\t},\r\n\t\tskewYgAt: function(/* Number */ degree, /* Number||Point */ a, /* Number? */ b){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tskews a picture along the y axis using a specified point as a center of skewing\r\n\t\t\t// description:\r\n\t\t\t//\t\tCompare with skewYg().\r\n\t\t\t// degree: Number\r\n\t\t\t//\t\ta skewing angle in degrees\r\n\t\t\t// a: Number|dojox/gfx.Point\r\n\t\t\t//\t\tan x component of a central point, or a central point\r\n\t\t\t// b: Number?\r\n\t\t\t//\t\ta y component of a central point\r\n\t\t\t// returns: TransformMatrix\r\n\t\t\tif(arguments.length > 2){\r\n\t\t\t\treturn this._sandwich(this.skewYg(degree), a, b); // TransformMatrix\r\n\t\t\t}\r\n\t\t\treturn this._sandwich(this.skewYg(degree), a.x, a.y); // TransformMatrix\r\n\t\t}\r\n\t\r\n\t\r\n\t});\r\n\r\n\treturn numerics.TransformMatrix = TransformMatrix;\r\n});\r\n\ndefine('skylark-langx-numerics/translate-transform',[\r\n    \"./numerics\",\r\n    \"./transform\",\r\n    \"./matrix-transform\"\r\n],function(numerics,Transform,Matrix,Point,Rect) {\r\n\r\n    //|1   0   dx|\r\n    //|0   1   dy|\r\n    //|0   0    1|\r\n\r\n   var TranslateTransform =  Transform.inherit({\r\n        \"klassName\": \"TranslateTransform\",\r\n\r\n        \"value\": {\r\n            get: function() {\r\n                    return Matrix.scaleAt(this.x, this.y);\r\n            }\r\n        },\r\n\r\n        \"x\": {\r\n            get : function() {\r\n                return this._.x;\r\n            }\r\n        },\r\n\r\n        \"y\": {\r\n            get : function() {\r\n                return this._.y;\r\n            }\r\n        },\r\n\r\n        clone: /*SkewTransform*/ function() {},\r\n\r\n        transform: /*Point*/ function( /*Point*/ point) {},\r\n\r\n        transformBounds: /*Rect*/ function( /*Rect*/ rect) {},\r\n\r\n        \"init\": function( /*Number*/ x, /*Number*/ y) {\r\n            var _ = this._;\r\n\r\n            _.x = x ? x : 0;\r\n            _.y = y ? y : 0;\r\n        }\r\n    });\r\n\r\n    return numerics.TranslateTransform =TranslateTransform;\r\n});\t\r\n\ndefine('skylark-langx-numerics/vector4',[\r\n\t\"skylark-langx-klass\",\r\n\t\"./numerics\"\r\n] ,function(klass,numerics) {\r\n\r\n\tvar Vector4 = klass({\r\n\t\t\"klassName\" : \"Vector4\",\r\n\r\n\t\tset: function ( x, y, z, w ) {\r\n\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tthis.z = z;\r\n\t\t\tthis.w = w;\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\tsetScalar: function ( scalar ) {\r\n\r\n\t\t\tthis.x = scalar;\r\n\t\t\tthis.y = scalar;\r\n\t\t\tthis.z = scalar;\r\n\t\t\tthis.w = scalar;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetX: function ( x ) {\r\n\r\n\t\t\tthis.x = x;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetY: function ( y ) {\r\n\r\n\t\t\tthis.y = y;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetZ: function ( z ) {\r\n\r\n\t\t\tthis.z = z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetW: function ( w ) {\r\n\r\n\t\t\tthis.w = w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetComponent: function ( index, value ) {\r\n\r\n\t\t\tswitch ( index ) {\r\n\r\n\t\t\t\tcase 0: this.x = value; break;\r\n\t\t\t\tcase 1: this.y = value; break;\r\n\t\t\t\tcase 2: this.z = value; break;\r\n\t\t\t\tcase 3: this.w = value; break;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\tgetComponent: function ( index ) {\r\n\r\n\t\t\tswitch ( index ) {\r\n\r\n\t\t\t\tcase 0: return this.x;\r\n\t\t\t\tcase 1: return this.y;\r\n\t\t\t\tcase 2: return this.z;\r\n\t\t\t\tcase 3: return this.w;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tclone: function () {\r\n\r\n\t\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\r\n\r\n\t\t},\r\n\r\n\t\tcopy: function ( v ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\t\t\tthis.z = v.z;\r\n\t\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tadd: function ( v, w ) {\r\n\r\n\t\t\tif ( w !== undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\t\t\tthis.z += v.z;\r\n\t\t\tthis.w += v.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\taddScalar: function ( s ) {\r\n\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\t\t\tthis.z += s;\r\n\t\t\tthis.w += s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\taddVectors: function ( a, b ) {\r\n\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\t\t\tthis.z = a.z + b.z;\r\n\t\t\tthis.w = a.w + b.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\taddScaledVector: function ( v, s ) {\r\n\r\n\t\t\tthis.x += v.x * s;\r\n\t\t\tthis.y += v.y * s;\r\n\t\t\tthis.z += v.z * s;\r\n\t\t\tthis.w += v.w * s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsub: function ( v, w ) {\r\n\r\n\t\t\tif ( w !== undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\t\t\tthis.z -= v.z;\r\n\t\t\tthis.w -= v.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsubScalar: function ( s ) {\r\n\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\t\t\tthis.z -= s;\r\n\t\t\tthis.w -= s;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsubVectors: function ( a, b ) {\r\n\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\t\t\tthis.z = a.z - b.z;\r\n\t\t\tthis.w = a.w - b.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\t\tthis.x *= scalar;\r\n\t\t\tthis.y *= scalar;\r\n\t\t\tthis.z *= scalar;\r\n\t\t\tthis.w *= scalar;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tapplyMatrix4: function ( m ) {\r\n\r\n\t\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\r\n\t\t\tvar e = m.elements;\r\n\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\r\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\r\n\t\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tdivideScalar: function ( scalar ) {\r\n\r\n\t\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t\t},\r\n\r\n\t\tsetAxisAngleFromQuaternion: function ( q ) {\r\n\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n\r\n\t\t\t// q is assumed to be normalized\r\n\r\n\t\t\tthis.w = 2 * Math.acos( q.w );\r\n\r\n\t\t\tvar s = Math.sqrt( 1 - q.w * q.w );\r\n\r\n\t\t\tif ( s < 0.0001 ) {\r\n\r\n\t\t\t\tthis.x = 1;\r\n\t\t\t\tthis.y = 0;\r\n\t\t\t\tthis.z = 0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.x = q.x / s;\r\n\t\t\t\tthis.y = q.y / s;\r\n\t\t\t\tthis.z = q.z / s;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetAxisAngleFromRotationMatrix: function ( m ) {\r\n\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n\r\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\t\tvar angle, x, y, z,\t\t// variables for result\r\n\t\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\r\n\t\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\r\n\r\n\t\t\t\tte = m.elements,\r\n\r\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n\t\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\r\n\t\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\r\n\t\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\r\n\r\n\t\t\t\t// singularity found\r\n\t\t\t\t// first check for identity matrix which must have +1 for all terms\r\n\t\t\t\t// in leading diagonal and zero in other terms\r\n\r\n\t\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\r\n\t\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\r\n\t\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\r\n\t\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\r\n\r\n\t\t\t\t\t// this singularity is identity matrix so angle = 0\r\n\r\n\t\t\t\t\tthis.set( 1, 0, 0, 0 );\r\n\r\n\t\t\t\t\treturn this; // zero angle, arbitrary axis\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// otherwise this singularity is angle = 180\r\n\r\n\t\t\t\tangle = Math.PI;\r\n\r\n\t\t\t\tvar xx = ( m11 + 1 ) / 2;\r\n\t\t\t\tvar yy = ( m22 + 1 ) / 2;\r\n\t\t\t\tvar zz = ( m33 + 1 ) / 2;\r\n\t\t\t\tvar xy = ( m12 + m21 ) / 4;\r\n\t\t\t\tvar xz = ( m13 + m31 ) / 4;\r\n\t\t\t\tvar yz = ( m23 + m32 ) / 4;\r\n\r\n\t\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\r\n\r\n\t\t\t\t\t// m11 is the largest diagonal term\r\n\r\n\t\t\t\t\tif ( xx < epsilon ) {\r\n\r\n\t\t\t\t\t\tx = 0;\r\n\t\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tx = Math.sqrt( xx );\r\n\t\t\t\t\t\ty = xy / x;\r\n\t\t\t\t\t\tz = xz / x;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( yy > zz ) {\r\n\r\n\t\t\t\t\t// m22 is the largest diagonal term\r\n\r\n\t\t\t\t\tif ( yy < epsilon ) {\r\n\r\n\t\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\t\ty = 0;\r\n\t\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\ty = Math.sqrt( yy );\r\n\t\t\t\t\t\tx = xy / y;\r\n\t\t\t\t\t\tz = yz / y;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// m33 is the largest diagonal term so base result on this\r\n\r\n\t\t\t\t\tif ( zz < epsilon ) {\r\n\r\n\t\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\t\tz = 0;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tz = Math.sqrt( zz );\r\n\t\t\t\t\t\tx = xz / z;\r\n\t\t\t\t\t\ty = yz / z;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.set( x, y, z, angle );\r\n\r\n\t\t\t\treturn this; // return 180 deg rotation\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// as we have reached here there are no singularities so we can handle normally\r\n\r\n\t\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\r\n\t\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\r\n\t\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\r\n\r\n\t\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\r\n\r\n\t\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\r\n\t\t\t// caught by singularity test above, but I've left it in just in case\r\n\r\n\t\t\tthis.x = ( m32 - m23 ) / s;\r\n\t\t\tthis.y = ( m13 - m31 ) / s;\r\n\t\t\tthis.z = ( m21 - m12 ) / s;\r\n\t\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmin: function ( v ) {\r\n\r\n\t\t\tthis.x = Math.min( this.x, v.x );\r\n\t\t\tthis.y = Math.min( this.y, v.y );\r\n\t\t\tthis.z = Math.min( this.z, v.z );\r\n\t\t\tthis.w = Math.min( this.w, v.w );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tmax: function ( v ) {\r\n\r\n\t\t\tthis.x = Math.max( this.x, v.x );\r\n\t\t\tthis.y = Math.max( this.y, v.y );\r\n\t\t\tthis.z = Math.max( this.z, v.z );\r\n\t\t\tthis.w = Math.max( this.w, v.w );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tclamp: function ( min, max ) {\r\n\r\n\t\t\t// assumes min < max, componentwise\r\n\r\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\r\n\t\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tclampScalar: function ( minVal, maxVal ) {\r\n\r\n\t\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\r\n\t\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\r\n\t\t\tthis.z = Math.max( minVal, Math.min( maxVal, this.z ) );\r\n\t\t\tthis.w = Math.max( minVal, Math.min( maxVal, this.w ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tclampLength: function ( min, max ) {\r\n\r\n\t\t\tvar length = this.length();\r\n\r\n\t\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\r\n\r\n\t\t},\r\n\r\n\t\tfloor: function () {\r\n\r\n\t\t\tthis.x = Math.floor( this.x );\r\n\t\t\tthis.y = Math.floor( this.y );\r\n\t\t\tthis.z = Math.floor( this.z );\r\n\t\t\tthis.w = Math.floor( this.w );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tceil: function () {\r\n\r\n\t\t\tthis.x = Math.ceil( this.x );\r\n\t\t\tthis.y = Math.ceil( this.y );\r\n\t\t\tthis.z = Math.ceil( this.z );\r\n\t\t\tthis.w = Math.ceil( this.w );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tround: function () {\r\n\r\n\t\t\tthis.x = Math.round( this.x );\r\n\t\t\tthis.y = Math.round( this.y );\r\n\t\t\tthis.z = Math.round( this.z );\r\n\t\t\tthis.w = Math.round( this.w );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\troundToZero: function () {\r\n\r\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\t\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tnegate: function () {\r\n\r\n\t\t\tthis.x = - this.x;\r\n\t\t\tthis.y = - this.y;\r\n\t\t\tthis.z = - this.z;\r\n\t\t\tthis.w = - this.w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tdot: function ( v ) {\r\n\r\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\r\n\t\t},\r\n\r\n\t\tlengthSq: function () {\r\n\r\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\r\n\t\t},\r\n\r\n\t\tlength: function () {\r\n\r\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\r\n\r\n\t\t},\r\n\r\n\t\tmanhattanLength: function () {\r\n\r\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\r\n\r\n\t\t},\r\n\r\n\t\tnormalize: function () {\r\n\r\n\t\t\treturn this.divideScalar( this.length() || 1 );\r\n\r\n\t\t},\r\n\r\n\t\tsetLength: function ( length ) {\r\n\r\n\t\t\treturn this.normalize().multiplyScalar( length );\r\n\r\n\t\t},\r\n\r\n\t\tlerp: function ( v, alpha ) {\r\n\r\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\t\t\tthis.w += ( v.w - this.w ) * alpha;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t\t},\r\n\r\n\t\tequals: function ( v ) {\r\n\r\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\r\n\r\n\t\t},\r\n\r\n\t\tfromArray: function ( array, offset ) {\r\n\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\t\tthis.x = array[ offset ];\r\n\t\t\tthis.y = array[ offset + 1 ];\r\n\t\t\tthis.z = array[ offset + 2 ];\r\n\t\t\tthis.w = array[ offset + 3 ];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\ttoArray: function ( array, offset ) {\r\n\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\t\tarray[ offset ] = this.x;\r\n\t\t\tarray[ offset + 1 ] = this.y;\r\n\t\t\tarray[ offset + 2 ] = this.z;\r\n\t\t\tarray[ offset + 3 ] = this.w;\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t},\r\n\r\n\t\tfromBufferAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\t\tif ( offset !== undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'Vector4: offset has been removed from .fromBufferAttribute().' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.x = attribute.getX( index );\r\n\t\t\tthis.y = attribute.getY( index );\r\n\t\t\tthis.z = attribute.getZ( index );\r\n\t\t\tthis.w = attribute.getW( index );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\r\n\t\t\"_construct\" :function ( x, y, z, w ) {\r\n\r\n\t\t\tthis.x = x || 0;\r\n\t\t\tthis.y = y || 0;\r\n\t\t\tthis.z = z || 0;\r\n\t\t\tthis.w = ( w !== undefined ) ? w : 1;\r\n\r\n\t\t}\r\n\r\n\t});\r\n\r\n/*\r\n\tObject.defineProperties( Vector4.prototype, {\r\n\r\n\t\t\"width\": {\r\n\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this.z;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis.z = value;\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t\"height\": {\r\n\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this.w;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis.w = value;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} );\r\n*/\r\n\r\n\treturn numerics.Vector4 = Vector4 ;\r\n\r\n});\ndefine('skylark-langx-numerics/main',[\r\n\t\"./numerics\",\r\n\t\"./euler\",\r\n\t\"./maths\",\r\n\t\"./matrix3\",\r\n\t\"./matrix4\",\r\n\t\"./matrix-transform\",\r\n\t\"./plane\",\r\n\t\"./quaternion\",\r\n\t\"./rotate-transform\",\r\n\t\"./scale-transform\",\r\n\t\"./skew-transform\",\r\n\t\"./transform\",\r\n\t\"./transform-matrix\",\r\n\t\"./translate-transform\",\r\n\t\"./vector2\",\r\n\t\"./vector3\",\r\n\t\"./vector4\"\r\n],function(numerics){\r\n\treturn numerics;\r\n});\ndefine('skylark-langx-numerics', ['skylark-langx-numerics/main'], function (main) { return main; });\n\ndefine('skylark-langx/numerics',[\r\n\t\"skylark-langx-numerics\"\r\n],function(numerics){\r\n\treturn numerics;\r\n});\ndefine('skylark-langx/objects',[\r\n    \"skylark-langx-objects\"\r\n],function(objects){\r\n    return objects;\r\n});\ndefine('skylark-langx/Evented',[\r\n    \"./emitter\"\r\n],function(Emitter){\r\n    return Emitter;\r\n});\ndefine('skylark-langx-strings/strings',[\r\n    \"skylark-langx-ns\"\r\n],function(skylark){\r\n    return skylark.attach(\"langx.strings\");\r\n});\ndefine('skylark-langx-strings/base64',[\r\n\t\"./strings\"\r\n],function(strings) {\r\n\r\n\t// private property\r\n\tconst _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\n\r\n\t// private method for UTF-8 encoding\r\n\tfunction _utf8_encode(string) {\r\n\t\tstring = string.replace(/\\r\\n/g,\"\\n\");\r\n\t\tvar utftext = \"\";\r\n\r\n\t\tfor (var n = 0; n < string.length; n++) {\r\n\r\n\t\t\tvar c = string.charCodeAt(n);\r\n\r\n\t\t\tif (c < 128) {\r\n\t\t\t\tutftext += String.fromCharCode(c);\r\n\t\t\t}\r\n\t\t\telse if((c > 127) && (c < 2048)) {\r\n\t\t\t\tutftext += String.fromCharCode((c >> 6) | 192);\r\n\t\t\t\tutftext += String.fromCharCode((c & 63) | 128);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tutftext += String.fromCharCode((c >> 12) | 224);\r\n\t\t\t\tutftext += String.fromCharCode(((c >> 6) & 63) | 128);\r\n\t\t\t\tutftext += String.fromCharCode((c & 63) | 128);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn utftext;\r\n\t}\r\n\r\n\t// private method for UTF-8 decoding\r\n\tfunction _utf8_decode(utftext) {\r\n\t\tvar string = \"\";\r\n\t\tvar i = 0;\r\n\t\tvar c = c1 = c2 = 0;\r\n\r\n\t\twhile ( i < utftext.length ) {\r\n\r\n\t\t\tc = utftext.charCodeAt(i);\r\n\r\n\t\t\tif (c < 128) {\r\n\t\t\t\tstring += String.fromCharCode(c);\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t\telse if((c > 191) && (c < 224)) {\r\n\t\t\t\tc2 = utftext.charCodeAt(i+1);\r\n\t\t\t\tstring += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\r\n\t\t\t\ti += 2;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tc2 = utftext.charCodeAt(i+1);\r\n\t\t\t\tc3 = utftext.charCodeAt(i+2);\r\n\t\t\t\tstring += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\r\n\t\t\t\ti += 3;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn string;\r\n\t}\r\n\r\n\t// public method for encoding\r\n\tfunction encode(input, binary) {\r\n\t\tbinary = (binary != null) ? binary : false;\r\n\t\tvar output = \"\";\r\n\t\tvar chr1, chr2, chr3, enc1, enc2, enc3, enc4;\r\n\t\tvar i = 0;\r\n\r\n\t\tif (!binary)\r\n\t\t{\r\n\t\t\tinput = _utf8_encode(input);\r\n\t\t}\r\n\r\n\t\twhile (i < input.length) {\r\n\r\n\t\t\tchr1 = input.charCodeAt(i++);\r\n\t\t\tchr2 = input.charCodeAt(i++);\r\n\t\t\tchr3 = input.charCodeAt(i++);\r\n\r\n\t\t\tenc1 = chr1 >> 2;\r\n\t\t\tenc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\r\n\t\t\tenc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\r\n\t\t\tenc4 = chr3 & 63;\r\n\r\n\t\t\tif (isNaN(chr2)) {\r\n\t\t\t\tenc3 = enc4 = 64;\r\n\t\t\t} else if (isNaN(chr3)) {\r\n\t\t\t\tenc4 = 64;\r\n\t\t\t}\r\n\r\n\t\t\toutput = output +\r\n\t\t\tthis._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +\r\n\t\t\tthis._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);\r\n\r\n\t\t}\r\n\r\n\t\treturn output;\r\n\t}\r\n\r\n\t// public method for decoding\r\n\tfunction decode(input, binary) {\r\n\t\tbinary = (binary != null) ? binary : false;\r\n\t\tvar output = \"\";\r\n\t\tvar chr1, chr2, chr3;\r\n\t\tvar enc1, enc2, enc3, enc4;\r\n\t\tvar i = 0;\r\n\r\n\t\tinput = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\r\n\r\n\t\twhile (i < input.length) {\r\n\r\n\t\t\tenc1 = this._keyStr.indexOf(input.charAt(i++));\r\n\t\t\tenc2 = this._keyStr.indexOf(input.charAt(i++));\r\n\t\t\tenc3 = this._keyStr.indexOf(input.charAt(i++));\r\n\t\t\tenc4 = this._keyStr.indexOf(input.charAt(i++));\r\n\r\n\t\t\tchr1 = (enc1 << 2) | (enc2 >> 4);\r\n\t\t\tchr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\r\n\t\t\tchr3 = ((enc3 & 3) << 6) | enc4;\r\n\r\n\t\t\toutput = output + String.fromCharCode(chr1);\r\n\r\n\t\t\tif (enc3 != 64) {\r\n\t\t\t\toutput = output + String.fromCharCode(chr2);\r\n\t\t\t}\r\n\t\t\tif (enc4 != 64) {\r\n\t\t\t\toutput = output + String.fromCharCode(chr3);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif (!binary) {\r\n\t\t\toutput = _utf8_decode(output);\r\n\t\t}\r\n\r\n\t\treturn output;\r\n\r\n\t}\r\n\r\n\r\n\treturn strings.base64 = {\r\n\t\tdecode,\r\n\t\tencode\r\n\t};\r\n\t\r\n});\ndefine('skylark-langx-strings/camel-case',[\r\n\t\"./strings\"\r\n],function(strings){\r\n    function camelCase(str) {\r\n        return str.replace(/-([\\da-z])/g, function(a) {\r\n            return a.toUpperCase().replace('-', '');\r\n        });\r\n    }\r\n\r\n\t\r\n\treturn strings.camelCase = camelCase;\r\n});\ndefine('skylark-langx-strings/dasherize',[\r\n\t\"./strings\"\r\n],function(strings){\r\n     /*\r\n     * Converts camel case into dashes.\r\n     * @param {String} str\r\n     * @return {String}\r\n     * @exapmle marginTop -> margin-top\r\n     */\r\n    function dasherize(str) {\r\n        return str.replace(/::/g, '/')\r\n            .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\r\n            .replace(/([a-z\\d])([A-Z])/g, '$1_$2')\r\n            .replace(/_/g, '-')\r\n            .toLowerCase();\r\n    }\r\n\r\n\t\r\n\treturn strings.dasherize = dasherize;\r\n});\ndefine('skylark-langx-strings/deserialize-value',[\r\n\t\"./strings\"\r\n],function(strings){\r\n    function deserializeValue(value) {\r\n        try {\r\n            return value ?\r\n                value == \"true\" ||\r\n                (value == \"false\" ? false :\r\n                    value == \"null\" ? null :\r\n                    +value + \"\" == value ? +value :\r\n                    /^[\\[\\{]/.test(value) ? JSON.parse(value) :\r\n                    value) : value;\r\n        } catch (e) {\r\n            return value;\r\n        }\r\n    }\r\n\r\n\r\n\r\n\t\r\n\treturn strings.deserializeValue = deserializeValue;\r\n});\ndefine('skylark-langx-strings/escape-html',[\r\n\t\"./strings\"\r\n],function(strings){\r\n    // add default escape function for escaping HTML entities\r\n    var escapeCharMap = Object.freeze({\r\n        '&': '&amp;',\r\n        '<': '&lt;',\r\n        '>': '&gt;',\r\n        '\"': '&quot;',\r\n        \"'\": '&#x27;',\r\n        '`': '&#x60;',\r\n        '=': '&#x3D;',\r\n    });\r\n    function replaceChar(c) {\r\n        return escapeCharMap[c];\r\n    }\r\n    var escapeChars = /[&<>\"'`=]/g;\r\n\r\n    function escapeHTML(str) {\r\n        if (str == null) {\r\n            return '';\r\n        }\r\n        if (!str) {\r\n            return String(str);\r\n        }\r\n\r\n        return str.toString().replace(escapeChars, replaceChar);\r\n    }\r\n\r\n\t\r\n\treturn strings.escapeHTML = escapeHTML;\r\n});\ndefine('skylark-langx-strings/generate-uuid',[\r\n\t\"./strings\"\r\n],function(strings){\r\n    function generateUUID() {\r\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n            var r = Math.random() * 16 | 0;\r\n            var v = c === 'x' ? r : ((r & 0x3) | 0x8);\r\n            return v.toString(16);\r\n        });\r\n    }\r\n\r\n\treturn strings.generateUUID = generateUUID;\r\n});\ndefine('skylark-langx-strings/lower-first',[\r\n\t\"./strings\"\r\n],function(strings){\r\n    function lowerFirst(str) {\r\n        return str.charAt(0).toLowerCase() + str.slice(1);\r\n    }\r\n\t\r\n\treturn strings.lowerFirst = lowerFirst;\r\n});\ndefine('skylark-langx-strings/ltrim',[\r\n\t\"./strings\"\r\n],function(strings){\r\n\r\n    function ltrim(str) {\r\n        return str.replace(/^\\s+/, '');\r\n    }\r\n\t\r\n\treturn strings.ltrim = ltrim;\r\n});\ndefine('skylark-langx-strings/rtrim',[\r\n\t\"./strings\"\r\n],function(strings){\r\n    function rtrim(str) {\r\n        return str.replace(/\\s+$/, '');\r\n    }\r\n\t\r\n\treturn strings.rtrim = rtrim;\r\n});\ndefine('skylark-langx-strings/serialize-value',[\r\n\t\"./strings\"\r\n],function(strings){\r\n    function serializeValue(value) {\r\n        return JSON.stringify(value)\r\n    }\r\n\t\r\n\treturn strings.serializeValue = serializeValue;\r\n});\ndefine('skylark-langx-strings/slugify',[\r\n\t\"./strings\"\r\n],function(strings){\r\n    // Slugify a string\r\n    function slugify(str) {\r\n        str = str.replace(/^\\s+|\\s+$/g, '');\r\n\r\n        // Make the string lowercase\r\n        str = str.toLowerCase();\r\n\r\n        // Remove accents, swap ñ for n, etc\r\n        var from = \"ÁÄÂÀÃÅČÇĆĎÉĚËÈÊẼĔȆÍÌÎÏŇÑÓÖÒÔÕØŘŔŠŤÚŮÜÙÛÝŸŽáäâàãåčçćďéěëèêẽĕȇíìîïňñóöòôõøðřŕšťúůüùûýÿžþÞĐđßÆa·/_,:;\";\r\n        var to   = \"AAAAAACCCDEEEEEEEEIIIINNOOOOOORRSTUUUUUYYZaaaaaacccdeeeeeeeeiiiinnooooooorrstuuuuuyyzbBDdBAa------\";\r\n        for (var i=0, l=from.length ; i<l ; i++) {\r\n            str = str.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i));\r\n        }\r\n\r\n        // Remove invalid chars\r\n        //str = str.replace(/[^a-z0-9 -]/g, '') \r\n        // Collapse whitespace and replace by -\r\n        str = str.replace(/\\s+/g, '-') \r\n        // Collapse dashes\r\n        .replace(/-+/g, '-'); \r\n\r\n        return str;\r\n    }    \r\n\r\n\treturn strings.slugify = slugify;\r\n});\ndefine('skylark-langx-strings/substitute',[\r\n\t\"./strings\"\r\n],function(strings){\r\n    function substitute( /*String*/ template,\r\n        /*Object|Array*/\r\n        map,\r\n        /*Function?*/\r\n        transform,\r\n        /*Object?*/\r\n        thisObject) {\r\n        // summary:\r\n        //    Performs parameterized substitutions on a string. Throws an\r\n        //    exception if any parameter is unmatched.\r\n        // template:\r\n        //    a string with expressions in the form `${key}` to be replaced or\r\n        //    `${key:format}` which specifies a format function. keys are case-sensitive.\r\n        // map:\r\n        //    hash to search for substitutions\r\n        // transform:\r\n        //    a function to process all parameters before substitution takes\r\n\r\n\r\n        thisObject = thisObject || window;\r\n        transform = transform ?\r\n            proxy(thisObject, transform) : function(v) {\r\n                return v;\r\n            };\r\n\r\n        function getObject(key, map) {\r\n            if (key.match(/\\./)) {\r\n                var retVal,\r\n                    getValue = function(keys, obj) {\r\n                        var _k = keys.pop();\r\n                        if (_k) {\r\n                            if (!obj[_k]) return null;\r\n                            return getValue(keys, retVal = obj[_k]);\r\n                        } else {\r\n                            return retVal;\r\n                        }\r\n                    };\r\n                return getValue(key.split(\".\").reverse(), map);\r\n            } else {\r\n                return map[key];\r\n            }\r\n        }\r\n\r\n        return template.replace(/\\$\\{([^\\s\\:\\}]+)(?:\\:([^\\s\\:\\}]+))?\\}/g,\r\n            function(match, key, format) {\r\n                var value = getObject(key, map);\r\n                if (format) {\r\n                    value = getObject(format, thisObject).call(thisObject, value, key);\r\n                }\r\n                return transform(value, key).toString();\r\n            }); // String\r\n    }\r\n\r\n\treturn strings.substitute = substitute;\r\n});\ndefine('skylark-langx-strings/trim',[\r\n\t\"./strings\"\r\n],function(strings){\r\n    function trim(str) {\r\n        return str == null ? \"\" : String.prototype.trim.call(str);\r\n    }\r\n\t\r\n\treturn strings.trim = trim;\r\n});\ndefine('skylark-langx-strings/trim-null',[\r\n\t\"./strings\"\r\n],function(strings){\r\n    const NullCharactersRegExp = /\\x00/g;\r\n\r\n    /**\r\n     * @param {string} str\r\n     */\r\n    function trimNull(str) {\r\n      if (typeof str !== \"string\") {\r\n        warn(\"The argument for removeNullCharacters must be a string.\");\r\n        return str;\r\n      }\r\n      return str.replace(NullCharactersRegExp, \"\");\r\n    }\r\n\r\n\t\r\n\treturn strings.trimNull = trimNull;\r\n});\ndefine('skylark-langx-strings/unique-id',[\r\n\t\"./strings\"\r\n],function(strings){\r\n\r\n    var idCounter = 0;\r\n    function uniqueId (prefix) {\r\n        var id = ++idCounter + '';\r\n        return prefix ? prefix + id : id;\r\n    }\r\n\r\n\treturn strings.uniqueId = uniqueId;\r\n});\ndefine('skylark-langx-strings/upper-first',[\r\n\t\"./strings\"\r\n],function(strings){\r\n\r\n    function upperFirst(str) {\r\n        return str.charAt(0).toUpperCase() + str.slice(1);\r\n    }\r\n\t\r\n\treturn strings.upperFirst = upperFirst;\r\n});\ndefine('skylark-langx-strings/words',[\r\n\t\"./strings\"\r\n],function(strings){\r\n\t/** Used to compose unicode character classes. */\r\n\tconst rsAstralRange = '\\\\ud800-\\\\udfff'\r\n\tconst rsComboMarksRange = '\\\\u0300-\\\\u036f'\r\n\tconst reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f'\r\n\tconst rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff'\r\n\tconst rsComboMarksExtendedRange = '\\\\u1ab0-\\\\u1aff'\r\n\tconst rsComboMarksSupplementRange = '\\\\u1dc0-\\\\u1dff'\r\n\tconst rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange\r\n\tconst rsDingbatRange = '\\\\u2700-\\\\u27bf'\r\n\tconst rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff'\r\n\tconst rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7'\r\n\tconst rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf'\r\n\tconst rsPunctuationRange = '\\\\u2000-\\\\u206f'\r\n\tconst rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000'\r\n\tconst rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde'\r\n\tconst rsVarRange = '\\\\ufe0e\\\\ufe0f'\r\n\tconst rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange\r\n\r\n\t/** Used to compose unicode capture groups. */\r\n\tconst rsApos = \"['\\u2019]\"\r\n\tconst rsBreak = `[${rsBreakRange}]`\r\n\tconst rsCombo = `[${rsComboRange}]`\r\n\tconst rsDigit = '\\\\d'\r\n\tconst rsDingbat = `[${rsDingbatRange}]`\r\n\tconst rsLower = `[${rsLowerRange}]`\r\n\tconst rsMisc = `[^${rsAstralRange}${rsBreakRange + rsDigit + rsDingbatRange + rsLowerRange + rsUpperRange}]`\r\n\tconst rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]'\r\n\tconst rsModifier = `(?:${rsCombo}|${rsFitz})`\r\n\tconst rsNonAstral = `[^${rsAstralRange}]`\r\n\tconst rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}'\r\n\tconst rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]'\r\n\tconst rsUpper = `[${rsUpperRange}]`\r\n\tconst rsZWJ = '\\\\u200d'\r\n\r\n\t/** Used to compose unicode regexes. */\r\n\tconst rsMiscLower = `(?:${rsLower}|${rsMisc})`\r\n\tconst rsMiscUpper = `(?:${rsUpper}|${rsMisc})`\r\n\tconst rsOptContrLower = `(?:${rsApos}(?:d|ll|m|re|s|t|ve))?`\r\n\tconst rsOptContrUpper = `(?:${rsApos}(?:D|LL|M|RE|S|T|VE))?`\r\n\tconst reOptMod = `${rsModifier}?`\r\n\tconst rsOptVar = `[${rsVarRange}]?`\r\n\tconst rsOptJoin = `(?:${rsZWJ}(?:${[rsNonAstral, rsRegional, rsSurrPair].join('|')})${rsOptVar + reOptMod})*`\r\n\tconst rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])'\r\n\tconst rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])'\r\n\tconst rsSeq = rsOptVar + reOptMod + rsOptJoin\r\n\tconst rsEmoji = `(?:${[rsDingbat, rsRegional, rsSurrPair].join('|')})${rsSeq}`\r\n\r\n\tconst reUnicodeWords = RegExp([\r\n\t  `${rsUpper}?${rsLower}+${rsOptContrLower}(?=${[rsBreak, rsUpper, '$'].join('|')})`,\r\n\t  `${rsMiscUpper}+${rsOptContrUpper}(?=${[rsBreak, rsUpper + rsMiscLower, '$'].join('|')})`,\r\n\t  `${rsUpper}?${rsMiscLower}+${rsOptContrLower}`,\r\n\t  `${rsUpper}+${rsOptContrUpper}`,\r\n\t  rsOrdUpper,\r\n\t  rsOrdLower,\r\n\t  `${rsDigit}+`,\r\n\t  rsEmoji\r\n\t].join('|'), 'g')\r\n\r\n\t/**\r\n\t * Splits a Unicode `string` into an array of its words.\r\n\t *\r\n\t * @private\r\n\t * @param {string} The string to inspect.\r\n\t * @returns {Array} Returns the words of `string`.\r\n\t */\r\n\tfunction unicodeWords(string) {\r\n\t  return string.match(reUnicodeWords)\r\n\t}\r\n\r\n\r\n\tconst hasUnicodeWord = RegExp.prototype.test.bind(\r\n\t  /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/\r\n\t)\r\n\r\n\t/** Used to match words composed of alphanumeric characters. */\r\n\tconst reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g\r\n\r\n\tfunction asciiWords(string) {\r\n\t  return string.match(reAsciiWord)\r\n\t}\r\n\r\n\t/**\r\n\t * Splits `string` into an array of its words.\r\n\t *\r\n\t * @since 3.0.0\r\n\t * @category String\r\n\t * @param {string} [string=''] The string to inspect.\r\n\t * @param {RegExp|string} [pattern] The pattern to match words.\r\n\t * @returns {Array} Returns the words of `string`.\r\n\t * @example\r\n\t *\r\n\t * words('fred, barney, & pebbles')\r\n\t * // => ['fred', 'barney', 'pebbles']\r\n\t *\r\n\t * words('fred, barney, & pebbles', /[^, ]+/g)\r\n\t * // => ['fred', 'barney', '&', 'pebbles']\r\n\t */\r\n\tfunction words(string, pattern) {\r\n\t  if (pattern === undefined) {\r\n\t    const result = hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string)\r\n\t    return result || []\r\n\t  }\r\n\t  return string.match(pattern) || []\r\n\t}\r\n\r\n\t\r\n\treturn strings.words = words;\r\n});\ndefine('skylark-langx-strings/main',[\r\n\t\"./strings\",\r\n\t\"./base64\",\r\n\t\"./camel-case\",\r\n\t\"./dasherize\",\r\n\t\"./deserialize-value\",\r\n\t\"./escape-html\",\r\n\t\"./generate-uuid\",\r\n\t\"./lower-first\",\r\n\t\"./ltrim\",\r\n\t\"./rtrim\",\r\n\t\"./serialize-value\",\r\n\t\"./slugify\",\r\n\t\"./substitute\",\r\n\t\"./trim\",\r\n\t\"./trim-null\",\r\n\t\"./unique-id\",\r\n\t\"./upper-first\",\r\n\t\"./words\"\r\n],function(strings){\r\n\treturn strings;\r\n});\ndefine('skylark-langx-strings', ['skylark-langx-strings/main'], function (main) { return main; });\n\ndefine('skylark-langx/strings',[\r\n    \"skylark-langx-strings\"\r\n],function(strings){\r\n    return strings;\r\n});\ndefine('skylark-langx/stateful',[\r\n\t\"./Evented\",\r\n  \"./strings\",\r\n  \"./objects\"\r\n],function(Evented,strings,objects){\r\n    var isEqual = objects.isEqual,\r\n        mixin = objects.mixin,\r\n        result = objects.result,\r\n        isEmptyObject = objects.isEmptyObject,\r\n        clone = objects.clone,\r\n        uniqueId = strings.uniqueId;\r\n\r\n    var Stateful = Evented.inherit({\r\n        _construct : function(attributes, options) {\r\n            var attrs = attributes || {};\r\n            options || (options = {});\r\n            this.cid = uniqueId(this.cidPrefix);\r\n            this.attributes = {};\r\n            if (options.collection) this.collection = options.collection;\r\n            if (options.parse) attrs = this.parse(attrs, options) || {};\r\n            var defaults = result(this, 'defaults');\r\n            attrs = mixin({}, defaults, attrs);\r\n            this.set(attrs, options);\r\n            this.changed = {};\r\n        },\r\n\r\n        // A hash of attributes whose current and previous value differ.\r\n        changed: null,\r\n\r\n        // The value returned during the last failed validation.\r\n        validationError: null,\r\n\r\n        // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\r\n        // CouchDB users may want to set this to `\"_id\"`.\r\n        idAttribute: 'id',\r\n\r\n        // The prefix is used to create the client id which is used to identify models locally.\r\n        // You may want to override this if you're experiencing name clashes with model ids.\r\n        cidPrefix: 'c',\r\n\r\n\r\n        // Return a copy of the model's `attributes` object.\r\n        toJSON: function(options) {\r\n          return clone(this.attributes);\r\n        },\r\n\r\n\r\n        // Get the value of an attribute.\r\n        get: function(attr) {\r\n          return this.attributes[attr];\r\n        },\r\n\r\n        // Returns `true` if the attribute contains a value that is not null\r\n        // or undefined.\r\n        has: function(attr) {\r\n          return this.get(attr) != null;\r\n        },\r\n\r\n        // Set a hash of model attributes on the object, firing `\"change\"`. This is\r\n        // the core primitive operation of a model, updating the data and notifying\r\n        // anyone who needs to know about the change in state. The heart of the beast.\r\n        set: function(key, val, options) {\r\n          if (key == null) return this;\r\n\r\n          // Handle both `\"key\", value` and `{key: value}` -style arguments.\r\n          var attrs;\r\n          if (typeof key === 'object') {\r\n            attrs = key;\r\n            options = val;\r\n          } else {\r\n            (attrs = {})[key] = val;\r\n          }\r\n\r\n          options || (options = {});\r\n\r\n          // Run validation.\r\n          if (!this._validate(attrs, options)) return false;\r\n\r\n          // Extract attributes and options.\r\n          var unset      = options.unset;\r\n          var silent     = options.silent;\r\n          var changes    = [];\r\n          var changing   = this._changing;\r\n          this._changing = true;\r\n\r\n          if (!changing) {\r\n            this._previousAttributes = clone(this.attributes);\r\n            this.changed = {};\r\n          }\r\n\r\n          var current = this.attributes;\r\n          var changed = this.changed;\r\n          var prev    = this._previousAttributes;\r\n\r\n          // For each `set` attribute, update or delete the current value.\r\n          for (var attr in attrs) {\r\n            val = attrs[attr];\r\n            if (!isEqual(current[attr], val)) changes.push(attr);\r\n            if (!isEqual(prev[attr], val)) {\r\n              changed[attr] = val;\r\n            } else {\r\n              delete changed[attr];\r\n            }\r\n            unset ? delete current[attr] : current[attr] = val;\r\n          }\r\n\r\n          // Update the `id`.\r\n          if (this.idAttribute in attrs) this.id = this.get(this.idAttribute);\r\n\r\n          // Trigger all relevant attribute changes.\r\n          if (!silent) {\r\n            if (changes.length) this._pending = options;\r\n            for (var i = 0; i < changes.length; i++) {\r\n              this.trigger('change:' + changes[i], this, current[changes[i]], options);\r\n            }\r\n          }\r\n\r\n          // You might be wondering why there's a `while` loop here. Changes can\r\n          // be recursively nested within `\"change\"` events.\r\n          if (changing) return this;\r\n          if (!silent) {\r\n            while (this._pending) {\r\n              options = this._pending;\r\n              this._pending = false;\r\n              this.trigger('change', this, options);\r\n            }\r\n          }\r\n          this._pending = false;\r\n          this._changing = false;\r\n          return this;\r\n        },\r\n\r\n        // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\r\n        // if the attribute doesn't exist.\r\n        unset: function(attr, options) {\r\n          return this.set(attr, void 0, mixin({}, options, {unset: true}));\r\n        },\r\n\r\n        // Clear all attributes on the model, firing `\"change\"`.\r\n        clear: function(options) {\r\n          var attrs = {};\r\n          for (var key in this.attributes) attrs[key] = void 0;\r\n          return this.set(attrs, mixin({}, options, {unset: true}));\r\n        },\r\n\r\n        // Determine if the model has changed since the last `\"change\"` event.\r\n        // If you specify an attribute name, determine if that attribute has changed.\r\n        hasChanged: function(attr) {\r\n          if (attr == null) return !isEmptyObject(this.changed);\r\n          return this.changed[attr] !== undefined;\r\n        },\r\n\r\n        // Return an object containing all the attributes that have changed, or\r\n        // false if there are no changed attributes. Useful for determining what\r\n        // parts of a view need to be updated and/or what attributes need to be\r\n        // persisted to the server. Unset attributes will be set to undefined.\r\n        // You can also pass an attributes object to diff against the model,\r\n        // determining if there *would be* a change.\r\n        changedAttributes: function(diff) {\r\n          if (!diff) return this.hasChanged() ? clone(this.changed) : false;\r\n          var old = this._changing ? this._previousAttributes : this.attributes;\r\n          var changed = {};\r\n          for (var attr in diff) {\r\n            var val = diff[attr];\r\n            if (isEqual(old[attr], val)) continue;\r\n            changed[attr] = val;\r\n          }\r\n          return !isEmptyObject(changed) ? changed : false;\r\n        },\r\n\r\n        // Get the previous value of an attribute, recorded at the time the last\r\n        // `\"change\"` event was fired.\r\n        previous: function(attr) {\r\n          if (attr == null || !this._previousAttributes) return null;\r\n          return this._previousAttributes[attr];\r\n        },\r\n\r\n        // Get all of the attributes of the model at the time of the previous\r\n        // `\"change\"` event.\r\n        previousAttributes: function() {\r\n          return clone(this._previousAttributes);\r\n        },\r\n\r\n        // Create a new model with identical attributes to this one.\r\n        clone: function() {\r\n          return new this.constructor(this.attributes);\r\n        },\r\n\r\n        // A model is new if it has never been saved to the server, and lacks an id.\r\n        isNew: function() {\r\n          return !this.has(this.idAttribute);\r\n        },\r\n\r\n        // Check if the model is currently in a valid state.\r\n        isValid: function(options) {\r\n          return this._validate({}, mixin({}, options, {validate: true}));\r\n        },\r\n\r\n        // Run validation against the next complete set of model attributes,\r\n        // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\r\n        _validate: function(attrs, options) {\r\n          if (!options.validate || !this.validate) return true;\r\n          attrs = mixin({}, this.attributes, attrs);\r\n          var error = this.validationError = this.validate(attrs, options) || null;\r\n          if (!error) return true;\r\n          this.trigger('invalid', this, error, mixin(options, {validationError: error}));\r\n          return false;\r\n        }\r\n    });\r\n\r\n\treturn Stateful;\r\n});\ndefine('skylark-langx-topic/topic',[\n\t\"skylark-langx-ns\",\n\t\"skylark-langx-events\"\n],function(skylark,events){\n\tvar hub = new events.Emitter();\n\n\treturn skylark.attach(\"langx.topic\",{\n\t    publish: function(name, arg1,argn) {\n\t        var data = [].slice.call(arguments, 1);\n\n\t        return hub.trigger({\n\t            type : name,\n\t            data : data\n\t        });\n\t    },\n\n        subscribe: function(name, listener,ctx) {\n        \tvar handler = function(e){\n                listener.apply(ctx,e.data);\n            };\n            hub.on(name, handler);\n            return {\n            \tremove : function(){\n            \t\thub.off(name,handler);\n            \t}\n            }\n\n        }\n\n\t});\n});\ndefine('skylark-langx-topic/main',[\n\t\"./topic\"\n],function(topic){\n\treturn topic;\n});\ndefine('skylark-langx-topic', ['skylark-langx-topic/main'], function (main) { return main; });\n\ndefine('skylark-langx/topic',[\r\n\t\"skylark-langx-topic\"\r\n],function(topic){\r\n\treturn topic;\r\n});\ndefine('skylark-langx/types',[\r\n    \"skylark-langx-types\"\r\n],function(types){\r\n    return types;\r\n});\ndefine('skylark-langx-urls/urls',[\r\n  \"skylark-langx-ns\"\r\n],function(skylark){\r\n\r\n\r\n    return skylark.attach(\"langx.urls\",{\r\n\r\n    });\r\n});\r\n\r\n\r\n\ndefine('skylark-langx-urls/create_object_url',[\r\n    './urls'\r\n], function (urls) {\r\n    'use strict';\r\n\r\n    const digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\r\n    function createObjectURL(data, contentType, forceDataSchema = false) {\r\n        if (!forceDataSchema && URL.createObjectURL) {\r\n            const blob = new Blob([data], { type: contentType });\r\n            return URL.createObjectURL(blob);\r\n        }\r\n        let buffer = `data:${ contentType };base64,`;\r\n        for (let i = 0, ii = data.length; i < ii; i += 3) {\r\n            const b1 = data[i] & 255;\r\n            const b2 = data[i + 1] & 255;\r\n            const b3 = data[i + 2] & 255;\r\n            const d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;\r\n            const d3 = i + 1 < ii ? (b2 & 15) << 2 | b3 >> 6 : 64;\r\n            const d4 = i + 2 < ii ? b3 & 63 : 64;\r\n            buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];\r\n        }\r\n        return buffer;\r\n    };\r\n\r\n\r\n    return urls.createObjectURL = createObjectURL;\r\n\r\n});\r\n\r\n\ndefine('skylark-langx-urls/create_valid_absolute_url',[\r\n    './urls'\r\n], function (urls) {\r\n    'use strict';\r\n\r\n    function _isValidProtocol(url) {\r\n        if (!url) {\r\n            return false;\r\n        }\r\n        switch (url.protocol) {\r\n        case 'http:':\r\n        case 'https:':\r\n        case 'ftp:':\r\n        case 'mailto:':\r\n        case 'tel:':\r\n            return true;\r\n        default:\r\n            return false;\r\n        }\r\n    }\r\n    function createValidAbsoluteUrl(url, baseUrl) {\r\n        if (!url) {\r\n            return null;\r\n        }\r\n        try {\r\n            const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\r\n            if (_isValidProtocol(absoluteUrl)) {\r\n                return absoluteUrl;\r\n            }\r\n        } catch (ex) {\r\n        }\r\n        return null;\r\n    }\r\n\r\n    return urls.createValidAbsoluteUrl = createValidAbsoluteUrl;\r\n\r\n});\r\n\r\n\ndefine('skylark-langx-urls/get-absolute-url',[\r\n    './urls'\r\n], function (urls) {\r\n    'use strict';\r\n\r\n    const getAbsoluteUrl = function (url) {\r\n        if (!url.match(/^https?:\\/\\//)) {\r\n            const div = document.createElement('div');\r\n            div.innerHTML = `<a href=\"${ url }\">x</a>`;\r\n            url = div.firstChild.href;\r\n        }\r\n        return url;\r\n    };\r\n\r\n    return urls.getAbsoluteUrl = getAbsoluteUrl;\r\n\r\n});\ndefine('skylark-langx-urls/get-file-extension',[\r\n    './urls'\r\n], function (urls) {\r\n    'use strict';\r\n\r\n    const getFileExtension = function (path) {\r\n        if (typeof path === 'string') {\r\n            const splitPathRe = /^(\\/?)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?)(\\.([^\\.\\/\\?]+)))(?:[\\/]*|[\\?].*)$/;\r\n            const pathParts = splitPathRe.exec(path);\r\n            if (pathParts) {\r\n                return pathParts.pop().toLowerCase();\r\n            }\r\n        }\r\n        return '';\r\n    };\r\n\r\n    return urls.getFileExtension = getFileExtension;\r\n\r\n});\n   define('skylark-langx-urls/get-file-name',[\r\n    './urls'\r\n], function (urls) {\r\n    'use strict';\r\n\r\n    function getFileName (url) {\r\n        ///var fileName = url.split('/').pop() || \"\";\r\n        ///return fileName;\r\n        const anchor = url.indexOf('#');\r\n        const query = url.indexOf('?');\r\n        const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);\r\n        return url.substring(url.lastIndexOf('/', end) + 1, end);         \r\n    }\r\n\r\n\r\n\r\n\r\n    return urls.getFileName = getFileName;\r\n\r\n});\ndefine('skylark-langx-urls/get-query',[\r\n    './urls'\r\n], function (urls) {\r\n    'use strict';\r\n\tfunction getQuery(querystring) {\r\n\t\tvar query = {};\r\n\r\n\t\tvar pairs = querystring.split('&'),\r\n\t\t    length = pairs.length,\r\n\t\t    keyval = [],\r\n\t\t    i = 0;\r\n\r\n\t\tfor (; i < length; i++) {\r\n\t\t  keyval = pairs[i].split('=', 2);\r\n\t\t  try {\r\n\t\t    keyval[0] = decodeURIComponent(keyval[0]); // key\r\n\t\t    keyval[1] = decodeURIComponent(keyval[1]); // value\r\n\t\t  } catch (e) {}\r\n\r\n\t\t  if (query[keyval[0]] === undefined) {\r\n\t\t    query[keyval[0]] = keyval[1];\r\n\t\t  } else {\r\n\t\t    query[keyval[0]] += ',' + keyval[1];\r\n\t\t  }\r\n\t\t}\r\n\r\n\t\treturn query;\r\n\t}\r\n\r\n\treturn urls.getQuery = getQuery;\r\n\r\n});\ndefine('skylark-langx-urls/parse-url',[\r\n    './urls'\r\n], function (urls) {\r\n    'use strict';\r\n    const parseUrl = function (url) {\r\n        const props = [\r\n            'protocol',\r\n            'hostname',\r\n            'port',\r\n            'pathname',\r\n            'search',\r\n            'hash',\r\n            'host'\r\n        ];\r\n        let a = document.createElement('a');\r\n        a.href = url;\r\n        const addToBody = a.host === '' && a.protocol !== 'file:';\r\n        let div;\r\n        if (addToBody) {\r\n            div = document.createElement('div');\r\n            div.innerHTML = `<a href=\"${ url }\"></a>`;\r\n            a = div.firstChild;\r\n            div.setAttribute('style', 'display:none; position:absolute;');\r\n            document.body.appendChild(div);\r\n        }\r\n        const details = {};\r\n        for (let i = 0; i < props.length; i++) {\r\n            details[props[i]] = a[props[i]];\r\n        }\r\n        if (details.protocol === 'http:') {\r\n            details.host = details.host.replace(/:80$/, '');\r\n        }\r\n        if (details.protocol === 'https:') {\r\n            details.host = details.host.replace(/:443$/, '');\r\n        }\r\n        if (!details.protocol) {\r\n            details.protocol = window.location.protocol;\r\n        }\r\n        if (addToBody) {\r\n            document.body.removeChild(div);\r\n        }\r\n        return details;\r\n    };\r\n\r\n    return urls.parseUrl = parseUrl;\r\n});\ndefine('skylark-langx-urls/is-cross-origin',[\r\n    './urls',\r\n    \"./parse-url\"\r\n], function (urls,parseUrl) {\r\n    'use strict';\r\n\r\n    const isCrossOrigin = function (url, winLoc = window.location) {\r\n        const urlInfo = parseUrl(url);\r\n        const srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;\r\n        const crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;\r\n        return crossOrigin;\r\n    };\r\n\r\n    return urls.isCrossOrigin = isCrossOrigin;\r\n\r\n});\ndefine('skylark-langx-urls/is_same_origin',[\r\n    './urls'\r\n], function (urls) {\r\n    'use strict';\r\n\r\n    function isSameOrigin(baseUrl, otherUrl) {\r\n        let base;\r\n        try {\r\n            base = new URL(baseUrl);\r\n            if (!base.origin || base.origin === 'null') {\r\n                return false;\r\n            }\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n        const other = new URL(otherUrl, base);\r\n        return base.origin === other.origin;\r\n    }\r\n\r\n    return urls.isSameOrigin = isSameOrigin;\r\n\r\n});\r\n\ndefine('skylark-langx-urls/path',[\r\n    \"skylark-langx-types\",\r\n    \"skylark-langx-constructs\",\r\n    \"./urls\"\r\n], function(types,constructs,urls) {\r\n\r\n    /**\r\n     * @class Path\r\n     * @constructor\r\n     */\r\n    var Path =   constructs.klass({\r\n        _construct : function() {\r\n            var _ = this._ = {\r\n                segments : null,\r\n                hasLeading : false,\r\n                hasTrailing : false\r\n            };\r\n            if (arguments.length == 1 && types.isString(arguments[0])) {\r\n                  this._parse(arguments[0]);\r\n            } else  if (types.isArray(arguments[0])){\r\n                _.segments = arguments[0];\r\n                _.hasLeading = arguments[1] || false;\r\n                _.hasTrailing = arguments[2] || false;\r\n                this._canonicalize();                \r\n            }\r\n        },\r\n\r\n        _canonicalize: function() {\r\n            var doIt;\r\n            var segments = this._.segments;\r\n            for (var i = 0; i < segments.length; i++) {\r\n                if (segments[i] == \".\" || segments[i] == \"..\") {\r\n                    doIt = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (doIt) {\r\n                var stack = [];\r\n                for (var i = 0; i < segments.length; i++) {\r\n                    if (segments[i] == \"..\") {\r\n                        if (stack.length == 0) {\r\n                            // if the stack is empty we are going out of our scope\r\n                            // so we need to accumulate segments.  But only if the original\r\n                            // path is relative.  If it is absolute then we can't go any higher than\r\n                            // root so simply toss the .. references.\r\n                            if (!this.hasLeading) {\r\n                                stack.push(segments[i]); //stack push\r\n                            }\r\n                        } else {\r\n                            // if the top is '..' then we are accumulating segments so don't pop\r\n                            if (\"..\" == stack[stack.length - 1]) {\r\n                                stack.push(\"..\");\r\n                            } else {\r\n                                stack.pop();\r\n                            }\r\n                        }\r\n                        //collapse current references\r\n                    } else if (segments[i] != \".\" || segments.length == 1) {\r\n                        stack.push(segments[i]); //stack push\r\n                    }\r\n                }\r\n                //if the number of segments hasn't changed, then no modification needed\r\n                if (stack.length == segments.length) {\r\n                    return;\r\n                }\r\n                this._.segments = stack;\r\n            }\r\n        },\r\n\r\n        _length: function(anotherPath) {\r\n            return this._.segments.length;\r\n        },\r\n\r\n\r\n        _parse : function( /*String*/ path) {\r\n            if (!path) {\r\n                path = \".\";\r\n            }\r\n            var _ = this._,\r\n                segments = path.split(\"/\");\r\n\r\n            if (path.charAt(0) == \"/\") {\r\n                _.hasLeading = true;\r\n                segments.shift();\r\n            }\r\n            if (path.charAt(path.length - 1) == \"/\") {\r\n                _.hasTrailing = true;\r\n                // If the path ends in '/', split() will create an array whose last element\r\n                // is an empty string. Remove that here.\r\n                segments.pop();\r\n            }\r\n            _.segments = segments;\r\n            _.path = path;\r\n\r\n            this._canonicalize()\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method append\r\n         *@parameter {Path|String}tail\r\n         *@return {Path}\r\n         */\r\n        append: /*Path*/ function( /*Path*/ tail) {\r\n            if (types.isString(tail)) {\r\n                return this.appendPathStr(tail);\r\n            } else {\r\n                return this.appendPath(tail);\r\n            }\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method appendPath\r\n         *@parameter {Path}tail\r\n         *@return {Path}\r\n         */\r\n        appendPath: /*Path*/ function( /*Path*/ tail) {\r\n            if (tail.isAbsolute()) {\r\n                return tail;\r\n            }\r\n            var mySegments = this.segments,\r\n                tailSegments = tail.segments,\r\n                newSegments = mySegments.concat(tailSegments),\r\n                result = new Path(newSegments, this.hasLeading, tail.hasTrailing);\r\n            return result;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method appendPathStr\r\n         *@parameter {String}tail\r\n         *@return {Path}\r\n         */\r\n        appendPathStr: function( /*String*/ tail) {\r\n            tail = new Path(tail || \"\");\r\n            return this.appendPath(tail);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method clone\r\n         *@return {Path}\r\n         */\r\n        \"clone\": function() {\r\n            return new Path(this.segments, this.hasLeading, this.hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *Tests if this path ends with the given path.\r\n         *@method endsWidth\r\n         *@parameter {String}tail\r\n         *@return {Boolean}\r\n         */\r\n        \"endsWith\": /*Boolean*/ function( /*String*/ tail) {\r\n            var segments = this.segments;\r\n            var tailSegments = (new Path(tail)).segments;\r\n            while (tailSegments.length > 0 && segments.length > 0) {\r\n                if (tailSegments.pop() != segments.pop()) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        },\r\n\r\n        /*\r\n         *Tests this path for equality with the given object.\r\n         *@method equals\r\n         *@parameter {Path}another\r\n         *@return {Boolean}\r\n         */\r\n        \"equals\": /*Boolean*/ function( /*Path*/ another) {\r\n            var segments = this._.segments,\r\n                anotherSegments = another._.segments;\r\n            if (segments.length != anotherSegments.length) {\r\n                return false;\r\n            }\r\n            for (var i = 0; i < segments.length; i++) {\r\n                if (anotherSegments[i] != segments[i]) {\r\n                    return false;\r\n                };\r\n            }\r\n            return true;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method firstSegment\r\n         *@parameter {Number}length\r\n         *@return {String}\r\n         */\r\n        firstSegment: /*String*/ function( /*Number*/ length) {\r\n            var segments = this._.segments;\r\n            return segments[length || 0];\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method getExtension\r\n         *@return {String}\r\n         */\r\n        getExtension: function() {\r\n            var extension = this._.extension,\r\n                path = this._.path;\r\n            if (!textension) {\r\n                extension = this._.extension = path.substr(path.lastIndexOf('.') + 1);\r\n            }\r\n            return extension;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method getSegments\r\n         *@return {Array}\r\n         */\r\n        getSegments: /*Array*/ function() {\r\n            return this.segments;\r\n        },\r\n\r\n        /*\r\n         *Returns the parent path, or null if this path does not have a parent.\r\n         *@method getParentPath\r\n         *@return {Path}\r\n         */\r\n        getParentPath: /*Path*/ function() {\r\n            var parentPath = this._.parentPath;\r\n            if (!parentPath) {\r\n                var parentSegments = this.segments;\r\n                parentSegments.pop();\r\n                parentPath = this._.parentPath = new Path(parentSegments, this.hasLeading);\r\n            }\r\n            return parentPath;\r\n        },\r\n\r\n\r\n        /*\r\n         *Returns the root component of this path as a Path object, or null if this path does not have a root component.\r\n         *@method getRoot\r\n         *@return {Path}\r\n         */\r\n        \"getRoot\": /*Path*/ function() {\r\n            //TODO: will be implemented\r\n        },\r\n\r\n        /*\r\n         *Tells whether or not this path is absolute.\r\n         *@method isAbsolute\r\n         *@return {Boolean}\r\n         */\r\n        isAbsolute: /*Boolean*/ function() {\r\n            return this.hasLeading;\r\n        },\r\n\r\n\r\n        /*\r\n         *\r\n         *@method lastSegment\r\n         *@ return {String}\r\n         */\r\n        lastSegment: /*String*/ function() {\r\n            var segments = this._.segments;\r\n            return segments[segments.length - 1];\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method matchingFirstSegments\r\n         *@parameter {Path}another\r\n         *@return {Number}\r\n         */\r\n        matchingFirstSegments: /*Number*/ function( /*Path*/ another) {\r\n            var mySegments = this.segments;\r\n            var pathSegments = another.segments;\r\n            var max = Math.min(mySegments.length, pathSegments.length);\r\n            var count = 0;\r\n            for (var i = 0; i < max; i++) {\r\n                if (mySegments[i] != pathSegments[i]) {\r\n                    return count;\r\n                }\r\n                count++;\r\n            }\r\n            return count;\r\n        },\r\n\r\n        /*\r\n         *Returns a path that is this path with redundant name elements eliminated.\r\n         *@method normalize\r\n         *@return {Path}\r\n         */\r\n        \"normalize\": /*Path*/ function() {\r\n            //TODO: will be implemented\r\n        },\r\n\r\n\r\n        /*\r\n         *\r\n         *@method removeFirstSegments\r\n         *@parameter {Number}count\r\n         *@return {Path}\r\n         */\r\n        removeFirstSegments: /*Path*/ function( /*Number*/ count) {\r\n            var segments = this._.segments,\r\n                hasLeading = this._.hasLeading;\r\n            hasTrailing = this._.hasTrailing;\r\n\r\n            return new Path(segments.slice(count, segments.length), hasLeading, hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeLastSegments\r\n         *@parameter {Number}count\r\n         *@return {Path}\r\n         */\r\n        removeLastSegments: /*Path*/ function( /*Number?*/ count) {\r\n            var segments = this._.segments,\r\n                hasLeading = this._.hasLeading;\r\n            hasTrailing = this._.hasTrailing;\r\n\r\n            if (!count) {\r\n                count = 1;\r\n            }\r\n\r\n            return new Path(segments.slice(0, segments.length - count), hasLeading, hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeMatchingFirstSegments\r\n         *@parameter {Path}another\r\n         *@return {Path}\r\n         */\r\n        removeMatchingFirstSegments: /*Path*/ function( /*Path*/ another) {\r\n            var match = this.matchingFirstSegments(another);\r\n            return this.removeFirstSegments(match);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeMatchingLastSegments\r\n         *@parameter {Path}another\r\n         *@return {Path}\r\n         */\r\n        removeMatchingLastSegments: /*Path*/ function( /*Path*/ another) {\r\n            var match = this.matchingFirstSegments(anotherPath);\r\n            return this.removeLastSegments(match);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeRelative\r\n         *@return {Path}\r\n         */\r\n        removeRelative: function() {\r\n            var segs = this.segments;\r\n            if (segs.length > 0 && segs[1] == \".\")\r\n                return this.removeFirstSegments(1);\r\n            return this;\r\n        },\r\n\r\n        /*\r\n         *Constructs a relative path between this path and a given path.\r\n         *@method relativeTo\r\n         *@parameter {Path}base\r\n         *@return {Path}\r\n         */\r\n        relativeTo: /*Path*/ function( /*Path|String*/ base, /*Boolean*/ ignoreFilename) {\r\n            if (typeof base == 'string') {\r\n                base = new Path(base);\r\n            }\r\n            var mySegments = this.segments;\r\n            if (this.isAbsolute()) {\r\n                return this;\r\n            }\r\n            var baseSegments = base.segments;\r\n            var commonLength = this.matchingFirstSegments(base);\r\n            var baseSegmentLength = baseSegments.length;\r\n            if (ignoreFilename) {\r\n                baseSegmentLength = baseSegmentLength - 1;\r\n            }\r\n            var differenceLength = baseSegmentLength - commonLength;\r\n            var newSegmentLength = differenceLength + mySegments.length - commonLength;\r\n            if (newSegmentLength == 0) {\r\n                return Path.EMPTY;\r\n            }\r\n            var newSegments = [];\r\n            for (var i = 0; i < differenceLength; i++) {\r\n                newSegments.push('..');\r\n            }\r\n            for (var i = commonLength; i < mySegments.length; i++) {\r\n                newSegments.push(mySegments[i]);\r\n            }\r\n            return new Path(newSegments, false, this.hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method segment\r\n         *@parameter {Number}index\r\n         *@return {String}\r\n         */\r\n        segment: /*String*/ function( /*Number*/ index) {\r\n            var segments = this._.segments;\r\n            if (segments.length < index) return null;\r\n            return segments[index];\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method startsWith\r\n         *@parameter {Path}index\r\n         *@return {Boolean}\r\n         */\r\n        startsWith: /*Boolean*/ function( /*Path*/ another) {\r\n            var count = this.matchingFirstSegments(another);\r\n            return another._length() == count;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method toString\r\n         *@return {String}\r\n         */\r\n        toString: function() {\r\n            var result = [],\r\n                segments = this._.segments;\r\n            if (this.hasLeading) {\r\n                result.push(\"/\");\r\n            }\r\n            for (var i = 0; i < segments.length; i++) {\r\n                if (i > 0) {\r\n                    result.push(\"/\");\r\n                }\r\n                result.push(segments[i]);\r\n            }\r\n            if (this.hasTrailing) {\r\n                result.push(\"/\");\r\n            }\r\n            return result.join(\"\");\r\n        },\r\n\r\n        hasLeading : {\r\n            get : function() {\r\n                return this._.hasLeading\r\n            }\r\n        },\r\n\r\n        hasTrailing : {\r\n            get : function() {\r\n                return this._.hasTrailing\r\n            }\r\n        }\r\n\r\n    });\r\n\r\n\r\n    Path.EMPTY = new Path(\"\");\r\n\r\n    return urls.Path = Path;\r\n});\r\n\ndefine('skylark-langx-urls/main',[\r\n\t\"./urls\",\r\n\t\"./create_object_url\",\r\n\t\"./create_valid_absolute_url\",\r\n\t\"./get-absolute-url\",\r\n\t\"./get-file-extension\",\r\n\t\"./get-file-name\",\r\n\t\"./get-query\",\r\n\t\"./is-cross-origin\",\r\n\t\"./is_same_origin\",\r\n\t\"./parse-url\",\r\n\t\"./path\"\r\n],function(urls){\r\n\treturn urls;\r\n});\ndefine('skylark-langx-urls', ['skylark-langx-urls/main'], function (main) { return main; });\n\ndefine('skylark-langx/urls',[\r\n\t\"skylark-langx-urls\"\r\n],function(urls){\r\n\treturn urls;\r\n});\ndefine('skylark-langx/langx',[\r\n    \"./skylark\",\r\n    \"./arrays\",\r\n    \"./array-store\",\r\n    \"./aspect\",\r\n    \"./async\",\r\n    \"./binary\",\r\n    \"./constructs\",\r\n    \"./datetimes\",\r\n    \"./deferred\",\r\n    \"./emitter\",\r\n    \"./evented\",\r\n    \"./events\",\r\n    \"./funcs\",\r\n    \"./globals\",\r\n    \"./hoster\",\r\n    \"./klass\",\r\n    \"./maths\",\r\n    \"./numerics\",\r\n    \"./objects\",\r\n    \"./stateful\",\r\n    \"./strings\",\r\n    \"./topic\",\r\n    \"./types\",\r\n    \"./urls\"\r\n], function(\r\n    skylark,\r\n    arrays,\r\n    ArrayStore,\r\n    aspect,\r\n    async,\r\n    binary,\r\n    constructs,\r\n    datetimes,\r\n    Deferred,\r\n    Emitter,\r\n    Evented,\r\n    events,\r\n    funcs,\r\n    globals,\r\n    hoster,\r\n    klass,\r\n    maths,\r\n    numerics,\r\n    objects,\r\n    Stateful,\r\n    strings,\r\n    topic,\r\n    types,\r\n    urls\r\n) {\r\n    \"use strict\";\r\n    var toString = {}.toString,\r\n        concat = Array.prototype.concat,\r\n        indexOf = Array.prototype.indexOf,\r\n        slice = Array.prototype.slice,\r\n        filter = Array.prototype.filter,\r\n        mixin = objects.mixin,\r\n        safeMixin = objects.safeMixin,\r\n        isFunction = types.isFunction;\r\n\r\n\r\n    function funcArg(context, arg, idx, payload) {\r\n        return isFunction(arg) ? arg.call(context, idx, payload) : arg;\r\n    }\r\n\r\n    function getQueryParams(url) {\r\n        var url = url || window.location.href,\r\n            segs = url.split(\"?\"),\r\n            params = {};\r\n\r\n        if (segs.length > 1) {\r\n            segs[1].split(\"&\").forEach(function(queryParam) {\r\n                var nv = queryParam.split('=');\r\n                params[nv[0]] = nv[1];\r\n            });\r\n        }\r\n        return params;\r\n    }\r\n\r\n\r\n    function toPixel(value) {\r\n        // style values can be floats, client code may want\r\n        // to round for integer pixels.\r\n        return parseFloat(value) || 0;\r\n    }\r\n\r\n\r\n    var _uid = 1;\r\n\r\n    function uid(obj) {\r\n        return obj._uid || (obj._uid = _uid++);\r\n    }\r\n\r\n    function langx() {\r\n        return langx;\r\n    }\r\n\r\n    mixin(langx, {\r\n        createEvent : Emitter.createEvent,\r\n\r\n        funcArg: funcArg,\r\n\r\n        getQueryParams: getQueryParams,\r\n\r\n        toPixel: toPixel,\r\n\r\n        uid: uid,\r\n\r\n        URL: typeof window !== \"undefined\" ? window.URL || window.webkitURL : null\r\n\r\n    });\r\n\r\n\r\n    mixin(langx, arrays,aspect,datetimes,funcs,numerics,objects,strings,types,{\r\n        ArrayStore : ArrayStore,\r\n\r\n        async : async,\r\n        \r\n        Deferred: Deferred,\r\n\r\n        Emitter: Emitter,\r\n\r\n        Evented: Evented,\r\n\r\n        hoster : hoster,\r\n\r\n        klass : klass,\r\n       \r\n        Stateful: Stateful,\r\n\r\n        topic : topic\r\n    });\r\n\r\n    return skylark.langx = langx;\r\n});\ndefine('skylark-domx-browser/browser',[\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\"\r\n], function(skylark,langx) {\r\n    \"use strict\";\r\n\r\n    var browser = langx.hoster.browser;\r\n\r\n\r\n    langx.mixin(browser, {\r\n\r\n        isIE : !!/msie/i.exec( window.navigator.userAgent ),\r\n\r\n        location: function() {\r\n            return window.location;\r\n        },\r\n\r\n        support : {\r\n\r\n        }\r\n\r\n    });\r\n\r\n\r\n\r\n    return skylark.attach(\"domx.browser\",browser);\r\n});\r\n\ndefine('skylark-domx-browser/support/css3',[\r\n    \"skylark-langx/langx\",\r\n    \"../browser\"\r\n], function(langx,browser) {\r\n    \"use strict\";\r\n\r\n    var checkedCssProperties = {\r\n            \"transitionproperty\": \"TransitionProperty\",\r\n        },\r\n        transEndEventNames = {\r\n          WebkitTransition : 'webkitTransitionEnd',\r\n          MozTransition    : 'transitionend',\r\n          OTransition      : 'oTransitionEnd otransitionend',\r\n          transition       : 'transitionend'\r\n        },\r\n        transEndEventName = null;\r\n\r\n\r\n    var css3PropPrefix = \"\",\r\n        css3StylePrefix = \"\",\r\n        css3EventPrefix = \"\",\r\n\r\n        cssStyles = {},\r\n        cssProps = {},\r\n\r\n        vendorPrefix,\r\n        vendorPrefixRE,\r\n        vendorPrefixesRE = /^(Webkit|webkit|O|Moz|moz|ms)(.*)$/,\r\n\r\n        document = window.document,\r\n        testEl = document.createElement(\"div\"),\r\n\r\n        matchesSelector = testEl.webkitMatchesSelector ||\r\n                          testEl.mozMatchesSelector ||\r\n                          testEl.oMatchesSelector ||\r\n                          testEl.matchesSelector,\r\n\r\n        testStyle = testEl.style;\r\n\r\n    for (var name in testStyle) {\r\n        var matched = name.match(vendorPrefixRE || vendorPrefixesRE);\r\n        if (matched) {\r\n            if (!vendorPrefixRE) {\r\n                vendorPrefix = matched[1];\r\n                vendorPrefixRE = new RegExp(\"^(\" + vendorPrefix + \")(.*)$\");\r\n\r\n                css3StylePrefix = vendorPrefix;\r\n                css3PropPrefix = '-' + vendorPrefix.toLowerCase() + '-';\r\n                css3EventPrefix = vendorPrefix.toLowerCase();\r\n            }\r\n\r\n            cssStyles[langx.lowerFirst(matched[2])] = name;\r\n            var cssPropName = langx.dasherize(matched[2]);\r\n            cssProps[cssPropName] = css3PropPrefix + cssPropName;\r\n\r\n            if (transEndEventNames[name]) {\r\n              transEndEventName = transEndEventNames[name];\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!transEndEventName) {\r\n        if (testStyle[\"transition\"] !== undefined) {\r\n            transEndEventName = transEndEventNames[\"transition\"];\r\n        }\r\n    }\r\n\r\n    function normalizeCssEvent(name) {\r\n        return css3EventPrefix ? css3EventPrefix + name : name.toLowerCase();\r\n    }\r\n\r\n    function normalizeCssProperty(name) {\r\n        return cssProps[name] || name;\r\n    }\r\n\r\n    function normalizeStyleProperty(name) {\r\n        return cssStyles[name] || name;\r\n    }\r\n\r\n\r\n    var css3 = {\r\n\r\n        normalizeStyleProperty: normalizeStyleProperty,\r\n\r\n        normalizeCssProperty: normalizeCssProperty,\r\n\r\n        normalizeCssEvent: normalizeCssEvent,\r\n\r\n        matchesSelector: matchesSelector        \r\n    };\r\n\r\n    langx.mixin(browser,css3);\r\n\r\n    browser.css3PropPrefix = css3.propPrefix =  css3PropPrefix;\r\n\r\n    if  (transEndEventName) {\r\n        browser.support.transition = css3.transition = {\r\n            end : transEndEventName\r\n        };\r\n    }\r\n\r\n    browser.support.cssPointerEvents = css3.pointerEvents =  (function() {\r\n        testEl.style.cssText = 'pointer-events:auto';\r\n        return testEl.style.pointerEvents === 'auto';\r\n    })(),\r\n\r\n\r\n\r\n\r\n    testEl = null;\r\n\r\n    return browser.support.css3 = css3;\r\n});\r\n\ndefine('skylark-domx-browser/support/fullscreen',[\r\n    \"../browser\"\r\n],function(browser){\r\n\r\n    const FullscreenApi = { \r\n        prefixed: true \r\n    };\r\n\r\n    const apiMap = [\r\n        [\r\n            'requestFullscreen',\r\n            'exitFullscreen',\r\n            'fullscreenElement',\r\n            'fullscreenEnabled',\r\n            'fullscreenchange',\r\n            'fullscreenerror',\r\n            'fullscreen'\r\n        ],\r\n        [\r\n            'webkitRequestFullscreen',\r\n            'webkitExitFullscreen',\r\n            'webkitFullscreenElement',\r\n            'webkitFullscreenEnabled',\r\n            'webkitfullscreenchange',\r\n            'webkitfullscreenerror',\r\n            '-webkit-full-screen'\r\n        ],\r\n        [\r\n            'mozRequestFullScreen',\r\n            'mozCancelFullScreen',\r\n            'mozFullScreenElement',\r\n            'mozFullScreenEnabled',\r\n            'mozfullscreenchange',\r\n            'mozfullscreenerror',\r\n            '-moz-full-screen'\r\n        ],\r\n        [\r\n            'msRequestFullscreen',\r\n            'msExitFullscreen',\r\n            'msFullscreenElement',\r\n            'msFullscreenEnabled',\r\n            'MSFullscreenChange',\r\n            'MSFullscreenError',\r\n            '-ms-fullscreen'\r\n        ]\r\n    ];\r\n    const specApi = apiMap[0];\r\n    let browserApi;\r\n    for (let i = 0; i < apiMap.length; i++) {\r\n        if (apiMap[i][1] in document) {\r\n            browserApi = apiMap[i];\r\n            break;\r\n        }\r\n    }\r\n    if (browserApi) {\r\n        for (let i = 0; i < browserApi.length; i++) {\r\n            FullscreenApi[specApi[i]] = browserApi[i];\r\n        }\r\n        FullscreenApi.prefixed = browserApi[0] !== specApi[0];\r\n\r\n        browser.requestFullscreen = function() {\r\n            return document.body[FullscreenApi[\"requestFullscreen\"]].apply(this,arguments);\r\n        };\r\n        browser.exitFullscreen = function() {\r\n            return document[FullscreenApi[\"exitFullscreen\"]].apply(this,arguments);\r\n        };\r\n\r\n        browser.support.fullscreen = FullscreenApi;\r\n    } else {\r\n        browser.support.fullscreen = null;\r\n    }\r\n\r\n    return browser.support.fullscreen;\r\n});\ndefine('skylark-domx-browser/support/touch',[\r\n\t\"../browser\"\r\n],function(browser){\r\n\r\n    function supportTouch() {\r\n        return !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch);\r\n    }\r\n\r\n    return browser.support.tocuh = supportTouch();\r\n});\ndefine('skylark-domx-browser/main',[\r\n\t\"./browser\",\r\n\t\"./support/css3\",\r\n\t\"./support/fullscreen\",\r\n\t\"./support/touch\"\r\n],function(browser){\r\n\treturn browser;\r\n});\ndefine('skylark-domx-browser', ['skylark-domx-browser/main'], function (main) { return main; });\n\ndefine('skylark-langx/main',[\r\n    \"./langx\"\r\n], function(langx) {\r\n    return langx;\r\n});\r\n\ndefine('skylark-langx', ['skylark-langx/main'], function (main) { return main; });\n\ndefine('skylark-langx-scripter/scripter',[\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx\"\r\n], function(skylark, langx) {\r\n\r\n    var head = document.getElementsByTagName('head')[0],\r\n        scriptsByUrl = {},\r\n        scriptElementsById = {},\r\n        count = 0;\r\n\r\n    function scripter() {\r\n        return scripter;\r\n    }\r\n\r\n\r\n    var preservedScriptAttributes = {\r\n        type: true,\r\n        src: true,\r\n        nonce: true,\r\n        noModule: true\r\n    };\r\n\r\n    function evaluate(code,node, doc ) {\r\n        doc = doc || document;\r\n\r\n        var i, val,\r\n            script = doc.createElement(\"script\");\r\n\r\n        script.text = code;\r\n        if ( node ) {\r\n            for ( i in preservedScriptAttributes ) {\r\n\r\n                // Support: Firefox 64+, Edge 18+\r\n                // Some browsers don't support the \"nonce\" property on scripts.\r\n                // On the other hand, just using `getAttribute` is not enough as\r\n                // the `nonce` attribute is reset to an empty string whenever it\r\n                // becomes browsing-context connected.\r\n                // See https://github.com/whatwg/html/issues/2369\r\n                // See https://html.spec.whatwg.org/#nonce-attributes\r\n                // The `node.getAttribute` check was added for the sake of\r\n                // `jQuery.globalEval` so that it can fake a nonce-containing node\r\n                // via an object.\r\n                val = node[ i ] || node.getAttribute && node.getAttribute( i );\r\n                if ( val ) {\r\n                    script.setAttribute( i, val );\r\n                }\r\n            }\r\n        }\r\n        doc.head.appendChild( script ).parentNode.removeChild( script );\r\n\r\n        return this;\r\n    }\r\n\r\n    langx.mixin(scripter, {\r\n        /*\r\n         * Load a script from a url into the document.\r\n         * @param {} url\r\n         * @param {} loadedCallback\r\n         * @param {} errorCallback\r\n         */\r\n        loadJavaScript: function(url, loadedCallback, errorCallback) {\r\n            var script = scriptsByUrl[url];\r\n            if (!script) {\r\n                script = scriptsByUrl[url] = {\r\n                    state: 0, //0:unload,1:loaded,-1:loaderror\r\n                    loadedCallbacks: [],\r\n                    errorCallbacks: []\r\n                }\r\n            }\r\n\r\n            script.loadedCallbacks.push(loadedCallback);\r\n            script.errorCallbacks.push(errorCallback);\r\n\r\n            if (script.state === 1) {\r\n                script.node.onload();\r\n            } else if (script.state === -1) {\r\n                script.node.onerror();\r\n            } else {\r\n                var node = script.node = document.createElement(\"script\"),\r\n                    id = script.id = (count++);\r\n\r\n                node.type = \"text/javascript\";\r\n                node.async = false;\r\n                node.defer = false;\r\n                startTime = new Date().getTime();\r\n                head.appendChild(node);\r\n\r\n                node.onload = function() {\r\n                        script.state = 1;\r\n\r\n                        var callbacks = script.loadedCallbacks,\r\n                            i = callbacks.length;\r\n\r\n                        while (i--) {\r\n                            callbacks[i]();\r\n                        }\r\n                        script.loadedCallbacks = [];\r\n                        script.errorCallbacks = [];\r\n                    },\r\n                    node.onerror = function() {\r\n                        script.state = -1;\r\n                        var callbacks = script.errorCallbacks,\r\n                            i = callbacks.length;\r\n\r\n                        while (i--) {\r\n                            callbacks[i]();\r\n                        }\r\n                        script.loadedCallbacks = [];\r\n                        script.errorCallbacks = [];\r\n                    };\r\n                node.src = url;\r\n\r\n                scriptElementsById[id] = node;\r\n            }\r\n            return script.id;\r\n        },\r\n        /*\r\n         * Remove the specified script from the document.\r\n         * @param {Number} id\r\n         */\r\n        deleteJavaScript: function(id) {\r\n            var node = scriptElementsById[id];\r\n            if (node) {\r\n                var url = node.src;\r\n                if (node.parentNode) {\r\n                    node.parentNode.remove(node);\r\n                }\r\n                delete scriptElementsById[id];\r\n                delete scriptsByUrl[url];\r\n            }\r\n        },\r\n\r\n        evaluate : evaluate,\r\n\r\n        loadScript : function(url) {\r\n            var d = new langx.Deferred();\r\n\r\n            d.promise.scriptId = this.loadJavaScript(url,function(){\r\n                d.resolve();\r\n            },function(e){\r\n                d.reject(e);\r\n            });\r\n\r\n            return d.promise;\r\n        }\r\n\r\n\r\n    });\r\n\r\n    return skylark.attach(\"langx.scripter\", scripter);\r\n});\ndefine('skylark-langx-scripter/main',[\r\n\t\"./scripter\"\r\n],function(scripter){\r\n\t\r\n\treturn scripter;\r\n});\ndefine('skylark-langx-scripter', ['skylark-langx-scripter/main'], function (main) { return main; });\n\ndefine('skylark-domx-noder/noder',[\r\n    \"skylark-langx-ns\",\r\n    \"skylark-langx-types\",\r\n    \"skylark-langx-arrays\",\r\n    \"skylark-langx-strings\",\r\n    \"skylark-langx-scripter\",\r\n    \"skylark-domx-browser\"\r\n], function(skylark, types, arrays, strings,scripter,browser) {\r\n    var  \r\n        map = Array.prototype.map,\r\n        slice = Array.prototype.slice;\r\n\r\n\r\n    /**\r\n     * Generate id\r\n     * @param   {HTMLElement} el\r\n     * @returns {String}\r\n     * @private\r\n     */\r\n    function generateId(el) {\r\n        var str = el.tagName + el.className + el.src + el.href + el.textContent,\r\n            i = str.length,\r\n            sum = 0;\r\n\r\n        while (i--) {\r\n            sum += str.charCodeAt(i);\r\n        }\r\n\r\n        return sum.toString(36);\r\n    }\r\n\r\n\r\n    function noder() {\r\n        return noder;\r\n    }\r\n\r\n    Object.assign(noder, {\r\n\r\n\r\n        blur : function(el) {\r\n            el.blur();\r\n        },\r\n\r\n\r\n        generateId\r\n    });\r\n\r\n    return skylark.attach(\"domx.noder\" , noder);\r\n});\ndefine('skylark-domx-noder/active',[\r\n\t\"./noder\"\r\n],function(noder){\r\n\r\n    function activeElement(doc) {\r\n        doc = doc || document;\r\n        var el;\r\n\r\n        // Support: IE 9 only\r\n        // IE9 throws an \"Unspecified error\" accessing document.activeElement from an <iframe>\r\n        try {\r\n            el = doc.activeElement;\r\n        } catch ( error ) {\r\n            el = doc.body;\r\n        }\r\n\r\n        // Support: IE 9 - 11 only\r\n        // IE may return null instead of an element\r\n        // Interestingly, this only seems to occur when NOT in an iframe\r\n        if ( !el ) {\r\n            el = doc.body;\r\n        }\r\n\r\n        // Support: IE 11 only\r\n        // IE11 returns a seemingly empty object in some cases when accessing\r\n        // document.activeElement from an <iframe>\r\n        if ( !el.nodeName ) {\r\n            el = doc.body;\r\n        }\r\n\r\n        return el;\r\n    };\r\n\treturn noder.active = activeElement;\r\n});\ndefine('skylark-domx-noder/_enhance_place_content',[\r\n    \"skylark-langx-types\",\r\n    \"skylark-langx-arrays\",\r\n\t\"./noder\"\r\n],function(types,arrays,noder){\r\n    function enhancePlaceContent(placing,node) {\r\n        if (types.isFunction(placing)) {\r\n            return placing.apply(node,[]);\r\n        }\r\n        if (types.isArrayLike(placing)) {\r\n            var neddsFlattern;\r\n            for (var i=0;i<placing.length;i++) {\r\n                if (types.isFunction(placing[i])) {\r\n                    placing[i] = placing[i].apply(node,[]);\r\n                    if (types.isArrayLike(placing[i])) {\r\n                        neddsFlattern = true;\r\n                    }\r\n                }\r\n            }\r\n            if (neddsFlattern) {\r\n                placing = arrays.flatten(placing);\r\n            }\r\n        }\r\n        return placing;\r\n    }\r\n\r\n\treturn enhancePlaceContent;\r\n});\ndefine('skylark-domx-noder/is-element',[\r\n\t\"./noder\"\r\n],function(noder){\r\n \r\n    function isElement(node) {\r\n        return node && node.nodeType === 1;\r\n    }\r\n\r\n\t\r\n\treturn noder.isElement = isElement;\r\n});\ndefine('skylark-domx-noder/is-text-node',[\r\n\t\"./noder\"\r\n],function(noder){\r\n \r\n    function isTextNode(node) {\r\n        return node && node.nodeType === 3;\r\n    }\r\n\r\n\t\r\n\treturn noder.isTextNode = isTextNode;\r\n});\ndefine('skylark-domx-noder/is-fragment',[\r\n\t\"./noder\"\r\n],function(noder){\r\n \r\n    function isFragment(node) {\r\n        return node && node.nodeType === 11;\r\n    }\r\n\r\n\treturn noder.isFragment = isFragment;\r\n});\ndefine('skylark-domx-noder/_normalize_content',[\r\n    \"skylark-langx-types\",\r\n\t\"./noder\",\r\n    \"./is-element\",\r\n    \"./is-text-node\",\r\n    \"./is-fragment\"\r\n],function(types,noder,isElement,isTextNode,isFragment){\r\n    var  \r\n        map = Array.prototype.map;\r\n        \r\n    function normalizeContent(content) {\r\n        if (typeof content === 'function') {\r\n            content = content();\r\n        }\r\n        return map.call(types.isArrayLike(content) ? content : [content],value => {\r\n            if (typeof value === 'function') {\r\n                value = value();\r\n            }\r\n            if (isElement(value) || isTextNode(value) || isFragment(value)) {\r\n                return value;\r\n            }\r\n            if (typeof value === 'string' && /\\S/.test(value)) {\r\n                return document.createTextNode(value);\r\n            }\r\n        }).filter(value => value);\r\n    }\r\n\r\n\treturn normalizeContent;\r\n});\ndefine('skylark-domx-noder/_ensure_nodes',[\r\n    \"skylark-langx-arrays\",\r\n\t\"./noder\",\r\n    \"./_normalize_content\"\r\n],function(arrays,noder,normalizeContent){\r\n    var  \r\n        map = Array.prototype.map;\r\n\r\n    function ensureNodes(content, copyByClone) {\r\n        var nodes = normalizeContent(content);\r\n\r\n\r\n        //if (!types.isArrayLike(nodes)) {\r\n        //    nodes = [nodes];\r\n        //}\r\n        if (copyByClone) {\r\n            nodes = map.call(nodes, function(node) {\r\n                return node.cloneNode(true);\r\n            });\r\n        }\r\n        return arrays.flatten(nodes);\r\n    }\r\n\r\n\treturn ensureNodes;\r\n});\ndefine('skylark-domx-noder/after',[\r\n\t\"./noder\",\r\n    \"./_enhance_place_content\",\r\n    \"./_ensure_nodes\"\r\n],function(noder,enhancePlaceContent,ensureNodes){\r\n \r\n    function after(node, placing, copyByClone) {\r\n        placing = enhancePlaceContent(placing,node);\r\n        var refNode = node,\r\n            parent = refNode.parentNode;\r\n        if (parent) {\r\n            var nodes = ensureNodes(placing, copyByClone),\r\n                refNode = refNode.nextSibling;\r\n\r\n            for (var i = 0; i < nodes.length; i++) {\r\n                if (refNode) {\r\n                    parent.insertBefore(nodes[i], refNode);\r\n                } else {\r\n                    parent.appendChild(nodes[i]);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n\t\r\n\treturn noder.after = after;\r\n});\ndefine('skylark-domx-noder/append',[\r\n    \"./noder\",\r\n    \"./_enhance_place_content\",\r\n    \"./_ensure_nodes\"\r\n],function(noder,enhancePlaceContent,ensureNodes){\r\n \r\n    function append(node, placing, copyByClone) {\r\n        placing = enhancePlaceContent(placing,node);\r\n        var parentNode = node,\r\n            nodes = ensureNodes(placing, copyByClone);\r\n        for (var i = 0; i < nodes.length; i++) {\r\n            parentNode.appendChild(nodes[i]);\r\n        }\r\n        return this;\r\n    }\r\n    \r\n    return noder.append = append;\r\n});\ndefine('skylark-domx-noder/before',[\r\n    \"./noder\",\r\n    \"./_enhance_place_content\",\r\n    \"./_ensure_nodes\"\r\n],function(noder,enhancePlaceContent,ensureNodes){\r\n \r\n\r\n    function before(node, placing, copyByClone) {\r\n        placing = enhancePlaceContent(placing,node);\r\n        var refNode = node,\r\n            parent = refNode.parentNode;\r\n        if (parent) {\r\n            var nodes = ensureNodes(placing, copyByClone);\r\n            for (var i = 0; i < nodes.length; i++) {\r\n                parent.insertBefore(nodes[i], refNode);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n\t\r\n\treturn noder.before = before;\r\n});\ndefine('skylark-domx-noder/body',[\r\n\t\"./noder\"\r\n],function(noder){\r\n\tfunction body() {\r\n\t\treturn  document.body;\r\n\t}\r\n\t\r\n\treturn noder.body = body;\r\n});\ndefine('skylark-domx-noder/clone',[\r\n\t\"./noder\"\r\n],function(noder){\r\n \r\n    /*   \r\n     * Create a deep copy of the set of matched elements.\r\n     * @param {HTMLElement} node\r\n     * @param {Boolean} deep\r\n     */\r\n    function clone(node, deep) {\r\n        return node.cloneNode(deep);\r\n    }\r\n\r\n\t\r\n\treturn noder.clone = clone;\r\n});\ndefine('skylark-domx-noder/is-child-of',[\r\n\t\"./noder\"\r\n],function(noder){\r\n    /*   \r\n     * Check to see if a dom node is a descendant of another dom node.\r\n     * @param {Node} node\r\n     * @param {Node} parent\r\n     * @param {Node} directly\r\n     */\r\n    function isChildOf(node, parent, directly) {\r\n        if (directly) {\r\n            return node.parentNode === parent;\r\n        }\r\n        if (document.documentElement.contains) {\r\n            return parent.contains(node);\r\n        }\r\n        while (node) {\r\n            if (parent === node) {\r\n                return true;\r\n            }\r\n\r\n            node = node.parentNode;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\t\r\n\treturn noder.isChildOf = isChildOf;\r\n});\ndefine('skylark-domx-noder/contains',[\r\n\t\"./noder\",\r\n    \"./is-child-of\"\r\n],function(noder,isChildOf){\r\n \r\n    /*   \r\n     * Check to see if a dom node is a descendant of another dom node .\r\n     * @param {String} node\r\n     * @param {Node} child\r\n     */\r\n    function contains(node, child) {\r\n        return isChildOf(child, node);\r\n    }\r\n\t\r\n\treturn noder.contains = contains;\r\n});\ndefine('skylark-domx-noder/create-element',[\r\n    \"skylark-langx-types\",\r\n\t\"./noder\"\r\n],function(types,noder){\r\n \r\n    /*   \r\n     * Create a element and set attributes on it.\r\n     * @param {HTMLElement} tag\r\n     * @param {attrs} attrs\r\n     * @param } parent\r\n     */\r\n    function createElement(tag, props,attrs, parent) {\r\n        var node;\r\n\r\n        if (/svg/i.test(tag)) {\r\n            node = document.createElementNS(\"http://www.w3.org/2000/svg\", tag)\r\n        } else {\r\n            node = document.createElement(tag);\r\n        }\r\n\r\n        if (types.isHtmlNode(props)) {\r\n            parent = props;\r\n            props = null;\r\n            attrs = null;\r\n        } else if (types.isHtmlNode(attrs)){\r\n            parent = attrs;\r\n            attrs = null;\r\n        }\r\n\r\n        if (props) {\r\n            for (var name in props) {\r\n                node[name] = props[name];\r\n            }\r\n        }\r\n\r\n        if (attrs) {\r\n            for (var name in attrs) {\r\n                node.setAttribute(name, attrs[name]);\r\n            }\r\n        }\r\n        if (parent) {\r\n            noder.append(parent, node);\r\n        }\r\n        return node;\r\n    }\r\n\r\n\t\r\n\treturn noder.createElement = createElement;\r\n});\ndefine('skylark-domx-noder/create-fragment',[\r\n    \"skylark-langx-strings\",\r\n\t\"./noder\",\r\n    \"./create-element\"\r\n],function(strings,noder,createElement){\r\n    var fragmentRE = /^\\s*<(\\w+|!)[^>]*>/,\r\n        singleTagRE = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\r\n        div = document.createElement(\"div\"),\r\n        table = document.createElement('table'),\r\n        tableBody = document.createElement('tbody'),\r\n        tableRow = document.createElement('tr'),\r\n        containers = {\r\n            'tr': tableBody,\r\n            'tbody': table,\r\n            'thead': table,\r\n            'tfoot': table,\r\n            'td': tableRow,\r\n            'th': tableRow,\r\n            '*': div\r\n        },\r\n        slice = Array.prototype.slice;\r\n\r\n\r\n    function removeSelfClosingTags(xml) {\r\n        var split = xml.split(\"/>\");\r\n        var newXml = \"\";\r\n        for (var i = 0; i < split.length - 1;i++) {\r\n            var edsplit = split[i].split(\"<\");\r\n            newXml += split[i] + \"></\" + edsplit[edsplit.length - 1].split(\" \")[0] + \">\";\r\n        }\r\n        return newXml + split[split.length-1];\r\n    }\r\n\r\n\r\n    /*   \r\n     * Create a DocumentFragment from the HTML fragment.\r\n     * @param {String} html\r\n     */\r\n    function createFragment(html) {\r\n        // A special case optimization for a single tag\r\n        html = strings.trim(html);\r\n        if (singleTagRE.test(html)) {\r\n            return [createElement(RegExp.$1)];\r\n        }\r\n\r\n        var name = fragmentRE.test(html) && RegExp.$1\r\n        if (!(name in containers)) {\r\n            name = \"*\"\r\n        }\r\n        var container = containers[name];\r\n        container.innerHTML = removeSelfClosingTags(\"\" + html);\r\n        dom = slice.call(container.childNodes);\r\n\r\n        dom.forEach(function(node) {\r\n            container.removeChild(node);\r\n        })\r\n\r\n        return dom;\r\n    }\r\n\r\n\t\r\n\treturn noder.createFragment = createFragment;\r\n});\ndefine('skylark-domx-noder/create-text-node',[\r\n\t\"./noder\"\r\n],function(noder){\r\n \r\n    /*   \r\n     * Create a new Text node.\r\n     * @param {String} text\r\n     * @param {Node} child\r\n     */\r\n    function createTextNode(text) {\r\n        return document.createTextNode(text);\r\n    }\r\n\r\n\r\n\treturn noder.createTextNode = createTextNode;\r\n});\ndefine('skylark-domx-noder/doc',[\r\n\t\"./noder\"\r\n],function(noder){\r\n \r\n    /*   \r\n     * Get the current document object.\r\n     */\r\n    function doc() {\r\n        return document;\r\n    }\r\n\r\n\treturn noder.doc = doc;\r\n});\ndefine('skylark-domx-noder/empty',[\r\n\t\"./noder\"\r\n],function(noder){\r\n \r\n    /*   \r\n     * Remove all child nodes of the set of matched elements from the DOM.\r\n     * @param {Object} node\r\n     */\r\n    function empty(node) {\r\n        while (node.hasChildNodes()) {\r\n            var child = node.firstChild;\r\n            node.removeChild(child);\r\n        }\r\n        return this;\r\n    }\r\n\t\r\n\treturn noder.empty = empty;\r\n});\ndefine('skylark-domx-noder/focusable',[\r\n\t\"./noder\"\r\n],function(noder){\r\n \r\n    // Selectors\r\n    function focusable( element, hasTabindex ) {\r\n        var map, mapName, img, focusableIfVisible, fieldset,\r\n            nodeName = element.nodeName.toLowerCase();\r\n\r\n        if ( \"area\" === nodeName ) {\r\n            map = element.parentNode;\r\n            mapName = map.name;\r\n            if ( !element.href || !mapName || map.nodeName.toLowerCase() !== \"map\" ) {\r\n                return false;\r\n            }\r\n            img = $( \"img[usemap='#\" + mapName + \"']\" );\r\n            return img.length > 0 && img.is( \":visible\" );\r\n        }\r\n\r\n        if ( /^(input|select|textarea|button|object)$/.test( nodeName ) ) {\r\n            focusableIfVisible = !element.disabled;\r\n\r\n            if ( focusableIfVisible ) {\r\n\r\n                // Form controls within a disabled fieldset are disabled.\r\n                // However, controls within the fieldset's legend do not get disabled.\r\n                // Since controls generally aren't placed inside legends, we skip\r\n                // this portion of the check.\r\n                fieldset = $( element ).closest( \"fieldset\" )[ 0 ];\r\n                if ( fieldset ) {\r\n                    focusableIfVisible = !fieldset.disabled;\r\n                }\r\n            }\r\n        } else if ( \"a\" === nodeName ) {\r\n            focusableIfVisible = element.href || hasTabindex;\r\n        } else {\r\n            focusableIfVisible = hasTabindex;\r\n        }\r\n\r\n        return focusableIfVisible && $( element ).is( \":visible\" ) && visible( $( element ) );\r\n    };\r\n\t\r\n\treturn noder.focusable = focusable;\r\n});\ndefine('skylark-domx-noder/from-point',[\r\n\t\"./noder\"\r\n],function(noder){\r\n\r\n    function fromPoint(x,y) {\r\n        return document.elementFromPoint(x,y);\r\n    }\r\n\r\n\t\r\n\treturn noder.fromPoint = fromPoint;\r\n});\ndefine('skylark-domx-noder/fullscreen',[\r\n    \"skylark-domx-browser\",\r\n\t\"./noder\"\r\n],function(browser,noder){\r\n\r\n    var fulledEl = null;\r\n\r\n    function fullscreen(el) {\r\n        if (el === false) {\r\n            return browser.exitFullscreen.apply(document);\r\n        } else if (el) {\r\n            return el[browser.support.fullscreen.requestFullscreen]();\r\n            fulledEl = el;\r\n        } else {\r\n            return (\r\n                document.fullscreenElement ||\r\n                document.webkitFullscreenElement ||\r\n                document.mozFullScreenElement ||\r\n                document.msFullscreenElement\r\n            )\r\n        }\r\n    }\r\n\t\r\n\treturn noder.fullscreen = fullscreen;\r\n});\ndefine('skylark-domx-noder/html',[\r\n    \"skylark-langx-types\",\r\n    \"skylark-langx-scripter\",\r\n\t\"./noder\",\r\n    \"./empty\"\r\n],function(types,scripter,noder,empty){\r\n \r\n   var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\r\n       rscriptType = ( /^$|^module$|\\/(?:java|ecma)script/i );\r\n\r\n    /*   \r\n     * Get the HTML contents of the first element in the set of matched elements.\r\n     * @param {HTMLElement} node\r\n     * @param {String} html\r\n     */\r\n    function _html(node, html) {\r\n        if (html === undefined) {\r\n            return node.innerHTML;\r\n        } else {\r\n            empty(node);\r\n            html = html || \"\";\r\n            if (types.isString(html)) {\r\n                html = html.replace( rxhtmlTag, \"<$1></$2>\" );\r\n            }\r\n            if (types.isString(html) || types.isNumber(html)) {               \r\n                node.innerHTML = html;\r\n            } else if (types.isArrayLike(html)) {\r\n                for (var i = 0; i < html.length; i++) {\r\n                    node.appendChild(html[i]);\r\n                }\r\n            } else {\r\n                node.appendChild(html);\r\n            }\r\n\r\n            return this;\r\n        }\r\n    }\r\n\r\n\r\n    function html(node,value) {\r\n        var result = _html(node,value);\r\n\r\n        if (value !== undefined) {\r\n            var scripts = node.querySelectorAll('script');\r\n\r\n            for (var i =0; i<scripts.length; i++) {\r\n                var node1 = scripts[i];\r\n                if (rscriptType.test( node1.type || \"\" ) ) {\r\n                  scripter.evaluate(node1.textContent,node1);\r\n                }\r\n            }       \r\n            return this;         \r\n        } else {\r\n            return result;\r\n        }\r\n    }\r\n\r\n\r\n\treturn noder.html = html;\r\n});\ndefine('skylark-domx-noder/is-active',[\r\n\t\"./noder\"\r\n],function(noder){\r\n    function isActive (elem) {\r\n            return elem === document.activeElement && (elem.type || elem.href);\r\n    }\r\n\r\n\t\r\n\treturn noder.isActive = isActive;\r\n});\ndefine('skylark-domx-noder/is-block-node',[\r\n\t\"./noder\"\r\n],function(noder){\r\n\r\n    var blockNodes = [\"div\", \"p\", \"ul\", \"ol\", \"li\", \"blockquote\", \"hr\", \"pre\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"table\"];\r\n\r\n    function isBlockNode(node) {\r\n        if (!node || node.nodeType === 3) {\r\n          return false;\r\n        }\r\n        return new RegExp(\"^(\" + (blockNodes.join('|')) + \")$\").test(node.nodeName.toLowerCase());\r\n    }\r\n\r\n\r\n\t\r\n\treturn noder.isBlockNode = isBlockNode;\r\n});\ndefine('skylark-domx-noder/is-doc',[\r\n\t\"./noder\"\r\n],function(noder){\r\n    /*   \r\n     * Check to see if a dom node is a document.\r\n     * @param {Node} node\r\n     */\r\n    function isDocument(node) {\r\n        return node != null && node.nodeType == node.DOCUMENT_NODE\r\n    }\r\n\r\n\t\r\n\treturn noder.isDoc = isDocument;\r\n});\ndefine('skylark-domx-noder/is-editable',[\r\n\t\"./noder\"\r\n],function(noder){\r\n \r\n    function isEditable (el) {\r\n      if (!el) { return false; } // no parents were editable\r\n      if (el.contentEditable === 'false') { return false; } // stop the lookup\r\n      if (el.contentEditable === 'true') { return true; } // found a contentEditable element in the chain\r\n      return isEditable(el.parentNode); // contentEditable is set to 'inherit'\r\n    }\r\n\r\n\t\r\n\treturn noder.isEditable = isEditable;\r\n});\ndefine('skylark-domx-noder/is-fullscreen',[\r\n\t\"./noder\",\r\n    \"./fullscreen\"\r\n],function(noder,fullscreen){\r\n \r\n    function isFullscreen(el) {\r\n        return fullscreen() === el;\r\n    }\r\n\t\r\n\treturn noder.isFullscreen = isFullscreen;\r\n});\ndefine('skylark-domx-noder/is-in-document',[\r\n\t\"./noder\"\r\n],function(noder){\r\n    /*   \r\n     * Check to see if a dom node is in the document\r\n     * @param {Node} node\r\n     */\r\n    function isInDocument(node) {\r\n      return (node === document.body) ? true : document.body.contains(node);\r\n    }     \r\n\r\n\t\r\n\treturn noder.isInDocument = isInDocument;\r\n});\ndefine('skylark-domx-noder/is-in-frame',[\r\n\t\"./noder\"\r\n],function(noder){\r\n     function isInFrame() {\r\n        try {\r\n            return window.parent !== window.self;\r\n        } catch (x) {\r\n            return true;\r\n        }\r\n    }\r\n\t\r\n\treturn noder.isInFrame = isInFrame;\r\n});\ndefine('skylark-domx-noder/is-input',[\r\n\t\"./noder\",\r\n    \"./is-editable\"\r\n],function(noder,isEditable){\r\n \r\n    function isInput (el) { \r\n        return el.tagName === 'INPUT' || \r\n               el.tagName === 'TEXTAREA' || \r\n               el.tagName === 'SELECT' || \r\n               isEditable(el); \r\n    }\r\n\t\r\n\treturn noder.isInput = isInput;\r\n});\ndefine('skylark-domx-noder/is-window',[\r\n    \"skylark-langx-types\",\r\n    \"./noder\"\r\n],function(types,noder){\r\n   \r\n    return noder.isWindow = types.isWindow;\r\n\t\r\n});\ndefine('skylark-domx-noder/node-name',[\r\n\t\"./noder\"\r\n],function(noder){\r\n \r\n    function nodeName(elm, chkName) {\r\n        var name = elm.nodeName && elm.nodeName.toLowerCase();\r\n        if (chkName !== undefined) {\r\n            return name === chkName.toLowerCase();\r\n        }\r\n        return name;\r\n    };\r\n\t\r\n\treturn noder.nodeName = nodeName;\r\n});\ndefine('skylark-domx-noder/offset-parent',[\r\n\t\"./noder\"\r\n],function(noder){\r\n \r\n    var  rootNodeRE = /^(?:body|html)$/i;\r\n    \r\n    /*   \r\n     *\r\n     * @param {Node} elm\r\n     */\r\n    function offsetParent(elm) {\r\n        var parent = elm.offsetParent || document.body;\r\n        while (parent && !rootNodeRE.test(parent.nodeName) && document.defaultView.getComputedStyle(parent).position == \"static\") {\r\n            parent = parent.offsetParent;\r\n        }\r\n        return parent;\r\n    }\r\n\t\r\n\treturn noder.offsetParent = offsetParent;\r\n});\ndefine('skylark-domx-styler/styler',[\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\"\r\n], function(skylark, langx) {\r\n    var every = Array.prototype.every,\r\n        forEach = Array.prototype.forEach,\r\n        camelCase = langx.camelCase,\r\n        dasherize = langx.dasherize;\r\n\r\n    function maybeAddPx(name, value) {\r\n        return (typeof value == \"number\" && !cssNumber[dasherize(name)]) ? value + \"px\" : value\r\n    }\r\n\r\n    var cssNumber = {\r\n            'column-count': 1,\r\n            'columns': 1,\r\n            'font-weight': 1,\r\n            'line-height': 1,\r\n            'opacity': 1,\r\n            'z-index': 1,\r\n            'zoom': 1\r\n        },\r\n        classReCache = {\r\n\r\n        };\r\n\r\n    function classRE(name) {\r\n        return name in classReCache ?\r\n            classReCache[name] : (classReCache[name] = new RegExp('(^|\\\\s)' + name + '(\\\\s|$)'));\r\n    }\r\n\r\n    // access className property while respecting SVGAnimatedString\r\n    /*\r\n     * Adds the specified class(es) to each element in the set of matched elements.\r\n     * @param {HTMLElement} node\r\n     * @param {String} value\r\n     */\r\n    function className(node, value) {\r\n        var klass = node.className || '',\r\n            svg = klass && klass.baseVal !== undefined\r\n\r\n        if (value === undefined) return svg ? klass.baseVal : klass\r\n        svg ? (klass.baseVal = value) : (node.className = value)\r\n    }\r\n\r\n    function disabled(elm, value ) {\r\n        if (arguments.length < 2) {\r\n            return !!this.dom.disabled;\r\n        }\r\n\r\n        elm.disabled = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    var elementDisplay = {};\r\n\r\n    function defaultDisplay(nodeName) {\r\n        var element, display\r\n        if (!elementDisplay[nodeName]) {\r\n            element = document.createElement(nodeName)\r\n            document.body.appendChild(element)\r\n            display = getStyles(element).getPropertyValue(\"display\")\r\n            element.parentNode.removeChild(element)\r\n            display == \"none\" && (display = \"block\")\r\n            elementDisplay[nodeName] = display\r\n        }\r\n        return elementDisplay[nodeName]\r\n    }\r\n    /*\r\n     * Display the matched elements.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function show(elm) {\r\n        styler.css(elm, \"display\", \"\");\r\n        if (styler.css(elm, \"display\") == \"none\") {\r\n            styler.css(elm, \"display\", defaultDisplay(elm.nodeName));\r\n        }\r\n        return this;\r\n    }\r\n\r\n    function isInvisible(elm) {\r\n        return styler.css(elm, \"display\") == \"none\" || styler.css(elm, \"opacity\") == 0 || styler.css(elm,\"visibility\") == \"hidden\";\r\n    }\r\n\r\n    /*\r\n     * Hide the matched elements.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function hide(elm) {\r\n        styler.css(elm, \"display\", \"none\");\r\n        return this;\r\n    }\r\n\r\n    /*\r\n     * Adds the specified class(es) to each element in the set of matched elements.\r\n     * @param {HTMLElement} elm\r\n     * @param {String} name\r\n     */\r\n    function addClass(elm, name) {\r\n        if (!name) return this\r\n        var cls = className(elm),\r\n            names;\r\n        if (langx.isString(name)) {\r\n            names = name.split(/\\s+/g);\r\n        } else {\r\n            names = name;\r\n        }\r\n        names.forEach(function(klass) {\r\n            var re = classRE(klass);\r\n            if (!cls.match(re)) {\r\n                cls += (cls ? \" \" : \"\") + klass;\r\n            }\r\n        });\r\n\r\n        className(elm, cls);\r\n\r\n        return this;\r\n    }\r\n\r\n    function getStyles( elem ) {\r\n\r\n        // Support: IE <=11 only, Firefox <=30 (#15098, #14150)\r\n        // IE throws on elements created in popups\r\n        // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\r\n        var view = elem.ownerDocument.defaultView;\r\n\r\n        if ( !view || !view.opener ) {\r\n            view = window;\r\n        }\r\n\r\n        return view.getComputedStyle( elem);\r\n    }\r\n\r\n\r\n    /*\r\n     * Get the value of a computed style property for the first element in the set of matched elements or set one or more CSS properties for every matched element.\r\n     * @param {HTMLElement} elm\r\n     * @param {String} property\r\n     * @param {Any} value\r\n     */\r\n    function css(elm, property, value) {\r\n        //if (arguments.length < 3) {\r\n        if (value == void 0) {\r\n            var computedStyle,\r\n                computedStyle = getStyles(elm)\r\n            if (property == void 0) {\r\n                return computedStyle;\r\n            } else if (langx.isString(property)) {\r\n                return elm.style[camelCase(property)] || computedStyle.getPropertyValue(dasherize(property))\r\n            } else if (langx.isArrayLike(property)) {\r\n                var props = {}\r\n                forEach.call(property, function(prop) {\r\n                    props[prop] = (elm.style[camelCase(prop)] || computedStyle.getPropertyValue(dasherize(prop)))\r\n                })\r\n                return props\r\n            }\r\n        }\r\n\r\n        var css = '';\r\n        if (typeof(property) == 'string') {\r\n            if (!value && value !== 0) {\r\n                elm.style.removeProperty(dasherize(property));\r\n            } else {\r\n                css = dasherize(property) + \":\" + maybeAddPx(property, value)\r\n            }\r\n        } else {\r\n            for (key in property) {\r\n                if (property[key] === undefined) {\r\n                    continue;\r\n                }\r\n                if (!property[key] && property[key] !== 0) {\r\n                    elm.style.removeProperty(dasherize(key));\r\n                } else {\r\n                    css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'\r\n                }\r\n            }\r\n        }\r\n\r\n        elm.style.cssText += ';' + css;\r\n        return this;\r\n    }\r\n\r\n    /*\r\n     * Determine whether any of the matched elements are assigned the given class.\r\n     * @param {HTMLElement} elm\r\n     * @param {String} name\r\n     */\r\n    function hasClass(elm, name) {\r\n        var re = classRE(name);\r\n        return elm.className && elm.className.match(re);\r\n    }\r\n\r\n    /*\r\n     * Remove a single class, multiple classes, or all classes from each element in the set of matched elements.\r\n     * @param {HTMLElement} elm\r\n     * @param {String} name\r\n     */\r\n    function removeClass(elm, name) {\r\n        if (name) {\r\n            var cls = className(elm),\r\n                names;\r\n\r\n            if (langx.isString(name)) {\r\n                names = name.split(/\\s+/g);\r\n            } else {\r\n                names = name;\r\n            }\r\n\r\n            names.forEach(function(klass) {\r\n                var re = classRE(klass);\r\n                if (cls.match(re)) {\r\n                    cls = cls.replace(re, \" \");\r\n                }\r\n            });\r\n\r\n            className(elm, cls.trim());\r\n        } else {\r\n            className(elm, \"\");\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /*\r\n     * Add or remove one or more classes from the specified element.\r\n     * @param {HTMLElement} elm\r\n     * @param {String} name\r\n     * @param {} when\r\n     */\r\n    function toggleClass(elm, name, when) {\r\n        var self = this;\r\n        name.split(/\\s+/g).forEach(function(klass) {\r\n            if (when === undefined) {\r\n                when = !hasClass(elm, klass);\r\n            }\r\n            if (when) {\r\n                addClass(elm, klass);\r\n            } else {\r\n                removeClass(elm, klass)\r\n            }\r\n        });\r\n\r\n        return self;\r\n    }\r\n\r\n    var styler = function() {\r\n        return styler;\r\n    };\r\n\r\n    langx.mixin(styler, {\r\n        autocssfix: false,\r\n        cssHooks: {\r\n\r\n        },\r\n\r\n        addClass: addClass,\r\n        className: className,\r\n        css: css,\r\n        disabled : disabled,        \r\n        hasClass: hasClass,\r\n        hide: hide,\r\n        isInvisible: isInvisible,\r\n        removeClass: removeClass,\r\n        show: show,\r\n        toggleClass: toggleClass\r\n    });\r\n\r\n    return skylark.attach(\"domx.styler\", styler);\r\n});\ndefine('skylark-domx-styler/main',[\r\n\t\"./styler\"\r\n],function(styler,velm,$){\r\n\t\r\n\treturn styler;\r\n});\ndefine('skylark-domx-styler', ['skylark-domx-styler/main'], function (main) { return main; });\n\ndefine('skylark-domx-noder/overlay',[\r\n\t\"skylark-domx-styler\",\r\n\t\"./noder\"\r\n],function(styler,noder){\r\n    /*   \r\n     *\r\n     * @param {Node} elm\r\n     * @param {Node} params\r\n     */\r\n    function overlay(elm, params) {\r\n        var overlayDiv = noder.createElement(\"div\", params);\r\n        styler.css(overlayDiv, {\r\n            position: \"absolute\",\r\n            top: 0,\r\n            left: 0,\r\n            width: \"100%\",\r\n            height: \"100%\",\r\n            zIndex: 0x7FFFFFFF,\r\n            opacity: 0.7\r\n        });\r\n        elm.appendChild(overlayDiv);\r\n        return overlayDiv;\r\n\r\n    }\r\n\r\n    return noder.overlay = overlay;\r\n });\ndefine('skylark-domx-noder/owner-doc',[\r\n\t\"./noder\"\r\n],function(noder){\r\n \r\n    /*   \r\n     * Get the owner document object for the specified element.\r\n     * @param {Node} elm\r\n     */\r\n    function ownerDoc(elm) {\r\n        if (!elm) {\r\n            return document;\r\n        }\r\n\r\n        if (elm.nodeType == 9) {\r\n            return elm;\r\n        }\r\n\r\n        return elm.ownerDocument;\r\n    }\r\n\r\n\t\r\n\treturn noder.ownerDoc = ownerDoc;\r\n});\ndefine('skylark-domx-noder/owner-window',[\r\n\t\"./noder\",\r\n    \"./owner-doc\"\r\n],function(noder,ownerDoc){\r\n \r\n    /*   \r\n     *\r\n     * @param {Node} elm\r\n     */\r\n    function ownerWindow(elm) {\r\n        var doc = ownerDoc(elm);\r\n        return doc.defaultView || doc.parentWindow;\r\n    }\r\n\r\n\treturn noder.ownerWindow = ownerWindow;\r\n});\ndefine('skylark-domx-noder/picture-in-picture',[\r\n    \"skylark-domx-browser\",\r\n\t\"./noder\"\r\n],function(browser,noder){\r\n\r\n    var fulledEl = null;\r\n\r\n    function pictureInPicture(el) {\r\n        if (el === false) {\r\n            return   document.exitPictureInPicture();\r\n        } else if (el) {\r\n            if (el !== document.pictureInPictureElement) {\r\n                el.requestPictureInPicture();\r\n                fulledEl = el;\r\n            }          \r\n        } else {\r\n            return document.pictureInPictureElement;\r\n        }\r\n    }\r\n\t\r\n\treturn noder.pictureInPicture = pictureInPicture;\r\n});\ndefine('skylark-domx-noder/prepend',[\r\n    \"./noder\",\r\n    \"./_enhance_place_content\",\r\n    \"./_ensure_nodes\"\r\n],function(noder,enhancePlaceContent,ensureNodes){\r\n\r\n    /*   \r\n     * insert one or more nodes as the first children of the specified node.\r\n     * @param {Node} node\r\n     * @param {Node or ArrayLike} placing\r\n     * @param {Boolean Optional} copyByClone\r\n     */\r\n    function prepend(node, placing, copyByClone) {\r\n        var parentNode = node,\r\n            refNode = parentNode.firstChild,\r\n            nodes = ensureNodes(placing, copyByClone);\r\n        for (var i = 0; i < nodes.length; i++) {\r\n            if (refNode) {\r\n                parentNode.insertBefore(nodes[i], refNode);\r\n            } else {\r\n                parentNode.appendChild(nodes[i]);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n\t\r\n\treturn noder.prepend = prepend;\r\n});\ndefine('skylark-domx-noder/reflow',[\r\n\t\"./noder\"\r\n],function(noder){\r\n \r\n    function reflow(elm) {\r\n        if (!elm) {\r\n          elm = document;\r\n        }\r\n        elm.offsetHeight;\r\n\r\n        return this;      \r\n    }\r\n\t\r\n\treturn noder.reflow = reflow;\r\n});\ndefine('skylark-domx-noder/remove-child',[\r\n    \"skylark-langx-types\",\r\n\t\"./noder\"\r\n],function(types,noder){\r\n \r\n\r\n    function removeChild(node,children) {\r\n        if (!types.isArrayLike(children)) {\r\n            children = [children];\r\n        }\r\n        for (var i=0;i<children.length;i++) {\r\n            node.removeChild(children[i]);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n\t\r\n\treturn noder.removeChild = removeChild;\r\n});\ndefine('skylark-domx-noder/remove',[\r\n\t\"./noder\"\r\n],function(noder){\r\n \r\n    /*   \r\n     * Remove the set of matched elements from the DOM.\r\n     * @param {Node} node\r\n     */\r\n    function remove(node) {\r\n        if (node && node.parentNode) {\r\n            try {\r\n                node.parentNode.removeChild(node);\r\n            } catch (e) {\r\n                console.warn(\"The node is already removed\", e);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\t\r\n\treturn noder.remove = remove;\r\n});\ndefine('skylark-domx-noder/replace',[\r\n\t\"./noder\"\r\n],function(noder){\r\n     /*   \r\n     * Replace an old node with the specified node.\r\n     * @param {Node} node\r\n     * @param {Node} oldNode\r\n     */\r\n    function replace(node, oldNode) {\r\n        oldNode.parentNode.replaceChild(node, oldNode);\r\n        return this;\r\n    }\r\n\r\n\treturn noder.replace = replace;\r\n});\ndefine('skylark-domx-noder/reverse',[\r\n\t\"./noder\"\r\n],function(noder){\r\n    /*   \r\n     *\r\n     * @param {Node} node\r\n     */\r\n    function reverse(node) {\r\n        var firstChild = node.firstChild;\r\n        for (var i = node.children.length - 1; i > 0; i--) {\r\n            if (i > 0) {\r\n                var child = node.children[i];\r\n                node.insertBefore(child, firstChild);\r\n            }\r\n        }\r\n    }\r\n\t\r\n\treturn noder.reverse = reverse;\r\n});\ndefine('skylark-domx-noder/root',[\r\n\t\"./noder\"\r\n],function(noder){\r\n\tfunction root() {\r\n\t\treturn  document.documentElement;\r\n\t}\r\n\t\r\n\treturn noder.root = root;\r\n});\ndefine('skylark-domx-noder/scrolling-element',[\r\n\t\"./noder\"\r\n],function(noder){\r\n\tfunction scrollingElement() {\r\n\t\treturn document.scrollingElement || document.documentElement;\r\n\t}\r\n\t\r\n\treturn noder.scrollingElement = scrollingElement;\r\n});\ndefine('skylark-domx-noder/selectable',[\r\n\t\"./noder\"\r\n],function(noder){\r\n \r\n\r\n    function selectable(elem, selectable) {\r\n        if (elem === undefined || elem.style === undefined)\r\n            return;\r\n        elem.onselectstart = selectable ? function () {\r\n            return false;\r\n        } : function () {\r\n        };\r\n        elem.style.MozUserSelect = selectable ? 'auto' : 'none';\r\n        elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';\r\n        elem.unselectable = selectable ? 'on' : 'off';\r\n    }\r\n\r\n\t\r\n\treturn noder.selectable = selectable;\r\n});\ndefine('skylark-domx-noder/throb',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-styler\",\r\n    \"./noder\"\r\n],function(langx,styler,noder) {\r\n\r\n    \r\n    /*   \r\n     * Replace an old node with the specified node.\r\n     * @param {HTMLElement} elm\r\n     * @param {Node} params\r\n     */\r\n    function throb(elm, params) {\r\n        params = params || {};\r\n\r\n        var self = this,\r\n            text = params.text,\r\n            style = params.style,\r\n            time = params.time,\r\n            callback = params.callback,\r\n            timer,\r\n\r\n            throbber = noder.createElement(\"div\", {\r\n                \"className\": params.className || \"throbber\"\r\n            }),\r\n            //_overlay = overlay(throbber, {\r\n            //    \"class\": 'overlay fade'\r\n            //}),\r\n            remove = function() {\r\n                if (timer) {\r\n                    clearTimeout(timer);\r\n                    timer = null;\r\n                }\r\n                if (throbber) {\r\n                    noder.remove(throbber);\r\n                    throbber = null;\r\n                }\r\n            },\r\n            update = function(params) {\r\n                if (params && params.text && throbber) {\r\n                    textNode.nodeValue = params.text;\r\n                }\r\n            };\r\n\r\n        if (params.style) {\r\n            styler.css(throbber,params.style);\r\n        }\r\n\r\n        //throb = noder.createElement(\"div\", {\r\n        //   \"class\": params.throb && params.throb.className || \"throb\"\r\n        //}),\r\n        //textNode = noder.createTextNode(text || \"\"),\r\n \r\n        var content = params.content ||  '<span class=\"throb\"></span>';\r\n\r\n        //throb.appendChild(textNode);\r\n        //throbber.appendChild(throb);\r\n\r\n        noder.html(throbber,content);\r\n        \r\n        elm.appendChild(throbber);\r\n\r\n        var end = function() {\r\n            remove();\r\n            if (callback) callback();\r\n        };\r\n        if (time) {\r\n            timer = setTimeout(end, time);\r\n        }\r\n\r\n        return {\r\n            throbber : throbber,\r\n            remove: remove,\r\n            update: update\r\n        };\r\n    }\r\n\r\n    return noder.throb = throb;\r\n});\ndefine('skylark-domx-noder/traverse',[\r\n\t\"./noder\"\r\n],function(noder){\r\n \r\n    /*   \r\n     * traverse the specified node and its descendants, perform the callback function on each\r\n     * @param {Node} node\r\n     * @param {Function} fn\r\n     */\r\n    function traverse(node, fn) {\r\n        fn(node)\r\n        for (var i = 0, len = node.childNodes.length; i < len; i++) {\r\n            traverse(node.childNodes[i], fn);\r\n        }\r\n        return this;\r\n    }\r\n\t\r\n\treturn noder.traverse = traverse;\r\n});\ndefine('skylark-domx-noder/unwrap',[\r\n\t\"./noder\",\r\n    \"./is-doc\"\r\n],function(noder,isDoc){\r\n\r\n    /*   \r\n     * Remove the parents of the set of matched elements from the DOM, leaving the matched\r\n     * @param {Node} node\r\n     */\r\n    function unwrap(node) {\r\n        var child, parent = node.parentNode;\r\n        if (parent) {\r\n            if (isDoc(parent.parentNode)) return;\r\n            parent.parentNode.insertBefore(node, parent);\r\n        }\r\n    }\r\n\r\n\treturn noder.unwrap = unwrap;\r\n});\ndefine('skylark-domx-noder/wrapper-inner',[\r\n\t\"./noder\"\r\n],function(noder){\r\n    var  slice = Array.prototype.slice;\r\n\r\n    /*   \r\n     * Wrap an HTML structure around the content of each element in the set of matched\r\n     * @param {Node} node\r\n     * @param {Node} wrapperNode\r\n     */\r\n    function wrapperInner(node, wrapperNode) {\r\n        var childNodes = slice.call(node.childNodes);\r\n        node.appendChild(wrapperNode);\r\n        for (var i = 0; i < childNodes.length; i++) {\r\n            wrapperNode.appendChild(childNodes[i]);\r\n        }\r\n        return this;\r\n    }\r\n\r\n\t\r\n\treturn noder.wrapperInner = wrapperInner;\r\n});\ndefine('skylark-domx-noder/wrapper',[\r\n\t\"./noder\"\r\n],function(noder){\r\n \r\n    /*   \r\n     * Wrap an HTML structure around each element in the set of matched elements.\r\n     * @param {Node} node\r\n     * @param {Node} wrapperNode\r\n     */\r\n    function wrapper(node, wrapperNode) {\r\n        if (types.isString(wrapperNode)) {\r\n            wrapperNode = this.createFragment(wrapperNode).firstChild;\r\n        }\r\n        node.parentNode.insertBefore(wrapperNode, node);\r\n        wrapperNode.appendChild(node);\r\n    }\r\n\t\r\n\treturn noder.wrapper = wrapper;\r\n});\ndefine('skylark-domx-noder/main',[\r\n\t\"./noder\",\r\n\t\"./active\",\r\n\t\"./after\",\r\n\t\"./append\",\r\n\t\"./before\",\r\n\t\"./body\",\r\n\t\"./clone\",\r\n\t\"./contains\",\r\n\t\"./create-element\",\r\n\t\"./create-fragment\",\r\n\t\"./create-text-node\",\r\n\t\"./doc\",\r\n\t\"./empty\",\r\n\t\"./focusable\",\r\n\t\"./from-point\",\r\n\t\"./fullscreen\",\r\n\t\"./html\",\r\n\t\"./is-active\",\r\n\t\"./is-block-node\",\r\n\t\"./is-child-of\",\r\n\t\"./is-doc\",\r\n\t\"./is-editable\",\r\n\t\"./is-element\",\r\n\t\"./is-fragment\",\r\n\t\"./is-fullscreen\",\r\n\t\"./is-in-document\",\r\n\t\"./is-in-frame\",\r\n\t\"./is-input\",\r\n\t\"./is-text-node\",\r\n\t\"./is-window\",\r\n\t\"./node-name\",\r\n\t\"./offset-parent\",\r\n\t\"./overlay\",\r\n\t\"./owner-doc\",\r\n\t\"./owner-window\",\r\n\t\"./picture-in-picture\",\r\n\t\"./prepend\",\r\n\t\"./reflow\",\r\n\t\"./remove-child\",\r\n\t\"./remove\",\r\n\t\"./replace\",\r\n\t\"./reverse\",\r\n\t\"./root\",\r\n\t\"./scrolling-element\",\r\n\t\"./selectable\",\r\n\t\"./throb\",\r\n\t\"./traverse\",\r\n\t\"./unwrap\",\r\n\t\"./wrapper-inner\",\r\n\t\"./wrapper\",\r\n\t\"./throb\"\r\n],function(noder){\r\n\treturn noder;\r\n});\ndefine('skylark-domx-noder', ['skylark-domx-noder/main'], function (main) { return main; });\n\ndefine('skylark-domx-finder/finder',[\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-browser\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-styler\"\r\n], function(skylark, langx, browser, noder,styler) {\r\n    var local = {},\r\n        filter = Array.prototype.filter,\r\n        slice = Array.prototype.slice,\r\n        nativeMatchesSelector = browser.matchesSelector;\r\n\r\n    /*\r\n    ---\r\n    name: Slick.Parser\r\n    description: Standalone CSS3 Selector parser\r\n    provides: Slick.Parser\r\n    ...\r\n    */\r\n    ;\r\n    (function() {\r\n\r\n        var parsed,\r\n            separatorIndex,\r\n            combinatorIndex,\r\n            reversed,\r\n            cache = {},\r\n            reverseCache = {},\r\n            reUnescape = /\\\\/g;\r\n\r\n        var parse = function(expression, isReversed) {\r\n            if (expression == null) return null;\r\n            if (expression.Slick === true) return expression;\r\n            expression = ('' + expression).replace(/^\\s+|\\s+$/g, '');\r\n            reversed = !!isReversed;\r\n            var currentCache = (reversed) ? reverseCache : cache;\r\n            if (currentCache[expression]) return currentCache[expression];\r\n            parsed = {\r\n                Slick: true,\r\n                expressions: [],\r\n                raw: expression,\r\n                reverse: function() {\r\n                    return parse(this.raw, true);\r\n                }\r\n            };\r\n            separatorIndex = -1;\r\n            while (expression != (expression = expression.replace(regexp, parser)));\r\n            parsed.length = parsed.expressions.length;\r\n            return currentCache[parsed.raw] = (reversed) ? reverse(parsed) : parsed;\r\n        };\r\n\r\n        var reverseCombinator = function(combinator) {\r\n            if (combinator === '!') return ' ';\r\n            else if (combinator === ' ') return '!';\r\n            else if ((/^!/).test(combinator)) return combinator.replace(/^!/, '');\r\n            else return '!' + combinator;\r\n        };\r\n\r\n        var reverse = function(expression) {\r\n            var expressions = expression.expressions;\r\n            for (var i = 0; i < expressions.length; i++) {\r\n                var exp = expressions[i];\r\n                var last = {\r\n                    parts: [],\r\n                    tag: '*',\r\n                    combinator: reverseCombinator(exp[0].combinator)\r\n                };\r\n\r\n                for (var j = 0; j < exp.length; j++) {\r\n                    var cexp = exp[j];\r\n                    if (!cexp.reverseCombinator) cexp.reverseCombinator = ' ';\r\n                    cexp.combinator = cexp.reverseCombinator;\r\n                    delete cexp.reverseCombinator;\r\n                }\r\n\r\n                exp.reverse().push(last);\r\n            }\r\n            return expression;\r\n        };\r\n\r\n        var escapeRegExp = (function() {\r\n            // Credit: XRegExp 0.6.1 (c) 2007-2008 Steven Levithan <http://stevenlevithan.com/regex/xregexp/> MIT License\r\n            var from = /(?=[\\-\\[\\]{}()*+?.\\\\\\^$|,#\\s])/g,\r\n                to = '\\\\';\r\n            return function(string) {\r\n                return string.replace(from, to)\r\n            }\r\n        }())\r\n\r\n        var regexp = new RegExp(\r\n            \"^(?:\\\\s*(,)\\\\s*|\\\\s*(<combinator>+)\\\\s*|(\\\\s+)|(<unicode>+|\\\\*)|\\\\#(<unicode>+)|\\\\.(<unicode>+)|\\\\[\\\\s*(<unicode1>+)(?:\\\\s*([*^$!~|]?=)(?:\\\\s*(?:([\\\"']?)(.*?)\\\\9)))?\\\\s*\\\\](?!\\\\])|(:+)(<unicode>+)(?:\\\\((?:(?:([\\\"'])([^\\\\13]*)\\\\13)|((?:\\\\([^)]+\\\\)|[^()]*)+))\\\\))?)\"\r\n            .replace(/<combinator>/, '[' + escapeRegExp(\">+~`!@$%^&={}\\\\;</\") + ']')\r\n            .replace(/<unicode>/g, '(?:[\\\\w\\\\u00a1-\\\\uFFFF-]|\\\\\\\\[^\\\\s0-9a-f])')\r\n            .replace(/<unicode1>/g, '(?:[:\\\\w\\\\u00a1-\\\\uFFFF-]|\\\\\\\\[^\\\\s0-9a-f])')\r\n        );\r\n\r\n        function parser(\r\n            rawMatch,\r\n\r\n            separator,\r\n            combinator,\r\n            combinatorChildren,\r\n\r\n            tagName,\r\n            id,\r\n            className,\r\n\r\n            attributeKey,\r\n            attributeOperator,\r\n            attributeQuote,\r\n            attributeValue,\r\n\r\n            pseudoMarker,\r\n            pseudoClass,\r\n            pseudoQuote,\r\n            pseudoClassQuotedValue,\r\n            pseudoClassValue\r\n        ) {\r\n            if (separator || separatorIndex === -1) {\r\n                parsed.expressions[++separatorIndex] = [];\r\n                combinatorIndex = -1;\r\n                if (separator) return '';\r\n            }\r\n\r\n            if (combinator || combinatorChildren || combinatorIndex === -1) {\r\n                combinator = combinator || ' ';\r\n                var currentSeparator = parsed.expressions[separatorIndex];\r\n                if (reversed && currentSeparator[combinatorIndex])\r\n                    currentSeparator[combinatorIndex].reverseCombinator = reverseCombinator(combinator);\r\n                currentSeparator[++combinatorIndex] = {\r\n                    combinator: combinator,\r\n                    tag: '*'\r\n                };\r\n            }\r\n\r\n            var currentParsed = parsed.expressions[separatorIndex][combinatorIndex];\r\n\r\n            if (tagName) {\r\n                currentParsed.tag = tagName.replace(reUnescape, '');\r\n\r\n            } else if (id) {\r\n                currentParsed.id = id.replace(reUnescape, '');\r\n\r\n            } else if (className) {\r\n                className = className.replace(reUnescape, '');\r\n\r\n                if (!currentParsed.classList) currentParsed.classList = [];\r\n                if (!currentParsed.classes) currentParsed.classes = [];\r\n                currentParsed.classList.push(className);\r\n                currentParsed.classes.push({\r\n                    value: className,\r\n                    regexp: new RegExp('(^|\\\\s)' + escapeRegExp(className) + '(\\\\s|$)')\r\n                });\r\n\r\n            } else if (pseudoClass) {\r\n                pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue;\r\n                pseudoClassValue = pseudoClassValue ? pseudoClassValue.replace(reUnescape, '') : null;\r\n\r\n                if (!currentParsed.pseudos) currentParsed.pseudos = [];\r\n                currentParsed.pseudos.push({\r\n                    key: pseudoClass.replace(reUnescape, ''),\r\n                    value: pseudoClassValue,\r\n                    type: pseudoMarker.length == 1 ? 'class' : 'element'\r\n                });\r\n\r\n            } else if (attributeKey) {\r\n                attributeKey = attributeKey.replace(reUnescape, '');\r\n                attributeValue = (attributeValue || '').replace(reUnescape, '');\r\n\r\n                var test, regexp;\r\n\r\n                switch (attributeOperator) {\r\n                    case '^=':\r\n                        regexp = new RegExp('^' + escapeRegExp(attributeValue));\r\n                        break;\r\n                    case '$=':\r\n                        regexp = new RegExp(escapeRegExp(attributeValue) + '$');\r\n                        break;\r\n                    case '~=':\r\n                        regexp = new RegExp('(^|\\\\s)' + escapeRegExp(attributeValue) + '(\\\\s|$)');\r\n                        break;\r\n                    case '|=':\r\n                        regexp = new RegExp('^' + escapeRegExp(attributeValue) + '(-|$)');\r\n                        break;\r\n                    case '=':\r\n                        test = function(value) {\r\n                            return attributeValue == value;\r\n                        };\r\n                        break;\r\n                    case '*=':\r\n                        test = function(value) {\r\n                            return value && value.indexOf(attributeValue) > -1;\r\n                        };\r\n                        break;\r\n                    case '!=':\r\n                        test = function(value) {\r\n                            return attributeValue != value;\r\n                        };\r\n                        break;\r\n                    default:\r\n                        test = function(value) {\r\n                            return !!value;\r\n                        };\r\n                }\r\n\r\n                if (attributeValue == '' && (/^[*$^]=$/).test(attributeOperator)) test = function() {\r\n                    return false;\r\n                };\r\n\r\n                if (!test) test = function(value) {\r\n                    return value && regexp.test(value);\r\n                };\r\n\r\n                if (!currentParsed.attributes) currentParsed.attributes = [];\r\n                currentParsed.attributes.push({\r\n                    key: attributeKey,\r\n                    operator: attributeOperator,\r\n                    value: attributeValue,\r\n                    test: test\r\n                });\r\n\r\n            }\r\n\r\n            return '';\r\n        };\r\n\r\n        // Slick NS\r\n\r\n        var Slick = (this.Slick || {});\r\n\r\n        Slick.parse = function(expression) {\r\n            return parse(expression);\r\n        };\r\n\r\n        Slick.escapeRegExp = escapeRegExp;\r\n\r\n        if (!this.Slick) this.Slick = Slick;\r\n\r\n    }).apply(local);\r\n\r\n\r\n    var simpleClassSelectorRE = /^\\.([\\w-]*)$/,\r\n        simpleIdSelectorRE = /^#([\\w-]*)$/,\r\n        rinputs = /^(?:input|select|textarea|button)$/i,\r\n        rheader = /^h\\d$/i,\r\n        slice = Array.prototype.slice;\r\n\r\n\r\n    local.parseSelector = local.Slick.parse;\r\n\r\n\r\n    var pseudos = local.pseudos = {\r\n        // custom pseudos\r\n        \"button\": function(elem) {\r\n            var name = elem.nodeName.toLowerCase();\r\n            return name === \"input\" && elem.type === \"button\" || name === \"button\";\r\n        },\r\n\r\n        'checked': function(elm) {\r\n            return !!elm.checked;\r\n        },\r\n\r\n        'contains': function(elm, idx, nodes, text) {\r\n            if ($(this).text().indexOf(text) > -1) return this\r\n        },\r\n\r\n        'disabled': function(elm) {\r\n            return !!elm.disabled;\r\n        },\r\n\r\n        'enabled': function(elm) {\r\n            return !elm.disabled;\r\n        },\r\n\r\n        'eq': function(elm, idx, nodes, value) {\r\n            return (idx == value);\r\n        },\r\n\r\n        'even': function(elm, idx, nodes, value) {\r\n            return (idx % 2) === 0;\r\n        },\r\n\r\n        'focus': function(elm) {\r\n            return document.activeElement === elm && (elm.href || elm.type || elm.tabindex);\r\n        },\r\n\r\n        'focusable': function( elm ) {\r\n            return noder.focusable(elm, elm.tabindex != null );\r\n        },\r\n\r\n        'first': function(elm, idx) {\r\n            return (idx === 0);\r\n        },\r\n\r\n        'gt': function(elm, idx, nodes, value) {\r\n            return (idx > value);\r\n        },\r\n\r\n        'has': function(elm, idx, nodes, sel) {\r\n            return find(elm, sel);\r\n        },\r\n\r\n        // Element/input types\r\n        \"header\": function(elem) {\r\n            return rheader.test(elem.nodeName);\r\n        },\r\n\r\n        'hidden': function(elm) {\r\n            return !local.pseudos[\"visible\"](elm);\r\n        },\r\n\r\n        \"input\": function(elem) {\r\n            return rinputs.test(elem.nodeName);\r\n        },\r\n\r\n        'last': function(elm, idx, nodes) {\r\n            return (idx === nodes.length - 1);\r\n        },\r\n\r\n        'lt': function(elm, idx, nodes, value) {\r\n            return (idx < value);\r\n        },\r\n\r\n        'not': function(elm, idx, nodes, sel) {\r\n            return !matches(elm, sel);\r\n        },\r\n\r\n        'odd': function(elm, idx, nodes, value) {\r\n            return (idx % 2) === 1;\r\n        },\r\n\r\n        /*   \r\n         * Get the parent of each element in the current set of matched elements.\r\n         * @param {Object} elm\r\n         */\r\n        'parent': function(elm) {\r\n            return !!elm.parentElement;\r\n        },\r\n\r\n        'selected': function(elm) {\r\n            return !!elm.selected;\r\n        },\r\n\r\n        'tabbable': function(elm) {\r\n            var tabIndex = elm.tabindex,\r\n                hasTabindex = tabIndex != null;\r\n            return ( !hasTabindex || tabIndex >= 0 ) && noder.focusable( element, hasTabindex );\r\n        },\r\n\r\n        'text': function(elm) {\r\n            return elm.type === \"text\";\r\n        },\r\n\r\n        'visible': function(elm) {\r\n            return elm.offsetWidth && elm.offsetWidth\r\n        },\r\n        'empty': function(elm) {\r\n            return !elm.hasChildNodes();\r\n        }\r\n    };\r\n\r\n    [\"first\", \"eq\", \"last\"].forEach(function(item) {\r\n        pseudos[item].isArrayFilter = true;\r\n    });\r\n\r\n\r\n\r\n    pseudos[\"nth\"] = pseudos[\"eq\"];\r\n\r\n    function createInputPseudo(type) {\r\n        return function(elem) {\r\n            var name = elem.nodeName.toLowerCase();\r\n            return name === \"input\" && elem.type === type;\r\n        };\r\n    }\r\n\r\n    function createButtonPseudo(type) {\r\n        return function(elem) {\r\n            var name = elem.nodeName.toLowerCase();\r\n            return (name === \"input\" || name === \"button\") && elem.type === type;\r\n        };\r\n    }\r\n\r\n    // Add button/input type pseudos\r\n    for (i in {\r\n        radio: true,\r\n        checkbox: true,\r\n        file: true,\r\n        password: true,\r\n        image: true\r\n    }) {\r\n        pseudos[i] = createInputPseudo(i);\r\n    }\r\n    for (i in {\r\n        submit: true,\r\n        reset: true\r\n    }) {\r\n        pseudos[i] = createButtonPseudo(i);\r\n    }\r\n\r\n\r\n    local.divide = function(cond) {\r\n        var nativeSelector = \"\",\r\n            customPseudos = [],\r\n            tag,\r\n            id,\r\n            classes,\r\n            attributes,\r\n            pseudos;\r\n\r\n\r\n        if (id = cond.id) {\r\n            nativeSelector += (\"#\" + id);\r\n        }\r\n        if (classes = cond.classes) {\r\n            for (var i = classes.length; i--;) {\r\n                nativeSelector += (\".\" + classes[i].value);\r\n            }\r\n        }\r\n        if (attributes = cond.attributes) {\r\n            for (var i = 0; i < attributes.length; i++) {\r\n                if (attributes[i].operator) {\r\n                    nativeSelector += (\"[\" + attributes[i].key + attributes[i].operator + JSON.stringify(attributes[i].value) + \"]\");\r\n                } else {\r\n                    nativeSelector += (\"[\" + attributes[i].key + \"]\");\r\n                }\r\n            }\r\n        }\r\n        if (pseudos = cond.pseudos) {\r\n            for (i = pseudos.length; i--;) {\r\n                part = pseudos[i];\r\n                if (this.pseudos[part.key]) {\r\n                    customPseudos.push(part);\r\n                } else {\r\n                    if (part.value !== undefined) {\r\n                        nativeSelector += (\":\" + part.key + \"(\" + JSON.stringify(part))\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (tag = cond.tag) {\r\n            if (tag !== \"*\") {\r\n                nativeSelector = tag.toUpperCase() + nativeSelector;\r\n            }\r\n        }\r\n\r\n        if (!nativeSelector) {\r\n            nativeSelector = \"*\";\r\n        }\r\n\r\n        return {\r\n            nativeSelector: nativeSelector,\r\n            customPseudos: customPseudos\r\n        }\r\n\r\n    };\r\n\r\n    local.check = function(node, cond, idx, nodes, arrayFilte) {\r\n        var tag,\r\n            id,\r\n            classes,\r\n            attributes,\r\n            pseudos,\r\n\r\n            i, part, cls, pseudo;\r\n\r\n        if (!arrayFilte) {\r\n            if (tag = cond.tag) {\r\n                var nodeName = node.nodeName.toUpperCase();\r\n                if (tag == '*') {\r\n                    if (nodeName < '@') return false; // Fix for comment nodes and closed nodes\r\n                } else {\r\n                    if (nodeName != (tag || \"\").toUpperCase()) return false;\r\n                }\r\n            }\r\n\r\n            if (id = cond.id) {\r\n                if (node.getAttribute('id') != id) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n\r\n            if (classes = cond.classes) {\r\n                for (i = classes.length; i--;) {\r\n                    cls = node.getAttribute('class');\r\n                    if (!(cls && classes[i].regexp.test(cls))) return false;\r\n                }\r\n            }\r\n\r\n            if (attributes = cond.attributes) {\r\n                for (i = attributes.length; i--;) {\r\n                    part = attributes[i];\r\n                    if (part.operator ? !part.test(node.getAttribute(part.key)) : !node.hasAttribute(part.key)) return false;\r\n                }\r\n            }\r\n\r\n        }\r\n        if (pseudos = cond.pseudos) {\r\n            for (i = pseudos.length; i--;) {\r\n                part = pseudos[i];\r\n                if (pseudo = this.pseudos[part.key]) {\r\n                    if ((arrayFilte && pseudo.isArrayFilter) || (!arrayFilte && !pseudo.isArrayFilter)) {\r\n                        if (!pseudo(node, idx, nodes, part.value)) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (!arrayFilte && !nativeMatchesSelector.call(node, part.key)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    local.match = function(node, selector) {\r\n\r\n        var parsed;\r\n\r\n        if (langx.isString(selector)) {\r\n            parsed = local.Slick.parse(selector);\r\n        } else {\r\n            parsed = selector;\r\n        }\r\n\r\n        if (!parsed) {\r\n            return true;\r\n        }\r\n\r\n        // simple (single) selectors\r\n        var expressions = parsed.expressions,\r\n            simpleExpCounter = 0,\r\n            i,\r\n            currentExpression;\r\n        for (i = 0;\r\n            (currentExpression = expressions[i]); i++) {\r\n            if (currentExpression.length == 1) {\r\n                var exp = currentExpression[0];\r\n                if (this.check(node, exp)) {\r\n                    return true;\r\n                }\r\n                simpleExpCounter++;\r\n            }\r\n        }\r\n\r\n        if (simpleExpCounter == parsed.length) {\r\n            return false;\r\n        }\r\n\r\n        var nodes = this.query(document, parsed),\r\n            item;\r\n        for (i = 0; item = nodes[i++];) {\r\n            if (item === node) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n\r\n\r\n    local.filterSingle = function(nodes, exp) {\r\n        var matchs = filter.call(nodes, function(node, idx) {\r\n            return local.check(node, exp, idx, nodes, false);\r\n        });\r\n\r\n        matchs = filter.call(matchs, function(node, idx) {\r\n            return local.check(node, exp, idx, matchs, true);\r\n        });\r\n        return matchs;\r\n    };\r\n\r\n    local.filter = function(nodes, selector) {\r\n        var parsed;\r\n\r\n        if (langx.isString(selector)) {\r\n            parsed = local.Slick.parse(selector);\r\n        } else {\r\n            return local.filterSingle(nodes, selector);\r\n        }\r\n\r\n        // simple (single) selectors\r\n        var expressions = parsed.expressions,\r\n            i,\r\n            currentExpression,\r\n            ret = [];\r\n        for (i = 0;\r\n            (currentExpression = expressions[i]); i++) {\r\n            if (currentExpression.length == 1) {\r\n                var exp = currentExpression[0];\r\n\r\n                var matchs = local.filterSingle(nodes, exp);\r\n\r\n                ret = langx.uniq(ret.concat(matchs));\r\n            } else {\r\n                throw new Error(\"not supported selector:\" + selector);\r\n            }\r\n        }\r\n\r\n        return ret;\r\n\r\n    };\r\n\r\n    local.combine = function(elm, bit) {\r\n        var op = bit.combinator,\r\n            cond = bit,\r\n            node1,\r\n            nodes = [];\r\n\r\n        switch (op) {\r\n            case '>': // direct children\r\n                nodes = children(elm, cond);\r\n                break;\r\n            case '+': // next sibling\r\n                node1 = nextSibling(elm, cond, true);\r\n                if (node1) {\r\n                    nodes.push(node1);\r\n                }\r\n                break;\r\n            case '^': // first child\r\n                node1 = firstChild(elm, cond, true);\r\n                if (node1) {\r\n                    nodes.push(node1);\r\n                }\r\n                break;\r\n            case '~': // next siblings\r\n                nodes = nextSiblings(elm, cond);\r\n                break;\r\n            case '++': // next sibling and previous sibling\r\n                var prev = previousSibling(elm, cond, true),\r\n                    next = nextSibling(elm, cond, true);\r\n                if (prev) {\r\n                    nodes.push(prev);\r\n                }\r\n                if (next) {\r\n                    nodes.push(next);\r\n                }\r\n                break;\r\n            case '~~': // next siblings and previous siblings\r\n                nodes = siblings(elm, cond);\r\n                break;\r\n            case '!': // all parent nodes up to document\r\n                nodes = ancestors(elm, cond);\r\n                break;\r\n            case '!>': // direct parent (one level)\r\n                node1 = parent(elm, cond);\r\n                if (node1) {\r\n                    nodes.push(node1);\r\n                }\r\n                break;\r\n            case '!+': // previous sibling\r\n                nodes = previousSibling(elm, cond, true);\r\n                break;\r\n            case '!^': // last child\r\n                node1 = lastChild(elm, cond, true);\r\n                if (node1) {\r\n                    nodes.push(node1);\r\n                }\r\n                break;\r\n            case '!~': // previous siblings\r\n                nodes = previousSiblings(elm, cond);\r\n                break;\r\n            default:\r\n                var divided = this.divide(bit);\r\n                nodes = slice.call(elm.querySelectorAll(divided.nativeSelector));\r\n                if (divided.customPseudos) {\r\n                    for (var i = divided.customPseudos.length - 1; i >= 0; i--) {\r\n                        nodes = filter.call(nodes, function(item, idx) {\r\n                            return local.check(item, {\r\n                                pseudos: [divided.customPseudos[i]]\r\n                            }, idx, nodes, false)\r\n                        });\r\n\r\n                        nodes = filter.call(nodes, function(item, idx) {\r\n                            return local.check(item, {\r\n                                pseudos: [divided.customPseudos[i]]\r\n                            }, idx, nodes, true)\r\n                        });\r\n                    }\r\n                }\r\n                break;\r\n\r\n        }\r\n        return nodes;\r\n    }\r\n\r\n    local.query = function(node, selector, single) {\r\n\r\n\r\n        var parsed = this.Slick.parse(selector);\r\n\r\n        var\r\n            founds = [],\r\n            currentExpression, currentBit,\r\n            expressions = parsed.expressions;\r\n\r\n        for (var i = 0;\r\n            (currentExpression = expressions[i]); i++) {\r\n            var currentItems = [node],\r\n                found;\r\n            for (var j = 0;\r\n                (currentBit = currentExpression[j]); j++) {\r\n                found = langx.map(currentItems, function(item, i) {\r\n                    return local.combine(item, currentBit)\r\n                });\r\n                if (found) {\r\n                    currentItems = found;\r\n                }\r\n            }\r\n            if (found) {\r\n                founds = founds.concat(found);\r\n            }\r\n        }\r\n\r\n        return founds;\r\n    }\r\n\r\n    /*\r\n     * Get the nearest ancestor of the specified element,optional matched by a selector.\r\n     * @param {HTMLElement} node\r\n     * @param {String Optional } selector\r\n     * @param {Object} root\r\n     */\r\n    function ancestor(node, selector, root) {\r\n        var rootIsSelector = root && langx.isString(root);\r\n        while (node = node.parentElement) {\r\n            if (matches(node, selector)) {\r\n                return node;\r\n            }\r\n            if (root) {\r\n                if (rootIsSelector) {\r\n                    if (matches(node, root)) {\r\n                        break;\r\n                    }\r\n                } else if (node == root) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /*\r\n     * Get the ancestors of the specitied element , optionally filtered by a selector.\r\n     * @param {HTMLElement} node\r\n     * @param {String Optional } selector\r\n     * @param {Object} root\r\n     */\r\n    function ancestors(node, selector, root) {\r\n        var ret = [],\r\n            rootIsSelector = root && langx.isString(root);\r\n        while ((node = node.parentElement) && (node.nodeType !== 9)) {\r\n            if (root) {\r\n                if (rootIsSelector) {\r\n                    if (matches(node, root)) {\r\n                        break;\r\n                    }\r\n                } else if (langx.isArrayLike(root)) {\r\n                    if (langx.inArray(node,root)>-1) {\r\n                        break;\r\n                    }\r\n                } else if (node == root) {\r\n                    break;\r\n                }\r\n            }\r\n            if (!selector || matches(node, selector)) {\r\n              ret.push(node); \r\n            }\r\n        }\r\n\r\n        //if (selector) {\r\n        //    ret = local.filter(ret, selector);\r\n        //}\r\n        return ret;\r\n    }\r\n\r\n\r\n    /*\r\n     * Returns a element by its ID.\r\n     * @param {string} id\r\n     */\r\n    function byId(id, doc) {\r\n        doc = doc || noder.doc();\r\n        return doc.getElementById(id);\r\n    }\r\n\r\n    /*\r\n     * Get the children of the specified element , optionally filtered by a selector.\r\n     * @param {string} node\r\n     * @param {String optionlly} selector\r\n     */\r\n    function children(node, selector) {\r\n        var childNodes = node.childNodes,\r\n            ret = [];\r\n        for (var i = 0; i < childNodes.length; i++) {\r\n            var node = childNodes[i];\r\n            if (node.nodeType == 1) {\r\n                ret.push(node);\r\n            }\r\n        }\r\n        if (selector) {\r\n            ret = local.filter(ret, selector);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Gets nth child of elm, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)\r\n     * and non-draggable elements\r\n     * @param  {HTMLElement} elm       The parent element\r\n     * @param  {Number} idx      The index of the child\r\n     * @param  {Object} options       Parent's options\r\n     * @return {HTMLElement}          The child at index idx, or null if not found\r\n     */\r\n    function childAt(elm, idx, options) {\r\n        var currentChild = 0,\r\n            children = elm.children;\r\n\r\n        options = langx.mixin({\r\n            ignoreHidden : true,\r\n            excluding : null,\r\n            closesting : null\r\n        },options);\r\n\r\n        for(var i=0;i < children.length;i++) {\r\n            var child = children[i];\r\n            if (options.ignoreHidden && styler.css(child) === \"none\") {\r\n                continue;\r\n            }\r\n            if (options.excluding && options.excluding.includes(child)) {\r\n                continue;\r\n            }\r\n\r\n            if (options.closesting &&  !closest(child, options.closesting, elm, false)) {\r\n                continue;\r\n            }\r\n\r\n            if (currentChild === idx) {\r\n                return child;\r\n            }\r\n            currentChild++;\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n\r\n    //function closest(node, selector) {\r\n    //    while (node && !(matches(node, selector))) {\r\n    //        node = node.parentElement;\r\n    //    }\r\n    //   return node;\r\n    //}\r\n\r\n\r\n    function closest(/**HTMLElement*/elm, /**String*/selector, /**HTMLElement*/ctx, includeCTX) {\r\n        if (elm) {\r\n            ctx = ctx || document;\r\n\r\n            do {\r\n                if (\r\n                    selector != null &&\r\n                    (\r\n                        selector[0] === '>' ?\r\n                        elm.parentElement === ctx && matches(elm, selector) :\r\n                        matches(elm, selector)\r\n                    ) ||\r\n                    includeCTX && elm === ctx\r\n                ) {\r\n                    return elm;\r\n                }\r\n\r\n                if (elm === ctx) break;\r\n                /* jshint boss:true */\r\n            } while (elm = parent(elm));\r\n        }\r\n\r\n        return null;\r\n    }\r\n    /*\r\n     * Get the decendant of the specified element , optionally filtered by a selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     */\r\n    function descendants(elm, selector) {\r\n        // Selector\r\n        try {\r\n            return slice.call(elm.querySelectorAll(selector));\r\n        } catch (matchError) {\r\n            //console.log(matchError);\r\n        }\r\n        return local.query(elm, selector);\r\n    }\r\n\r\n    /*\r\n     * Get the nearest decendent of the specified element,optional matched by a selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     */\r\n    function descendant(elm, selector) {\r\n        // Selector\r\n        try {\r\n            return elm.querySelector(selector);\r\n        } catch (matchError) {\r\n            //console.log(matchError);\r\n        }\r\n        var nodes = local.query(elm, selector);\r\n        if (nodes.length > 0) {\r\n            return nodes[0];\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get the descendants of each element in the current set of matched elements, filtered by a selector, jQuery object, or element.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     */\r\n    function find(elm, selector) {\r\n        if (!selector) {\r\n            selector = elm;\r\n            elm = document.body;\r\n        }\r\n        if (matches(elm, selector)) {\r\n            return elm;\r\n        } else {\r\n            return descendant(elm, selector);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get the findAll of the specified element , optionally filtered by a selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     */\r\n    function findAll(elm, selector) {\r\n        if (!selector) {\r\n            selector = elm;\r\n            elm = document.body;\r\n        }\r\n        return descendants(elm, selector);\r\n    }\r\n\r\n    /*\r\n     * Get the first child of the specified element , optionally filtered by a selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     * @param {String} first\r\n     */\r\n    function firstChild(elm, selector, first) {\r\n        var childNodes = elm.childNodes,\r\n            node = childNodes[0];\r\n        while (node) {\r\n            if (node.nodeType == 1) {\r\n                if (!selector || matches(node, selector)) {\r\n                    return node;\r\n                }\r\n                if (first) {\r\n                    break;\r\n                }\r\n            }\r\n            node = node.nextSibling;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the index of an element within its parent for a selected set of\r\n     * elements\r\n     * @param  {HTMLElement} el\r\n     * @param  {selector} selector\r\n     * @return {number}\r\n     */\r\n    function index(el, selector) {\r\n        var index = 0;\r\n\r\n        if (!el || !el.parentNode) {\r\n            return -1;\r\n        }\r\n\r\n        while (el && (el = el.previousElementSibling)) {\r\n            if (langx.isString(selector)) {\r\n                if (matches(el, selector)) {\r\n                    index++;\r\n                }\r\n            } else if (langx.isFunction(selector)) {\r\n                if (selector(el)) {\r\n                    index++;\r\n                }\r\n            }\r\n            index++;\r\n        }\r\n\r\n        return index;\r\n    }    \r\n\r\n    /*\r\n     * Get the last child of the specified element , optionally filtered by a selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     * @param {String } last\r\n     */\r\n    function lastChild(elm, selector, last) {\r\n        var childNodes = elm.childNodes,\r\n            node = childNodes[childNodes.length - 1];\r\n        while (node) {\r\n            if (node.nodeType == 1) {\r\n                if (!selector || matches(node, selector)) {\r\n                    return node;\r\n                }\r\n                if (last) {\r\n                    break;\r\n                }\r\n            }\r\n            node = node.previousSibling;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /*\r\n     * Check the specified element against a selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     */\r\n    function matches(elm, selector) {\r\n        if (!selector || !elm || elm.nodeType !== 1) {\r\n            return false\r\n        }\r\n\r\n        if (langx.isString(selector)) {\r\n            try {\r\n                return nativeMatchesSelector.call(elm, selector.replace(/\\[([^=]+)=\\s*([^'\"\\]]+?)\\s*\\]/g, '[$1=\"$2\"]'));\r\n            } catch (matchError) {\r\n                //console.log(matchError);\r\n            }\r\n            return local.match(elm, selector);\r\n        } else if (langx.isArrayLike(selector)) {\r\n            return langx.inArray(elm, selector) > -1;\r\n        } else if (langx.isPlainObject(selector)) {\r\n            return local.check(elm, selector);\r\n        } else {\r\n            return elm === selector;\r\n        }\r\n\r\n    }\r\n\r\n    /*\r\n     * Get the nearest next sibing of the specitied element , optional matched by a selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     * @param {Boolean Optional} adjacent\r\n     */\r\n    function nextSibling(elm, selector, adjacent) {\r\n        var node = elm.nextSibling;\r\n        while (node) {\r\n            if (node.nodeType == 1) {\r\n                if (!selector || matches(node, selector)) {\r\n                    return node;\r\n                }\r\n                if (adjacent) {\r\n                    break;\r\n                }\r\n            }\r\n            node = node.nextSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /*\r\n     * Get the next siblings of the specified element , optional filtered by a selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     */\r\n    function nextSiblings(elm, selector) {\r\n        var node = elm.nextSibling,\r\n            ret = [];\r\n        while (node) {\r\n            if (node.nodeType == 1) {\r\n                if (!selector || matches(node, selector)) {\r\n                    ret.push(node);\r\n                }\r\n            }\r\n            node = node.nextSibling;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * Get the parent element of the specified element. if a selector is provided, it retrieves the parent element only if it matches that selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     */\r\n    function parent(elm, selector) {\r\n        var node = (elm.host && elm !== document && elm.host.nodeType) ? elm.host : elm.parentElement;\r\n\r\n        if (node && (!selector || matches(node, selector))) {\r\n            return node;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /*\r\n     * Get hte nearest previous sibling of the specified element ,optional matched by a selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     * @param {Boolean Optional } adjacent\r\n     */\r\n    function previousSibling(elm, selector, adjacent) {\r\n        var node = elm.previousSibling;\r\n        while (node) {\r\n            if (node.nodeType == 1) {\r\n                if (!selector || matches(node, selector)) {\r\n                    return node;\r\n                }\r\n                if (adjacent) {\r\n                    break;\r\n                }\r\n            }\r\n            node = node.previousSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /*\r\n     * Get all preceding siblings of each element in the set of matched elements, optionally filtered by a selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     */\r\n    function previousSiblings(elm, selector) {\r\n        var node = elm.previousSibling,\r\n            ret = [];\r\n        while (node) {\r\n            if (node.nodeType == 1) {\r\n                if (!selector || matches(node, selector)) {\r\n                    ret.push(node);\r\n                }\r\n            }\r\n            node = node.previousSibling;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * Selects all sibling elements that follow after the “prev” element, have the same parent, and match the filtering “siblings” selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     */\r\n    function siblings(elm, selector) {\r\n        var node = elm.parentElement.firstChild,\r\n            ret = [];\r\n        while (node) {\r\n            if (node.nodeType == 1 && node !== elm) {\r\n                if (!selector || matches(node, selector)) {\r\n                    ret.push(node);\r\n                }\r\n            }\r\n            node = node.nextSibling;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n\r\n    function scrollableParent(el, includeSelf) {\r\n        // skip to window\r\n        if (!el || !el.getBoundingClientRect) {\r\n            return noder.scrollingElement();\r\n        }\r\n\r\n        var elem = el;\r\n        var gotSelf = false;\r\n        do {\r\n            // we don't need to get elem css if it isn't even overflowing in the first place (performance)\r\n            if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {\r\n                var elemCSS = styler.css(elem);\r\n                if (\r\n                    elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') ||\r\n                    elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')\r\n                ) {\r\n                    if (!elem || !elem.getBoundingClientRect || elem === document.body) {\r\n                        return noder.scrollingElement();\r\n                    } \r\n                    if (gotSelf || includeSelf) {\r\n                        return elem;\r\n                    }\r\n                    gotSelf = true;\r\n                }\r\n            }\r\n        /* jshint boss:true */\r\n        } while (elem = elem.parentNode);\r\n\r\n        return noder.scrollingElement();\r\n    }\r\n\r\n\r\n    var finder = function() {\r\n        return finder;\r\n    };\r\n\r\n    langx.mixin(finder, {\r\n\r\n        ancestor: ancestor,\r\n\r\n        ancestors: ancestors,\r\n\r\n        byId: byId,\r\n\r\n        childAt: childAt,\r\n\r\n        children: children,\r\n\r\n        closest: closest,\r\n\r\n        descendant: descendant,\r\n\r\n        descendants: descendants,\r\n\r\n        find: find,\r\n\r\n        findAll: findAll,\r\n\r\n        firstChild: firstChild,\r\n\r\n        index,\r\n\r\n        lastChild: lastChild,\r\n\r\n        matches: matches,\r\n\r\n        nextSibling: nextSibling,\r\n\r\n        nextSiblings: nextSiblings,\r\n\r\n        parent: parent,\r\n\r\n        previousSibling,\r\n\r\n        previousSiblings,\r\n\r\n        pseudos: local.pseudos,\r\n\r\n        scrollableParent,\r\n\r\n        siblings: siblings\r\n    });\r\n\r\n    return skylark.attach(\"domx.finder\", finder);\r\n});\ndefine('skylark-domx-finder/main',[\r\n\t\"./finder\"\r\n],function(finder){\r\n\r\n\treturn finder;\r\n});\ndefine('skylark-domx-finder', ['skylark-domx-finder/main'], function (main) { return main; });\n\ndefine('skylark-domx-data/data',[\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-finder\",\r\n    \"skylark-domx-noder\"\r\n], function(skylark, langx, finder,noder) {\r\n    var map = Array.prototype.map,\r\n        filter = Array.prototype.filter,\r\n        camelCase = langx.camelCase,\r\n        deserializeValue = langx.deserializeValue,\r\n\r\n        capitalRE = /([A-Z])/g,\r\n        propMap = {\r\n            'tabindex': 'tabIndex',\r\n            'readonly': 'readOnly',\r\n            'for': 'htmlFor',\r\n            'class': 'className',\r\n            'maxlength': 'maxLength',\r\n            'cellspacing': 'cellSpacing',\r\n            'cellpadding': 'cellPadding',\r\n            'rowspan': 'rowSpan',\r\n            'colspan': 'colSpan',\r\n            'usemap': 'useMap',\r\n            'frameborder': 'frameBorder',\r\n            'contenteditable': 'contentEditable'\r\n        };\r\n\r\n    // Strip and collapse whitespace according to HTML spec\r\n    function stripAndCollapse( value ) {\r\n      var tokens = value.match( /[^\\x20\\t\\r\\n\\f]+/g ) || [];\r\n      return tokens.join( \" \" );\r\n    }\r\n\r\n\r\n    var valHooks = {\r\n      option: {\r\n        get: function( elem ) {\r\n          var val = elem.getAttribute( \"value\" );\r\n          return val != null ?  val :  stripAndCollapse(text( elem ) );\r\n        }\r\n      },\r\n      select: {\r\n        get: function( elem ) {\r\n          var value, option, i,\r\n            options = elem.options,\r\n            index = elem.selectedIndex,\r\n            one = elem.type === \"select-one\",\r\n            values = one ? null : [],\r\n            max = one ? index + 1 : options.length;\r\n\r\n          if ( index < 0 ) {\r\n            i = max;\r\n\r\n          } else {\r\n            i = one ? index : 0;\r\n          }\r\n\r\n          // Loop through all the selected options\r\n          for ( ; i < max; i++ ) {\r\n            option = options[ i ];\r\n\r\n            if ( option.selected &&\r\n\r\n                // Don't return options that are disabled or in a disabled optgroup\r\n                !option.disabled &&\r\n                ( !option.parentNode.disabled ||\r\n                  !noder.nodeName( option.parentNode, \"optgroup\" ) ) ) {\r\n\r\n              // Get the specific value for the option\r\n              value = val(option);\r\n\r\n              // We don't need an array for one selects\r\n              if ( one ) {\r\n                return value;\r\n              }\r\n\r\n              // Multi-Selects return an array\r\n              values.push( value );\r\n            }\r\n          }\r\n\r\n          return values;\r\n        },\r\n\r\n        set: function( elem, value ) {\r\n          var optionSet, option,\r\n            options = elem.options,\r\n            values = langx.makeArray( value ),\r\n            i = options.length;\r\n\r\n          while ( i-- ) {\r\n            option = options[ i ];\r\n\r\n            /* eslint-disable no-cond-assign */\r\n\r\n            if ( option.selected =\r\n              langx.inArray( valHooks.option.get( option ), values ) > -1\r\n            ) {\r\n              optionSet = true;\r\n            }\r\n\r\n            /* eslint-enable no-cond-assign */\r\n          }\r\n\r\n          // Force browsers to behave consistently when non-matching value is set\r\n          if ( !optionSet ) {\r\n            elem.selectedIndex = -1;\r\n          }\r\n          return values;\r\n        }\r\n      }\r\n    };\r\n\r\n\r\n    // Radios and checkboxes getter/setter\r\n    langx.each( [ \"radio\", \"checkbox\" ], function() {\r\n      valHooks[ this ] = {\r\n        set: function( elem, value ) {\r\n          if ( langx.isArray( value ) ) {\r\n            return ( elem.checked = langx.inArray( val(elem), value ) > -1 );\r\n          }\r\n        }\r\n      };\r\n    });\r\n\r\n\r\n\r\n    /*\r\n     * Set property values\r\n     * @param {Object} elm  \r\n     * @param {String} name\r\n     * @param {String} value\r\n     */\r\n\r\n    function setAttribute(elm, name, value) {\r\n        if (value == null) {\r\n            elm.removeAttribute(name);\r\n        } else {\r\n            elm.setAttribute(name, value);\r\n        }\r\n    }\r\n\r\n    function aria(elm, name, value) {\r\n        return this.attr(elm, \"aria-\" + name, value);\r\n    }\r\n\r\n    /*\r\n     * Set property values\r\n     * @param {Object} elm  \r\n     * @param {String} name\r\n     * @param {String} value\r\n     */\r\n\r\n    function attr(elm, name, value) {\r\n        if (value === undefined) {\r\n            if (typeof name === \"object\") {\r\n                for (var attrName in name) {\r\n                    attr(elm, attrName, name[attrName]);\r\n                }\r\n                return this;\r\n            } else {\r\n                return elm.getAttribute ? elm.getAttribute(name) : elm[name];\r\n            }\r\n        } else {\r\n            elm.setAttribute ? elm.setAttribute(name, value) : elm[name] = value;\r\n            return this;\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n     *  Read all \"data-*\" attributes from a node\r\n     * @param {Object} elm  \r\n     */\r\n\r\n    function _attributeData(elm) {\r\n        var store = {}\r\n        langx.each(elm.attributes || [], function(i, attr) {\r\n            if (attr.name.indexOf('data-') == 0) {\r\n                store[camelCase(attr.name.replace('data-', ''))] = deserializeValue(attr.value);\r\n            }\r\n        })\r\n        return store;\r\n    }\r\n\r\n    function _store(elm, confirm) {\r\n        var store = elm[\"_$_store\"];\r\n        if (!store && confirm) {\r\n            store = elm[\"_$_store\"] = _attributeData(elm);\r\n        }\r\n        return store;\r\n    }\r\n\r\n    function _getData(elm, name) {\r\n        if (name === undefined) {\r\n            return _store(elm, true);\r\n        } else {\r\n            var store = _store(elm);\r\n            if (store) {\r\n                if (name in store) {\r\n                    return store[name];\r\n                }\r\n                var camelName = camelCase(name);\r\n                if (camelName in store) {\r\n                    return store[camelName];\r\n                }\r\n            }\r\n            var attrName = 'data-' + name.replace(capitalRE, \"-$1\").toLowerCase()\r\n            var value = attr(elm, attrName);\r\n            if (!langx.isString(value)) {\r\n              value = undefined;\r\n            }\r\n            return value;\r\n        }\r\n\r\n    }\r\n\r\n    function _setData(elm, name, value) {\r\n        var store = _store(elm, true);\r\n        store[camelCase(name)] = value;\r\n    }\r\n\r\n\r\n    /*\r\n     * xxx\r\n     * @param {Object} elm  \r\n     * @param {String} name\r\n     * @param {String} value\r\n     */\r\n    function data(elm, name, value) {\r\n\r\n        if (value === undefined) {\r\n            if (typeof name === \"object\") {\r\n                for (var dataAttrName in name) {\r\n                    _setData(elm, dataAttrName, name[dataAttrName]);\r\n                }\r\n                return this;\r\n            } else {\r\n                return _getData(elm, name);\r\n            }\r\n        } else {\r\n            _setData(elm, name, value);\r\n            return this;\r\n        }\r\n    } \r\n    /*\r\n     * Remove from the element all items that have not yet been run. \r\n     * @param {Object} elm  \r\n     */\r\n\r\n    function cleanData(elm) {\r\n        if (elm[\"_$_store\"]) {\r\n            delete elm[\"_$_store\"];\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Remove a previously-stored piece of data. \r\n     * @param {Object} elm  \r\n     * @param {Array} names\r\n     */\r\n    function removeData(elm, names) {\r\n        if (names) {\r\n            if (langx.isString(names)) {\r\n                names = names.split(/\\s+/);\r\n            }\r\n            var store = _store(elm, true);\r\n            names.forEach(function(name) {\r\n                delete store[name];\r\n            });            \r\n        } else {\r\n            cleanData(elm);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /*\r\n     * xxx \r\n     * @param {Object} elm  \r\n     * @param {Array} names\r\n     */\r\n    function pluck(nodes, property) {\r\n        return map.call(nodes, function(elm) {\r\n            return elm[property];\r\n        });\r\n    }\r\n\r\n    /*\r\n     * Get or set the value of an property for the specified element.\r\n     * @param {Object} elm  \r\n     * @param {String} name\r\n     * @param {String} value\r\n     */\r\n    function prop(elm, name, value) {\r\n      if (value === undefined) {\r\n          if (typeof name === \"object\") {\r\n              for (var propName in name) {\r\n                  prop(elm, propName, name[propName]);\r\n              }\r\n              return this;\r\n          } \r\n      } \r\n\r\n\r\n      name = propMap[name] || name;\r\n      if (value === undefined) {\r\n          return elm[name];\r\n      } else {\r\n          elm[name] = value;\r\n          return this;\r\n      }\r\n    }\r\n\r\n    /*\r\n     * remove Attributes  \r\n     * @param {Object} elm  \r\n     * @param {String} name\r\n     */\r\n    function removeAttr(elm, name) {\r\n        name.split(' ').forEach(function(attr) {\r\n            setAttribute(elm, attr);\r\n        });\r\n        return this;\r\n    }\r\n\r\n\r\n    /*\r\n     * Remove the value of a property for the first element in the set of matched elements or set one or more properties for every matched element.\r\n     * @param {Object} elm  \r\n     * @param {String} name\r\n     */\r\n    function removeProp(elm, name) {\r\n        name.split(' ').forEach(function(prop) {\r\n            delete elm[prop];\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /*   \r\n     * Get the combined text contents of each element in the set of matched elements, including their descendants, or set the text contents of the matched elements.  \r\n     * @param {Object} elm  \r\n     * @param {String} txt\r\n     */\r\n    function text(elm, txt) {\r\n        if (txt === undefined) {\r\n            return elm.textContent !==undefined  ? elm.textContent : elm.innerText;\r\n        } else {\r\n            txt = txt == null ? '' : '' + txt ;\r\n            if (elm.textContent !==undefined ) {\r\n              elm.textContent = txt ;\r\n            } else {\r\n              elm.innerText = txt ;\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*   \r\n     * Get the current value of the first element in the set of matched elements or set the value of every matched element.\r\n     * @param {Object} elm  \r\n     * @param {String} value\r\n     */\r\n    function val(elm, value) {\r\n        var hooks = valHooks[ elm.type ] || valHooks[ elm.nodeName.toLowerCase() ];\r\n        if (value === undefined) {\r\n/*\r\n            if (elm.multiple) {\r\n                // select multiple values\r\n                var selectedOptions = filter.call(finder.find(elm, \"option\"), (function(option) {\r\n                    return option.selected;\r\n                }));\r\n                return pluck(selectedOptions, \"value\");\r\n            } else {\r\n                if (/input|textarea/i.test(elm.tagName)) {\r\n                  return elm.value;\r\n                }\r\n                return text(elm);\r\n            }\r\n*/\r\n\r\n          if ( hooks &&  \"get\" in hooks &&  ( ret = hooks.get( elm, \"value\" ) ) !== undefined ) {\r\n            return ret;\r\n          }\r\n\r\n          ret = elm.value;\r\n\r\n          // Handle most common string cases\r\n          if ( typeof ret === \"string\" ) {\r\n            return ret.replace( /\\r/g, \"\" );\r\n          }\r\n\r\n          // Handle cases where value is null/undef or number\r\n          return ret == null ? \"\" : ret;\r\n\r\n        } else {\r\n/*          \r\n            if (/input|textarea/i.test(elm.tagName)) {\r\n              elm.value = value;\r\n            } else {\r\n              text(elm,value);\r\n            }\r\n            return this;\r\n*/\r\n          // Treat null/undefined as \"\"; convert numbers to string\r\n          if ( value == null ) {\r\n            value = \"\";\r\n\r\n          } else if ( typeof value === \"number\" ) {\r\n            value += \"\";\r\n\r\n          } else if ( langx.isArray( value ) ) {\r\n            value = langx.map( value, function( value1 ) {\r\n              return value1 == null ? \"\" : value1 + \"\";\r\n            } );\r\n          }\r\n\r\n          // If set returns undefined, fall back to normal setting\r\n          if ( !hooks || !( \"set\" in hooks ) || hooks.set( elm, value, \"value\" ) === undefined ) {\r\n            elm.value = value;\r\n          }\r\n        }      \r\n    }\r\n\r\n\r\n    finder.pseudos.data = function( elem, i, match,dataName ) {\r\n        return !!data( elem, dataName || match[3]);\r\n    };\r\n   \r\n\r\n    function datax() {\r\n        return datax;\r\n    }\r\n\r\n    langx.mixin(datax, {\r\n        aria: aria,\r\n\r\n        attr: attr,\r\n\r\n        cleanData: cleanData,\r\n\r\n        data: data,\r\n\r\n        pluck: pluck,\r\n\r\n        prop: prop,\r\n\r\n        removeAttr: removeAttr,\r\n\r\n        removeData: removeData,\r\n\r\n        removeProp: removeProp,\r\n\r\n        text: text,\r\n\r\n        val: val,\r\n\r\n        valHooks : valHooks\r\n    });\r\n\r\n    return skylark.attach(\"domx.data\", datax);\r\n});\ndefine('skylark-domx-query/query',[\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-finder\"\r\n], function(skylark, langx, noder, finder) {\r\n    var some = Array.prototype.some,\r\n        push = Array.prototype.push,\r\n        every = Array.prototype.every,\r\n        concat = Array.prototype.concat,\r\n        slice = Array.prototype.slice,\r\n        map = Array.prototype.map,\r\n        filter = Array.prototype.filter,\r\n        forEach = Array.prototype.forEach,\r\n        indexOf = Array.prototype.indexOf,\r\n        sort = Array.prototype.sort,\r\n        isQ;\r\n\r\n    var rquickExpr = /^(?:[^#<]*(<[\\w\\W]+>)[^>]*$|#([\\w\\-]*)$)/;\r\n\r\n    var funcArg = langx.funcArg,\r\n        isArrayLike = langx.isArrayLike,\r\n        isString = langx.isString,\r\n        uniq = langx.uniq,\r\n        isFunction = langx.isFunction;\r\n\r\n    var type = langx.type,\r\n        isArray = langx.isArray,\r\n\r\n        isWindow = langx.isWindow,\r\n\r\n        isDocument = langx.isDocument,\r\n\r\n        isObject = langx.isObject,\r\n\r\n        isPlainObject = langx.isPlainObject,\r\n\r\n        compact = langx.compact,\r\n\r\n        flatten = langx.flatten,\r\n\r\n        camelCase = langx.camelCase,\r\n\r\n        dasherize = langx.dasherize,\r\n        children = finder.children;\r\n\r\n    function wrapper_node_operation(func, context, oldValueFunc) {\r\n        return function(html) {\r\n            var argType, nodes = langx.map(arguments, function(arg) {\r\n                argType = type(arg)\r\n                return argType == \"function\" || argType == \"object\" || argType == \"array\" || arg == null ?\r\n                    arg : noder.createFragment(arg)\r\n            });\r\n            if (nodes.length < 1) {\r\n                return this\r\n            }\r\n            this.each(function(idx) {\r\n                func.apply(context, [this, nodes, idx > 0]);\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    function wrapper_map(func, context,mapValue) {\r\n        return function() {\r\n            var self = this,\r\n                params = slice.call(arguments);\r\n            var result = langx.map(self, function(elem, idx) {\r\n                return func.apply(context, [elem].concat(params));\r\n            });\r\n            if (mapValue) {\r\n                return result;\r\n            } else {\r\n                    return query(uniq(result));\r\n            }\r\n        }\r\n    }\r\n\r\n    function wrapper_selector(func, context, last) {\r\n        return function(selector) {\r\n            var self = this,\r\n                params = slice.call(arguments);\r\n            var result = this.map(function(idx, elem) {\r\n                // if (elem.nodeType == 1) {\r\n                if (elem.querySelector) {\r\n                    return func.apply(context, last ? [elem] : [elem, selector]);\r\n                } else {\r\n                    return [];\r\n                }\r\n            });\r\n            if (last && selector) {\r\n                return result.filter(selector);\r\n            } else {\r\n                return result;\r\n            }\r\n        }\r\n    }\r\n\r\n    function wrapper_selector_until(func, context, last) {\r\n        return function(util, selector) {\r\n            var self = this,\r\n                params = slice.call(arguments);\r\n            //if (selector === undefined) { //TODO : needs confirm?\r\n            //    selector = util;\r\n            //    util = undefined;\r\n            //}\r\n            var result = this.map(function(idx, elem) {\r\n                // if (elem.nodeType == 1) { // TODO\r\n                //if (elem.querySelector) {\r\n                    return func.apply(context, last ? [elem, util] : [elem, selector, util]);\r\n                //} else {\r\n                //    return [];\r\n                //}\r\n            });\r\n            if (last && selector) {\r\n                return result.filter(selector);\r\n            } else {\r\n                return result;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function wrapper_every_act(func, context) {\r\n        return function() {\r\n            var self = this,\r\n                params = slice.call(arguments);\r\n            this.each(function(idx,node) {\r\n                func.apply(context, [this].concat(params));\r\n            });\r\n            return self;\r\n        }\r\n    }\r\n\r\n    function wrapper_every_act_firstArgFunc(func, context, oldValueFunc) {\r\n        return function(arg1) {\r\n            var self = this,\r\n                params = slice.call(arguments);\r\n            forEach.call(self, function(elem, idx) {\r\n                var newArg1 = funcArg(elem, arg1, idx, oldValueFunc(elem));\r\n                func.apply(context, [elem, newArg1].concat(params.slice(1)));\r\n            });\r\n            return self;\r\n        }\r\n    }\r\n\r\n    function wrapper_some_chk(func, context) {\r\n        return function() {\r\n            var self = this,\r\n                params = slice.call(arguments);\r\n            return some.call(self, function(elem) {\r\n                return func.apply(context, [elem].concat(params));\r\n            });\r\n        }\r\n    }\r\n\r\n    function wrapper_name_value(func, context, oldValueFunc) {\r\n        return function(name, value) {\r\n            var self = this;\r\n\r\n            if (langx.isPlainObject(name) || langx.isDefined(value)) {\r\n                forEach.call(self, function(elem, idx) {\r\n                    var newValue;\r\n                    if (oldValueFunc) {\r\n                        newValue = funcArg(elem, value, idx, oldValueFunc(elem, name));\r\n                    } else {\r\n                        newValue = value\r\n                    }\r\n                    func.apply(context, [elem,name,newValue]);\r\n                });\r\n                return self;\r\n            } else {\r\n                if (self[0]) {\r\n                    return func.apply(context, [self[0], name]);\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    function wrapper_value(func, context, oldValueFunc) {\r\n        return function(value) {\r\n            var self = this;\r\n\r\n            if (langx.isDefined(value)) {\r\n                forEach.call(self, function(elem, idx) {\r\n                    var newValue;\r\n                    if (oldValueFunc) {\r\n                        newValue = funcArg(elem, value, idx, oldValueFunc(elem));\r\n                    } else {\r\n                        newValue = value\r\n                    }\r\n                    func.apply(context, [elem, newValue]);\r\n                });\r\n                return self;\r\n            } else {\r\n                if (self[0]) {\r\n                    return func.apply(context, [self[0]]);\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n\r\n    var NodeList = langx.klass({\r\n        klassName: \"SkNodeList\",\r\n        init: function(selector, context) {\r\n            var self = this,\r\n                match, nodes, node, props;\r\n\r\n            if (selector) {\r\n                self.context = context = context || noder.doc();\r\n\r\n                if (isString(selector)) {\r\n                    // a html string or a css selector is expected\r\n                    self.selector = selector;\r\n\r\n                    if (selector.charAt(0) === \"<\" && selector.charAt(selector.length - 1) === \">\" && selector.length >= 3) {\r\n                        match = [null, selector, null];\r\n                    } else {\r\n                        match = rquickExpr.exec(selector);\r\n                    }\r\n\r\n                    if (match) {\r\n                        if (match[1]) {\r\n                            // if selector is html\r\n                            nodes = noder.createFragment(selector);\r\n\r\n                            if (langx.isPlainObject(context)) {\r\n                                props = context;\r\n                            }\r\n\r\n                        } else {\r\n                            node = finder.byId(match[2], noder.ownerDoc(context));\r\n\r\n                            if (node) {\r\n                                // if selector is id\r\n                                nodes = [node];\r\n                            }\r\n\r\n                        }\r\n                    } else {\r\n                        // if selector is css selector\r\n                        if (langx.isString(context)) {\r\n                            context = finder.find(context);\r\n                        }\r\n\r\n                        nodes = finder.descendants(context, selector);\r\n                    }\r\n                } else {\r\n                    if (!noder.isWindow(selector) && isArrayLike(selector)) {\r\n                        // a dom node array is expected\r\n                        nodes = selector;\r\n                    } else {\r\n                        // a dom node is expected\r\n                        nodes = [selector];\r\n                    }\r\n                    //self.add(selector, false);\r\n                }\r\n            }\r\n\r\n\r\n            if (nodes) {\r\n\r\n                push.apply(self, nodes);\r\n\r\n                if (props) {\r\n                    for ( var name  in props ) {\r\n                        // Properties of context are called as methods if possible\r\n                        if ( langx.isFunction( this[ name ] ) ) {\r\n                            this[ name ]( props[ name ] );\r\n                        } else {\r\n                            this.attr( name, props[ name ] );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return self;\r\n        }\r\n    });\r\n\r\n    var query = (function() {\r\n        isQ = function(object) {\r\n            return object instanceof NodeList;\r\n        }\r\n        init = function(selector, context) {\r\n            return new NodeList(selector, context);\r\n        }\r\n\r\n        var $ = function(selector, context) {\r\n            if (isFunction(selector)) {\r\n                $.ready(function() {\r\n                    selector($);\r\n                });\r\n                return rootQuery;\r\n            } else if (isQ(selector)) {\r\n                return selector;\r\n            } else {\r\n                if (context && isQ(context) && isString(selector)) {\r\n                    return context.find(selector);\r\n                }\r\n                return init(selector, context);\r\n            }\r\n        },rootQuery = $(document);\r\n\r\n        $.fn = NodeList.prototype;\r\n        langx.mixin($.fn, {\r\n            // `map` and `slice` in the jQuery API work differently\r\n            // from their array counterparts\r\n            length : 0,\r\n\r\n            map: function(fn) {\r\n                return $(uniq(langx.map(this, function(el, i) {\r\n                    return fn.call(el, i, el)\r\n                })));\r\n            },\r\n\r\n            slice: function() {\r\n                return $(slice.apply(this, arguments))\r\n            },\r\n\r\n            forEach: function() {\r\n                return forEach.apply(this,arguments);\r\n            },\r\n\r\n            get: function(idx) {\r\n                return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]\r\n            },\r\n\r\n            indexOf: function() {\r\n                return indexOf.apply(this,arguments);\r\n            },\r\n\r\n            sort : function() {\r\n                return sort.apply(this,arguments);\r\n            },\r\n\r\n            toArray: function() {\r\n                return slice.call(this);\r\n            },\r\n\r\n            size: function() {\r\n                return this.length\r\n            },\r\n\r\n            //remove: wrapper_every_act(noder.remove, noder),\r\n            remove : function(selector) {\r\n                if (selector) {\r\n                    return this.find(selector).remove();\r\n                }\r\n                this.each(function(i,node){\r\n                    noder.remove(node);\r\n                });\r\n                return this;\r\n            },\r\n\r\n            each: function(callback) {\r\n                langx.each(this, callback);\r\n                return this;\r\n            },\r\n\r\n            filter: function(selector) {\r\n                if (isFunction(selector)) return this.not(this.not(selector))\r\n                return $(filter.call(this, function(element) {\r\n                    return finder.matches(element, selector)\r\n                }))\r\n            },\r\n\r\n            add: function(selector, context) {\r\n                return $(uniq(this.toArray().concat($(selector, context).toArray())));\r\n            },\r\n\r\n            is: function(selector) {\r\n                if (this.length > 0) {\r\n                    var self = this;\r\n                    if (langx.isString(selector)) {\r\n                        return some.call(self,function(elem) {\r\n                            return finder.matches(elem, selector);\r\n                        });\r\n                    } else if (langx.isArrayLike(selector)) {\r\n                       return some.call(self,function(elem) {\r\n                            return langx.inArray(elem, selector) > -1;\r\n                        });\r\n                    } else if (langx.isHtmlNode(selector)) {\r\n                       return some.call(self,function(elem) {\r\n                            return elem ==  selector;\r\n                        });\r\n                    }\r\n                }\r\n                return false;\r\n            },\r\n            \r\n            not: function(selector) {\r\n                var nodes = []\r\n                if (isFunction(selector) && selector.call !== undefined)\r\n                    this.each(function(idx,node) {\r\n                        if (!selector.call(this, idx,node)) nodes.push(this)\r\n                    })\r\n                else {\r\n                    var excludes = typeof selector == 'string' ? this.filter(selector) :\r\n                        (isArrayLike(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)\r\n                    this.forEach(function(el) {\r\n                        if (excludes.indexOf(el) < 0) nodes.push(el)\r\n                    })\r\n                }\r\n                return $(nodes)\r\n            },\r\n\r\n            has: function(selector) {\r\n                return this.filter(function() {\r\n                    return isObject(selector) ?\r\n                        noder.contains(this, selector) :\r\n                        $(this).find(selector).size()\r\n                })\r\n            },\r\n\r\n            eq: function(idx) {\r\n                return idx === -1 ? this.slice(idx) : this.slice(idx, +idx + 1);\r\n            },\r\n\r\n            first: function() {\r\n                return this.eq(0);\r\n            },\r\n\r\n            last: function() {\r\n                return this.eq(-1);\r\n            },\r\n\r\n            find: wrapper_selector(finder.descendants, finder),\r\n\r\n            closest: wrapper_selector(finder.closest, finder),\r\n            /*\r\n                        closest: function(selector, context) {\r\n                            var node = this[0],\r\n                                collection = false\r\n                            if (typeof selector == 'object') collection = $(selector)\r\n                            while (node && !(collection ? collection.indexOf(node) >= 0 : finder.matches(node, selector)))\r\n                                node = node !== context && !isDocument(node) && node.parentNode\r\n                            return $(node)\r\n                        },\r\n            */\r\n\r\n\r\n            parents: wrapper_selector(finder.ancestors, finder),\r\n\r\n            parentsUntil: wrapper_selector_until(finder.ancestors, finder),\r\n\r\n\r\n            parent: wrapper_selector(finder.parent, finder),\r\n\r\n            children: wrapper_selector(finder.children, finder),\r\n\r\n            contents: wrapper_map(noder.contents, noder),\r\n\r\n            empty: wrapper_every_act(noder.empty, noder),\r\n\r\n            html: wrapper_value(noder.html, noder),\r\n\r\n            // `pluck` is borrowed from Prototype.js\r\n            pluck: function(property) {\r\n                return langx.map(this, function(el) {\r\n                    return el[property]\r\n                })\r\n            },\r\n\r\n            pushStack : function(elms) {\r\n                var ret = $(elms);\r\n                ret.prevObject = this;\r\n                return ret;\r\n            },\r\n            \r\n            replaceWith: function(newContent) {\r\n                return this.before(newContent).remove();\r\n            },\r\n\r\n            wrap: function(html) {\r\n                /*\r\n                var func = isFunction(structure)\r\n                if (this[0] && !func)\r\n                    var dom = $(structure).get(0),\r\n                        clone = dom.parentNode || this.length > 1\r\n\r\n                return this.each(function(index,node) {\r\n                    $(this).wrapAll(\r\n                        func ? structure.call(this, index,node) :\r\n                        clone ? dom.cloneNode(true) : dom\r\n                    )\r\n                })\r\n                */\r\n                var htmlIsFunction = typeof html === \"function\";\r\n\r\n                return this.each( function( i ) {\r\n                    $( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\r\n                } );                \r\n            },\r\n\r\n            wrapAll: function(html) {\r\n                /*\r\n                if (this[0]) {\r\n                    $(this[0]).before(wrappingElement = $(wrappingElement));\r\n                    var children;\r\n                    // drill down to the inmost element\r\n                    while ((children = wrappingElement.children()).length) {\r\n                        wrappingElement = children.first();\r\n                    }\r\n                    $(wrappingElement).append(this);\r\n                }\r\n                return this\r\n                */\r\n                var wrap;\r\n\r\n                if ( this[ 0 ] ) {\r\n                    if ( typeof html === \"function\" ) {\r\n                        html = html.call( this[ 0 ] );\r\n                    }\r\n\r\n                    // The elements to wrap the target around\r\n                    wrap = $( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\r\n\r\n                    if ( this[ 0 ].parentNode ) {\r\n                        wrap.insertBefore( this[ 0 ] );\r\n                    }\r\n\r\n                    wrap.map( function() {\r\n                        var elem = this;\r\n\r\n                        while ( elem.firstElementChild ) {\r\n                            elem = elem.firstElementChild;\r\n                        }\r\n\r\n                        return elem;\r\n                    } ).append( this );\r\n                }\r\n\r\n                return this;\r\n\r\n            },\r\n\r\n            wrapInner: function(html) {\r\n                /*\r\n                var func = isFunction(wrappingElement)\r\n                return this.each(function(index,node) {\r\n                    var self = $(this),\r\n                        contents = self.contents(),\r\n                        dom = func ? wrappingElement.call(this, index,node) : wrappingElement\r\n                    contents.length ? contents.wrapAll(dom) : self.append(dom)\r\n                })\r\n                */\r\n                if ( typeof html === \"function\" ) {\r\n                    return this.each( function( i ) {\r\n                        $( this ).wrapInner( html.call( this, i ) );\r\n                    } );\r\n                }\r\n\r\n                return this.each( function() {\r\n                    var self = $( this ),\r\n                        contents = self.contents();\r\n\r\n                    if ( contents.length ) {\r\n                        contents.wrapAll( html );\r\n\r\n                    } else {\r\n                        self.append( html );\r\n                    }\r\n                } );\r\n\r\n            },\r\n\r\n            unwrap: function(selector) {\r\n                /*\r\n                if (this.parent().children().length === 0) {\r\n                    // remove dom without text\r\n                    this.parent(selector).not(\"body\").each(function() {\r\n                        $(this).replaceWith(document.createTextNode(this.childNodes[0].textContent));\r\n                    });\r\n                } else {\r\n                    this.parent().each(function() {\r\n                        $(this).replaceWith($(this).children())\r\n                    });\r\n                }\r\n                return this\r\n                */\r\n                this.parent(selector).not(\"body\").each( function() {\r\n                    $(this).replaceWith(this.childNodes);\r\n                });\r\n                return this;\r\n\r\n            },\r\n\r\n            clone: function() {\r\n                return this.map(function() {\r\n                    return this.cloneNode(true)\r\n                })\r\n            },\r\n\r\n\r\n            toggle: function(setting) {\r\n                return this.each(function() {\r\n                    var el = $(this);\r\n                    (setting === undefined ? el.css(\"display\") == \"none\" : setting) ? el.show(): el.hide()\r\n                })\r\n            },\r\n\r\n            prev: function(selector) {\r\n                return $(this.pluck('previousElementSibling')).filter(selector || '*')\r\n            },\r\n\r\n            prevAll: wrapper_selector(finder.previousSiblings, finder),\r\n\r\n            next: function(selector) {\r\n                return $(this.pluck('nextElementSibling')).filter(selector || '*')\r\n            },\r\n\r\n            nextAll: wrapper_selector(finder.nextSiblings, finder),\r\n\r\n            siblings: wrapper_selector(finder.siblings, finder),\r\n\r\n            index: function(elem) {\r\n                if (elem) {\r\n                    return this.indexOf($(elem)[0]);\r\n                } else {\r\n                    return this.parent().children().indexOf(this[0]);\r\n                }\r\n            }\r\n        });\r\n\r\n        // for now\r\n        $.fn.detach = $.fn.remove;\r\n\r\n        $.fn.hover = function(fnOver, fnOut) {\r\n            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);\r\n        };\r\n\r\n\r\n        var traverseNode = noder.traverse;\r\n\r\n\r\n        $.fn.after = wrapper_node_operation(noder.after, noder);\r\n\r\n        $.fn.prepend = wrapper_node_operation(noder.prepend, noder);\r\n\r\n        $.fn.before = wrapper_node_operation(noder.before, noder);\r\n\r\n        $.fn.append = wrapper_node_operation(noder.append, noder);\r\n\r\n\r\n        langx.each( {\r\n            appendTo: \"append\",\r\n            prependTo: \"prepend\",\r\n            insertBefore: \"before\",\r\n            insertAfter: \"after\",\r\n            replaceAll: \"replaceWith\"\r\n        }, function( name, original ) {\r\n            $.fn[ name ] = function( selector ) {\r\n                var elems,\r\n                    ret = [],\r\n                    insert = $( selector ),\r\n                    last = insert.length - 1,\r\n                    i = 0;\r\n\r\n                for ( ; i <= last; i++ ) {\r\n                    elems = i === last ? this : this.clone( true );\r\n                    $( insert[ i ] )[ original ]( elems );\r\n\r\n                    // Support: Android <=4.0 only, PhantomJS 1 only\r\n                    // .get() because push.apply(_, arraylike) throws on ancient WebKit\r\n                    push.apply( ret, elems.get() );\r\n                }\r\n\r\n                return this.pushStack( ret );\r\n            };\r\n        } );\r\n\r\n/*\r\n        $.fn.insertAfter = function(html) {\r\n            $(html).after(this);\r\n            return this;\r\n        };\r\n\r\n        $.fn.insertBefore = function(html) {\r\n            $(html).before(this);\r\n            return this;\r\n        };\r\n\r\n        $.fn.appendTo = function(html) {\r\n            $(html).append(this);\r\n            return this;\r\n        };\r\n\r\n        $.fn.prependTo = function(html) {\r\n            $(html).prepend(this);\r\n            return this;\r\n        };\r\n\r\n        $.fn.replaceAll = function(selector) {\r\n            $(selector).replaceWith(this);\r\n            return this;\r\n        };\r\n*/\r\n        return $;\r\n    })();\r\n\r\n    (function($) {\r\n        $.fn.scrollParent = function( includeHidden ) {\r\n            var position = this.css( \"position\" ),\r\n                excludeStaticParent = position === \"absolute\",\r\n                overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,\r\n                scrollParent = this.parents().filter( function() {\r\n                    var parent = $( this );\r\n                    if ( excludeStaticParent && parent.css( \"position\" ) === \"static\" ) {\r\n                        return false;\r\n                    }\r\n                    return overflowRegex.test( parent.css( \"overflow\" ) + parent.css( \"overflow-y\" ) +\r\n                        parent.css( \"overflow-x\" ) );\r\n                } ).eq( 0 );\r\n\r\n            return position === \"fixed\" || !scrollParent.length ?\r\n                $( this[ 0 ].ownerDocument || document ) :\r\n                scrollParent;\r\n        };\r\n\r\n    })(query);\r\n\r\n\r\n    (function($) {\r\n        $.fn.end = function() {\r\n            return this.prevObject || $()\r\n        }\r\n\r\n        $.fn.andSelf = function() {\r\n            return this.add(this.prevObject || $())\r\n        }\r\n\r\n        $.fn.addBack = function(selector) {\r\n            if (this.prevObject) {\r\n                if (selector) {\r\n                    return this.add(this.prevObject.filter(selector));\r\n                } else {\r\n                    return this.add(this.prevObject);\r\n                }\r\n            } else {\r\n                return this;\r\n            }\r\n        }\r\n\r\n        'filter,add,not,eq,first,last,find,closest,parents,parent,children,siblings,prev,prevAll,next,nextAll'.split(',').forEach(function(property) {\r\n            var fn = $.fn[property]\r\n            $.fn[property] = function() {\r\n                var ret = fn.apply(this, arguments)\r\n                ret.prevObject = this\r\n                return ret\r\n            }\r\n        })\r\n    })(query);\r\n\r\n\r\n    (function($) {\r\n        $.fn.query = $.fn.find;\r\n\r\n        $.fn.place = function(refNode, position) {\r\n            // summary:\r\n            //      places elements of this node list relative to the first element matched\r\n            //      by queryOrNode. Returns the original NodeList. See: `dojo/dom-construct.place`\r\n            // queryOrNode:\r\n            //      may be a string representing any valid CSS3 selector or a DOM node.\r\n            //      In the selector case, only the first matching element will be used\r\n            //      for relative positioning.\r\n            // position:\r\n            //      can be one of:\r\n            //\r\n            //      -   \"last\" (default)\r\n            //      -   \"first\"\r\n            //      -   \"before\"\r\n            //      -   \"after\"\r\n            //      -   \"only\"\r\n            //      -   \"replace\"\r\n            //\r\n            //      or an offset in the childNodes\r\n            if (langx.isString(refNode)) {\r\n                refNode = finder.descendant(refNode);\r\n            } else if (isQ(refNode)) {\r\n                refNode = refNode[0];\r\n            }\r\n            return this.each(function(i, node) {\r\n                switch (position) {\r\n                    case \"before\":\r\n                        noder.before(refNode, node);\r\n                        break;\r\n                    case \"after\":\r\n                        noder.after(refNode, node);\r\n                        break;\r\n                    case \"replace\":\r\n                        noder.replace(refNode, node);\r\n                        break;\r\n                    case \"only\":\r\n                        noder.empty(refNode);\r\n                        noder.append(refNode, node);\r\n                        break;\r\n                    case \"first\":\r\n                        noder.prepend(refNode, node);\r\n                        break;\r\n                        // else fallthrough...\r\n                    default: // aka: last\r\n                        noder.append(refNode, node);\r\n                }\r\n            });\r\n        };\r\n\r\n        $.fn.addContent = function(content, position) {\r\n            if (content.template) {\r\n                content = langx.substitute(content.template, content);\r\n            }\r\n            return this.append(content);\r\n        };\r\n\r\n\r\n\r\n        $.fn.disableSelection = ( function() {\r\n            var eventType = \"onselectstart\" in document.createElement( \"div\" ) ?\r\n                \"selectstart\" :\r\n                \"mousedown\";\r\n\r\n            return function() {\r\n                return this.on( eventType + \".ui-disableSelection\", function( event ) {\r\n                    event.preventDefault();\r\n                } );\r\n            };\r\n        } )();\r\n\r\n        $.fn.enableSelection = function() {\r\n            return this.off( \".ui-disableSelection\" );\r\n        };\r\n\r\n        $.fn.reflow = function() {\r\n            return noder.reflow(this[0]);\r\n        };\r\n\r\n        $.fn.isBlockNode = function() {\r\n            return noder.isBlockNode(this[0]);\r\n        };\r\n       \r\n\r\n    })(query);\r\n\r\n    query.fn.plugin = function(name,options) {\r\n        var args = slice.call( arguments, 1 ),\r\n            self = this,\r\n            returnValue = this;\r\n\r\n        this.each(function(){\r\n            returnValue = plugins.instantiate.apply(self,[this,name].concat(args));\r\n        });\r\n        return returnValue;\r\n    };\r\n\r\n\r\n    query.wraps = {\r\n        wrapper_node_operation,\r\n        wrapper_map,\r\n        wrapper_value,\r\n        wrapper_selector,\r\n        wrapper_some_chk,\r\n        wrapper_selector_until,\r\n        wrapper_every_act_firstArgFunc,\r\n        wrapper_every_act,\r\n        wrapper_name_value\r\n\r\n    };\r\n\r\n    return skylark.attach(\"domx.query\", query);\r\n\r\n});\ndefine('skylark-domx-query/main',[\r\n\t\"./query\",\r\n\t\"skylark-domx-styler\"\r\n],function($,styler){\r\n\r\n    $.fn.disabled = $.wraps.wrapper_name_value(styler.disabled, styler);\r\n\r\n    $.fn.style = $.wraps.wrapper_name_value(styler.css, styler);\r\n\r\n    $.fn.css = $.wraps.wrapper_name_value(styler.css, styler);\r\n\r\n    //hasClass(name)\r\n    $.fn.hasClass = $.wraps.wrapper_some_chk(styler.hasClass, styler);\r\n\r\n    //addClass(name)\r\n    $.fn.addClass = $.wraps.wrapper_every_act_firstArgFunc(styler.addClass, styler, styler.className);\r\n\r\n    //removeClass(name)\r\n    $.fn.removeClass = $.wraps.wrapper_every_act_firstArgFunc(styler.removeClass, styler, styler.className);\r\n\r\n    //toogleClass(name,when)\r\n    $.fn.toggleClass = $.wraps.wrapper_every_act_firstArgFunc(styler.toggleClass, styler, styler.className);\r\n\r\n    $.fn.replaceClass = function(newClass, oldClass) {\r\n        this.removeClass(oldClass);\r\n        this.addClass(newClass);\r\n        return this;\r\n    };\r\n\r\n    $.fn.replaceClass = function(newClass, oldClass) {\r\n        this.removeClass(oldClass);\r\n        this.addClass(newClass);\r\n        return this;\r\n    };\r\n        \r\n\r\n\treturn $;\r\n});\ndefine('skylark-domx-query', ['skylark-domx-query/main'], function (main) { return main; });\n\ndefine('skylark-domx-velm/velm',[\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-finder\",\r\n    \"skylark-domx-query\"\r\n], function(skylark, langx, noder, finder, $) {\r\n    var map = Array.prototype.map,\r\n        slice = Array.prototype.slice;\r\n    /*\r\n     * VisualElement is a skylark class type wrapping a visule dom node,\r\n     * provides a number of prototype methods and supports chain calls.\r\n     */\r\n    var VisualElement = langx.klass({\r\n        klassName: \"VisualElement\",\r\n\r\n        \"_construct\": function(node) {\r\n            if (langx.isString(node)) {\r\n                node = langx.trim(node);\r\n                if (node.charAt(0) === \"<\") {\r\n                    //html\r\n                    node = noder.createFragment(node)[0];\r\n                } else {\r\n                    // id\r\n                    node = document.getElementById(node);\r\n                }\r\n            }\r\n            this._elm = node;\r\n        }\r\n    });\r\n\r\n    VisualElement.prototype.$ = VisualElement.prototype.query = function(selector) {\r\n        return $(selector,this._elm);\r\n    };\r\n\r\n    VisualElement.prototype.elm = function() {\r\n        return this._elm;\r\n    };\r\n\r\n    /*\r\n     * the VisualElement object wrapping document.body\r\n     */\r\n    var root = new VisualElement(document.body),\r\n        velm = function(node) {\r\n            if (node) {\r\n                if (node instanceof VisualElement) {\r\n                    return node;\r\n                }\r\n                return new VisualElement(node);\r\n            } else {\r\n                return root;\r\n            }\r\n        };\r\n    /*\r\n     * Extend VisualElement prototype with wrapping the specified methods.\r\n     * @param {ArrayLike} fn\r\n     * @param {Object} context\r\n     */\r\n    function _delegator(fn, context) {\r\n        return function() {\r\n            var self = this,\r\n                elem = self._elm,\r\n                ret = fn.apply(context, [elem].concat(slice.call(arguments)));\r\n\r\n            if (ret) {\r\n                if (ret === context) {\r\n                    return self;\r\n                } else {\r\n                    if (ret instanceof HTMLElement) {\r\n                        ret = new VisualElement(ret);\r\n                    } else if (langx.isArrayLike(ret)) {\r\n                        ret = map.call(ret, function(el) {\r\n                            if (el instanceof HTMLElement) {\r\n                                return new VisualElement(el);\r\n                            } else {\r\n                                return el;\r\n                            }\r\n                        })\r\n                    }\r\n                }\r\n            }\r\n            return ret;\r\n        };\r\n    }\r\n\r\n    langx.mixin(velm, {\r\n        batch: function(nodes, action, args) {\r\n            nodes.forEach(function(node) {\r\n                var elm = (node instanceof VisualElement) ? node : velm(node);\r\n                elm[action].apply(elm, args);\r\n            });\r\n\r\n            return this;\r\n        },\r\n\r\n        root: new VisualElement(document.body),\r\n\r\n        VisualElement: VisualElement,\r\n\r\n        partial: function(name, fn) {\r\n            var props = {};\r\n\r\n            props[name] = fn;\r\n\r\n            VisualElement.partial(props);\r\n        },\r\n\r\n        delegate: function(names, context,matching) {\r\n            var props = {};\r\n\r\n            names.forEach(function(name) {\r\n                var matchedName = name;\r\n                if (matching && matching[name]) {\r\n                    matchedName = matching[name];\r\n                } \r\n                props[name] = _delegator(context[matchedName], context);\r\n            });\r\n\r\n            VisualElement.partial(props);\r\n        }\r\n    });\r\n\r\n    // from ./finder\r\n    velm.delegate([\r\n        \"ancestor\",\r\n        \"ancestors\",\r\n        \"children\",\r\n        \"descendant\",\r\n        \"find\",\r\n        \"findAll\",\r\n        \"firstChild\",\r\n        \"lastChild\",\r\n        \"matches\",\r\n        \"nextSibling\",\r\n        \"nextSiblings\",\r\n        \"parent\",\r\n        \"previousSibling\",\r\n        \"previousSiblings\",\r\n        \"siblings\"\r\n    ], finder);\r\n\r\n    /*\r\n     * find a dom element matched by the specified selector.\r\n     * @param {String} selector\r\n     */\r\n    velm.find = function(selector) {\r\n        if (selector === \"body\") {\r\n            return this.root;\r\n        } else {\r\n            return this.root.descendant(selector);\r\n        }\r\n    };\r\n\r\n\r\n    // from ./noder\r\n    velm.delegate([\r\n        \"after\",\r\n        \"append\",\r\n        \"before\",\r\n        \"clone\",\r\n        \"contains\",\r\n        \"contents\",\r\n        \"empty\",\r\n        \"fullscreen\",\r\n        \"html\",\r\n        \"isChildOf\",\r\n        \"isDocument\",\r\n        \"isInDocument\",\r\n        \"isWindow\",\r\n        \"ownerDoc\",\r\n        \"prepend\",\r\n        \"remove\",\r\n        \"removeChild\",\r\n        \"replace\",\r\n        \"reverse\",\r\n        \"throb\",\r\n        \"traverse\",\r\n        \"wrapper\",\r\n        \"wrapperInner\",\r\n        \"unwrap\"\r\n    ], noder);\r\n\r\n\r\n    return skylark.attach(\"domx.velm\", velm);\r\n});\ndefine('skylark-domx-velm/main',[\r\n\t\"./velm\",\r\n\t\"skylark-domx-styler\"\r\n],function(velm,styler){\r\n    // from ./styler\r\n    velm.delegate([\r\n        \"addClass\",\r\n        \"className\",\r\n        \"css\",\r\n        \"disabled\",\r\n        \"hasClass\",\r\n        \"hide\",\r\n        \"isInvisible\",\r\n        \"removeClass\",\r\n        \"show\",\r\n        \"toggleClass\"\r\n    ], styler);\r\n\r\n    // properties\r\n\r\n    var properties = [ 'position', 'left', 'top', 'right', 'bottom', 'width', 'height', 'border', 'borderLeft',\r\n    'borderTop', 'borderRight', 'borderBottom', 'borderColor', 'display', 'overflow', 'margin', 'marginLeft', 'marginTop', 'marginRight', 'marginBottom', 'padding', 'paddingLeft', 'paddingTop', 'paddingRight', 'paddingBottom', 'color',\r\n    'background', 'backgroundColor', 'opacity', 'fontSize', 'fontWeight', 'textAlign', 'textDecoration', 'textTransform', 'cursor', 'zIndex' ];\r\n\r\n    properties.forEach( function ( property ) {\r\n\r\n        var method = property;\r\n\r\n        velm.VisualElement.prototype[method ] = function (value) {\r\n\r\n            this.css( property, value );\r\n\r\n            return this;\r\n\r\n        };\r\n\r\n    });\r\n\r\n\treturn velm;\r\n});\ndefine('skylark-domx-velm', ['skylark-domx-velm/main'], function (main) { return main; });\n\ndefine('skylark-domx-data/main',[\r\n    \"./data\",\r\n    \"skylark-domx-velm\",\r\n    \"skylark-domx-query\"    \r\n],function(data,velm,$){\r\n    // from ./data\r\n    velm.delegate([\r\n        \"attr\",\r\n        \"data\",\r\n        \"prop\",\r\n        \"removeAttr\",\r\n        \"removeData\",\r\n        \"text\",\r\n        \"val\"\r\n    ], data);\r\n\r\n    $.fn.text = $.wraps.wrapper_value(data.text, data, data.text);\r\n\r\n    $.fn.attr = $.wraps.wrapper_name_value(data.attr, data, data.attr);\r\n\r\n    $.fn.removeAttr = $.wraps.wrapper_every_act(data.removeAttr, data);\r\n\r\n    $.fn.prop = $.wraps.wrapper_name_value(data.prop, data, data.prop);\r\n\r\n    $.fn.removeProp = $.wraps.wrapper_every_act(data.removeProp, data);\r\n\r\n    $.fn.data = $.wraps.wrapper_name_value(data.data, data);\r\n\r\n    $.fn.removeData = $.wraps.wrapper_every_act(data.removeData);\r\n\r\n    $.fn.val = $.wraps.wrapper_value(data.val, data, data.val);\r\n\r\n\r\n    return data;\r\n});\ndefine('skylark-domx-data', ['skylark-domx-data/main'], function (main) { return main; });\n\ndefine('skylark-domx-eventer/eventer',[\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-browser\",\r\n    \"skylark-domx-finder\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-data\"\r\n], function(skylark, langx, browser, finder, noder, datax) {\r\n    var mixin = langx.mixin,\r\n        each = langx.each,\r\n        slice = Array.prototype.slice,\r\n        uid = langx.uid,\r\n        ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$)/,\r\n        eventMethods = {\r\n            preventDefault: \"isDefaultPrevented\",\r\n            stopImmediatePropagation: \"isImmediatePropagationStopped\",\r\n            stopPropagation: \"isPropagationStopped\"\r\n        },\r\n        readyRE = /complete|loaded|interactive/;\r\n\r\n    function compatible(event, source) {\r\n        if (source || !event.isDefaultPrevented) {\r\n            if (!source) {\r\n                source = event;\r\n            }\r\n\r\n            langx.each(eventMethods, function(name, predicate) {\r\n                var sourceMethod = source[name];\r\n                event[name] = function() {\r\n                    this[predicate] = langx.returnTrue;\r\n                    return sourceMethod && sourceMethod.apply(source, arguments);\r\n                }\r\n                event[predicate] = langx.returnFalse;\r\n            });\r\n        }\r\n        return event;\r\n    }\r\n\r\n    function parse(event) {\r\n        if (event) {\r\n            var segs = (\"\" + event).split(\".\");\r\n            return {\r\n                type: segs[0],\r\n                ns: segs.slice(1).sort().join(\" \")\r\n            };\r\n        } else {\r\n            return {\r\n                type : null,\r\n                ns : null\r\n            }\r\n        }\r\n    }\r\n\r\n    function isHandler(callback) {\r\n        return callback && (langx.isFunction(callback) || langx.isFunction(callback.handleEvent));\r\n    }\r\n\r\n    var NativeEventCtors = [\r\n            window[\"CustomEvent\"], // 0 default\r\n            window[\"CompositionEvent\"], // 1\r\n            window[\"DragEvent\"], // 2\r\n            window[\"Event\"], // 3\r\n            window[\"FocusEvent\"], // 4\r\n            window[\"KeyboardEvent\"], // 5\r\n            window[\"MessageEvent\"], // 6\r\n            window[\"MouseEvent\"], // 7\r\n            window[\"MouseScrollEvent\"], // 8\r\n            window[\"MouseWheelEvent\"], // 9\r\n            window[\"MutationEvent\"], // 10\r\n            window[\"ProgressEvent\"], // 11\r\n            window[\"TextEvent\"], // 12\r\n            window[\"TouchEvent\"], // 13\r\n            window[\"UIEvent\"], // 14\r\n            window[\"WheelEvent\"], // 15\r\n            window[\"ClipboardEvent\"] // 16\r\n        ],\r\n        NativeEvents = {\r\n            \"compositionstart\": 1, // CompositionEvent\r\n            \"compositionend\": 1, // CompositionEvent\r\n            \"compositionupdate\": 1, // CompositionEvent\r\n\r\n            \"beforecopy\": 16, // ClipboardEvent\r\n            \"beforecut\": 16, // ClipboardEvent\r\n            \"beforepaste\": 16, // ClipboardEvent\r\n            \"copy\": 16, // ClipboardEvent\r\n            \"cut\": 16, // ClipboardEvent\r\n            \"paste\": 16, // ClipboardEvent\r\n\r\n            \"drag\": 2, // DragEvent\r\n            \"dragend\": 2, // DragEvent\r\n            \"dragenter\": 2, // DragEvent\r\n            \"dragexit\": 2, // DragEvent\r\n            \"dragleave\": 2, // DragEvent\r\n            \"dragover\": 2, // DragEvent\r\n            \"dragstart\": 2, // DragEvent\r\n            \"drop\": 2, // DragEvent\r\n\r\n            \"abort\": 3, // Event\r\n            \"change\": 3, // Event\r\n            \"error\": 3, // Event\r\n            \"selectionchange\": 3, // Event\r\n            \"submit\": 3, // Event\r\n            \"reset\": 3, // Event\r\n            'fullscreenchange':3,\r\n            'fullscreenerror':3,\r\n\r\n/*\r\n            'disablepictureinpicturechanged':3,\r\n            'ended':3,\r\n            'enterpictureinpicture':3,\r\n            'durationchange':3,\r\n            'leavepictureinpicture':3,\r\n            'loadstart' : 3,\r\n            'loadedmetadata':3,\r\n            'pause' : 3,\r\n            'play':3,\r\n            'posterchange':3,\r\n            'ratechange':3,\r\n            'seeking' : 3,\r\n            'sourceset':3,\r\n            'suspend':3,\r\n            'textdata':3,\r\n            'texttrackchange':3,\r\n            'timeupdate':3,\r\n            'volumechange':3,\r\n            'waiting' : 3,\r\n*/\r\n\r\n\r\n            \"focus\": 4, // FocusEvent\r\n            \"blur\": 4, // FocusEvent\r\n            \"focusin\": 4, // FocusEvent\r\n            \"focusout\": 4, // FocusEvent\r\n\r\n            \"keydown\": 5, // KeyboardEvent\r\n            \"keypress\": 5, // KeyboardEvent\r\n            \"keyup\": 5, // KeyboardEvent\r\n\r\n            \"message\": 6, // MessageEvent\r\n\r\n            \"click\": 7, // MouseEvent\r\n            \"contextmenu\": 7, // MouseEvent\r\n            \"dblclick\": 7, // MouseEvent\r\n            \"mousedown\": 7, // MouseEvent\r\n            \"mouseup\": 7, // MouseEvent\r\n            \"mousemove\": 7, // MouseEvent\r\n            \"mouseover\": 7, // MouseEvent\r\n            \"mouseout\": 7, // MouseEvent\r\n            \"mouseenter\": 7, // MouseEvent\r\n            \"mouseleave\": 7, // MouseEvent\r\n\r\n\r\n            \"progress\" : 11, //ProgressEvent\r\n\r\n            \"textInput\": 12, // TextEvent\r\n\r\n            \"tap\": 13,\r\n            \"touchstart\": 13, // TouchEvent\r\n            \"touchmove\": 13, // TouchEvent\r\n            \"touchend\": 13, // TouchEvent\r\n\r\n            \"load\": 14, // UIEvent\r\n            \"resize\": 14, // UIEvent\r\n            \"select\": 14, // UIEvent\r\n            \"scroll\": 14, // UIEvent\r\n            \"unload\": 14, // UIEvent,\r\n\r\n            \"wheel\": 15, // WheelEvent\r\n\r\n\r\n\r\n        };\r\n\r\n    //create a custom dom event\r\n    var createEvent = (function() {\r\n\r\n        function getEventCtor(type) {\r\n            var idx = NativeEvents[type];\r\n            if (!idx) {\r\n                idx = 0;\r\n            }\r\n            return NativeEventCtors[idx];\r\n        }\r\n\r\n        return function(type, props) {\r\n            //create a custom dom event\r\n\r\n            if (langx.isString(type)) {\r\n                props = props || {};\r\n            } else {\r\n                props = type || {};\r\n                type = props.type || \"\";\r\n            }\r\n            var parsed = parse(type);\r\n            type = parsed.type;\r\n\r\n            props = langx.mixin({\r\n                bubbles: true,\r\n                cancelable: true\r\n            }, props);\r\n\r\n            if (parsed.ns) {\r\n                props.namespace = parsed.ns;\r\n            }\r\n\r\n            var ctor = getEventCtor(type),\r\n                e = new ctor(type, props);\r\n\r\n            langx.safeMixin(e, props);\r\n\r\n            return compatible(e);\r\n        };\r\n    })();\r\n\r\n    function createProxy(src, props) {\r\n        var key,\r\n            proxy = {\r\n                originalEvent: src\r\n            };\r\n        for (key in src) {\r\n            if (key !== \"keyIdentifier\" && !ignoreProperties.test(key) && src[key] !== undefined) {\r\n                proxy[key] = src[key];\r\n            }\r\n        }\r\n        if (props) {\r\n            langx.mixin(proxy, props);\r\n        }\r\n        return compatible(proxy, src);\r\n    }\r\n\r\n    var\r\n        specialEvents = {},\r\n        focusinSupported = \"onfocusin\" in window,\r\n        focus = { focus: \"focusin\", blur: \"focusout\" },\r\n        hover = { mouseenter: \"mouseover\", mouseleave: \"mouseout\" },\r\n        realEvent = function(type) {\r\n            return hover[type] || (focusinSupported && focus[type]) || type;\r\n        },\r\n        handlers = {},\r\n        EventBindings = langx.klass({\r\n            init: function(target, event) {\r\n                this._target = target;\r\n                this._event = event;\r\n                this._bindings = [];\r\n            },\r\n\r\n            add: function(fn, options) {\r\n                var bindings = this._bindings,\r\n                    binding = {\r\n                        fn: fn,\r\n                        options: langx.mixin({}, options)\r\n                    };\r\n\r\n                bindings.push(binding);\r\n\r\n                var self = this;\r\n                if (!self._listener) {\r\n                    self._listener = function(domEvt) {\r\n                        var elm = this,\r\n                            e = createProxy(domEvt),\r\n                            args = domEvt._args,\r\n                            bindings = self._bindings,\r\n                            ns = e.namespace;\r\n\r\n                        if (langx.isDefined(args)) {\r\n                            args = [e].concat(args);\r\n                        } else {\r\n                            args = [e];\r\n                        }\r\n\r\n                        e.type = self._event; // convert realEvent to listened event\r\n\r\n                        langx.each(bindings, function(idx, binding) {\r\n                            var match = elm;\r\n                            if (e.isImmediatePropagationStopped && e.isImmediatePropagationStopped()) {\r\n                                return false;\r\n                            }\r\n                            var fn = binding.fn,\r\n                                options = binding.options || {},\r\n                                selector = options.selector,\r\n                                one = options.one,\r\n                                data = options.data;\r\n\r\n                            if (ns && ns != options.ns && options.ns.indexOf(ns) === -1) {\r\n                                return;\r\n                            }\r\n                            if (selector) {\r\n                                match = finder.closest(e.target, selector);\r\n                                if (match && match !== elm) {\r\n                                    langx.mixin(e, {\r\n                                        currentTarget: match,\r\n                                        liveFired: elm\r\n                                    });\r\n                                } else {\r\n                                    return;\r\n                                }\r\n                            }\r\n\r\n                            var originalEvent = self._event;\r\n                            if (originalEvent in hover) {\r\n                                var related = e.relatedTarget;\r\n                                if (related && (related === match || noder.contains(match, related))) {\r\n                                    return;\r\n                                }\r\n                            }\r\n\r\n                            if (langx.isDefined(data)) {\r\n                                e.data = data;\r\n                            }\r\n\r\n                            if (one) {\r\n                                self.remove(fn, options);\r\n                            }\r\n\r\n                            var result ;\r\n                            if (fn.handleEvent) {\r\n                                result = fn.handleEvent.apply(fn,args);\r\n                            } else {\r\n                                if (options.ctx) {\r\n                                    result = fn.apply(options.ctx, args);                                   \r\n                                } else {\r\n                                    result = fn.apply(match, args);                                   \r\n                                }\r\n                            }\r\n\r\n                            if (result === false) {\r\n                                e.preventDefault();\r\n                                e.stopPropagation();\r\n                            }\r\n                        });;\r\n                    };\r\n\r\n                    var event = self._event;\r\n                    /*\r\n                                        if (event in hover) {\r\n                                            var l = self._listener;\r\n                                            self._listener = function(e) {\r\n                                                var related = e.relatedTarget;\r\n                                                if (!related || (related !== this && !noder.contains(this, related))) {\r\n                                                    return l.apply(this, arguments);\r\n                                                }\r\n                                            }\r\n                                        }\r\n                    */\r\n\r\n                    if (self._target.addEventListener) {\r\n                        self._target.addEventListener(realEvent(event), self._listener, false);\r\n                    } else {\r\n                        console.warn(\"invalid eventer object\", self._target);\r\n                    }\r\n                }\r\n\r\n            },\r\n            remove: function(fn, options) {\r\n                options = langx.mixin({}, options);\r\n\r\n                function matcherFor(ns) {\r\n                    return new RegExp(\"(?:^| )\" + ns.replace(\" \", \" .* ?\") + \"(?: |$)\");\r\n                }\r\n                var matcher;\r\n                if (options.ns) {\r\n                    matcher = matcherFor(options.ns);\r\n                }\r\n\r\n                this._bindings = this._bindings.filter(function(binding) {\r\n                    var removing = (!fn || fn === binding.fn) &&\r\n                        (!matcher || matcher.test(binding.options.ns)) &&\r\n                        (!options.selector || options.selector == binding.options.selector);\r\n\r\n                    return !removing;\r\n                });\r\n                if (this._bindings.length == 0) {\r\n                    if (this._target.removeEventListener) {\r\n                        this._target.removeEventListener(realEvent(this._event), this._listener, false);\r\n                    }\r\n                    this._listener = null;\r\n                }\r\n            }\r\n        }),\r\n        EventsHandler = langx.klass({\r\n            init: function(elm) {\r\n                this._target = elm;\r\n                this._handler = {};\r\n            },\r\n\r\n            // add a event listener\r\n            // selector Optional\r\n            register: function(event, callback, options) {\r\n                // Seperate the event from the namespace\r\n                var parsed = parse(event),\r\n                    event = parsed.type,\r\n                    specialEvent = specialEvents[event],\r\n                    bindingEvent = specialEvent && (specialEvent.bindType || specialEvent.bindEventName);\r\n\r\n                var events = this._handler;\r\n\r\n                // Check if there is already a handler for this event\r\n                if (events[event] === undefined) {\r\n                    events[event] = new EventBindings(this._target, bindingEvent || event);\r\n                }\r\n\r\n                // Register the new callback function\r\n                events[event].add(callback, langx.mixin({\r\n                    ns: parsed.ns\r\n                }, options)); // options:{selector:xxx}\r\n            },\r\n\r\n            // remove a event listener\r\n            unregister: function(event, fn, options) {\r\n                // Check for parameter validtiy\r\n                var events = this._handler,\r\n                    parsed = parse(event);\r\n                event = parsed.type;\r\n\r\n                if (event) {\r\n                    var listener = events[event];\r\n\r\n                    if (listener) {\r\n                        listener.remove(fn, langx.mixin({\r\n                            ns: parsed.ns\r\n                        }, options));\r\n                    }\r\n                } else {\r\n                    //remove all events\r\n                    for (event in events) {\r\n                        var listener = events[event];\r\n                        listener.remove(fn, langx.mixin({\r\n                            ns: parsed.ns\r\n                        }, options));\r\n                    }\r\n                }\r\n            }\r\n        }),\r\n\r\n        findHandler = function(elm) {\r\n            var id = uid(elm),\r\n                handler = handlers[id];\r\n            if (!handler) {\r\n                handler = handlers[id] = new EventsHandler(elm);\r\n            }\r\n            return handler;\r\n        };\r\n\r\n\r\n    /*   \r\n     * Remove all event handlers from the specified element.\r\n     * @param {HTMLElement} elm  \r\n     */\r\n    function clear(elm) {\r\n        var handler = findHandler(elm);\r\n\r\n        handler.unregister();\r\n\r\n        return this;\r\n    }\r\n\r\n    var focusedQueue = [],\r\n        focuser = langx.loop(function(){\r\n            for (var i = 0; i<focusedQueue.length; i++) {\r\n                trigger(focusedQueue[i],\"focused\");\r\n            }\r\n            focusedQueue = [];\r\n        });\r\n\r\n    focuser.start();\r\n\r\n\r\n    function focused(elm) {\r\n        if (!focusedQueue.includes(elm)) {\r\n            focusedQueue.push(elm)\r\n        }\r\n    }\r\n\r\n    /*   \r\n     * Remove an event handler for one or more events from the specified element.\r\n     * @param {HTMLElement} elm  \r\n     * @param {String} events\r\n     * @param {String　Optional } selector\r\n     * @param {Function} callback\r\n     */\r\n    function off(elm, events, selector, callback) {\r\n        var $this = this\r\n        if (langx.isPlainObject(events)) {\r\n            langx.each(events, function(type, fn) {\r\n                off(elm, type, selector, fn);\r\n            })\r\n            return $this;\r\n        }\r\n\r\n        if (!langx.isString(selector) && !isHandler(callback) && callback !== false) {\r\n            callback = selector;\r\n            selector = undefined;\r\n        }\r\n\r\n        if (callback === false) {\r\n            callback = langx.returnFalse;\r\n        }\r\n\r\n        if (typeof events == \"string\") {\r\n            if (events.indexOf(\",\") > -1) {\r\n                events = events.split(\",\");\r\n            } else {\r\n                events = events.split(/\\s/);\r\n            }\r\n        }\r\n\r\n        var handler = findHandler(elm);\r\n\r\n        if (events) events.forEach(function(event) {\r\n\r\n            handler.unregister(event, callback, {\r\n                selector: selector,\r\n            });\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /*   \r\n     * Attach an event handler function for one or more events to the selected elements.\r\n     * @param {HTMLElement} elm  \r\n     * @param {String} events\r\n     * @param {String　Optional} selector\r\n     * @param {Anything Optional} data\r\n     * @param {Function} callback\r\n     * @param {Boolean　Optional} one\r\n     */\r\n    function on(elm, events, selector, data, callback, ctx,one) {\r\n\r\n        var autoRemove, delegator;\r\n        if (langx.isPlainObject(events)) {\r\n            langx.each(events, function(type, fn) {\r\n                on(elm, type, selector, data, fn, one);\r\n            });\r\n            return this;\r\n        }\r\n\r\n        if (!langx.isString(selector) && !isHandler(callback)) {\r\n            one = ctx;\r\n            ctx = callback;\r\n            callback = data;\r\n            data = selector;\r\n            selector = undefined;\r\n        }\r\n\r\n        if (isHandler(data)) {\r\n            one = ctx;\r\n            ctx = callback;\r\n            callback = data;\r\n            data = undefined;\r\n        }\r\n\r\n        if (langx.isBoolean(ctx)) {\r\n            one = ctx;\r\n            ctx = undefined;\r\n        }\r\n        if (callback === false) {\r\n            callback = langx.returnFalse;\r\n        }\r\n\r\n        if (typeof events == \"string\") {\r\n            if (events.indexOf(\",\") > -1) {\r\n                events = events.split(\",\");\r\n            } else {\r\n                events = events.split(/\\s/);\r\n            }\r\n        }\r\n\r\n        var handler = findHandler(elm);\r\n\r\n        events.forEach(function(event) {\r\n            if (event == \"ready\") {\r\n                return ready(callback);\r\n            }\r\n            handler.register(event, callback, {\r\n                data: data,\r\n                selector: selector,\r\n                ctx : ctx,\r\n                one: !!one\r\n            });\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /*   \r\n     * Attach a handler to an event for the elements. The handler is executed at most once per \r\n     * @param {HTMLElement} elm  \r\n     * @param {String} event\r\n     * @param {String　Optional} selector\r\n     * @param {Anything Optional} data\r\n     * @param {Function} callback\r\n     */\r\n    function one(...args) {\r\n        on(...args, true);\r\n\r\n        return this;\r\n    }\r\n\r\n    /*   \r\n     * Prevents propagation and clobbers the default action of the passed event. The same as calling event.preventDefault() and event.stopPropagation(). \r\n     * @param {String} event\r\n     */\r\n    function stop(event) {\r\n        if (window.document.all) {\r\n            event.keyCode = 0;\r\n        }\r\n        if (event.preventDefault) {\r\n            event.preventDefault();\r\n            event.stopPropagation();\r\n        }\r\n        return this;\r\n    }\r\n    /*   \r\n     * Execute all handlers and behaviors attached to the matched elements for the given event  \r\n     * @param {String} evented\r\n     * @param {String} type\r\n     * @param {Array or PlainObject } args\r\n     */\r\n    function trigger(evented, type, args) {\r\n        var e;\r\n        if (type instanceof Event) {\r\n            e = type;\r\n        } else {\r\n            e = createEvent(type, args);\r\n        }\r\n        e._args = args;\r\n\r\n        var fn = (evented.dispatchEvent || evented.trigger);\r\n        if (fn) {\r\n            fn.call(evented, e);\r\n        } else {\r\n            console.warn(\"The evented parameter is not a eventable object\");\r\n        }\r\n\r\n        return this;\r\n    }\r\n    /*   \r\n     * Specify a function to execute when the DOM is fully loaded.  \r\n     * @param {Function} callback\r\n     */\r\n    function ready(callback) {\r\n        // need to check if document.body exists for IE as that browser reports\r\n        // document ready when it hasn't yet created the body elm\r\n        if (readyRE.test(document.readyState) && document.body) {\r\n            langx.defer(callback);\r\n        } else {\r\n            document.addEventListener('DOMContentLoaded', callback, false);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    var resizedQueue = [],\r\n        resizer = langx.loop(function(){\r\n            for (var i = 0; i<resizedQueue.length; i++) {\r\n                trigger(resizedQueue[i],\"resized\");\r\n            }\r\n            resizedQueue = [];\r\n        });\r\n\r\n    resizer.start();\r\n\r\n\r\n    function resized(elm) {\r\n        if (!resizedQueue.includes(elm)) {\r\n            resizedQueue.push(elm)\r\n        }\r\n    }\r\n\r\n\r\n    var keyCodeLookup = {\r\n        \"backspace\": 8,\r\n        \"comma\": 188,\r\n        \"delete\": 46,\r\n        \"down\": 40,\r\n        \"end\": 35,\r\n        \"enter\": 13,\r\n        \"escape\": 27,\r\n        \"home\": 36,\r\n        \"left\": 37,\r\n        \"page_down\": 34,\r\n        \"page_up\": 33,\r\n        \"period\": 190,\r\n        \"right\": 39,\r\n        \"space\": 32,\r\n        \"tab\": 9,\r\n        \"up\": 38\r\n    };\r\n    //example:\r\n    //shortcuts(elm).add(\"CTRL+ALT+SHIFT+X\",function(){console.log(\"test!\")});\r\n    function shortcuts(elm) {\r\n\r\n        var registry = datax.data(elm, \"shortcuts\");\r\n        if (!registry) {\r\n            registry = {};\r\n            datax.data(elm, \"shortcuts\", registry);\r\n            var run = function(shortcut, event) {\r\n                var n = event.metaKey || event.ctrlKey;\r\n                if (shortcut.ctrl == n && shortcut.alt == event.altKey && shortcut.shift == event.shiftKey) {\r\n                    if (event.keyCode == shortcut.keyCode || event.charCode && event.charCode == shortcut.charCode) {\r\n                        event.preventDefault();\r\n                        if (\"keydown\" == event.type) {\r\n                            shortcut.fn(event);\r\n                        }\r\n                        return true;\r\n                    }\r\n                }\r\n            };\r\n            on(elm, \"keyup keypress keydown\", function(event) {\r\n                if (!(/INPUT|TEXTAREA/.test(event.target.nodeName))) {\r\n                    for (var key in registry) {\r\n                        run(registry[key], event);\r\n                    }\r\n                }\r\n            });\r\n\r\n        }\r\n\r\n        return {\r\n            add: function(pattern, fn) {\r\n                var shortcutKeys;\r\n                if (pattern.indexOf(\",\") > -1) {\r\n                    shortcutKeys = pattern.toLowerCase().split(\",\");\r\n                } else {\r\n                    shortcutKeys = pattern.toLowerCase().split(\" \");\r\n                }\r\n                shortcutKeys.forEach(function(shortcutKey) {\r\n                    var setting = {\r\n                        fn: fn,\r\n                        alt: false,\r\n                        ctrl: false,\r\n                        shift: false\r\n                    };\r\n                    shortcutKey.split(\"+\").forEach(function(key) {\r\n                        switch (key) {\r\n                            case \"alt\":\r\n                            case \"ctrl\":\r\n                            case \"shift\":\r\n                                setting[key] = true;\r\n                                break;\r\n                            default:\r\n                                setting.charCode = key.charCodeAt(0);\r\n                                setting.keyCode = keyCodeLookup[key] || key.toUpperCase().charCodeAt(0);\r\n                        }\r\n                    });\r\n                    var regKey = (setting.ctrl ? \"ctrl\" : \"\") + \",\" + (setting.alt ? \"alt\" : \"\") + \",\" + (setting.shift ? \"shift\" : \"\") + \",\" + setting.keyCode;\r\n                    registry[regKey] = setting;\r\n                })\r\n            }\r\n\r\n        };\r\n\r\n    }\r\n\r\n    if (browser.support.transition) {\r\n        specialEvents.transitionEnd = {\r\n//          handle: function (e) {\r\n//            if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)\r\n//          },\r\n          bindType: browser.support.transition.end,\r\n          delegateType: browser.support.transition.end\r\n        }        \r\n    }\r\n\r\n    function isNativeEvent(events) {\r\n        if (langx.isString(events)) {\r\n            return !!NativeEvents[events];\r\n        } else if (langx.isArray(events)) {\r\n            for (var i=0; i<events.length; i++) {\r\n                if (NativeEvents[events]) {\r\n                    return false;\r\n                }\r\n            }\r\n            return events.length > 0;\r\n        }\r\n    }\r\n\r\n\r\n    function eventer() {\r\n        return eventer;\r\n    }\r\n\r\n    langx.mixin(eventer, {\r\n        NativeEvents : NativeEvents,\r\n        \r\n        clear,\r\n        \r\n        create: createEvent,\r\n\r\n        focused,\r\n\r\n        keys: keyCodeLookup,\r\n\r\n        isNativeEvent,\r\n\r\n        off: off,\r\n\r\n        on: on,\r\n\r\n        one: one,\r\n\r\n        proxy: createProxy,\r\n\r\n        ready: ready,\r\n\r\n        resized,\r\n        \r\n        shortcuts: shortcuts,\r\n\r\n        special: specialEvents,\r\n\r\n        stop: stop,\r\n\r\n        trigger: trigger\r\n\r\n    });\r\n\r\n    each(NativeEvents,function(name){\r\n        eventer[name] = function(elm,selector,data,callback) {\r\n            if (arguments.length>1) {\r\n                return this.on(elm,name,selector,data,callback);\r\n            } else {\r\n                if (name == \"focus\") {\r\n                    if (elm.focus) {\r\n                        elm.focus();\r\n                    }\r\n                } else if (name == \"blur\") {\r\n                    if (elm.blur) {\r\n                        elm.blur();\r\n                    }\r\n                } else if (name == \"click\") {\r\n                    if (elm.click) {\r\n                        elm.click();\r\n                    }\r\n                } else {\r\n                    this.trigger(elm,name);\r\n                }\r\n\r\n                return this;\r\n            }\r\n        };\r\n    });\r\n\r\n    return skylark.attach(\"domx.eventer\",eventer);\r\n});\ndefine('skylark-domx-eventer/main',[\r\n    \"skylark-langx/langx\",\r\n    \"./eventer\",\r\n    \"skylark-domx-velm\",\r\n    \"skylark-domx-query\"        \r\n],function(langx,eventer,velm,$){\r\n\r\n    var delegateMethodNames = [\r\n        \"off\",\r\n        \"on\",\r\n        \"one\",\r\n        \"trigger\"\r\n    ];\r\n\r\n    langx.each(eventer.NativeEvents,function(name){\r\n        delegateMethodNames.push(name);\r\n    });\r\n\r\n    // from ./eventer\r\n    velm.delegate(delegateMethodNames, eventer);\r\n\r\n    langx.each(delegateMethodNames,function(i,name){\r\n        $.fn[name] = $.wraps.wrapper_every_act(eventer[name],eventer);\r\n    });\r\n\r\n\r\n    /*\r\n    $.fn.on = $.wraps.wrapper_every_act(eventer.on, eventer);\r\n\r\n    $.fn.off = $.wraps.wrapper_every_act(eventer.off, eventer);\r\n\r\n    $.fn.trigger = $.wraps.wrapper_every_act(eventer.trigger, eventer);\r\n\r\n    ('focusin focusout focus blur load resize scroll unload click dblclick ' +\r\n        'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' +\r\n        'change select keydown keypress keyup error transitionEnd').split(' ').forEach(function(event) {\r\n        $.fn[event] = $.wraps.wrapper_every_act(eventer[event],eventer);\r\n    });\r\n\r\n    $.fn.one = function(event, selector, data, callback) {\r\n        if (!langx.isString(selector) && !langx.isFunction(callback)) {\r\n            callback = data;\r\n            data = selector;\r\n            selector = null;\r\n        }\r\n\r\n        if (langx.isFunction(data)) {\r\n            callback = data;\r\n            data = null;\r\n        }\r\n\r\n        return this.on(event, selector, data, callback, 1)\r\n    }; \r\n    */\r\n\r\n    $.ready = eventer.ready;\r\n\r\n    return eventer;\r\n});\ndefine('skylark-domx-eventer', ['skylark-domx-eventer/main'], function (main) { return main; });\n\ndefine('skylark-domx-forms/forms',[\r\n\t\"skylark-langx/skylark\"\r\n],function(skylark){\r\n\treturn skylark.attach(\"domx.forms\",{});\r\n});\ndefine('skylark-domx-forms/deserialize',[\r\n  \"skylark-langx/langx\",\r\n  \"skylark-domx-query\",\r\n  \"./forms\"\r\n],function(langx,$,forms){\r\n  /**\r\n   * Updates a key/valueArray with the given property and value. Values will always be stored as arrays.\r\n   *\r\n   * @param prop The property to add the value to.\r\n   * @param value The value to add.\r\n   * @param obj The object to update.\r\n   * @returns {object} Updated object.\r\n   */\r\n  function updateKeyValueArray( prop, value, obj ) {\r\n    var current = obj[ prop ];\r\n\r\n    if ( current === undefined ) {\r\n      obj[ prop ] = [ value ];\r\n    } else {\r\n      current.push( value );\r\n    }\r\n\r\n    return obj;\r\n  }\r\n\r\n  /**\r\n   * Get all of the fields contained within the given elements by name.\r\n   *\r\n   * @param formElm The form element.\r\n   * @param filter Custom filter to apply to the list of fields.\r\n   * @returns {object} All of the fields contained within the given elements, keyed by name.\r\n   */\r\n  function getFieldsByName(formElm, filter ) {\r\n    var elementsByName = {};\r\n\r\n    // Extract fields from elements\r\n    var fields = $(formElm)\r\n      .map(function convertFormToElements() {\r\n        return this.elements ? langx.makeArray( this.elements ) : this;\r\n      })\r\n      .filter( filter || \":input:not(:disabled)\" )\r\n      .get();\r\n\r\n    langx.each( fields, function( index, field ) {\r\n      updateKeyValueArray( field.name, field, elementsByName );\r\n    });\r\n\r\n    return elementsByName;\r\n  }\r\n\r\n  /**\r\n   * Figure out the type of an element. Input type will be used first, falling back to nodeName.\r\n   *\r\n   * @param element DOM element to check type of.\r\n   * @returns {string} The element's type.\r\n   */\r\n  function getElementType( element ) {\r\n    return ( element.type || element.nodeName ).toLowerCase();\r\n  }\r\n\r\n  /**\r\n   * Normalize the provided data into a key/valueArray store.\r\n   *\r\n   * @param data The data provided by the user to the plugin.\r\n   * @returns {object} The data normalized into a key/valueArray store.\r\n   */\r\n  function normalizeData( data ) {\r\n    var normalized = {};\r\n    var rPlus = /\\+/g;\r\n\r\n    // Convert data from .serializeObject() notation\r\n    if ( langx.isPlainObject( data ) ) {\r\n      langx.extend( normalized, data );\r\n\r\n      // Convert non-array values into an array\r\n      langx.each( normalized, function( name, value ) {\r\n        if ( !langx.isArray( value ) ) {\r\n          normalized[ name ] = [ value ];\r\n        }\r\n      });\r\n\r\n    // Convert data from .serializeArray() notation\r\n    } else if ( langx.isArray( data ) ) {\r\n      langx.each( data, function( index, field ) {\r\n        updateKeyValueArray( field.name, field.value, normalized );\r\n      });\r\n\r\n    // Convert data from .serialize() notation\r\n    } else if ( typeof data === \"string\" ) {\r\n      langx.each( data.split( \"&\" ), function( index, field ) {\r\n        var current = field.split( \"=\" );\r\n        var name = decodeURIComponent( current[ 0 ].replace( rPlus, \"%20\" ) );\r\n        var value = decodeURIComponent( current[ 1 ].replace( rPlus, \"%20\" ) );\r\n        updateKeyValueArray( name, value, normalized );\r\n      });\r\n    }\r\n\r\n    return normalized;\r\n  }\r\n\r\n  /**\r\n   * Map of property name -> element types.\r\n   *\r\n   * @type {object}\r\n   */\r\n  var updateTypes = {\r\n    checked: [\r\n      \"radio\",\r\n      \"checkbox\"\r\n    ],\r\n    selected: [\r\n      \"option\",\r\n      \"select-one\",\r\n      \"select-multiple\"\r\n    ],\r\n    value: [\r\n      \"button\",\r\n      \"color\",\r\n      \"date\",\r\n      \"datetime\",\r\n      \"datetime-local\",\r\n      \"email\",\r\n      \"hidden\",\r\n      \"month\",\r\n      \"number\",\r\n      \"password\",\r\n      \"range\",\r\n      \"reset\",\r\n      \"search\",\r\n      \"submit\",\r\n      \"tel\",\r\n      \"text\",\r\n      \"textarea\",\r\n      \"time\",\r\n      \"url\",\r\n      \"week\"\r\n    ]\r\n  };\r\n\r\n  /**\r\n   * Get the property to update on an element being updated.\r\n   *\r\n   * @param element The DOM element to get the property for.\r\n   * @returns The name of the property to update if element is supported, otherwise `undefined`.\r\n   */\r\n  function getPropertyToUpdate( element ) {\r\n    var type = getElementType( element );\r\n    var elementProperty = undefined;\r\n\r\n    langx.each( updateTypes, function( property, types ) {\r\n      if ( langx.inArray( type, types ) > -1 ) {\r\n        elementProperty = property;\r\n        return false;\r\n      }\r\n    });\r\n\r\n    return elementProperty;\r\n  }\r\n\r\n  /**\r\n   * Update the element based on the provided data.\r\n   *\r\n   * @param element The DOM element to update.\r\n   * @param elementIndex The index of this element in the list of elements with the same name.\r\n   * @param value The serialized element value.\r\n   * @param valueIndex The index of the value in the list of values for elements with the same name.\r\n   * @param callback A function to call if the value of an element was updated.\r\n   */\r\n  function update( element, elementIndex, value, valueIndex, callback ) {\r\n    var property = getPropertyToUpdate( element );\r\n\r\n    // Handle value inputs\r\n    // If there are multiple value inputs with the same name, they will be populated by matching indexes.\r\n    if ( property == \"value\" && elementIndex == valueIndex ) {\r\n      element.value = value;\r\n      callback.call( element, value );\r\n\r\n    // Handle select menus, checkboxes and radio buttons\r\n    } else if ( property == \"checked\" || property == \"selected\" ) {\r\n      var fields = [];\r\n\r\n      // Extract option fields from select menus\r\n      if ( element.options ) {\r\n        langx.each( element.options, function( index, option ) {\r\n          fields.push( option );\r\n        });\r\n\r\n      } else {\r\n        fields.push( element );\r\n      }\r\n\r\n      // #37: Remove selection from multiple select menus before deserialization\r\n      if ( element.multiple && valueIndex == 0 ) {\r\n        element.selectedIndex = -1;\r\n      }\r\n\r\n      langx.each( fields, function( index, field ) {\r\n        if ( field.value == value ) {\r\n          field[ property ] = true;\r\n          callback.call( field, value );\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Default plugin options.\r\n   *\r\n   * @type {object}\r\n   */\r\n  var defaultOptions = {\r\n    change: langx.noop,\r\n    complete: langx.noop\r\n  };\r\n\r\n  /**\r\n   * The $.deserialize function.\r\n   *\r\n   * @param data The data to deserialize.\r\n   * @param options Additional options.\r\n   * @returns {jQuery} The jQuery object that was provided to the plugin.\r\n   */\r\n  function deserialize(formElm,data, options ) {\r\n\r\n    // Backwards compatible with old arguments: data, callback\r\n    if ( langx.isFunction( options ) ) {\r\n      options = { complete: options };\r\n    }\r\n\r\n    options = langx.extend( defaultOptions, options || {} );\r\n    data = normalizeData( data );\r\n\r\n    var elementsByName = getFieldsByName( formElm, options.filter );\r\n\r\n    langx.each( data, function( name, values ) {\r\n      langx.each( elementsByName[ name ], function( elementIndex, element ) {\r\n        langx.each( values, function( valueIndex, value ) {\r\n          update( element, elementIndex, value, valueIndex, options.change );\r\n        });\r\n      });\r\n    });\r\n\r\n    options.complete.call( formElm );\r\n\r\n    return this;\r\n  };\r\n\r\n  return forms.deserialize = deserialize;\r\n});\ndefine('skylark-domx-forms/serialize-array',[\r\n  \"skylark-langx/langx\",\r\n  \"skylark-domx-data\",\r\n  \"./forms\"\r\n],function(langx,datax,forms){\r\n    function serializeArray(formElm) {\r\n        var name, type, result = [],\r\n            add = function(value) {\r\n                if (value.forEach) return value.forEach(add)\r\n                result.push({ name: name, value: value })\r\n            },\r\n            elements;\r\n        if (formElm.elements) {\r\n            elements = formElm.elements;\r\n        } else if (langx.isArrayLike(formElm)) {\r\n            elements = formElm;\r\n        } else {\r\n            elements = [formElm];\r\n        }\r\n        langx.each(elements, function(_, field) {\r\n            type = field.type, name = field.name\r\n            if (name && field.nodeName.toLowerCase() != 'fieldset' &&\r\n                !field.disabled && type != 'submit' && type != 'reset' && type != 'button' && type != 'file' &&\r\n                ((type != 'radio' && type != 'checkbox') || field.checked))\r\n                add(datax.val(field))\r\n        })\r\n        return result\r\n    };\r\n\r\n    return forms.serializeArray = serializeArray;\r\n});\r\n\ndefine('skylark-domx-forms/serialize-object',[\r\n  \"skylark-langx/langx\",\r\n  \"./forms\",\r\n  \"./serialize-array\"\r\n],function(langx,forms,serializeArray){\r\n\r\n  function serializeObject(formElm){\r\n    var obj = {};\r\n    \r\n    langx.each(serializeArray(formElm), function(i,o){\r\n      var n = o.name,\r\n        v = o.value;\r\n        \r\n        obj[n] = obj[n] === undefined ? v\r\n          : langx.isArray( obj[n] ) ? obj[n].concat( v )\r\n          : [ obj[n], v ];\r\n    });\r\n    \r\n    return obj;\r\n  }\r\n\r\n  return forms.serializeObject = serializeObject;\r\n});  \ndefine('skylark-domx-forms/serialize',[\r\n  \"skylark-langx/langx\",\r\n  \"./forms\",\r\n  \"./serialize-array\"\r\n],function(langx,forms,serializeArray){\r\n    function serialize(formElm) {\r\n        var result = []\r\n        serializeArray(formElm).forEach(function(elm) {\r\n            result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value))\r\n        })\r\n        return result.join('&')\r\n    }\r\n\r\n    return forms.serialize = serialize;\r\n});\ndefine('skylark-domx-forms/main',[\r\n    \"skylark-langx\",\r\n    \"skylark-domx-data\",\r\n\t\"./forms\",\r\n    \"skylark-domx-velm\",\r\n    \"skylark-domx-query\",\r\n    \"./deserialize\",\r\n    \"./serialize-array\",\r\n    \"./serialize-object\",\r\n    \"./serialize\"\r\n],function(langx,datax,forms,velm,$){\r\n\r\n    // from ./data\r\n    velm.delegate([\r\n        \"deserialize\",\r\n        \"serializeArray\",\r\n        \"serializeObject\",\r\n        \"serialize\"\r\n    ], forms);\r\n\r\n    $.fn.deserialize = $.wraps.wrapper_every_act(forms.deserialize, forms, forms.deserialize);\r\n    $.fn.serializeArray = $.wraps.wrapper_map(forms.serializeArray, forms, forms.serializeArray,true);\r\n    $.fn.serializeObject = $.wraps.wrapper_map(forms.serializeObject, forms, forms.serializeObject,true);\r\n    $.fn.serialize = $.wraps.wrapper_value(forms.serialize, forms, forms.serialize);\r\n\r\n\r\n/*\r\n    var r20 = /%20/g,\r\n        rbracket = /\\[\\]$/,\r\n        rCRLF = /\\r?\\n/g,\r\n        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\r\n        rsubmittable = /^(?:input|select|textarea|keygen)/i;\r\n    var rcheckableType = ( /^(?:checkbox|radio)$/i );\r\n\r\n    $.fn.serializeArray = function() {\r\n        return this.map( function() {\r\n\r\n            // Can add propHook for \"elements\" to filter or add form elements\r\n            var elements = datax.prop(this, \"elements\" );\r\n            return elements ? langx.makeArray( elements ) : this;\r\n        } )\r\n        .filter( function() {\r\n            var type = this.type;\r\n\r\n            // Use .is( \":disabled\" ) so that fieldset[disabled] works\r\n            return this.name && !$(this).is( \":disabled\" ) &&\r\n                rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\r\n                ( this.checked || !rcheckableType.test( type ) );\r\n        } )\r\n        .map( function( i, elem ) {\r\n            var val = $(this).val();\r\n\r\n            return val == null ?\r\n                null :\r\n                langx.isArray( val ) ?\r\n                    langx.map( val, function( val ) {\r\n                        return { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\r\n                    } ) :\r\n                    { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\r\n        } ).get();\r\n    };\r\n*/\r\n\r\n\treturn forms;\r\n});\ndefine('skylark-domx-forms', ['skylark-domx-forms/main'], function (main) { return main; });\n\ndefine('skylark-domx-transits/transits',[\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\"\r\n], function(skylark,langx) {\r\n\r\n    function transits() {\r\n        return transits;\r\n    }\r\n\r\n    langx.mixin(transits, {\r\n        off: false,\r\n        speeds: {\r\n            normal: 400,\r\n            fast: 200,\r\n            slow: 600\r\n        }\r\n    });\r\n\r\n    return skylark.attach(\"domx.transits\", transits);\r\n});\ndefine('skylark-domx-geom/geom',[\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-styler\"\r\n], function(skylark, langx, noder, styler) {\r\n  'use strict'\r\n\r\n    var rootNodeRE = /^(?:body|html)$/i,\r\n        px = langx.toPixel,\r\n        offsetParent = noder.offsetParent,\r\n        cachedScrollbarWidth;\r\n\r\n    function scrollbarWidth() {\r\n        if (cachedScrollbarWidth !== undefined) {\r\n            return cachedScrollbarWidth;\r\n        }\r\n        var w1, w2,\r\n            div = noder.createFragment(\"<div style=\" +\r\n                \"'display:block;position:absolute;width:200px;height:200px;overflow:hidden;'>\" +\r\n                \"<div style='height:300px;width:auto;'></div></div>\")[0],\r\n            innerDiv = div.childNodes[0];\r\n\r\n        noder.append(document.body, div);\r\n\r\n        w1 = innerDiv.offsetWidth;\r\n        styler.css(div, \"overflow\", \"scroll\");\r\n\r\n        w2 = innerDiv.offsetWidth;\r\n\r\n        if (w1 === w2) {\r\n            w2 = div[0].clientWidth;\r\n        }\r\n\r\n        noder.remove(div);\r\n\r\n        return (cachedScrollbarWidth = w1 - w2);\r\n    }\r\n\r\n\r\n    function hasScrollbar() {\r\n        return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight);\r\n    }\r\n\r\n    /*\r\n     * Get the widths of each border of the specified element.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function borderExtents(elm) {\r\n        if (noder.isWindow(elm)) {\r\n            return {\r\n                left : 0,\r\n                top : 0,\r\n                right : 0,\r\n                bottom : 0\r\n            }\r\n        }        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.borderLeftWidth, elm),\r\n            top: px(s.borderTopWidth, elm),\r\n            right: px(s.borderRightWidth, elm),\r\n            bottom: px(s.borderBottomWidth, elm)\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n     * Get the document size.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function boundingHeight(elm, value) {\r\n        if (value == undefined) {\r\n            return boundingSize(elm).height;\r\n        } else {\r\n            boundingSize(elm, {\r\n                height: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the viewport position of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function boundingPosition(elm, coords) {\r\n        if (coords === undefined) {\r\n            return rootNodeRE.test(elm.nodeName) ? { top: 0, left: 0 } : elm.getBoundingClientRect();\r\n        } else {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            relativePosition(elm, {\r\n                top: coords.top - parentOffset.top - mex.top - pbex.top + (scrollTop(parent) || 0),\r\n                left: coords.left - parentOffset.left - mex.left - pbex.left + (scrollLeft(parent) || 0)\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the viewport rect of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function boundingRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            if (elm == window || elm == document.documentElement || elm == document.body){\r\n                return {\r\n                    top : 0,\r\n                    left : 0,\r\n                    bottom : window.innerHeight,\r\n                    right : window.innerWidth,\r\n                    height : window.innerHeight,\r\n                    width : window.innerWidth\r\n                };\r\n            } else if (elm.getBoundingClientRect) {\r\n                return elm.getBoundingClientRect();\r\n            }\r\n        } else {\r\n            boundingPosition(elm, coords);\r\n            boundingSize(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n     * Get or set the size of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject}dimension\r\n     */\r\n    function boundingSize(elm, dimension) {\r\n        if (dimension == undefined) {\r\n            if (langx.isWindow(elm)) {\r\n                return {\r\n                    width: elm.innerWidth,\r\n                    height: elm.innerHeight\r\n                }\r\n\r\n            } else if (langx.isDocument(elm)) {\r\n                return getDocumentSize(document);\r\n            } else {\r\n                return {\r\n                    width: elm.offsetWidth,\r\n                    height: elm.offsetHeight\r\n                }\r\n            }\r\n        } else {\r\n            var isBorderBox = (styler.css(elm, \"box-sizing\") === \"border-box\"),\r\n                props = {\r\n                    width: dimension.width,\r\n                    height: dimension.height\r\n                };\r\n            if (!isBorderBox) {\r\n                var pex = paddingExtents(elm),\r\n                    bex = borderExtents(elm);\r\n\r\n                if (props.width !== undefined && props.width !== \"\" && props.width !== null) {\r\n                    props.width = props.width - pex.left - pex.right - bex.left - bex.right;\r\n                }\r\n\r\n                if (props.height !== undefined && props.height !== \"\" && props.height !== null) {\r\n                    props.height = props.height - pex.top - pex.bottom - bex.top - bex.bottom;\r\n                }\r\n            }\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n     * Get or set the size of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function boundingWidth(elm, value) {\r\n        if (value == undefined) {\r\n            return boundingSize(elm).width;\r\n        } else {\r\n            boundingSize(elm, {\r\n                width: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the height of the specified element client box.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function clientHeight(elm, value) {\r\n        if (value == undefined) {\r\n            return clientSize(elm).height;\r\n        } else {\r\n            return clientSize(elm, {\r\n                height: value\r\n            });\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the size of the specified element client box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} dimension\r\n     */\r\n    function clientSize(elm, dimension) {\r\n        if (dimension == undefined) {\r\n            return {\r\n                width: elm.clientWidth,\r\n                height: elm.clientHeight\r\n            }\r\n        } else {\r\n            var isBorderBox = (styler.css(elm, \"box-sizing\") === \"border-box\"),\r\n                props = {\r\n                    width: dimension.width,\r\n                    height: dimension.height\r\n                };\r\n            if (!isBorderBox) {\r\n                var pex = paddingExtents(elm);\r\n\r\n                if (props.width !== undefined) {\r\n                    props.width = props.width - pex.left - pex.right;\r\n                }\r\n\r\n                if (props.height !== undefined) {\r\n                    props.height = props.height - pex.top - pex.bottom;\r\n                }\r\n            } else {\r\n                var bex = borderExtents(elm);\r\n\r\n                if (props.width !== undefined) {\r\n                    props.width = props.width + bex.left + bex.right;\r\n                }\r\n\r\n                if (props.height !== undefined) {\r\n                    props.height = props.height + bex.top + bex.bottom;\r\n                }\r\n\r\n            }\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n        return {\r\n            width: elm.clientWidth,\r\n            height: elm.clientHeight\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get or set the width of the specified element client box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} dimension\r\n     */\r\n    function clientWidth(elm, value) {\r\n        if (value == undefined) {\r\n            return clientSize(elm).width;\r\n        } else {\r\n            clientSize(elm, {\r\n                width: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n     * Get or set the height of the specified element content box.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function contentHeight(elm, value) {\r\n        if (value == undefined) {\r\n            return contentSize(elm).height;\r\n        } else {\r\n            contentSize(elm, {\r\n                height: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get the rect of the specified element content box.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function contentRect(elm) {\r\n        var cs = clientSize(elm),\r\n            pex = paddingExtents(elm);\r\n\r\n\r\n        //// On Opera, offsetLeft includes the parent's border\r\n        //if(has(\"opera\")){\r\n        //    pe.l += be.l;\r\n        //    pe.t += be.t;\r\n        //}\r\n        return {\r\n            left: pex.left,\r\n            top: pex.top,\r\n            width: cs.width - pex.left - pex.right,\r\n            height: cs.height - pex.top - pex.bottom\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get or set the size of the specified element content box.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function contentSize(elm,dimension) {\r\n        var cs = clientSize(elm),\r\n            pex = paddingExtents(elm);\r\n\r\n        if (dimension === undefined) {\r\n            return {\r\n                width: cs.width - pex.left - pex.right,\r\n                height: cs.height - pex.top - pex.bottom\r\n            };\r\n        } else {\r\n            var isBorderBox = (styler.css(elm, \"box-sizing\") === \"border-box\"),\r\n                props = {\r\n                    width: dimension.width,\r\n                    height: dimension.height\r\n                };\r\n            if (isBorderBox) {\r\n                var bex = borderExtents(elm);\r\n\r\n                if (props.width !== undefined && props.width !== \"\" && props.width !== null) {\r\n                    props.width = props.width + pex.left + pex.right + bex.left + bex.right;\r\n                }\r\n\r\n                if (props.height !== undefined && props.height !== \"\" && props.height !== null) {\r\n                    props.height = props.height + pex.top + pex.bottom + bex.top + bex.bottom;\r\n                }\r\n            }\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n\r\n    }\r\n\r\n\r\n    /*\r\n     * Get or set the width of the specified element content box.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function contentWidth(elm, value) {\r\n        if (value == undefined) {\r\n            return contentSize(elm).width;\r\n        } else {\r\n            contentSize(elm, {\r\n                width: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n     * Get the document size.\r\n     * @param {HTMLDocument} doc\r\n     */\r\n    function getDocumentSize(doc) {\r\n        var documentElement = doc.documentElement,\r\n            body = doc.body,\r\n            max = Math.max,\r\n            scrollWidth = max(documentElement.scrollWidth, body.scrollWidth),\r\n            clientWidth = max(documentElement.clientWidth, body.clientWidth),\r\n            offsetWidth = max(documentElement.offsetWidth, body.offsetWidth),\r\n            scrollHeight = max(documentElement.scrollHeight, body.scrollHeight),\r\n            clientHeight = max(documentElement.clientHeight, body.clientHeight),\r\n            offsetHeight = max(documentElement.offsetHeight, body.offsetHeight);\r\n\r\n        return {\r\n            width: scrollWidth < offsetWidth ? clientWidth : scrollWidth,\r\n            height: scrollHeight < offsetHeight ? clientHeight : scrollHeight\r\n        };\r\n    }\r\n\r\n\r\n    function inview(elm, cushion) {\r\n        function calibrate(coords, cushion) {\r\n            var o = {};\r\n            cushion = +cushion || 0;\r\n            o.width = (o.right = coords.right + cushion) - (o.left = coords.left - cushion);\r\n            o.height = (o.bottom = coords.bottom + cushion) - (o.top = coords.top - cushion);\r\n            return o;\r\n        }\r\n\r\n        var r = calibrate(boundingRect(elm), cushion),\r\n            vsize = viewportSize();\r\n\r\n        return !!r && r.bottom >= 0 && r.right >= 0 && r.top <= vsize.height && r.left <= vsize.width;\r\n    }\r\n\r\n\r\n    /*\r\n     * Get the widths of each margin of the specified element.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function marginExtents(elm) {\r\n        if (noder.isWindow(elm)) {\r\n            return {\r\n                left : 0,\r\n                top : 0,\r\n                right : 0,\r\n                bottom : 0\r\n            }\r\n        }\r\n        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.marginLeft),\r\n            top: px(s.marginTop),\r\n            right: px(s.marginRight),\r\n            bottom: px(s.marginBottom),\r\n        }\r\n    }\r\n\r\n\r\n    function marginRect(elm) {\r\n        var obj = relativeRect(elm),\r\n            me = marginExtents(elm);\r\n\r\n        return {\r\n            left: obj.left,\r\n            top: obj.top,\r\n            width: obj.width + me.left + me.right,\r\n            height: obj.height + me.top + me.bottom\r\n        };\r\n    }\r\n\r\n\r\n    function marginSize(elm) {\r\n        var obj = boundingSize(elm),\r\n            me = marginExtents(elm);\r\n\r\n        return {\r\n            width: obj.width + me.left + me.right,\r\n            height: obj.height + me.top + me.bottom\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get the widths of each padding of the specified element.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function paddingExtents(elm) {\r\n        if (noder.isWindow(elm)) {\r\n            return {\r\n                left : 0,\r\n                top : 0,\r\n                right : 0,\r\n                bottom : 0\r\n            }\r\n        }\r\n        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.paddingLeft),\r\n            top: px(s.paddingTop),\r\n            right: px(s.paddingRight),\r\n            bottom: px(s.paddingBottom),\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the document position of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    //coordinate to the document\r\n    function pagePosition(elm, coords) {\r\n        if (coords === undefined) {\r\n            var obj = elm.getBoundingClientRect(),\r\n                w = elm.ownerDocument.defaultView;\r\n            return {\r\n                left: obj.left + w.pageXOffset,\r\n                top: obj.top + w.pageYOffset\r\n            }\r\n        } else {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                parentOffset = pagePosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            relativePosition(elm, {\r\n                top: coords.top - parentOffset.top - mex.top - pbex.top,\r\n                left: coords.left - parentOffset.left - mex.left - pbex.left\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the document rect of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function pageRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            var obj = elm.getBoundingClientRect(),\r\n                w = elm.ownerDocument.defaultView;\r\n            return {\r\n                left: obj.left + w.pageXOffset,\r\n                top: obj.top + w.pageYOffset,\r\n                width: Math.round(obj.width),\r\n                height: Math.round(obj.height)\r\n            }\r\n        } else {\r\n            pagePosition(elm, coords);\r\n            boundingSize(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the position of the specified element border box , relative to parent element.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    // coordinate relative to it's parent\r\n    function relativePosition(elm, coords) {\r\n        if (coords == undefined) {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                offset = boundingPosition(elm),\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            // Subtract parent offsets and element margins\r\n            return {\r\n                top: offset.top - parentOffset.top - pbex.top - mex.top,\r\n                left: offset.left - parentOffset.left - pbex.left - mex.left\r\n            }\r\n        } else {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm);\r\n\r\n            var props = {\r\n                top: coords.top,\r\n                left: coords.left\r\n            };\r\n\r\n            /*\r\n            if (langx.isDefined(props.top)) {\r\n                props.top = props.top + (scrollTop(parent) || 0);\r\n            }\r\n\r\n            if (langx.isDefined(props.left)) {\r\n                props.left = props.left + (scrollLeft(parent) || 0);\r\n            } \r\n            */ \r\n\r\n            if (styler.css(elm, \"position\") == \"static\") {\r\n                props['position'] = \"relative\";\r\n            }\r\n\r\n\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the rect of the specified element border box , relatived to parent element.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function relativeRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                offset = boundingRect(elm),\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            // Subtract parent offsets and element margins\r\n            return {\r\n                top: offset.top - parentOffset.top - pbex.top, // - mex.top,\r\n                left: offset.left - parentOffset.left - pbex.left, // - mex.left,\r\n                width: offset.width,\r\n                height: offset.height\r\n            }\r\n        } else {\r\n            relativePosition(elm, coords);\r\n            boundingSize(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n    /*\r\n     * Scroll the specified element into view.\r\n     * @param {HTMLElement} elm\r\n     * @param {} align\r\n     */\r\n    function scrollIntoView(elm, align) {\r\n        function getOffset(elm, rootElm) {\r\n            var x, y, parent = elm;\r\n\r\n            x = y = 0;\r\n            while (parent && parent != rootElm && parent.nodeType) {\r\n                x += parent.offsetLeft || 0;\r\n                y += parent.offsetTop || 0;\r\n                parent = parent.offsetParent;\r\n            }\r\n\r\n            return { x: x, y: y };\r\n        }\r\n\r\n        var parentElm = elm.parentNode;\r\n        var x, y, width, height, parentWidth, parentHeight;\r\n        var pos = getOffset(elm, parentElm);\r\n\r\n        x = pos.x;\r\n        y = pos.y;\r\n        width = elm.offsetWidth;\r\n        height = elm.offsetHeight;\r\n        parentWidth = parentElm.clientWidth;\r\n        parentHeight = parentElm.clientHeight;\r\n\r\n        if (align == \"end\") {\r\n            x -= parentWidth - width;\r\n            y -= parentHeight - height;\r\n        } else if (align == \"center\") {\r\n            x -= (parentWidth / 2) - (width / 2);\r\n            y -= (parentHeight / 2) - (height / 2);\r\n        }\r\n\r\n        parentElm.scrollLeft = x;\r\n        parentElm.scrollTop = y;\r\n\r\n        return this;\r\n    }\r\n    /*\r\n     * Get or set the current horizontal position of the scroll bar for the specified element.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function scrollLeft(elm, value) {\r\n        if (elm.nodeType === 9) {\r\n            elm = elm.defaultView;\r\n        } else if (elm == document.body) {\r\n            elm = document.scrollingElement  || document.documentElement;\r\n        }\r\n        var hasScrollLeft = \"scrollLeft\" in elm;\r\n        if (value === undefined) {\r\n            return hasScrollLeft ? elm.scrollLeft : elm.pageXOffset\r\n        } else {\r\n            if (hasScrollLeft) {\r\n                elm.scrollLeft = value;\r\n            } else {\r\n                elm.scrollTo(value, elm.scrollY);\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n    /*\r\n     * Get or the current vertical position of the scroll bar for the specified element.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function scrollTop(elm, value) {\r\n        if (elm.nodeType === 9) {\r\n            elm = elm.defaultView;\r\n        } else if (elm == document.body) {\r\n            elm = document.scrollingElement  || document.documentElement;\r\n        }\r\n\r\n        var hasScrollTop = \"scrollTop\" in elm;\r\n\r\n        if (value === undefined) {\r\n            return hasScrollTop ? elm.scrollTop : elm.pageYOffset\r\n        } else {\r\n            if (hasScrollTop) {\r\n                elm.scrollTop = value;\r\n            } else {\r\n                elm.scrollTo(elm.scrollX, value);\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n\r\n    function scrollBy(elm, x, y) {\r\n        elm.scrollLeft += x;\r\n        elm.scrollTop += y;\r\n    }\r\n\r\n\r\n\r\n    function viewportSize(win) {\r\n        win = win || window;\r\n\r\n        return boundingRect(win);\r\n    }\r\n\r\n\r\n\r\n    function testAxis(elm) {\r\n       \r\n        var top = elm.offsetTop;\r\n        var left = elm.offsetLeft;\r\n        var width = elm.offsetWidth;\r\n        var height = elm.offsetHeight;\r\n\r\n        while(elm.offsetParent) {\r\n            elm = elm.offsetParent;\r\n            top += elm.offsetTop;\r\n            left += elm.offsetLeft;\r\n        }\r\n\r\n        var result = {x: 0, y: 0};\r\n\r\n        //Over the top of the window\r\n        if(top < window.pageYOffset) {\r\n            result.y = top - window.pageYOffset;\r\n        }\r\n        //Bellow the window\r\n        else if((top + height) > (window.pageYOffset + window.innerHeight))\r\n        {\r\n            result.y = (top + height) - (window.pageYOffset + window.innerHeight);\r\n        }\r\n\r\n        //Left to the window\r\n        if(left < window.pageXOffset) {\r\n            result.x = left - window.pageXOffset;\r\n        }\r\n        //Right to the window\r\n        else if((left + width) > (window.pageXOffset + window.innerWidth))\r\n        {\r\n            result.x = (left + width) - (window.pageXOffset + window.innerWidth);\r\n        }\r\n\r\n        return result;\r\n    };    \r\n\r\n    function geom() {\r\n        return geom;\r\n    }\r\n\r\n    langx.mixin(geom, {\r\n        borderExtents: borderExtents,\r\n\r\n        boundingHeight,\r\n        boundingPosition,\r\n        boundingRect,\r\n        boundingSize,\r\n        boundingWidth,\r\n\r\n        clientHeight,\r\n        clientSize,\r\n        clientWidth,\r\n\r\n        contentHeight,\r\n        contentRect,\r\n        contentSize,\r\n        contentWidth,\r\n\r\n        getDocumentSize: getDocumentSize,\r\n\r\n        hasScrollbar,\r\n\r\n        height: contentHeight,\r\n\r\n        inview,\r\n\r\n        marginExtents: marginExtents,\r\n\r\n        marginRect,\r\n        marginSize,\r\n\r\n        offsetParent: offsetParent,\r\n\r\n        paddingExtents: paddingExtents,\r\n\r\n        //coordinate to the document\r\n        pagePosition: pagePosition,\r\n\r\n        pageRect: pageRect,\r\n\r\n        // coordinate relative to it's parent\r\n        relativePosition: relativePosition,\r\n\r\n        relativeRect: relativeRect,\r\n\r\n        scrollbarWidth: scrollbarWidth,\r\n\r\n        scrollIntoView: scrollIntoView,\r\n\r\n        scrollLeft: scrollLeft,\r\n\r\n        scrollTop: scrollTop,\r\n\r\n        scrollBy,\r\n            \r\n        size: contentSize,\r\n\r\n        testAxis,\r\n\r\n        viewportSize,\r\n\r\n        width: contentWidth\r\n    });\r\n\r\n\r\n\r\n    return skylark.attach(\"domx.geom\", geom);\r\n});\ndefine('skylark-domx-geom/posit',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-styler\",\r\n    \"./geom\"\r\n],function(langx,noder,styler,geom){\r\n  'use strict'\r\n\r\n    var max = Math.max,\r\n        abs = Math.abs,\r\n        rhorizontal = /left|center|right/,\r\n        rvertical = /top|center|bottom/,\r\n        roffset = /[\\+\\-]\\d+(\\.[\\d]+)?%?/,\r\n        rposition = /^\\w+/,\r\n        rpercent = /%$/;\r\n\r\n    function getOffsets( offsets, width, height ) {\r\n        return [\r\n            parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),\r\n            parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )\r\n        ];\r\n    }\r\n\r\n    function parseCss( element, property ) {\r\n        return parseInt( styler.css( element, property ), 10 ) || 0;\r\n    }\r\n\r\n    function getDimensions( raw ) {\r\n        if ( raw.nodeType === 9 ) {\r\n            return {\r\n                size: size(raw),\r\n                offset: { top: 0, left: 0 }\r\n            };\r\n        }\r\n        if ( noder.isWindow( raw ) ) {\r\n            return {\r\n                size: geom.size(raw),\r\n                offset: { \r\n                    top: geom.scrollTop(raw), \r\n                    left: geom.scrollLeft(raw) \r\n                }\r\n            };\r\n        }\r\n        if ( raw.preventDefault ) {\r\n            return {\r\n                size : {\r\n                    width: 0,\r\n                    height: 0\r\n                },\r\n                offset: { \r\n                    top: raw.pageY, \r\n                    left: raw.pageX \r\n                }\r\n            };\r\n        }\r\n        return {\r\n            size: geom.size(raw),\r\n            offset: geom.pagePosition(raw)\r\n        };\r\n    }\r\n\r\n    function getScrollInfo( within ) {\r\n        var overflowX = within.isWindow || within.isDocument ? \"\" :\r\n                styler.css(within.element,\"overflow-x\" ),\r\n            overflowY = within.isWindow || within.isDocument ? \"\" :\r\n                styler.css(within.element,\"overflow-y\" ),\r\n            hasOverflowX = overflowX === \"scroll\" ||\r\n                ( overflowX === \"auto\" && within.width < geom.scrollWidth(within.element) ),\r\n            hasOverflowY = overflowY === \"scroll\" ||\r\n                ( overflowY === \"auto\" && within.height < geom.scrollHeight(within.element));\r\n        return {\r\n            width: hasOverflowY ? geom.scrollbarWidth() : 0,\r\n            height: hasOverflowX ? geom.scrollbarWidth() : 0\r\n        };\r\n    }\r\n\r\n    function getWithinInfo( element ) {\r\n        var withinElement = element || window,\r\n            isWindow = noder.isWindow( withinElement),\r\n            isDocument = !!withinElement && withinElement.nodeType === 9,\r\n            hasOffset = !isWindow && !isDocument,\r\n            msize = geom.marginSize(withinElement);\r\n        return {\r\n            element: withinElement,\r\n            isWindow: isWindow,\r\n            isDocument: isDocument,\r\n            offset: hasOffset ? geom.pagePosition(element) : { left: 0, top: 0 },\r\n            scrollLeft: geom.scrollLeft(withinElement),\r\n            scrollTop: geom.scrollTop(withinElement),\r\n            width: msize.width,\r\n            height: msize.height\r\n        };\r\n    }\r\n\r\n    function posit(elm,options ) {\r\n        // Make a copy, we don't want to modify arguments\r\n        options = langx.extend( {}, options );\r\n\r\n        var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,\r\n            target = options.of,\r\n            within = getWithinInfo( options.within ),\r\n            scrollInfo = getScrollInfo( within ),\r\n            collision = ( options.collision || \"flip\" ).split( \" \" ),\r\n            offsets = {};\r\n\r\n        dimensions = getDimensions( target );\r\n        if ( target.preventDefault ) {\r\n\r\n            // Force left top to allow flipping\r\n            options.at = \"left top\";\r\n        }\r\n        targetWidth = dimensions.size.width;\r\n        targetHeight = dimensions.size.height;\r\n        targetOffset = dimensions.offset;\r\n\r\n        // Clone to reuse original targetOffset later\r\n        basePosition = langx.extend( {}, targetOffset );\r\n\r\n        // Force my and at to have valid horizontal and vertical positions\r\n        // if a value is missing or invalid, it will be converted to center\r\n        langx.each( [ \"my\", \"at\" ], function() {\r\n            var pos = ( options[ this ] || \"\" ).split( \" \" ),\r\n                horizontalOffset,\r\n                verticalOffset;\r\n\r\n            if ( pos.length === 1 ) {\r\n                pos = rhorizontal.test( pos[ 0 ] ) ?\r\n                    pos.concat( [ \"center\" ] ) :\r\n                    rvertical.test( pos[ 0 ] ) ?\r\n                        [ \"center\" ].concat( pos ) :\r\n                        [ \"center\", \"center\" ];\r\n            }\r\n            pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : \"center\";\r\n            pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : \"center\";\r\n\r\n            // Calculate offsets\r\n            horizontalOffset = roffset.exec( pos[ 0 ] );\r\n            verticalOffset = roffset.exec( pos[ 1 ] );\r\n            offsets[ this ] = [\r\n                horizontalOffset ? horizontalOffset[ 0 ] : 0,\r\n                verticalOffset ? verticalOffset[ 0 ] : 0\r\n            ];\r\n\r\n            // Reduce to just the positions without the offsets\r\n            options[ this ] = [\r\n                rposition.exec( pos[ 0 ] )[ 0 ],\r\n                rposition.exec( pos[ 1 ] )[ 0 ]\r\n            ];\r\n        } );\r\n\r\n        // Normalize collision option\r\n        if ( collision.length === 1 ) {\r\n            collision[ 1 ] = collision[ 0 ];\r\n        }\r\n\r\n        if ( options.at[ 0 ] === \"right\" ) {\r\n            basePosition.left += targetWidth;\r\n        } else if ( options.at[ 0 ] === \"center\" ) {\r\n            basePosition.left += targetWidth / 2;\r\n        }\r\n\r\n        if ( options.at[ 1 ] === \"bottom\" ) {\r\n            basePosition.top += targetHeight;\r\n        } else if ( options.at[ 1 ] === \"center\" ) {\r\n            basePosition.top += targetHeight / 2;\r\n        }\r\n\r\n        atOffset = getOffsets( offsets.at, targetWidth, targetHeight );\r\n        basePosition.left += atOffset[ 0 ];\r\n        basePosition.top += atOffset[ 1 ];\r\n\r\n        return ( function(elem) {\r\n            var collisionPosition, using,\r\n                msize = geom.marginSize(elem),\r\n                elemWidth = msize.width,\r\n                elemHeight = msize.height,\r\n                marginLeft = parseCss( elem, \"marginLeft\" ),\r\n                marginTop = parseCss( elem, \"marginTop\" ),\r\n                collisionWidth = elemWidth + marginLeft + parseCss( elem, \"marginRight\" ) +\r\n                    scrollInfo.width,\r\n                collisionHeight = elemHeight + marginTop + parseCss( elem, \"marginBottom\" ) +\r\n                    scrollInfo.height,\r\n                position = langx.extend( {}, basePosition ),\r\n                myOffset = getOffsets( offsets.my, msize.width, msize.height);\r\n\r\n            if ( options.my[ 0 ] === \"right\" ) {\r\n                position.left -= elemWidth;\r\n            } else if ( options.my[ 0 ] === \"center\" ) {\r\n                position.left -= elemWidth / 2;\r\n            }\r\n\r\n            if ( options.my[ 1 ] === \"bottom\" ) {\r\n                position.top -= elemHeight;\r\n            } else if ( options.my[ 1 ] === \"center\" ) {\r\n                position.top -= elemHeight / 2;\r\n            }\r\n\r\n            position.left += myOffset[ 0 ];\r\n            position.top += myOffset[ 1 ];\r\n\r\n            collisionPosition = {\r\n                marginLeft: marginLeft,\r\n                marginTop: marginTop\r\n            };\r\n\r\n            langx.each( [ \"left\", \"top\" ], function( i, dir ) {\r\n                if ( positions[ collision[ i ] ] ) {\r\n                    positions[ collision[ i ] ][ dir ]( position, {\r\n                        targetWidth: targetWidth,\r\n                        targetHeight: targetHeight,\r\n                        elemWidth: elemWidth,\r\n                        elemHeight: elemHeight,\r\n                        collisionPosition: collisionPosition,\r\n                        collisionWidth: collisionWidth,\r\n                        collisionHeight: collisionHeight,\r\n                        offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],\r\n                        my: options.my,\r\n                        at: options.at,\r\n                        within: within,\r\n                        elem: elem\r\n                    } );\r\n                }\r\n            } );\r\n\r\n            if ( options.using ) {\r\n\r\n                // Adds feedback as second argument to using callback, if present\r\n                using = function( props ) {\r\n                    var left = targetOffset.left - position.left,\r\n                        right = left + targetWidth - elemWidth,\r\n                        top = targetOffset.top - position.top,\r\n                        bottom = top + targetHeight - elemHeight,\r\n                        feedback = {\r\n                            target: {\r\n                                element: target,\r\n                                left: targetOffset.left,\r\n                                top: targetOffset.top,\r\n                                width: targetWidth,\r\n                                height: targetHeight\r\n                            },\r\n                            element: {\r\n                                element: elem,\r\n                                left: position.left,\r\n                                top: position.top,\r\n                                width: elemWidth,\r\n                                height: elemHeight\r\n                            },\r\n                            horizontal: right < 0 ? \"left\" : left > 0 ? \"right\" : \"center\",\r\n                            vertical: bottom < 0 ? \"top\" : top > 0 ? \"bottom\" : \"middle\"\r\n                        };\r\n                    if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {\r\n                        feedback.horizontal = \"center\";\r\n                    }\r\n                    if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {\r\n                        feedback.vertical = \"middle\";\r\n                    }\r\n                    if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {\r\n                        feedback.important = \"horizontal\";\r\n                    } else {\r\n                        feedback.important = \"vertical\";\r\n                    }\r\n                    options.using.call( this, props, feedback );\r\n                };\r\n            }\r\n\r\n            geom.pagePosition(elem, langx.extend( position, { using: using } ));\r\n        })(elm);\r\n    }\r\n\r\n    var positions = {\r\n        fit: {\r\n            left: function( position, data ) {\r\n                var within = data.within,\r\n                    withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\r\n                    outerWidth = within.width,\r\n                    collisionPosLeft = position.left - data.collisionPosition.marginLeft,\r\n                    overLeft = withinOffset - collisionPosLeft,\r\n                    overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\r\n                    newOverRight;\r\n\r\n                // Element is wider than within\r\n                if ( data.collisionWidth > outerWidth ) {\r\n\r\n                    // Element is initially over the left side of within\r\n                    if ( overLeft > 0 && overRight <= 0 ) {\r\n                        newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -\r\n                            withinOffset;\r\n                        position.left += overLeft - newOverRight;\r\n\r\n                    // Element is initially over right side of within\r\n                    } else if ( overRight > 0 && overLeft <= 0 ) {\r\n                        position.left = withinOffset;\r\n\r\n                    // Element is initially over both left and right sides of within\r\n                    } else {\r\n                        if ( overLeft > overRight ) {\r\n                            position.left = withinOffset + outerWidth - data.collisionWidth;\r\n                        } else {\r\n                            position.left = withinOffset;\r\n                        }\r\n                    }\r\n\r\n                // Too far left -> align with left edge\r\n                } else if ( overLeft > 0 ) {\r\n                    position.left += overLeft;\r\n\r\n                // Too far right -> align with right edge\r\n                } else if ( overRight > 0 ) {\r\n                    position.left -= overRight;\r\n\r\n                // Adjust based on position and margin\r\n                } else {\r\n                    position.left = max( position.left - collisionPosLeft, position.left );\r\n                }\r\n            },\r\n            top: function( position, data ) {\r\n                var within = data.within,\r\n                    withinOffset = within.isWindow ? within.scrollTop : within.offset.top,\r\n                    outerHeight = data.within.height,\r\n                    collisionPosTop = position.top - data.collisionPosition.marginTop,\r\n                    overTop = withinOffset - collisionPosTop,\r\n                    overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\r\n                    newOverBottom;\r\n\r\n                // Element is taller than within\r\n                if ( data.collisionHeight > outerHeight ) {\r\n\r\n                    // Element is initially over the top of within\r\n                    if ( overTop > 0 && overBottom <= 0 ) {\r\n                        newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -\r\n                            withinOffset;\r\n                        position.top += overTop - newOverBottom;\r\n\r\n                    // Element is initially over bottom of within\r\n                    } else if ( overBottom > 0 && overTop <= 0 ) {\r\n                        position.top = withinOffset;\r\n\r\n                    // Element is initially over both top and bottom of within\r\n                    } else {\r\n                        if ( overTop > overBottom ) {\r\n                            position.top = withinOffset + outerHeight - data.collisionHeight;\r\n                        } else {\r\n                            position.top = withinOffset;\r\n                        }\r\n                    }\r\n\r\n                // Too far up -> align with top\r\n                } else if ( overTop > 0 ) {\r\n                    position.top += overTop;\r\n\r\n                // Too far down -> align with bottom edge\r\n                } else if ( overBottom > 0 ) {\r\n                    position.top -= overBottom;\r\n\r\n                // Adjust based on position and margin\r\n                } else {\r\n                    position.top = max( position.top - collisionPosTop, position.top );\r\n                }\r\n            }\r\n        },\r\n        flip: {\r\n            left: function( position, data ) {\r\n                var within = data.within,\r\n                    withinOffset = within.offset.left + within.scrollLeft,\r\n                    outerWidth = within.width,\r\n                    offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\r\n                    collisionPosLeft = position.left - data.collisionPosition.marginLeft,\r\n                    overLeft = collisionPosLeft - offsetLeft,\r\n                    overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\r\n                    myOffset = data.my[ 0 ] === \"left\" ?\r\n                        -data.elemWidth :\r\n                        data.my[ 0 ] === \"right\" ?\r\n                            data.elemWidth :\r\n                            0,\r\n                    atOffset = data.at[ 0 ] === \"left\" ?\r\n                        data.targetWidth :\r\n                        data.at[ 0 ] === \"right\" ?\r\n                            -data.targetWidth :\r\n                            0,\r\n                    offset = -2 * data.offset[ 0 ],\r\n                    newOverRight,\r\n                    newOverLeft;\r\n\r\n                if ( overLeft < 0 ) {\r\n                    newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -\r\n                        outerWidth - withinOffset;\r\n                    if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {\r\n                        position.left += myOffset + atOffset + offset;\r\n                    }\r\n                } else if ( overRight > 0 ) {\r\n                    newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +\r\n                        atOffset + offset - offsetLeft;\r\n                    if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {\r\n                        position.left += myOffset + atOffset + offset;\r\n                    }\r\n                }\r\n            },\r\n            top: function( position, data ) {\r\n                var within = data.within,\r\n                    withinOffset = within.offset.top + within.scrollTop,\r\n                    outerHeight = within.height,\r\n                    offsetTop = within.isWindow ? within.scrollTop : within.offset.top,\r\n                    collisionPosTop = position.top - data.collisionPosition.marginTop,\r\n                    overTop = collisionPosTop - offsetTop,\r\n                    overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\r\n                    top = data.my[ 1 ] === \"top\",\r\n                    myOffset = top ?\r\n                        -data.elemHeight :\r\n                        data.my[ 1 ] === \"bottom\" ?\r\n                            data.elemHeight :\r\n                            0,\r\n                    atOffset = data.at[ 1 ] === \"top\" ?\r\n                        data.targetHeight :\r\n                        data.at[ 1 ] === \"bottom\" ?\r\n                            -data.targetHeight :\r\n                            0,\r\n                    offset = -2 * data.offset[ 1 ],\r\n                    newOverTop,\r\n                    newOverBottom;\r\n                if ( overTop < 0 ) {\r\n                    newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -\r\n                        outerHeight - withinOffset;\r\n                    if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {\r\n                        position.top += myOffset + atOffset + offset;\r\n                    }\r\n                } else if ( overBottom > 0 ) {\r\n                    newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +\r\n                        offset - offsetTop;\r\n                    if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {\r\n                        position.top += myOffset + atOffset + offset;\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        flipfit: {\r\n            left: function() {\r\n                positions.flip.left.apply( this, arguments );\r\n                positions.fit.left.apply( this, arguments );\r\n            },\r\n            top: function() {\r\n                positions.flip.top.apply( this, arguments );\r\n                positions.fit.top.apply( this, arguments );\r\n            }\r\n        }\r\n    };\r\n\r\n    return geom.posit = posit;\r\n});\ndefine('skylark-domx-geom/scroll-to-top',[\r\n    \"skylark-langx\",\r\n    \"skylark-domx-styler\",\r\n    \"./geom\"\r\n],function(langx,styler,geom) {\r\n    /*   \r\n     * Set the vertical position of the scroll bar for an element.\r\n     * @param {Object} elm  \r\n     * @param {Number or String} pos\r\n     * @param {Number or String} speed\r\n     * @param {Function} callback\r\n     */\r\n    function scrollToTop(elm, pos, speed, callback) {\r\n        var scrollFrom = parseInt(elm.scrollTop),\r\n            i = 0,\r\n            runEvery = 5, // run every 5ms\r\n            freq = speed * 1000 / runEvery,\r\n            scrollTo = parseInt(pos);\r\n\r\n        var interval = setInterval(function() {\r\n            i++;\r\n\r\n            if (i <= freq) elm.scrollTop = (scrollTo - scrollFrom) / freq * i + scrollFrom;\r\n\r\n            if (i >= freq + 1) {\r\n                clearInterval(interval);\r\n                if (callback) langx.debounce(callback, 1000)();\r\n            }\r\n        }, runEvery);\r\n\r\n        return this;\r\n    }\r\n\r\n    return geom.scrollToTop = scrollToTop;\r\n});\ndefine('skylark-domx-geom/main',[\r\n    \"skylark-langx/langx\",\r\n    \"./geom\",\r\n    \"skylark-domx-velm\",\r\n    \"skylark-domx-query\",\r\n    \"./posit\",\r\n    \"./scroll-to-top\"\r\n],function(langx,geom,velm,$){\r\n   // from ./geom\r\n    velm.delegate([\r\n        \"borderExtents\",\r\n        \"boundingPosition\",\r\n        \"boundingHeight\",\r\n        \"boundingRect\",\r\n        \"boundingSize\",\r\n        \"boundingWidth\",\r\n\r\n        \"clientHeight\",\r\n        \"clientSize\",\r\n        \"clientWidth\",\r\n\r\n        \"contentHeight\",\r\n        \"contentRect\",\r\n        \"contentSize\",\r\n        \"contentWidth\",\r\n\r\n///        \"height\",\r\n        \"marginExtents\",\r\n        \"marginRect\",\r\n        \"marginSize\",\r\n        \"offsetParent\",\r\n        \"paddingExtents\",\r\n        \"pagePosition\",\r\n        \"pageRect\",\r\n        \"relativePosition\",\r\n        \"relativeRect\",\r\n        \"scrollIntoView\",\r\n        \"scrollLeft\",\r\n        \"scrollTop\",\r\n///        \"pageSize\",\r\n///        \"width\"\r\n    ], geom,{\r\n///        \"pageSize\" : \"size\"\r\n    });\r\n\r\n    $.fn.offset = $.wraps.wrapper_value(geom.pagePosition, geom, geom.pagePosition);\r\n\r\n    $.fn.scrollTop = $.wraps.wrapper_value(geom.scrollTop, geom);\r\n\r\n    $.fn.scrollLeft = $.wraps.wrapper_value(geom.scrollLeft, geom);\r\n\r\n    $.fn.position =  function(options) {\r\n        if (!this.length) {\r\n            return this;\r\n        }\r\n\r\n        if (options) {\r\n            if (options.of && options.of.length) {\r\n                options = langx.clone(options);\r\n                options.of = options.of[0];\r\n            }\r\n            return this.each( function() {\r\n                geom.posit(this,options);\r\n            });\r\n        } else {\r\n            var elem = this[0];\r\n\r\n            return geom.relativePosition(elem);\r\n\r\n        }             \r\n    };\r\n\r\n    $.fn.offsetParent = $.wraps.wrapper_map(geom.offsetParent, geom);\r\n\r\n\r\n    ///$.fn.pageSize = $.wraps.wrapper_value(geom.size, geom);\r\n    $.fn.boundingSize = $.wraps.wrapper_value(geom.boundingSize, geom);\r\n\r\n    $.fn.width = $.wraps.wrapper_value(geom.width, geom, geom.width);\r\n\r\n    $.fn.height = $.wraps.wrapper_value(geom.height, geom, geom.height);\r\n\r\n    $.fn.clientSize = $.wraps.wrapper_value(geom.clientSize, geom);\r\n    \r\n    ['width', 'height'].forEach(function(dimension) {\r\n        var offset, Dimension = dimension.replace(/./, function(m) {\r\n            return m[0].toUpperCase()\r\n        });\r\n\r\n        $.fn['outer' + Dimension] = function(margin, value) {\r\n            if (arguments.length) {\r\n                if (typeof margin !== 'boolean') {\r\n                    value = margin;\r\n                    margin = false;\r\n                }\r\n            } else {\r\n                margin = false;\r\n                value = undefined;\r\n            }\r\n\r\n            if (value === undefined) {\r\n                var el = this[0];\r\n                if (!el) {\r\n                    return undefined;\r\n                }\r\n                var cb = geom.boundingSize(el);\r\n                if (margin) {\r\n                    var me = geom.marginExtents(el);\r\n                    cb.width = cb.width + me.left + me.right;\r\n                    cb.height = cb.height + me.top + me.bottom;\r\n                }\r\n                return dimension === \"width\" ? cb.width : cb.height;\r\n            } else {\r\n                return this.each(function(idx, el) {\r\n                    var mb = {};\r\n                    var me = geom.marginExtents(el);\r\n                    if (dimension === \"width\") {\r\n                        mb.width = value;\r\n                        if (margin) {\r\n                            mb.width = mb.width - me.left - me.right\r\n                        }\r\n                    } else {\r\n                        mb.height = value;\r\n                        if (margin) {\r\n                            mb.height = mb.height - me.top - me.bottom;\r\n                        }\r\n                    }\r\n                    geom.boundingSize(el, mb);\r\n                })\r\n\r\n            }\r\n        };\r\n    })\r\n\r\n    $.fn.innerWidth = $.wraps.wrapper_value(geom.clientWidth, geom, geom.clientWidth);\r\n\r\n    $.fn.innerHeight = $.wraps.wrapper_value(geom.clientHeight, geom, geom.clientHeight);\r\n\r\n    return geom;\r\n});\ndefine('skylark-domx-geom', ['skylark-domx-geom/main'], function (main) { return main; });\n\ndefine('skylark-domx-transits/transit',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-browser\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-geom\",\r\n    \"skylark-domx-styler\",\r\n    \"skylark-domx-eventer\",\r\n    \"./transits\"\r\n], function(langx, browser, noder, geom, styler, eventer,transits) {\r\n\r\n    var transitionProperty,\r\n        transitionDuration,\r\n        transitionTiming,\r\n        transitionDelay,\r\n\r\n        transitionEnd = browser.normalizeCssEvent('TransitionEnd'),\r\n\r\n        supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i,\r\n        transform = browser.css3PropPrefix + \"transform\",\r\n        cssReset = {};\r\n\r\n    cssReset[transitionProperty = browser.normalizeCssProperty(\"transition-property\")] =\r\n        cssReset[transitionDuration = browser.normalizeCssProperty(\"transition-duration\")] =\r\n        cssReset[transitionDelay = browser.normalizeCssProperty(\"transition-delay\")] =\r\n        cssReset[transitionTiming = browser.normalizeCssProperty(\"transition-timing-function\")] = \"\";\r\n\r\n    /*   \r\n     * Perform a custom animation of a set of CSS properties.\r\n     * @param {Object} elm  \r\n     * @param {Number or String} properties\r\n     * @param {String} ease\r\n     * @param {Number or String} duration\r\n     * @param {Function} callback\r\n     * @param {Number or String} delay\r\n     */\r\n    function transit(elm, properties, duration, ease, callback, delay) {\r\n        var key,\r\n            cssValues = {},\r\n            cssProperties = [],\r\n            transforms = \"\",\r\n            that = this,\r\n            endEvent,\r\n            wrappedCallback,\r\n            fired = false,\r\n            hasScrollTop = false,\r\n            resetClipAuto = false;\r\n\r\n        if (langx.isPlainObject(duration)) {\r\n            ease = duration.easing;\r\n            callback = duration.complete;\r\n            delay = duration.delay;\r\n            duration = duration.duration;\r\n        }\r\n\r\n        if (langx.isString(duration)) {\r\n            duration = transits.speeds[duration];\r\n        }\r\n        if (duration === undefined) {\r\n            duration = transits.speeds.normal;\r\n        }\r\n        duration = duration / 1000;\r\n        if (transits.off) {\r\n            duration = 0;\r\n        }\r\n\r\n        if (langx.isFunction(ease)) {\r\n            callback = ease;\r\n            eace = \"swing\";\r\n        } else {\r\n            ease = ease || \"swing\";\r\n        }\r\n\r\n        if (delay) {\r\n            delay = delay / 1000;\r\n        } else {\r\n            delay = 0;\r\n        }\r\n\r\n        // CSS transitions\r\n        for (key in properties) {\r\n            var v = properties[key];\r\n            if (supportedTransforms.test(key)) {\r\n                transforms += key + \"(\" + v + \") \";\r\n            } else {\r\n                if (key === \"scrollTop\") {\r\n                    hasScrollTop = true;\r\n                }\r\n                if (key == \"clip\" && langx.isPlainObject(v)) {\r\n                    cssValues[key] = \"rect(\" + v.top+\"px,\"+ v.right +\"px,\"+ v.bottom +\"px,\"+ v.left+\"px)\";\r\n                    if (styler.css(elm,\"clip\") == \"auto\") {\r\n                        var size = geom.size(elm);\r\n                        styler.css(elm,\"clip\",\"rect(\"+\"0px,\"+ size.width +\"px,\"+ size.height +\"px,\"+\"0px)\");  \r\n                        resetClipAuto = true;\r\n                    }\r\n\r\n                } else {\r\n                    cssValues[key] = v;\r\n                }\r\n                cssProperties.push(langx.dasherize(key));\r\n            }\r\n        }\r\n        endEvent = transitionEnd;\r\n\r\n        if (transforms) {\r\n            cssValues[transform] = transforms;\r\n            cssProperties.push(transform);\r\n        }\r\n\r\n        if (duration > 0) {\r\n            cssValues[transitionProperty] = cssProperties.join(\", \");\r\n            cssValues[transitionDuration] = duration + \"s\";\r\n            cssValues[transitionDelay] = delay + \"s\";\r\n            cssValues[transitionTiming] = ease;\r\n        }\r\n\r\n        wrappedCallback = function(event) {\r\n            fired = true;\r\n            if (event) {\r\n                if (event.target !== event.currentTarget) {\r\n                    return // makes sure the event didn't bubble from \"below\"\r\n                }\r\n                eventer.off(event.target, endEvent, wrappedCallback)\r\n            } else {\r\n                eventer.off(elm, endEvent, wrappedCallback) // triggered by setTimeout\r\n            }\r\n            styler.css(elm, cssReset);\r\n            if (resetClipAuto) {\r\n //               styler.css(elm,\"clip\",\"auto\");\r\n            }\r\n            callback && callback.call(this);\r\n        };\r\n\r\n        if (duration > 0) {\r\n            eventer.on(elm, endEvent, wrappedCallback);\r\n            // transitionEnd is not always firing on older Android phones\r\n            // so make sure it gets fired\r\n            langx.debounce(function() {\r\n                if (fired) {\r\n                    return;\r\n                }\r\n                wrappedCallback.call(that);\r\n            }, ((duration + delay) * 1000) + 25)();\r\n        }\r\n\r\n        // trigger page reflow so new elements can transit\r\n        elm.clientLeft;\r\n\r\n        styler.css(elm, cssValues);\r\n\r\n        if (duration <= 0) {\r\n            langx.debounce(function() {\r\n                if (fired) {\r\n                    return;\r\n                }\r\n                wrappedCallback.call(that);\r\n            }, 0)();\r\n        }\r\n\r\n        if (hasScrollTop) {\r\n            geom.scrollToTop(elm, properties[\"scrollTop\"], duration, callback);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    return transits.transit = transit;\r\n\r\n});\ndefine('skylark-domx-transits/bounce',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-geom\",\r\n    \"skylark-domx-styler\",\r\n    \"./transits\",\r\n    \"./transit\"\r\n],function(langx,geom,styler,transits,transit) {\r\n\r\n    function bounce(elm, options, done ) {\r\n        var upAnim, downAnim, refValue,\r\n            // Defaults:\r\n            mode = options.mode,\r\n            hide = mode === \"hide\",\r\n            show = mode === \"show\",\r\n            direction = options.direction || \"up\",\r\n            start,\r\n            distance = options.distance,\r\n            times = options.times || 5,\r\n\r\n            // Number of internal animations\r\n            anims = times * 2 + ( show || hide ? 1 : 0 ),\r\n            speed = options.duration / anims,\r\n            easing = options.easing,\r\n\r\n            // Utility:\r\n            ref = ( direction === \"up\" || direction === \"down\" ) ? \"top\" : \"left\",\r\n            motion = ( direction === \"up\" || direction === \"left\" ),\r\n            i = 0;\r\n\r\n        //createPlaceholder(elm);\r\n\r\n        var Deferred = langx.Deferred;\r\n        var funcs = [];\r\n\r\n        refValue = styler.css(elm,ref );\r\n\r\n        // Default distance for the BIGGEST bounce is the outer Distance / 3\r\n        if ( !distance ) {\r\n            var msize = geom.size(elm);\r\n            distance = (ref === \"top\" ? msize.height : msize.width) / 3;\r\n        }\r\n\r\n        start = geom.relativePosition(elm)[ref];\r\n\r\n        if ( show ) {\r\n            downAnim = { opacity: 1 };\r\n            downAnim[ ref ] = refValue;\r\n\r\n            // If we are showing, force opacity 0 and set the initial position\r\n            // then do the \"first\" animation\r\n            styler.css(elm, \"opacity\", 0 );\r\n            styler.css(elm, ref, start + (motion ? -distance * 2 : distance * 2 ));\r\n\r\n            funcs.push(doAnimate(elm,downAnim, speed, easing));\r\n        }\r\n\r\n        // Start at the smallest distance if we are hiding\r\n        if ( hide ) {\r\n            distance = distance / Math.pow( 2, times - 1 );\r\n        }\r\n\r\n        downAnim = {};\r\n        downAnim[ ref ] = refValue;\r\n\r\n\r\n        function doAnimate(elm,properties, duration, easing) {\r\n            return function() {\r\n                var d = new Deferred();\r\n\r\n                transit(elm,properties, duration, easing ,function(){\r\n                    d.resolve();\r\n                });\r\n                return d.promise;\r\n\r\n            }\r\n        }\r\n\r\n        // Bounces up/down/left/right then back to 0 -- times * 2 animations happen here\r\n        for ( ; i < times; i++ ) {\r\n            upAnim = {};\r\n            upAnim[ ref ] = start + ( motion ? -distance : distance) ;\r\n\r\n            funcs.push(doAnimate(elm,upAnim, speed, easing));\r\n\r\n            funcs.push(doAnimate(elm,downAnim, speed, easing));\r\n\r\n            distance = hide ? distance * 2 : distance / 2;\r\n        }\r\n\r\n        // Last Bounce when Hiding\r\n        if ( hide ) {\r\n            upAnim = { opacity: 0 };\r\n            upAnim[ ref ] = start + ( motion ? -1 * distance : distance) ;\r\n\r\n            funcs.push(doAnimate(elm,upAnim, speed, easing ));\r\n        }\r\n\r\n        funcs.push(done);\r\n        funcs.reduce(function(prev, curr, index, array) {\r\n            return prev.then(curr);\r\n        }, Deferred.resolve());\r\n\r\n        return this;\r\n    } \r\n\r\n    return transits.bounce = bounce;\r\n});\ndefine('skylark-domx-transits/emulate-transition-end',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-browser\",\r\n    \"skylark-domx-eventer\",\r\n    \"./transits\"\r\n],function(langx,browser,eventer,transits) {\r\n    \r\n    function emulateTransitionEnd(elm,duration) {\r\n        var called = false;\r\n        eventer.one(elm,'transitionEnd', function () { \r\n            called = true;\r\n        })\r\n        var callback = function () { \r\n            if (!called) {\r\n                eventer.trigger(elm,browser.support.transition.end) \r\n            }\r\n        };\r\n        setTimeout(callback, duration);\r\n        \r\n        return this;\r\n    } \r\n\r\n\r\n\r\n    return transits.emulateTransitionEnd = emulateTransitionEnd;\r\n});\ndefine('skylark-domx-transits/show',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-styler\",\r\n    \"./transits\",\r\n    \"./transit\"\r\n],function(langx,styler,transits,transit) {\r\n    /*   \r\n     * Display an element.\r\n     * @param {Object} elm  \r\n     * @param {String} speed\r\n     * @param {Function} callback\r\n     */\r\n    function show(elm, speed, callback) {\r\n        styler.show(elm);\r\n        if (speed) {\r\n            if (!callback && langx.isFunction(speed)) {\r\n                callback = speed;\r\n                speed = \"normal\";\r\n            }\r\n            styler.css(elm, \"opacity\", 0)\r\n            transit(elm, { opacity: 1, scale: \"1,1\" }, speed, callback);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    return transits.show = show;\r\n});\ndefine('skylark-domx-transits/hide',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-styler\",\r\n    \"./transits\",\r\n    \"./transit\"\r\n],function(langx,styler,transits,transit) {\r\n    /*   \r\n     * Hide an element.\r\n     * @param {Object} elm  \r\n     * @param {String} speed\r\n     * @param {Function} callback\r\n     */\r\n    function hide(elm, speed, callback) {\r\n        if (speed) {\r\n            if (!callback && langx.isFunction(speed)) {\r\n                callback = speed;\r\n                speed = \"normal\";\r\n            }\r\n            transit(elm, { opacity: 0, scale: \"0,0\" }, speed, function() {\r\n                styler.hide(elm);\r\n                if (callback) {\r\n                    callback.call(elm);\r\n                }\r\n            });\r\n        } else {\r\n            styler.hide(elm);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    return transits.hide = hide;\r\n});\ndefine('skylark-domx-transits/explode',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-styler\",\r\n    \"skylark-domx-geom\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-query\",\r\n    \"./transits\",\r\n    \"./transit\",\r\n    \"./show\",\r\n    \"./hide\"\r\n],function(langx,styler,geom,noder,$,transits,transit,show,hide) {\r\n\r\n    function explode( elm,options, done ) {\r\n\r\n\t\t// Show and then visibility:hidden the element before calculating offset\r\n\t\tstyler.show(elm);\r\n\t\tstyler.css(elm, \"visibility\", \"hidden\" );\r\n\r\n\t\tvar i, j, left, top, mx, my,\r\n\t\t\trows = options.pieces ? Math.round( Math.sqrt( options.pieces ) ) : 3,\r\n\t\t\tcells = rows,\r\n\t\t\tmode = options.mode,\r\n\t\t\tshow = mode === \"show\",\r\n\t\t\toffset = geom.pagePosition(elm),\r\n\r\n\t\t\t// Width and height of a piece\r\n\t\t\tsize = geom.marginSize(elm),\r\n\t\t\twidth = Math.ceil( size.width / cells ),\r\n\t\t\theight = Math.ceil( size.height / rows ),\r\n\t\t\tpieces = [];\r\n\r\n\t\t// Children transit complete:\r\n\t\tfunction childComplete() {\r\n\t\t\tpieces.push( this );\r\n\t\t\tif ( pieces.length === rows * cells ) {\r\n\t\t\t\tanimComplete();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Clone the element for each row and cell.\r\n\t\tfor ( var i = 0; i < rows; i++ ) { // ===>\r\n\t\t\ttop = offset.top + i * height;\r\n\t\t\tmy = i - ( rows - 1 ) / 2;\r\n\r\n\t\t\tfor ( j = 0; j < cells; j++ ) { // |||\r\n\t\t\t\tleft = offset.left + j * width;\r\n\t\t\t\tmx = j - ( cells - 1 ) / 2;\r\n\r\n\t\t\t\t// Create a clone of the now hidden main element that will be absolute positioned\r\n\t\t\t\t// within a wrapper div off the -left and -top equal to size of our pieces\r\n\t\t\t\t$(elm)\r\n\t\t\t\t\t.clone()\r\n\t\t\t\t\t.appendTo( \"body\" )\r\n\t\t\t\t\t.wrap( \"<div></div>\" )\r\n\t\t\t\t\t.css( {\r\n\t\t\t\t\t\tposition: \"absolute\",\r\n\t\t\t\t\t\tvisibility: \"visible\",\r\n\t\t\t\t\t\tleft: -j * width,\r\n\t\t\t\t\t\ttop: -i * height\r\n\t\t\t\t\t} )\r\n\r\n\t\t\t\t\t// Select the wrapper - make it overflow: hidden and absolute positioned based on\r\n\t\t\t\t\t// where the original was located +left and +top equal to the size of pieces\r\n\t\t\t\t\t.parent()\r\n\t\t\t\t\t\t.addClass( options.explodeClass || \"ui-effects-explode\" )\r\n\t\t\t\t\t\t.css( {\r\n\t\t\t\t\t\t\tposition: \"absolute\",\r\n\t\t\t\t\t\t\toverflow: \"hidden\",\r\n\t\t\t\t\t\t\twidth: width,\r\n\t\t\t\t\t\t\theight: height,\r\n\t\t\t\t\t\t\tleft: left + ( show ? mx * width : 0 ),\r\n\t\t\t\t\t\t\ttop: top + ( show ? my * height : 0 ),\r\n\t\t\t\t\t\t\topacity: show ? 0 : 1\r\n\t\t\t\t\t\t} )\r\n\t\t\t\t\t\t.transit( {\r\n\t\t\t\t\t\t\tleft: left + ( show ? 0 : mx * width ),\r\n\t\t\t\t\t\t\ttop: top + ( show ? 0 : my * height ),\r\n\t\t\t\t\t\t\topacity: show ? 1 : 0\r\n\t\t\t\t\t\t}, options.duration || 500, options.easing, childComplete );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction animComplete() {\r\n\t\t\tstyler.css(elm, {\r\n\t\t\t\tvisibility: \"visible\"\r\n\t\t\t} );\r\n\t\t\t$( pieces ).remove();\r\n\t\t\tdone();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\r\n\treturn transits.explode = explode;\r\n});\r\n\ndefine('skylark-domx-transits/fade',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-styler\",\r\n    \"./transits\",\r\n    \"./transit\"\r\n],function(langx,styler,transits,transit) {\r\n    /*   \r\n     * Adjust the opacity of an element.\r\n     * @param {Object} elm  \r\n     * @param {Number or String} speed\r\n     * @param {Number or String} opacity\r\n     * @param {String} easing\r\n     * @param {Function} callback\r\n     */\r\n    function fade(elm, opacity,options, callback) {\r\n        if (langx.isFunction(options)) {\r\n            callback = options;\r\n            options = {};\r\n        }\r\n        options = options || {};\r\n        \r\n        transit(elm, { opacity: opacity }, options.duration, options.easing, callback);\r\n        return this;\r\n    }\r\n\r\n\r\n    return transits.fade = fade;\r\n});\ndefine('skylark-domx-transits/fade-in',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-styler\",\r\n    \"./transits\",\r\n    \"./fade\"\r\n],function(langx,styler,transits,fadeTo) {\r\n    /*   \r\n     * Display an element by fading them to opaque.\r\n     * @param {Object} elm  \r\n     * @param {Number or String} duration\r\n     * @param {String} easing\r\n     * @param {Function} callback\r\n     */\r\n    function fadeIn(elm, options, callback) {\r\n        var target = styler.css(elm, \"opacity\");\r\n        if (target > 0) {\r\n            styler.css(elm, \"opacity\", 0);\r\n        } else {\r\n            target = 1;\r\n        }\r\n        styler.show(elm);\r\n\r\n        fadeTo(elm,  target,options, callback);\r\n\r\n        return this;\r\n    }\r\n\r\n\r\n    return transits.fadeIn = fadeIn;\r\n});\ndefine('skylark-domx-transits/fade-out',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-styler\",\r\n    \"./transits\",\r\n    \"./fade\"\r\n],function(langx,styler,transits,fadeTo) {\r\n    /*   \r\n     * Hide an element by fading them to transparent.\r\n     * @param {Object} elm  \r\n     * @param {Number or String} duration\r\n     * @param {String} easing\r\n     * @param {Function} callback\r\n     */\r\n    function fadeOut(elm, options, callback) {\r\n\r\n        function complete() {\r\n            styler.css(elm,\"opacity\",opacity);\r\n            styler.hide(elm);\r\n            if (callback) {\r\n                callback.call(elm);\r\n            }\r\n        }\r\n\r\n        fadeTo(elm, 0,options,callback);\r\n\r\n        return this;\r\n    }\r\n\r\n    return transits.fadeOut = fadeOut;\r\n});\ndefine('skylark-domx-transits/fade-toggle',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-styler\",\r\n    \"./transits\",\r\n    \"./fade-in\",\r\n    \"./fade-out\"\r\n],function(langx,styler,transits,fadeIn,fadeOut) {\r\n\r\n    /*   \r\n     * Display or hide an element by animating its opacity.\r\n     * @param {Object} elm  \r\n     * @param {Number or String} speed\r\n     * @param {String} ceasing\r\n     * @param {Function} callback\r\n     */\r\n    function fadeToggle(elm, speed, easing, callback) {\r\n        if (styler.isInvisible(elm)) {\r\n            fadeIn(elm, speed, easing, callback);\r\n        } else {\r\n            fadeOut(elm, speed, easing, callback);\r\n        }\r\n        return this;\r\n    }\r\n\r\n\r\n    return transits.fadeToggle = fadeToggle;\r\n});\ndefine('skylark-domx-transits/pulsate',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-geom\",\r\n    \"skylark-domx-styler\",\r\n    \"./transits\",\r\n    \"./transit\"\r\n],function(langx,geom,styler,transits,transit) {\r\n\r\n\tfunction pulsate(elm, options, done ) {\r\n\t\tvar \r\n\t\t\tmode = options.mode,\r\n\t\t\tshow = mode === \"show\" || !mode,\r\n\t\t\thide = mode === \"hide\",\r\n\t\t\tshowhide = show || hide,\r\n\r\n\t\t\t// Showing or hiding leaves off the \"last\" animation\r\n\t\t\tanims = ( ( options.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),\r\n\t\t\tduration = options.duration / anims,\r\n\t\t\tanimateTo = 0,\r\n\t\t\ti = 1;\r\n\r\n\t\tif ( show || styler.isInvisible(elm) ) {\r\n\t\t\tstyler.css(elm, \"opacity\", 0 );\r\n\t\t\tstyler.show(elm);\r\n\t\t\tanimateTo = 1;\r\n\t\t}\r\n\r\n\t\t// Anims - 1 opacity \"toggles\"\r\n\r\n\t\tvar Deferred = langx.Deferred;\r\n\t\tvar funcs = [];\r\n\r\n\t\tfunction doAnimate(elm,properties, duration, ease) {\r\n\t\t\treturn function() {\r\n\t\t\t\tvar d = new Deferred();\r\n\r\n\t\t\t\ttransit( elm,properties, duration, ease ,function(){\r\n\t\t\t\t\td.resolve();\r\n\t\t\t\t});\r\n\t\t\t\treturn d.promise;\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tfor ( ; i < anims; i++ ) {\r\n\t\t\tfuncs.push(doAnimate(elm,{ opacity: animateTo }, duration, options.easing ));\r\n\t\t\tanimateTo = 1 - animateTo;\r\n\t\t}\r\n\r\n\t    funcs.push(doAnimate(elm,{ opacity: animateTo }, duration, options.easing ));\r\n\r\n\t\tfuncs.push(done);\r\n\t\tfuncs.reduce(function(prev, curr, index, array) {\r\n\t  \t\treturn prev.then(curr);\r\n\t\t}, Deferred.resolve());\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\treturn transits.pulsate = pulsate;\r\n\r\n});\r\n\ndefine('skylark-domx-transits/shake',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-geom\",\r\n    \"skylark-domx-styler\",\r\n    \"./transits\",\r\n    \"./transit\"\r\n],function(langx,geom,styler,transits,transit) {\r\n\tfunction shake(elm, options, done ) {\r\n\r\n\t\tvar i = 1,\r\n\t\t\tdirection = options.direction || \"left\",\r\n\t\t\tdistance = options.distance || 20,\r\n\t\t\ttimes = options.times || 3,\r\n\t\t\tanims = times * 2 + 1,\r\n\t\t\tspeed = Math.round( options.duration / anims ),\r\n\t\t\tref = ( direction === \"up\" || direction === \"down\" ) ? \"top\" : \"left\",\r\n\t\t\tpositiveMotion = ( direction === \"up\" || direction === \"left\" ),\r\n\t\t\tanimation0 = {},\r\n\t\t\tanimation = {},\r\n\t\t\tanimation1 = {},\r\n\t\t\tanimation2 = {};\r\n\r\n\t\tvar Deferred = langx.Deferred;\r\n\t\t\tstart = geom.relativePosition(elm)[ref],\r\n\t\t\tfuncs = [];\r\n\r\n\t\tfunction doAnimate(elm,properties, duration, ease) {\r\n\t\t\treturn function() {\r\n\t\t\t\tvar d = new Deferred();\r\n\r\n\t\t\t\ttransit(elm, properties, duration, ease ,function(){\r\n\t\t\t\t\td.resolve();\r\n\t\t\t\t});\r\n\t\t\t\treturn d.promise;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Animation\r\n\t\tanimation0[ ref ] = start;\r\n\t\tanimation[ ref ] = start + ( positiveMotion ? -1 : 1 ) * distance;\r\n\t\tanimation1[ ref ] = animation[ ref ] + ( positiveMotion ? 1 : -1 ) * distance * 2;\r\n\t\tanimation2[ ref ] = animation1[ ref ] + ( positiveMotion ? -1 : 1 ) * distance * 2;\r\n\r\n\t\t// Animate\r\n\t    funcs.push(doAnimate(elm,animation, speed, options.easing ));\r\n\r\n\t\t// Shakes\r\n\t\tfor ( ; i < times; i++ ) {\r\n\t\t    funcs.push(doAnimate(elm,animation1, speed, options.easing ));\r\n\t\t    funcs.push(doAnimate(elm,animation2, speed, options.easing ));\r\n\t\t}\r\n\r\n\t    funcs.push(doAnimate(elm,animation0, speed /2 , options.easing ));\r\n\r\n\t\tfuncs.push(done);\r\n\t\tfuncs.reduce(function(prev, curr, index, array) {\r\n\t  \t\treturn prev.then(curr);\r\n\t\t}, Deferred.resolve());\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\treturn transits.shake = shake;\r\n\r\n});\r\n\ndefine('skylark-domx-transits/slide',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-styler\",\r\n    \"./transits\",\r\n    \"./transit\"\r\n],function(langx,styler,transits,transit) {\r\n\r\n    function slide(elm,options,callback ) {\r\n    \tif (langx.isFunction(options)) {\r\n    \t\tcallback = options;\r\n    \t\toptions = {};\r\n    \t}\r\n    \toptions = options || {};\r\n\t\tvar direction = options.direction || \"down\",\r\n\t\t\tisHide = ( direction === \"up\" || direction === \"left\" ),\r\n\t\t\tisVert = ( direction === \"up\" || direction === \"down\" ),\r\n\t\t\tduration = options.duration || transits.speeds.normal;\r\n\r\n\r\n        // get the element position to restore it then\r\n        var position = styler.css(elm, 'position');\r\n\r\n        if (isHide) {\r\n            // active the function only if the element is visible\r\n        \tif (styler.isInvisible(elm)) {\r\n        \t\treturn this;\r\n        \t}\r\n        } else {\r\n\t        // show element if it is hidden\r\n\t        styler.show(elm);        \t\r\n\t        // place it so it displays as usually but hidden\r\n\t        styler.css(elm, {\r\n\t            position: 'absolute',\r\n\t            visibility: 'hidden'\r\n\t        });\r\n        }\r\n\r\n\r\n\r\n        if (isVert) { // up--down\r\n\t        // get naturally height, margin, padding\r\n\t        var marginTop = styler.css(elm, 'margin-top');\r\n\t        var marginBottom = styler.css(elm, 'margin-bottom');\r\n\t        var paddingTop = styler.css(elm, 'padding-top');\r\n\t        var paddingBottom = styler.css(elm, 'padding-bottom');\r\n\t        var height = styler.css(elm, 'height');\r\n\r\n\t        if (isHide) {  \t// slideup\r\n\t            // set initial css for animation\r\n\t            styler.css(elm, {\r\n\t                visibility: 'visible',\r\n\t                overflow: 'hidden',\r\n\t                height: height,\r\n\t                marginTop: marginTop,\r\n\t                marginBottom: marginBottom,\r\n\t                paddingTop: paddingTop,\r\n\t                paddingBottom: paddingBottom\r\n\t            });\r\n\r\n\t            // transit element height, margin and padding to zero\r\n\t            transit(elm, {\r\n\t                height: 0,\r\n\t                marginTop: 0,\r\n\t                marginBottom: 0,\r\n\t                paddingTop: 0,\r\n\t                paddingBottom: 0\r\n\t            }, {\r\n\t                // callback : restore the element position, height, margin and padding to original values\r\n\t                duration: duration,\r\n\t                queue: false,\r\n\t                complete: function() {\r\n\t                    styler.hide(elm);\r\n\t                    styler.css(elm, {\r\n\t                        visibility: 'visible',\r\n\t                        overflow: 'hidden',\r\n\t                        height: height,\r\n\t                        marginTop: marginTop,\r\n\t                        marginBottom: marginBottom,\r\n\t                        paddingTop: paddingTop,\r\n\t                        paddingBottom: paddingBottom\r\n\t                    });\r\n\t                    if (callback) {\r\n\t                        callback.apply(elm);\r\n\t                    }\r\n\t                }\r\n\t            });\r\n\t        } else {     \t// slidedown\r\n\t\t        // set initial css for animation\r\n\t\t        styler.css(elm, {\r\n\t\t            position: position,\r\n\t\t            visibility: 'visible',\r\n\t\t            overflow: 'hidden',\r\n\t\t            height: 0,\r\n\t\t            marginTop: 0,\r\n\t\t            marginBottom: 0,\r\n\t\t            paddingTop: 0,\r\n\t\t            paddingBottom: 0\r\n\t\t        });\r\n\r\n\t\t        // transit to gotten height, margin and padding\r\n\t\t        transit(elm, {\r\n\t\t            height: height,\r\n\t\t            marginTop: marginTop,\r\n\t\t            marginBottom: marginBottom,\r\n\t\t            paddingTop: paddingTop,\r\n\t\t            paddingBottom: paddingBottom\r\n\t\t        }, {\r\n\t\t            duration: duration,\r\n\t\t            complete: function() {\r\n\t\t                if (callback) {\r\n\t\t                    callback.apply(elm);\r\n\t\t                }\r\n\t\t            }\r\n\t\t        });\r\n\r\n\t        }\r\n\r\n        } else { // left--right\r\n\t        // get naturally height, margin, padding\r\n\t        var marginLeft = styler.css(elm, 'margin-left');\r\n\t        var marginRight = styler.css(elm, 'margin-right');\r\n\t        var paddingLeft = styler.css(elm, 'padding-left');\r\n\t        var paddingRight = styler.css(elm, 'padding-right');\r\n\t        var width = styler.css(elm, 'width');\r\n\r\n\t        if (isHide) {  \t// slideleft\r\n\t            // set initial css for animation\r\n\t            styler.css(elm, {\r\n\t                visibility: 'visible',\r\n\t                overflow: 'hidden',\r\n\t                width: width,\r\n\t                marginLeft: marginLeft,\r\n\t                marginRight: marginRight,\r\n\t                paddingLeft: paddingLeft,\r\n\t                paddingRight: paddingRight\r\n\t            });\r\n\r\n\t            // transit element height, margin and padding to zero\r\n\t            transit(elm, {\r\n\t                width: 0,\r\n\t                marginLeft: 0,\r\n\t                marginRight: 0,\r\n\t                paddingLeft: 0,\r\n\t                paddingRight: 0\r\n\t            }, {\r\n\t                // callback : restore the element position, height, margin and padding to original values\r\n\t                duration: duration,\r\n\t                queue: false,\r\n\t                complete: function() {\r\n\t                    styler.hide(elm);\r\n\t                    styler.css(elm, {\r\n\t                        visibility: 'visible',\r\n\t                        overflow: 'hidden',\r\n\t                        width: width,\r\n\t                        marginLeft: marginLeft,\r\n\t                        marginRight: marginRight,\r\n\t                        paddingLeft: paddingLeft,\r\n\t                        paddingRight: paddingRight\r\n\t                    });\r\n\t                    if (callback) {\r\n\t                        callback.apply(elm);\r\n\t                    }\r\n\t                }\r\n\t            });\r\n\t        } else {     \t// slideright\r\n\t\t        // set initial css for animation\r\n\t\t        styler.css(elm, {\r\n\t\t            position: position,\r\n\t\t            visibility: 'visible',\r\n\t\t            overflow: 'hidden',\r\n\t\t            width: 0,\r\n\t\t            marginLeft: 0,\r\n\t\t            marginRight: 0,\r\n\t\t            paddingLeft: 0,\r\n\t\t            paddingRight: 0\r\n\t\t        });\r\n\r\n\t\t        // transit to gotten width, margin and padding\r\n\t\t        transit(elm, {\r\n\t\t            width: width,\r\n\t\t            marginLeft: marginLeft,\r\n\t\t            marginRight: marginRight,\r\n\t\t            paddingLeft: paddingLeft,\r\n\t\t            paddingRight: paddingRight\r\n\t\t        }, {\r\n\t\t            duration: duration,\r\n\t\t            complete: function() {\r\n\t\t                if (callback) {\r\n\t\t                    callback.apply(elm);\r\n\t\t                }\r\n\t\t            }\r\n\t\t        });\r\n\r\n\t        }       \t\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    return transits.slide = slide;\r\n\r\n});\r\n\ndefine('skylark-domx-transits/slide-down',[\r\n    \"./transits\",\r\n    \"./slide\"\r\n],function(transits,slide) {\r\n    /*   \r\n     * Display an element with a sliding motion.\r\n     * @param {Object} elm  \r\n     * @param {Number or String} duration\r\n     * @param {Function} callback\r\n     */\r\n    function slideDown(elm, duration, callback) {\r\n        return slide(elm,{\r\n            direction : \"down\",\r\n            duration : duration\r\n        },callback);\r\n    }\r\n\r\n    return transits.slideDown = slideDown;\r\n});\ndefine('skylark-domx-transits/slide-up',[\r\n    \"./transits\",\r\n    \"./slide\"\r\n],function(transits,slide) {\r\n    /*   \r\n     * Hide an element with a sliding motion.\r\n     * @param {Object} elm  \r\n     * @param {Number or String} duration\r\n     * @param {Function} callback\r\n     */\r\n    function slideUp(elm, duration, callback) {\r\n        return slide(elm,{\r\n            direction : \"up\",\r\n            duration : duration\r\n        },callback);\r\n    }\r\n\r\n\r\n\r\n    return transits.slideUp = slideUp;\r\n});\ndefine('skylark-domx-transits/slide-toggle',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-geom\",\r\n    \"./transits\",\r\n    \"./slide-down\",\r\n    \"./slide-up\"\r\n],function(langx,geom,transits,slideDown,slideUp) {\r\n\r\n    /*   \r\n     * Display or hide an element with a sliding motion.\r\n     * @param {Object} elm  \r\n     * @param {Number or String} duration\r\n     * @param {Function} callback\r\n     */\r\n    function slideToggle(elm, duration, callback) {\r\n\r\n        // if the element is hidden, slideDown !\r\n        if (geom.height(elm) == 0) {\r\n            slideDown(elm, duration, callback);\r\n        }\r\n        // if the element is visible, slideUp !\r\n        else {\r\n            slideUp(elm, duration, callback);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    return transits.slideToggle = slideToggle;\r\n});\ndefine('skylark-domx-transits/throb',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-styler\",\r\n    \"skylark-domx-noder\",\r\n    \"./transits\",\r\n    \"./transit\"\r\n],function(langx,styler,noder,transits,transit) {\r\n\r\n    \r\n    /*   \r\n     * Replace an old node with the specified node.\r\n     * @param {HTMLElement} elm\r\n     * @param {Node} params\r\n     */\r\n    function throb(elm, params) {\r\n        params = params || {};\r\n\r\n        var self = this,\r\n            text = params.text,\r\n            style = params.style,\r\n            time = params.time,\r\n            callback = params.callback,\r\n            timer,\r\n\r\n            throbber = noder.createElement(\"div\", {\r\n                \"class\": params.className || \"throbber\"\r\n            }),\r\n            //_overlay = overlay(throbber, {\r\n            //    \"class\": 'overlay fade'\r\n            //}),\r\n            remove = function() {\r\n                if (timer) {\r\n                    clearTimeout(timer);\r\n                    timer = null;\r\n                }\r\n                if (throbber) {\r\n                    noder.remove(throbber);\r\n                    throbber = null;\r\n                }\r\n            },\r\n            update = function(params) {\r\n                if (params && params.text && throbber) {\r\n                    textNode.nodeValue = params.text;\r\n                }\r\n            };\r\n\r\n        if (params.style) {\r\n            styler.css(throbber,params.style);\r\n        }\r\n\r\n        //throb = noder.createElement(\"div\", {\r\n        //   \"class\": params.throb && params.throb.className || \"throb\"\r\n        //}),\r\n        //textNode = noder.createTextNode(text || \"\"),\r\n \r\n        var content = params.content ||  '<span class=\"throb\"></span>';\r\n\r\n        //throb.appendChild(textNode);\r\n        //throbber.appendChild(throb);\r\n\r\n        noder.html(throbber,content);\r\n        \r\n        elm.appendChild(throbber);\r\n\r\n        var end = function() {\r\n            remove();\r\n            if (callback) callback();\r\n        };\r\n        if (time) {\r\n            timer = setTimeout(end, time);\r\n        }\r\n\r\n        return {\r\n            throbber : throbber,\r\n            remove: remove,\r\n            update: update\r\n        };\r\n    }\r\n\r\n    return transits.throb = throb;\r\n});\ndefine('skylark-domx-transits/toggle',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-styler\",\r\n    \"./transits\",\r\n    \"./show\",\r\n    \"./hide\"\r\n],function(langx,styler,transits,show,hide) {\r\n    /*   \r\n     * Display or hide an element.\r\n     * @param {Object} elm  \r\n     * @param {Number or String} speed\r\n     * @param {Function} callbacke\r\n     */\r\n    function toggle(elm, speed, callback) {\r\n        if (styler.isInvisible(elm)) {\r\n            show(elm, speed, callback);\r\n        } else {\r\n            hide(elm, speed, callback);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    return transits.toggle = toggle;\r\n});\ndefine('skylark-domx-transits/main',[\r\n\t\"./transits\",\r\n\t\"skylark-domx-velm\",\r\n\t\"skylark-domx-query\",\r\n    \"./transit\",\r\n    \"./bounce\",\r\n    \"./emulate-transition-end\",\r\n    \"./explode\",\r\n    \"./fade-in\",\r\n    \"./fade-out\",\r\n    \"./fade\",\r\n    \"./fade-toggle\",\r\n    \"./hide\",\r\n    \"./pulsate\",\r\n    \"./shake\",\r\n    \"./show\",\r\n    \"./slide\",\r\n    \"./slide-down\",\r\n    \"./slide-toggle\",\r\n    \"./slide-up\",\r\n    \"./throb\",\r\n    \"./toggle\"\r\n],function(transits,velm,$){\r\n    // from ./transits\r\n    velm.delegate([\r\n        \"transit\",\r\n        \"emulateTransitionEnd\",\r\n        \"fadeIn\",\r\n        \"fadeOut\",\r\n        \"fade\",\r\n        \"fadeToggle\",\r\n        \"hide\",\r\n        \"scrollToTop\",\r\n        \"slideDown\",\r\n        \"slideToggle\",\r\n        \"slideUp\",\r\n        \"show\",\r\n        \"toggle\"\r\n    ], transits);\r\n\r\n    $.fn.hide =  $.wraps.wrapper_every_act(transits.hide, transits);\r\n\r\n    $.fn.transit = $.wraps.wrapper_every_act(transits.transit, transits);\r\n    $.fn.emulateTransitionEnd = $.wraps.wrapper_every_act(transits.emulateTransitionEnd, transits);\r\n\r\n    $.fn.show = $.wraps.wrapper_every_act(transits.show, transits);\r\n    $.fn.hide = $.wraps.wrapper_every_act(transits.hide, transits);\r\n    $.fn.toogle = $.wraps.wrapper_every_act(transits.toogle, transits);\r\n    $.fn.fadeTo = $.wraps.wrapper_every_act(transits.fadeTo, transits);\r\n    $.fn.fadeIn = $.wraps.wrapper_every_act(transits.fadeIn, transits);\r\n    $.fn.fadeOut = $.wraps.wrapper_every_act(transits.fadeOut, transits);\r\n    $.fn.fadeToggle = $.wraps.wrapper_every_act(transits.fadeToggle, transits);\r\n\r\n    $.fn.slideDown = $.wraps.wrapper_every_act(transits.slideDown, transits);\r\n    $.fn.slideToggle = $.wraps.wrapper_every_act(transits.slideToggle, transits);\r\n    $.fn.slideUp = $.wraps.wrapper_every_act(transits.slideUp, transits);\r\n\r\n\treturn transits;\r\n});\ndefine('skylark-domx-transits', ['skylark-domx-transits/main'], function (main) { return main; });\n\ndefine('skylark-domx-fx/fx',[\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\"\r\n], function(skylark,langx) {\r\n\r\n    function fx() {\r\n        return fx;\r\n    }\r\n\r\n    langx.mixin(fx, {\r\n        off: false,\r\n        speeds: {\r\n            normal: 400,\r\n            fast: 200,\r\n            slow: 600\r\n        }\r\n    });\r\n\r\n    return skylark.attach(\"domx.fx\", fx);\r\n});\ndefine('skylark-domx-animates/animates',[\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-browser\"\r\n], function(skylark,langx,browser) {\r\n\r\n    function animates() {\r\n        return animates;\r\n    }\r\n\r\n    langx.mixin(animates, {\r\n        off: false,\r\n        speeds: {\r\n            normal: 400,\r\n            fast: 200,\r\n            slow: 600\r\n        },\r\n        animationName : browser.normalizeCssProperty(\"animation-name\"),\r\n        animationDuration : browser.normalizeCssProperty(\"animation-duration\"),\r\n        animationDelay : browser.normalizeCssProperty(\"animation-delay\"),\r\n        animationTiming : browser.normalizeCssProperty(\"animation-timing-function\"),\r\n        animationEnd : browser.normalizeCssEvent('AnimationEnd'),\r\n\r\n        animateBaseClass : \"animated\"\r\n    });\r\n\r\n    return skylark.attach(\"domx.animates\", animates);\r\n});\ndefine('skylark-domx-animates/animation',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-browser\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-geom\",\r\n    \"skylark-domx-styler\",\r\n    \"skylark-domx-eventer\",\r\n    \"./animates\"\r\n], function(langx, browser, noder, geom, styler, eventer,animates) {\r\n\r\n    var animationName = animates.animationName,\r\n        animationDuration = animates.animationDuration,\r\n        animationTiming = animates.animationTiming,\r\n        animationDelay = animates.animationDelay,\r\n\r\n        animationEnd = animates.animationEnd,\r\n\r\n        cssReset = {};\r\n\r\n\r\n    cssReset[animationName] =\r\n        cssReset[animationDuration] =\r\n        cssReset[animationDelay] =\r\n        cssReset[animationTiming] = \"\";\r\n\r\n    /*   \r\n     * Perform a custom animation.\r\n     * @param {Object} elm  \r\n     * @param {String} name\r\n     * @param {String} ease\r\n     * @param {Number or String} duration\r\n     * @param {Function} callback\r\n     * @param {Number or String} delay\r\n     */\r\n    function animation(elm, name, duration, ease, callback, delay) {\r\n        var cssValues = {};\r\n        if (langx.isPlainObject(duration)) {\r\n            ease = duration.easing;\r\n            callback = duration.complete;\r\n            delay = duration.delay;\r\n            duration = duration.duration;\r\n        }\r\n\r\n        if (langx.isString(duration)) {\r\n            duration = animates.speeds[duration];\r\n        }\r\n        if (duration === undefined) {\r\n            duration = animates.speeds.normal;\r\n        }\r\n        duration = duration / 1000;\r\n\r\n        if (langx.isFunction(ease)) {\r\n            callback = ease;\r\n            eace = \"swing\";\r\n        } else {\r\n            ease = ease || \"swing\";\r\n        }\r\n\r\n        if (delay) {\r\n            delay = delay / 1000;\r\n        } else {\r\n            delay = 0;\r\n        }\r\n        // keyframe animation\r\n        cssValues[animationName] = name;\r\n        cssValues[animationDuration] = duration + \"s\";\r\n        cssValues[animationTiming] = ease;\r\n\r\n\r\n        if (duration > 0) {\r\n            eventer.on(elm, animationEnd, callback);\r\n        }\r\n\r\n        // trigger page reflow so new elements can animate\r\n        elm.clientLeft;\r\n\r\n        styler.css(elm, cssValues);\r\n\r\n        return this;\r\n    }\r\n\r\n    return animates.animation = animation;\r\n\r\n});\ndefine('skylark-domx-fx/animate',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-transits/transit\",\r\n    \"skylark-domx-animates/animation\",\r\n    \"./fx\"\r\n], function(langx, transit,animation,fx) {\r\n\r\n    /*   \r\n     * Perform a custom animation of a set of CSS properties.\r\n     * @param {Object} elm  \r\n     * @param {Number or String} properties\r\n     * @param {String} ease\r\n     * @param {Number or String} duration\r\n     * @param {Function} callback\r\n     * @param {Number or String} delay\r\n     */\r\n    function animate(elm, properties, duration, ease, callback, delay) {\r\n        if (langx.isString(properties)) {\r\n            return animation(elm,properties,duration,ease,callback,delay);\r\n        } else {\r\n            return transit(elm,properties,duration,ease,callback,delay);\r\n        }\r\n\r\n    }\r\n\r\n    return fx.animate = animate;\r\n\r\n});\ndefine('skylark-domx-fx/bounce',[\r\n    \"skylark-domx-transits\",\r\n    \"./fx\"\r\n],function(transits,fx) {\r\n    return fx.bounce = transits.bounce;\r\n});\ndefine('skylark-domx-fx/emulateTransitionEnd',[\r\n    \"skylark-domx-transits\",\r\n    \"./fx\"\r\n],function(transits,fx) {\r\n    return fx.emulateTransitionEnd = transits.emulateTransitionEnd;\r\n});\ndefine('skylark-domx-fx/explode',[\r\n    \"skylark-domx-transits\",\r\n    \"./fx\"\r\n],function(transits,fx) {\r\n\treturn fx.explode = transits.explode;\r\n});\r\n\ndefine('skylark-domx-fx/fadeIn',[\r\n    \"skylark-domx-transits\",\r\n    \"./fx\"\r\n],function(transits,fx) {\r\n\r\n    return fx.fadeIn = transits.fadeIn;\r\n});\ndefine('skylark-domx-fx/fadeOut',[\r\n    \"skylark-domx-transits\",\r\n    \"./fx\"\r\n],function(transits,fx) {\r\n\r\n    return fx.fadeOut = transits.fadeOut;\r\n});\ndefine('skylark-domx-fx/fade',[\r\n    \"skylark-domx-transits\",\r\n    \"./fx\"\r\n],function(transits,fx) {\r\n\r\n    return fx.fade = transits.fade;\r\n});\ndefine('skylark-domx-fx/fadeToggle',[\r\n    \"skylark-domx-transits\",\r\n    \"./fx\"\r\n],function(transits,fx) {\r\n\r\n    return fx.fadeToggle = transits.fadeToggle;\r\n});\ndefine('skylark-domx-fx/hide',[\r\n    \"skylark-domx-transits\",\r\n    \"./fx\"\r\n],function(transits,fx) {\r\n\r\n    return fx.hide = transits.hide;\r\n});\ndefine('skylark-domx-fx/pulsate',[\r\n    \"skylark-domx-transits\",\r\n    \"./fx\"\r\n],function(transits,fx) {\r\n\r\n\treturn fx.pulsate = transits.pulsate;\r\n\r\n});\r\n\ndefine('skylark-domx-fx/shake',[\r\n    \"skylark-domx-transits\",\r\n    \"./fx\"\r\n],function(transits,fx) {\r\n\r\n\treturn fx.shake = transits.shake;\r\n\r\n});\r\n\ndefine('skylark-domx-fx/show',[\r\n    \"skylark-domx-transits\",\r\n    \"./fx\"\r\n],function(transits,fx) {\r\n\r\n    return fx.show = transits.show;\r\n});\ndefine('skylark-domx-fx/slide',[\r\n    \"skylark-domx-transits\",\r\n    \"./fx\"\r\n],function(transits,fx) {\r\n\r\n    function slide(elm,options,callback ) {\r\n    \tif (langx.isFunction(options)) {\r\n    \t\tcallback = options;\r\n    \t\toptions = {};\r\n    \t}\r\n    \toptions = options || {};\r\n\t\tvar direction = options.direction || \"down\",\r\n\t\t\tisHide = ( direction === \"up\" || direction === \"left\" ),\r\n\t\t\tisVert = ( direction === \"up\" || direction === \"down\" ),\r\n\t\t\tduration = options.duration || fx.speeds.normal;\r\n\r\n\r\n        // get the element position to restore it then\r\n        var position = styler.css(elm, 'position');\r\n\r\n        if (isHide) {\r\n            // active the function only if the element is visible\r\n        \tif (styler.isInvisible(elm)) {\r\n        \t\treturn this;\r\n        \t}\r\n        } else {\r\n\t        // show element if it is hidden\r\n\t        styler.show(elm);        \t\r\n\t        // place it so it displays as usually but hidden\r\n\t        styler.css(elm, {\r\n\t            position: 'absolute',\r\n\t            visibility: 'hidden'\r\n\t        });\r\n        }\r\n\r\n\r\n\r\n        if (isVert) { // up--down\r\n\t        // get naturally height, margin, padding\r\n\t        var marginTop = styler.css(elm, 'margin-top');\r\n\t        var marginBottom = styler.css(elm, 'margin-bottom');\r\n\t        var paddingTop = styler.css(elm, 'padding-top');\r\n\t        var paddingBottom = styler.css(elm, 'padding-bottom');\r\n\t        var height = styler.css(elm, 'height');\r\n\r\n\t        if (isHide) {  \t// slideup\r\n\t            // set initial css for animation\r\n\t            styler.css(elm, {\r\n\t                visibility: 'visible',\r\n\t                overflow: 'hidden',\r\n\t                height: height,\r\n\t                marginTop: marginTop,\r\n\t                marginBottom: marginBottom,\r\n\t                paddingTop: paddingTop,\r\n\t                paddingBottom: paddingBottom\r\n\t            });\r\n\r\n\t            // animate element height, margin and padding to zero\r\n\t            animate(elm, {\r\n\t                height: 0,\r\n\t                marginTop: 0,\r\n\t                marginBottom: 0,\r\n\t                paddingTop: 0,\r\n\t                paddingBottom: 0\r\n\t            }, {\r\n\t                // callback : restore the element position, height, margin and padding to original values\r\n\t                duration: duration,\r\n\t                queue: false,\r\n\t                complete: function() {\r\n\t                    styler.hide(elm);\r\n\t                    styler.css(elm, {\r\n\t                        visibility: 'visible',\r\n\t                        overflow: 'hidden',\r\n\t                        height: height,\r\n\t                        marginTop: marginTop,\r\n\t                        marginBottom: marginBottom,\r\n\t                        paddingTop: paddingTop,\r\n\t                        paddingBottom: paddingBottom\r\n\t                    });\r\n\t                    if (callback) {\r\n\t                        callback.apply(elm);\r\n\t                    }\r\n\t                }\r\n\t            });\r\n\t        } else {     \t// slidedown\r\n\t\t        // set initial css for animation\r\n\t\t        styler.css(elm, {\r\n\t\t            position: position,\r\n\t\t            visibility: 'visible',\r\n\t\t            overflow: 'hidden',\r\n\t\t            height: 0,\r\n\t\t            marginTop: 0,\r\n\t\t            marginBottom: 0,\r\n\t\t            paddingTop: 0,\r\n\t\t            paddingBottom: 0\r\n\t\t        });\r\n\r\n\t\t        // animate to gotten height, margin and padding\r\n\t\t        animate(elm, {\r\n\t\t            height: height,\r\n\t\t            marginTop: marginTop,\r\n\t\t            marginBottom: marginBottom,\r\n\t\t            paddingTop: paddingTop,\r\n\t\t            paddingBottom: paddingBottom\r\n\t\t        }, {\r\n\t\t            duration: duration,\r\n\t\t            complete: function() {\r\n\t\t                if (callback) {\r\n\t\t                    callback.apply(elm);\r\n\t\t                }\r\n\t\t            }\r\n\t\t        });\r\n\r\n\t        }\r\n\r\n        } else { // left--right\r\n\t        // get naturally height, margin, padding\r\n\t        var marginLeft = styler.css(elm, 'margin-left');\r\n\t        var marginRight = styler.css(elm, 'margin-right');\r\n\t        var paddingLeft = styler.css(elm, 'padding-left');\r\n\t        var paddingRight = styler.css(elm, 'padding-right');\r\n\t        var width = styler.css(elm, 'width');\r\n\r\n\t        if (isHide) {  \t// slideleft\r\n\t            // set initial css for animation\r\n\t            styler.css(elm, {\r\n\t                visibility: 'visible',\r\n\t                overflow: 'hidden',\r\n\t                width: width,\r\n\t                marginLeft: marginLeft,\r\n\t                marginRight: marginRight,\r\n\t                paddingLeft: paddingLeft,\r\n\t                paddingRight: paddingRight\r\n\t            });\r\n\r\n\t            // animate element height, margin and padding to zero\r\n\t            animate(elm, {\r\n\t                width: 0,\r\n\t                marginLeft: 0,\r\n\t                marginRight: 0,\r\n\t                paddingLeft: 0,\r\n\t                paddingRight: 0\r\n\t            }, {\r\n\t                // callback : restore the element position, height, margin and padding to original values\r\n\t                duration: duration,\r\n\t                queue: false,\r\n\t                complete: function() {\r\n\t                    styler.hide(elm);\r\n\t                    styler.css(elm, {\r\n\t                        visibility: 'visible',\r\n\t                        overflow: 'hidden',\r\n\t                        width: width,\r\n\t                        marginLeft: marginLeft,\r\n\t                        marginRight: marginRight,\r\n\t                        paddingLeft: paddingLeft,\r\n\t                        paddingRight: paddingRight\r\n\t                    });\r\n\t                    if (callback) {\r\n\t                        callback.apply(elm);\r\n\t                    }\r\n\t                }\r\n\t            });\r\n\t        } else {     \t// slideright\r\n\t\t        // set initial css for animation\r\n\t\t        styler.css(elm, {\r\n\t\t            position: position,\r\n\t\t            visibility: 'visible',\r\n\t\t            overflow: 'hidden',\r\n\t\t            width: 0,\r\n\t\t            marginLeft: 0,\r\n\t\t            marginRight: 0,\r\n\t\t            paddingLeft: 0,\r\n\t\t            paddingRight: 0\r\n\t\t        });\r\n\r\n\t\t        // animate to gotten width, margin and padding\r\n\t\t        animate(elm, {\r\n\t\t            width: width,\r\n\t\t            marginLeft: marginLeft,\r\n\t\t            marginRight: marginRight,\r\n\t\t            paddingLeft: paddingLeft,\r\n\t\t            paddingRight: paddingRight\r\n\t\t        }, {\r\n\t\t            duration: duration,\r\n\t\t            complete: function() {\r\n\t\t                if (callback) {\r\n\t\t                    callback.apply(elm);\r\n\t\t                }\r\n\t\t            }\r\n\t\t        });\r\n\r\n\t        }       \t\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    return fx.slide = slide;\r\n\r\n});\r\n\ndefine('skylark-domx-fx/slideDown',[\r\n    \"skylark-domx-transits\",\r\n    \"./fx\"\r\n],function(transits,fx) {\r\n    /*   \r\n     * Display an element with a sliding motion.\r\n     * @param {Object} elm  \r\n     * @param {Number or String} duration\r\n     * @param {Function} callback\r\n     */\r\n    function slideDown(elm, duration, callback) {\r\n        return slide(elm,{\r\n            direction : \"down\",\r\n            duration : duration\r\n        },callback);\r\n    }\r\n\r\n    return fx.slideDown = slideDown;\r\n});\ndefine('skylark-domx-fx/slideToggle',[\r\n    \"skylark-domx-transits\",\r\n    \"./fx\"\r\n],function(transits,fx) {\r\n\r\n    /*   \r\n     * Display or hide an element with a sliding motion.\r\n     * @param {Object} elm  \r\n     * @param {Number or String} duration\r\n     * @param {Function} callback\r\n     */\r\n    function slideToggle(elm, duration, callback) {\r\n\r\n        // if the element is hidden, slideDown !\r\n        if (geom.height(elm) == 0) {\r\n            slideDown(elm, duration, callback);\r\n        }\r\n        // if the element is visible, slideUp !\r\n        else {\r\n            slideUp(elm, duration, callback);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    return fx.slideToggle = slideToggle;\r\n});\ndefine('skylark-domx-fx/slideUp',[\r\n    \"skylark-domx-transits\",\r\n    \"./fx\"\r\n],function(transits,fx) {\r\n    /*   \r\n     * Hide an element with a sliding motion.\r\n     * @param {Object} elm  \r\n     * @param {Number or String} duration\r\n     * @param {Function} callback\r\n     */\r\n    function slideUp(elm, duration, callback) {\r\n        return slide(elm,{\r\n            direction : \"up\",\r\n            duration : duration\r\n        },callback);\r\n    }\r\n\r\n\r\n\r\n    return fx.slideUp = slideUp;\r\n});\ndefine('skylark-domx-fx/throb',[\r\n    \"skylark-domx-noder\",\r\n    \"./fx\"\r\n],function(noder,fx) {\r\n    \r\n    return fx.throb = noder.throb;\r\n});\ndefine('skylark-domx-fx/toggle',[\r\n    \"skylark-domx-transits\",\r\n    \"./fx\"\r\n],function(transits,fx) {\r\n    /*   \r\n     * Display or hide an element.\r\n     * @param {Object} elm  \r\n     * @param {Number or String} speed\r\n     * @param {Function} callbacke\r\n     */\r\n    function toggle(elm, speed, callback) {\r\n        if (styler.isInvisible(elm)) {\r\n            show(elm, speed, callback);\r\n        } else {\r\n            hide(elm, speed, callback);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    return fx.toggle = toggle;\r\n});\ndefine('skylark-domx-fx/main',[\r\n\t\"./fx\",\r\n    \"./animate\",\r\n    \"./bounce\",\r\n    \"./emulateTransitionEnd\",\r\n    \"./explode\",\r\n    \"./fadeIn\",\r\n    \"./fadeOut\",\r\n    \"./fade\",\r\n    \"./fadeToggle\",\r\n    \"./hide\",\r\n    \"./pulsate\",\r\n    \"./shake\",\r\n    \"./show\",\r\n    \"./slide\",\r\n    \"./slideDown\",\r\n    \"./slideToggle\",\r\n    \"./slideUp\",\r\n    \"./throb\",\r\n    \"./toggle\"\r\n],function(fx){\r\n\r\n\treturn fx;\r\n});\ndefine('skylark-domx-fx', ['skylark-domx-fx/main'], function (main) { return main; });\n\ndefine('skylark-jquery/core',[\r\n\t\"skylark-langx/skylark\",\r\n\t\"skylark-langx/langx\",\r\n\t\"skylark-domx-browser\",\r\n\t\"skylark-domx-noder\",\r\n\t\"skylark-domx-data\",\r\n\t\"skylark-domx-eventer\",\r\n\t\"skylark-domx-finder\",\r\n\t\"skylark-domx-forms\",\r\n\t\"skylark-domx-transits\",\r\n\t\"skylark-domx-fx\",\r\n\t\"skylark-domx-styler\",\r\n\t\"skylark-domx-query\",\r\n\t\"skylark-langx-scripter\"\r\n],function(skylark,langx,browser,noder,datax,eventer,finder,forms,transites,fx,styler,query,scripter){\r\n\tvar filter = Array.prototype.filter,\r\n\t\tslice = Array.prototype.slice;\r\n\r\n    (function($){\r\n\t    $.fn.jquery = '2.2.0';\r\n\r\n\t    $.browser = browser;\r\n\t    \r\n\t    $.camelCase = langx.camelCase;\r\n\r\n\t\t$.cleanData = function( elems ) {\r\n\t\t\tvar elem,\r\n\t\t\t\ti = 0;\r\n\r\n\t\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\r\n\t\t\t\tdatax.cleanData(elem);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t$.removeData = function(elm,name) {\r\n\t\t\tdatax.removeData(elm,name);\r\n\t\t}\r\n\t\r\n\t    $.each = langx.each;\r\n\r\n\t    $.extend = langx.extend;\r\n\r\n\t    $.grep = function(elements, callback) {\r\n\t        return filter.call(elements, callback)\r\n\t    };\r\n\r\n\t    $.attr = function(elm,name) {\r\n\t    \treturn datax.attr(elm,name);\r\n\t    };\r\n\r\n\t    $.isArray = langx.isArray;\r\n\t    $.isEmptyObject = langx.isEmptyObject;\r\n\t    $.isFunction = langx.isFunction;\r\n\t    $.isWindow = langx.isWindow;\r\n\t    $.isPlainObject = langx.isPlainObject;\r\n        $.isNumeric = langx.isNumber;\r\n\r\n\t    $.inArray = langx.inArray;\r\n\r\n\t    $.makeArray = langx.makeArray;\r\n\t    $.map = langx.map;  // The behavior is somewhat different from the original jquery.\r\n\r\n\t    $.noop = function() {\r\n\t    };\r\n\r\n\t    $.parseJSON = window.JSON.parse;\r\n\r\n\t    $.proxy = langx.proxy;\r\n\r\n\t    $.trim = langx.trim;\r\n\t    $.type = langx.type;\r\n\r\n\t    $.fn.extend = function(props) {\r\n\t        langx.mixin($.fn, props);\r\n\t    };\r\n\r\n\r\n    })(query);\r\n\r\n    (function($){\r\n        $.Event = function Event(src, props) {\r\n            if (langx.isString(src)) {\r\n            \tvar type = src;\r\n            \treturn eventer.create(type, props);\r\n\t        }\r\n            return eventer.proxy(src, props);\r\n        };\r\n\r\n        $.event = {};\r\n\r\n\t    $.event.special = eventer.special;\r\n\r\n\t    $.fn.submit = function(callback) {\r\n\t        if (0 in arguments) this.bind('submit', callback)\r\n\t        else if (this.length) {\r\n\t            var event = $.Event('submit')\r\n\t            this.eq(0).trigger(event)\r\n\t            if (!event.isDefaultPrevented()) this.get(0).submit()\r\n\t        }\r\n\t        return this\r\n\t    };\r\n\r\n\t    // event\r\n\t    $.fn.triggerHandler = $.fn.trigger;\r\n\r\n\t    $.fn.delegate = function(selector, event, callback) {\r\n\t        return this.on(event, selector, callback)\r\n\t    };\r\n\r\n\t    $.fn.undelegate = function(selector, event, callback) {\r\n\t        return this.off(event, selector, callback)\r\n\t    };\r\n\r\n\t    $.fn.live = function(event, callback) {\r\n\t        $(document.body).delegate(this.selector, event, callback)\r\n\t        return this\r\n\t    };\r\n\r\n\t    $.fn.die = function(event, callback) {\r\n\t        $(document.body).undelegate(this.selector, event, callback)\r\n\t        return this\r\n\t    };\r\n\r\n\t    $.fn.bind = function(event, selector, data, callback) {\r\n\t        return this.on(event, selector, data, callback)\r\n\t    };\r\n\r\n\t    $.fn.unbind = function(event, callback) {\r\n\t        return this.off(event, callback)\r\n\t    };\r\n\r\n\t    $.fn.ready = function(callback) {\r\n\t        eventer.ready(callback);\r\n\t        return this;\r\n\t    };\r\n\r\n\t    $.fn.stop = function() {\r\n\t        // todo\r\n\t        return this;\r\n\t    };\r\n\r\n\t    $.fn.moveto = function(x, y) {\r\n\t        return this.transit({\r\n\t            left: x + \"px\",\r\n\t            top: y + \"px\"\r\n\t        }, 0.4);\r\n\r\n\t    };\r\n\r\n\t    $.ready = eventer.ready;\r\n\r\n\t    $.on = eventer.on;\r\n\r\n\t    $.off = eventer.off;\r\n    })(query);\r\n\r\n    (function($){\r\n\t    // plugin compatibility\r\n\t    $.uuid = 0;\r\n\t    $.support = browser.support;\r\n\t    $.expr = {};\r\n\r\n\t    $.expr[\":\"] = $.expr.pseudos = $.expr.filters = finder.pseudos;\r\n\r\n\t    $.expr.createPseudo = function(fn) {\r\n\t    \treturn fn;\r\n\t    };\r\n\r\n\t    $.cssHooks = styler.cssHooks;\r\n\r\n\t    $.contains = noder.contains;\r\n\r\n\t    $.css = styler.css;\r\n\r\n\t    $.data = datax.data;\r\n\r\n\t    $.fx = fx;\r\n\t    $.fx.step = {\r\n\r\n        };\r\n\r\n        $.speed = function( speed, easing, fn ) {\r\n            var opt = speed && typeof speed === \"object\" ? $.extend( {}, speed ) : {\r\n                complete: fn || !fn && easing ||\r\n                    $.isFunction( speed ) && speed,\r\n                duration: speed,\r\n                easing: fn && easing || easing && !$.isFunction( easing ) && easing\r\n            };\r\n\r\n            // Go to the end state if fx are off\r\n            if ( $.fx.off ) {\r\n                opt.duration = 0;\r\n\r\n            } else {\r\n                if ( typeof opt.duration !== \"number\" ) {\r\n                    if ( opt.duration in $.fx.speeds ) {\r\n                        opt.duration = $.fx.speeds[ opt.duration ];\r\n\r\n                    } else {\r\n                        opt.duration = $.fx.speeds._default;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Normalize opt.queue - true/undefined/null -> \"fx\"\r\n            if ( opt.queue == null || opt.queue === true ) {\r\n                opt.queue = \"fx\";\r\n            }\r\n\r\n            // Queueing\r\n            opt.old = opt.complete;\r\n\r\n            opt.complete = function() {\r\n                if ( $.isFunction( opt.old ) ) {\r\n                    opt.old.call( this );\r\n                }\r\n\r\n                if ( opt.queue ) {\r\n                    $.dequeue( this, opt.queue );\r\n                }\r\n            };\r\n\r\n            return opt;\r\n        };\r\n\r\n        $.easing = {};\r\n\r\n\t    $.offset = {};\r\n\t    $.offset.setOffset = function(elem, options, i) {\r\n\t        var position = $.css(elem, \"position\");\r\n\r\n\t        // set position first, in-case top/left are set even on static elem\r\n\t        if (position === \"static\") {\r\n\t            elem.style.position = \"relative\";\r\n\t        }\r\n\r\n\t        var curElem = $(elem),\r\n\t            curOffset = curElem.offset(),\r\n\t            curCSSTop = $.css(elem, \"top\"),\r\n\t            curCSSLeft = $.css(elem, \"left\"),\r\n\t            calculatePosition = (position === \"absolute\" || position === \"fixed\") && $.inArray(\"auto\", [curCSSTop, curCSSLeft]) > -1,\r\n\t            props = {},\r\n\t            curPosition = {},\r\n\t            curTop, curLeft;\r\n\r\n\t        // need to be able to calculate position if either top or left is auto and position is either absolute or fixed\r\n\t        if (calculatePosition) {\r\n\t            curPosition = curElem.position();\r\n\t            curTop = curPosition.top;\r\n\t            curLeft = curPosition.left;\r\n\t        } else {\r\n\t            curTop = parseFloat(curCSSTop) || 0;\r\n\t            curLeft = parseFloat(curCSSLeft) || 0;\r\n\t        }\r\n\r\n\t        if ($.isFunction(options)) {\r\n\t            options = options.call(elem, i, curOffset);\r\n\t        }\r\n\r\n\t        if (options.top != null) {\r\n\t            props.top = (options.top - curOffset.top) + curTop;\r\n\t        }\r\n\t        if (options.left != null) {\r\n\t            props.left = (options.left - curOffset.left) + curLeft;\r\n\t        }\r\n\r\n\t        if (\"using\" in options) {\r\n\t            options.using.call(elem, props);\r\n\t        } else {\r\n\t            curElem.css(props);\r\n\t        }\r\n\t    };\r\n\r\n        $._data = function(elm,propName) {\r\n            if (elm.hasAttribute) {\r\n                return datax.data(elm,propName);\r\n            } else {\r\n                return {};\r\n            }\r\n        };\r\n\r\n     \tvar t = $.fn.text;  \r\n\t    $.fn.text = function(v) {\r\n\t        var r = t.apply(this,arguments);\r\n\t        if (r === undefined) {\r\n\t            r = \"\";\r\n\t        }  \r\n\t        return r;\r\n\t    };       \r\n\r\n\t    $.fn.pos = $.fn.position;\r\n        \t    \r\n    })(query);\r\n\r\n    query.parseHTML = function(html) {\r\n        return  noder.createFragment(html);\r\n    };\r\n\r\n    query.uniqueSort = query.unique = langx.uniq;\r\n\r\n    query.skylark = skylark;\r\n\r\n    return window.jQuery = window.$ = query;\r\n});\r\n\ndefine('skylark-langx-emitter/emitter',[\r\n    \"skylark-langx-events\"\r\n],function(events){\r\n    return events.Emitter;\r\n});\ndefine('skylark-langx-emitter/evented',[\r\n\t\"./emitter\"\r\n],function(Emitter){\r\n\treturn Emitter;\r\n});\ndefine('skylark-net-http/http',[\r\n  \"skylark-langx-ns/ns\",\r\n],function(skylark){\r\n\treturn skylark.attach(\"net.http\",{});\r\n});\ndefine('skylark-net-http/xhr',[\r\n  \"skylark-langx-ns/ns\",\r\n  \"skylark-langx-types\",\r\n  \"skylark-langx-objects\",\r\n  \"skylark-langx-arrays\",\r\n  \"skylark-langx-funcs\",\r\n  \"skylark-langx-async/deferred\",\r\n  \"skylark-langx-emitter/evented\",\r\n  \"skylark-langx-urls/is-cross-origin\",\r\n  \"./http\"\r\n],function(skylark,types,objects,arrays,funcs,Deferred,Evented,isCrossOrigin,http){\r\n\r\n    var each = objects.each,\r\n        mixin = objects.mixin,\r\n        noop = funcs.noop,\r\n        isArray = types.isArray,\r\n        isFunction = types.isFunction,\r\n        isPlainObject = types.isPlainObject,\r\n        type = types.type;\r\n \r\n     var getAbsoluteUrl = (function() {\r\n        var a;\r\n\r\n        return function(url) {\r\n            if (!a) a = document.createElement('a');\r\n            a.href = url;\r\n\r\n            return a.href;\r\n        };\r\n    })();\r\n   \r\n    var Xhr = (function(){\r\n        var jsonpID = 0,\r\n            key,\r\n            name,\r\n            rscript = /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,\r\n            scriptTypeRE = /^(?:text|application)\\/javascript/i,\r\n            xmlTypeRE = /^(?:text|application)\\/xml/i,\r\n            jsonType = 'application/json',\r\n            htmlType = 'text/html',\r\n            blankRE = /^\\s*$/;\r\n\r\n        var XhrDefaultOptions = {\r\n            async: true,\r\n\r\n            // Default type of request\r\n            type: 'GET',\r\n            // Callback that is executed before request\r\n            beforeSend: noop,\r\n            // Callback that is executed if the request succeeds\r\n            success: noop,\r\n            // Callback that is executed the the server drops error\r\n            error: noop,\r\n            // Callback that is executed on request complete (both: error and success)\r\n            complete: noop,\r\n            // The context for the callbacks\r\n            context: null,\r\n            // Whether to trigger \"global\" Ajax events\r\n            global: true,\r\n\r\n            // MIME types mapping\r\n            // IIS returns Javascript as \"application/x-javascript\"\r\n            accepts: {\r\n                script: 'text/javascript, application/javascript, application/x-javascript',\r\n                json: 'application/json',\r\n                xml: 'application/xml, text/xml',\r\n                html: 'text/html',\r\n                text: 'text/plain'\r\n            },\r\n            // Whether the request is to another domain\r\n            crossDomain: false,\r\n            // Default timeout\r\n            timeout: 0,\r\n            // Whether data should be serialized to string\r\n            processData: false,\r\n            // Whether the browser should be allowed to cache GET responses\r\n            cache: true,\r\n\r\n            traditional : false,\r\n            \r\n            xhrFields : {\r\n                ///withCredentials : false\r\n            }\r\n        };\r\n\r\n        function mimeToDataType(mime) {\r\n            if (mime) {\r\n                mime = mime.split(';', 2)[0];\r\n            }\r\n            if (mime) {\r\n                if (mime == htmlType) {\r\n                    return \"html\";\r\n                } else if (mime == jsonType) {\r\n                    return \"json\";\r\n                } else if (scriptTypeRE.test(mime)) {\r\n                    return \"script\";\r\n                } else if (xmlTypeRE.test(mime)) {\r\n                    return \"xml\";\r\n                }\r\n            }\r\n            return \"text\";\r\n        }\r\n\r\n        function appendQuery(url, query) {\r\n            if (query == '') return url\r\n            return (url + '&' + query).replace(/[&?]{1,2}/, '?')\r\n        }\r\n\r\n        // serialize payload and append it to the URL for GET requests\r\n        function serializeData(options) {\r\n            options.data = options.data || options.query;\r\n            if (options.processData && options.data && type(options.data) != \"string\") {\r\n                options.data = param(options.data, options.traditional);\r\n            }\r\n            if (options.data && (!options.type || options.type.toUpperCase() == 'GET')) {\r\n                if (type(options.data) != \"string\") {\r\n                    options.data = param(options.data, options.traditional);\r\n                }\r\n                options.url = appendQuery(options.url, options.data);\r\n                options.data = undefined;\r\n            }\r\n        }\r\n        \r\n        function serialize(params, obj, traditional, scope) {\r\n            var t, array = isArray(obj),\r\n                hash = isPlainObject(obj)\r\n            each(obj, function(key, value) {\r\n                t =type(value);\r\n                if (scope) key = traditional ? scope :\r\n                    scope + '[' + (hash || t == 'object' || t == 'array' ? key : '') + ']'\r\n                // handle data in serializeArray() format\r\n                if (!scope && array) params.add(value.name, value.value)\r\n                // recurse into nested objects\r\n                else if (t == \"array\" || (!traditional && t == \"object\"))\r\n                    serialize(params, value, traditional, key)\r\n                else params.add(key, value)\r\n            })\r\n        }\r\n\r\n        var param = function(obj, traditional) {\r\n            var params = []\r\n            params.add = function(key, value) {\r\n                if (isFunction(value)) {\r\n                  value = value();\r\n                }\r\n                if (value == null) {\r\n                  value = \"\";\r\n                }\r\n                this.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\r\n            };\r\n            serialize(params, obj, traditional)\r\n            return params.join('&').replace(/%20/g, '+')\r\n        };\r\n\r\n        var Xhr = Evented.inherit({\r\n            klassName : \"Xhr\",\r\n\r\n            _request  : function(args) {\r\n                var _ = this._,\r\n                    self = this,\r\n                    options = mixin({},XhrDefaultOptions,_.options,args),\r\n                    xhr = _.xhr = new XMLHttpRequest();\r\n\r\n                serializeData(options)\r\n\r\n                if (options.beforeSend) {\r\n                    options.beforeSend.call(this, xhr, options);\r\n                }                \r\n\r\n                var dataType = options.dataType || options.handleAs,\r\n                    mime = options.mimeType || options.accepts[dataType],\r\n                    headers = options.headers,\r\n                    xhrFields = options.xhrFields,\r\n                    isFormData = options.data && options.data instanceof FormData,\r\n                    basicAuthorizationToken = options.basicAuthorizationToken,\r\n                    type = options.type,\r\n                    url = options.url,\r\n                    async = options.async,\r\n                    user = options.user , \r\n                    password = options.password,\r\n                    deferred = new Deferred(),\r\n                    contentType = options.contentType || (isFormData ? false : 'application/x-www-form-urlencoded');\r\n\r\n                if (xhrFields) {\r\n                    for (name in xhrFields) {\r\n                        xhr[name] = xhrFields[name];\r\n                    }\r\n                }\r\n\r\n                if (mime && mime.indexOf(',') > -1) {\r\n                    mime = mime.split(',', 2)[0];\r\n                }\r\n                if (mime && xhr.overrideMimeType) {\r\n                    xhr.overrideMimeType(mime);\r\n                }\r\n\r\n                if (dataType == \"blob\" || dataType == \"arraybuffer\") {\r\n                    xhr.responseType = dataType;\r\n                }\r\n\r\n                var finish = function() {\r\n                    xhr.onloadend = noop;\r\n                    xhr.onabort = noop;\r\n                    xhr.onprogress = noop;\r\n                    xhr.ontimeout = noop;\r\n                    xhr = null;\r\n                }\r\n                var onloadend = function() {\r\n                    var result, error = false\r\n                    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && getAbsoluteUrl(url).startsWith('file:'))) {\r\n                        dataType = dataType || mimeToDataType(options.mimeType || xhr.getResponseHeader('content-type'));\r\n\r\n                        //result = xhr.responseText;\r\n                        try {\r\n                            if (dataType == 'script') {\r\n                                eval(xhr.responseText);\r\n                            } else if (dataType == 'xml') {\r\n                                result = xhr.responseXML;\r\n                            } else if (dataType == 'json') {\r\n                                result = blankRE.test(xhr.responseText) ? null : JSON.parse(xhr.responseText);\r\n                            } else if (dataType == \"blob\") {\r\n                                result = xhr.response; // new Blob([xhr.response]);\r\n                            } else if (dataType == \"arraybuffer\") {\r\n                                result = xhr.response;\r\n                            } else {\r\n                                //if (dataType == \"text\" || dataType==\"html\")\r\n                                result = xhr.responseText;\r\n                            }\r\n                        } catch (e) { \r\n                            error = e;\r\n                        }\r\n\r\n                        if (error) {\r\n                            deferred.reject(error,xhr.status,xhr);\r\n                        } else {\r\n                            deferred.resolve(result,xhr.status,xhr);\r\n                        }\r\n                    } else {\r\n                        deferred.reject(new Error(xhr.statusText),xhr.status,xhr);\r\n                    }\r\n                    finish();\r\n                };\r\n                \r\n                var onabort = function() {\r\n                    if (deferred) {\r\n                        deferred.reject(new Error(\"abort\"),xhr.status,xhr);\r\n                    }\r\n                    finish();                 \r\n                }\r\n \r\n                var ontimeout = function() {\r\n                    if (deferred) {\r\n                        deferred.reject(new Error(\"timeout\"),xhr.status,xhr);\r\n                    }\r\n                    finish();                 \r\n                }\r\n\r\n                var onprogress = function(evt) {\r\n                    if (deferred) {\r\n                        deferred.notify(evt,xhr.status,xhr);\r\n                    }\r\n                }\r\n\r\n                xhr.onloadend = onloadend;\r\n                xhr.onabort = onabort;\r\n                xhr.ontimeout = ontimeout;\r\n                xhr.onprogress = onprogress;\r\n\r\n                xhr.open(type, url, async, user, password);\r\n               \r\n                if (headers) {\r\n                    for ( var key in headers) {\r\n                        var value = headers[key];\r\n \r\n                        if(key.toLowerCase() === 'content-type'){\r\n                            contentType = value;\r\n                        } else {\r\n                           xhr.setRequestHeader(key, value);\r\n                        }\r\n                    }\r\n                }   \r\n\r\n                if  (contentType && contentType !== false){\r\n                    xhr.setRequestHeader('Content-Type', contentType);\r\n                }\r\n\r\n                if(!headers || !('X-Requested-With' in headers)){\r\n                    if (!isCrossOrigin(url)) {// for s02\r\n                      xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest'); \r\n                    }\r\n                }\r\n\r\n\r\n                //If basicAuthorizationToken is defined set its value into \"Authorization\" header\r\n                if (basicAuthorizationToken) {\r\n                    xhr.setRequestHeader(\"Authorization\", basicAuthorizationToken);\r\n                }\r\n\r\n                xhr.send(options.data ? options.data : null);\r\n\r\n                return deferred.promise;\r\n\r\n            },\r\n\r\n            \"abort\": function() {\r\n                var _ = this._,\r\n                    xhr = _.xhr;\r\n\r\n                if (xhr) {\r\n                    xhr.abort();\r\n                }    \r\n            },\r\n\r\n\r\n            \"request\": function(args) {\r\n                return this._request(args);\r\n            },\r\n\r\n            get : function(args) {\r\n                args = args || {};\r\n                args.type = \"GET\";\r\n                return this._request(args);\r\n            },\r\n\r\n            post : function(args) {\r\n                args = args || {};\r\n                args.type = \"POST\";\r\n                return this._request(args);\r\n            },\r\n\r\n            patch : function(args) {\r\n                args = args || {};\r\n                args.type = \"PATCH\";\r\n                return this._request(args);\r\n            },\r\n\r\n            put : function(args) {\r\n                args = args || {};\r\n                args.type = \"PUT\";\r\n                return this._request(args);\r\n            },\r\n\r\n            del : function(args) {\r\n                args = args || {};\r\n                args.type = \"DELETE\";\r\n                return this._request(args);\r\n            },\r\n\r\n            \"init\": function(options) {\r\n                this._ = {\r\n                    options : options || {}\r\n                };\r\n            }\r\n        });\r\n\r\n        [\"request\",\"get\",\"post\",\"put\",\"del\",\"patch\"].forEach(function(name){\r\n            Xhr[name] = function(url,args) {\r\n                var xhr = new Xhr({\"url\" : url});\r\n                return xhr[name](args);\r\n            };\r\n        });\r\n\r\n        Xhr.defaultOptions = XhrDefaultOptions;\r\n        Xhr.param = param;\r\n\r\n        return Xhr;\r\n    })();\r\n\r\n    return http.Xhr = Xhr;  \r\n});\ndefine('skylark-jquery/ajax',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-net-http/xhr\",\r\n    \"./core\",\r\n], function(langx,Xhr,$) {\r\n    var jsonpID = 0;\r\n\r\n     // Attach a bunch of functions for handling common AJAX events\r\n    $.each( [\r\n        \"ajaxStart\",\r\n        \"ajaxStop\",\r\n        \"ajaxComplete\",\r\n        \"ajaxError\",\r\n        \"ajaxSuccess\",\r\n        \"ajaxSend\"\r\n    ], function( i, type ) {\r\n        $.fn[ type ] = function( fn ) {\r\n            return this.on( type, fn );\r\n        };\r\n    } );\r\n   \r\n\r\n    function appendQuery(url, query) {\r\n        if (query == '') return url\r\n        return (url + '&' + query).replace(/[&?]{1,2}/, '?')\r\n    }\r\n    \r\n    $.ajaxJSONP = function(options) {\r\n        var deferred = new langx.Deferred();\r\n        var _callbackName = options.jsonpCallback,\r\n            callbackName = ($.isFunction(_callbackName) ?\r\n                _callbackName() : _callbackName) || ('jsonp' + (++jsonpID)),\r\n            script = document.createElement('script'),\r\n            originalCallback = window[callbackName],\r\n            responseData,\r\n            abort = function(errorType) {\r\n                $(script).triggerHandler('error', errorType || 'abort')\r\n            },\r\n            xhr = { abort: abort },\r\n            abortTimeout;\r\n\r\n        for (var key in options.data) {\r\n            options.url = appendQuery(options.url, key + \"=\" + options.data[key]);\r\n        }\r\n         \r\n//        if (deferred) deferred.promise(xhr)\r\n\r\n        $(script).on('load error', function(e, errorType) {\r\n            clearTimeout(abortTimeout)\r\n            $(script).off().remove()\r\n\r\n            if (e.type == 'error' || !responseData) {\r\n                deferred.reject(e);\r\n            } else {\r\n                deferred.resolve(responseData[0],200,xhr);\r\n            }\r\n\r\n            window[callbackName] = originalCallback\r\n            if (responseData && $.isFunction(originalCallback))\r\n                originalCallback(responseData[0])\r\n\r\n            originalCallback = responseData = undefined\r\n        })\r\n\r\n        window[callbackName] = function() {\r\n            responseData = arguments\r\n        }\r\n\r\n        script.src = options.url.replace(/\\?(.+)=\\?/, '?$1=' + callbackName)\r\n        document.head.appendChild(script)\r\n\r\n        if (options.timeout > 0) abortTimeout = setTimeout(function() {\r\n            abort('timeout')\r\n        }, options.timeout)\r\n\r\n        return deferred;\r\n    }\r\n\r\n    //$.ajaxSettings = Xhr.defaultOptions;\r\n    //$.ajaxSettings.xhr = function() {\r\n    //    return new window.XMLHttpRequest()\r\n    //};\r\n\r\n    $.ajaxSettings = {\r\n        processData : true\r\n    };\r\n\r\n\r\n    $.ajax = function(url,options) {\r\n        if (!url) {\r\n            options = {\r\n                url :  \"./\"\r\n            };\r\n        } else if (!options) {\r\n            if (langx.isString(url)) {\r\n                options = {\r\n                    url :  url\r\n                };\r\n            } else {\r\n                options = url;\r\n            }\r\n        } else {\r\n            options.url = url;\r\n        }\r\n\r\n        options = langx.mixin({},$.ajaxSettings,options);\r\n\r\n        if ('jsonp' == options.dataType) {\r\n            var hasPlaceholder = /\\?.+=\\?/.test(options.url);\r\n\r\n            if (!hasPlaceholder)\r\n                options.url = appendQuery(options.url,\r\n                    options.jsonp ? (options.jsonp + '=?') : options.jsonp === false ? '' : 'callback=?')\r\n            return $.ajaxJSONP(options);\r\n        }\r\n\r\n        function ajaxSuccess(data,status,xhr) {\r\n            $(document).trigger(\"ajaxSucess\");\r\n            if (options.success) {\r\n                options.success.apply(this,arguments);\r\n            }\r\n            if (options.complete) {\r\n                options.complete.apply(this,arguments);\r\n            }\r\n            return data;\r\n        }\r\n\r\n        function ajaxError() {\r\n            $(document).trigger(\"ajaxError\");\r\n            if (options.error) {\r\n                options.error.apply(this,arguments);\r\n            }\r\n        }\r\n\r\n        var p = Xhr.request(options.url,options);\r\n        p = p.then(ajaxSuccess,ajaxError);\r\n        p.success = p.done;\r\n        p.error = p.fail;\r\n        p.complete = p.always;\r\n        \r\n        return p;\r\n    };\r\n\r\n    // handle optional data/success arguments\r\n    function parseArguments(url, data, success, dataType) {\r\n        if ($.isFunction(url)) {\r\n            dataType = data, success = url, data = undefined,url = undefined;\r\n        } else if ($.isFunction(data)) {\r\n            dataType = success, success = data, data = undefined;\r\n        } \r\n        if (!$.isFunction(success)) dataType = success, success = undefined\r\n        return {\r\n            url: url,\r\n            data: data,\r\n            success: success,\r\n            dataType: dataType\r\n        }\r\n    }\r\n\r\n    $.get = function( /* url, data, success, dataType */ ) {\r\n        return $.ajax(parseArguments.apply(null, arguments))\r\n    }\r\n\r\n    $.post = function( /* url, data, success, dataType */ ) {\r\n        var options = parseArguments.apply(null, arguments)\r\n        options.type = 'POST'\r\n        return $.ajax(options)\r\n    }\r\n\r\n    $.getJSON = function( /* url, data, success */ ) {\r\n        var options = parseArguments.apply(null, arguments)\r\n        options.dataType = 'json'\r\n        return $.ajax(options)\r\n    }\r\n\r\n    var originalLoad = $.fn.load;\r\n\r\n    $.fn.load = function(url, data, success) {\r\n        if (\"string\" != typeof url && originalLoad) {\r\n            return originalLoad.apply(this, arguments);\r\n        }\r\n        if (!this.length) return this\r\n        var self = this,\r\n            options = parseArguments(url, data, success),\r\n            parts = options.url && options.url.split(/\\s/),\r\n            selector,\r\n            callback = options.success\r\n        if (parts && parts.length > 1) options.url = parts[0], selector = parts[1]\r\n\r\n        if (options.data && typeof options.data === \"object\") {\r\n            options.type = \"POST\";\r\n        }\r\n        options.success = function(response) {\r\n            self.html(selector ?\r\n                $('<div>').html(response.replace(rscript, \"\")).find(selector) : response)\r\n            callback && callback.apply(self, arguments)\r\n        }\r\n        $.ajax(options)\r\n        return this\r\n    }\r\n\r\n    $.param = Xhr.param;\r\n\r\n\r\n    // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\r\n    function addToPrefiltersOrTransports(structure) {\r\n\r\n        // dataTypeExpression is optional and defaults to \"*\"\r\n        return function(dataTypeExpression, func) {\r\n\r\n            if (typeof dataTypeExpression !== \"string\") {\r\n                func = dataTypeExpression;\r\n                dataTypeExpression = \"*\";\r\n            }\r\n\r\n            var dataType,\r\n                i = 0,\r\n                dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];\r\n\r\n            if (jQuery.isFunction(func)) {\r\n\r\n                // For each dataType in the dataTypeExpression\r\n                while ((dataType = dataTypes[i++])) {\r\n\r\n                    // Prepend if requested\r\n                    if (dataType[0] === \"+\") {\r\n                        dataType = dataType.slice(1) || \"*\";\r\n                        (structure[dataType] = structure[dataType] || []).unshift(func);\r\n\r\n                        // Otherwise append\r\n                    } else {\r\n                        (structure[dataType] = structure[dataType] || []).push(func);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    var\r\n        prefilters = {},\r\n        transports = {},\r\n        rnotwhite = (/\\S+/g);\r\n\r\n    $.ajaxPrefilter = addToPrefiltersOrTransports(prefilters);\r\n    $.ajaxTransport = addToPrefiltersOrTransports(transports);\r\n    $.ajaxSetup = function(target, settings) {\r\n        langx.mixin(Xhr.defaultOptions,target,settings);\r\n    };\r\n\r\n    $.getScript = function( url, callback ) {\r\n        return $.get( url, undefined, callback, \"script\" );\r\n    };\r\n\r\n    return $;\r\n\r\n});\r\n\ndefine('skylark-jquery/callbacks',[\r\n    \"./core\"\r\n], function($) {\r\n\r\n    //     This module is borrow from zepto.callback.js\r\n    //     (c) 2010-2014 Thomas Fuchs\r\n    //     Zepto.js may be freely distributed under the MIT license.\r\n\r\n    // Create a collection of callbacks to be fired in a sequence, with configurable behaviour\r\n    // Option flags:\r\n    //   - once: Callbacks fired at most one time.\r\n    //   - memory: Remember the most recent context and arguments\r\n    //   - stopOnFalse: Cease iterating over callback list\r\n    //   - unique: Permit adding at most one instance of the same callback\r\n    $.Callbacks = function(options) {\r\n        options = $.extend({}, options)\r\n\r\n        var memory, // Last fire value (for non-forgettable lists)\r\n            fired, // Flag to know if list was already fired\r\n            firing, // Flag to know if list is currently firing\r\n            firingStart, // First callback to fire (used internally by add and fireWith)\r\n            firingLength, // End of the loop when firing\r\n            firingIndex, // Index of currently firing callback (modified by remove if needed)\r\n            list = [], // Actual callback list\r\n            stack = !options.once && [], // Stack of fire calls for repeatable lists\r\n            fire = function(data) {\r\n                memory = options.memory && data\r\n                fired = true\r\n                firingIndex = firingStart || 0\r\n                firingStart = 0\r\n                firingLength = list.length\r\n                firing = true\r\n                for (; list && firingIndex < firingLength; ++firingIndex) {\r\n                    if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {\r\n                        memory = false\r\n                        break\r\n                    }\r\n                }\r\n                firing = false\r\n                if (list) {\r\n                    if (stack) stack.length && fire(stack.shift())\r\n                    else if (memory) list.length = 0\r\n                    else Callbacks.disable()\r\n                }\r\n            },\r\n\r\n            Callbacks = {\r\n                add: function() {\r\n                    if (list) {\r\n                        var start = list.length,\r\n                            add = function(args) {\r\n                                $.each(args, function(_, arg) {\r\n                                    if (typeof arg === \"function\") {\r\n                                        if (!options.unique || !Callbacks.has(arg)) list.push(arg)\r\n                                    } else if (arg && arg.length && typeof arg !== 'string') add(arg)\r\n                                })\r\n                            }\r\n                        add(arguments)\r\n                        if (firing) firingLength = list.length\r\n                        else if (memory) {\r\n                            firingStart = start\r\n                            fire(memory)\r\n                        }\r\n                    }\r\n                    return this\r\n                },\r\n                remove: function() {\r\n                    if (list) {\r\n                        $.each(arguments, function(_, arg) {\r\n                            var index\r\n                            while ((index = $.inArray(arg, list, index)) > -1) {\r\n                                list.splice(index, 1)\r\n                                // Handle firing indexes\r\n                                if (firing) {\r\n                                    if (index <= firingLength) --firingLength\r\n                                    if (index <= firingIndex) --firingIndex\r\n                                }\r\n                            }\r\n                        })\r\n                    }\r\n                    return this\r\n                },\r\n                has: function(fn) {\r\n                    return !!(list && (fn ? $.inArray(fn, list) > -1 : list.length))\r\n                },\r\n                empty: function() {\r\n                    firingLength = list.length = 0\r\n                    return this\r\n                },\r\n                disable: function() {\r\n                    list = stack = memory = undefined\r\n                    return this\r\n                },\r\n                disabled: function() {\r\n                    return !list\r\n                },\r\n                lock: function() {\r\n                    stack = undefined;\r\n                    if (!memory) Callbacks.disable()\r\n                    return this\r\n                },\r\n                locked: function() {\r\n                    return !stack\r\n                },\r\n                fireWith: function(context, args) {\r\n                    if (list && (!fired || stack)) {\r\n                        args = args || []\r\n                        args = [context, args.slice ? args.slice() : args]\r\n                        if (firing) stack.push(args)\r\n                        else fire(args)\r\n                    }\r\n                    return this\r\n                },\r\n                fire: function() {\r\n                    return Callbacks.fireWith(this, arguments)\r\n                },\r\n                fired: function() {\r\n                    return !!fired\r\n                }\r\n            }\r\n\r\n        return Callbacks\r\n    };\r\n\r\n    return $;\r\n\r\n});\r\n\ndefine('skylark-jquery/deferred',[\r\n    \"./core\",\r\n    \"skylark-langx/langx\"\r\n], function($,langx) {\r\n\r\n    $.Deferred = function() {\r\n        var d = new langx.Deferred(),\r\n            ret = {\r\n                promise : function() {\r\n                    return d.promise;\r\n                }\r\n            };\r\n\r\n        [\"resolve\",\"resolveWith\",\"reject\",\"rejectWith\",\"notify\",\"then\",\"done\",\"fail\",\"progress\",\"always\",\"state\"].forEach(function(name){\r\n            ret[name] = function() {\r\n              var ret2 =   d[name].apply(d,arguments);\r\n              if (ret2 == d) {\r\n                ret2 = ret;\r\n              }\r\n              return ret2;\r\n            }\r\n        });\r\n\r\n        return ret;\r\n    };\r\n    \r\n    $.when = function(){\r\n        var p = langx.Deferred.all(langx.makeArray(arguments)),\r\n            originThen = p.then;\r\n        p.then = function(onResolved,onRejected) {\r\n            var handler = function(results) {\r\n                //results = results.map(function(result){\r\n                //    return [result];\r\n                //});\r\n                return onResolved && onResolved.apply(null,results);\r\n            };\r\n            return originThen.call(p,handler,onRejected);\r\n        };\r\n        return p;\r\n    };\r\n\r\n    return $;\r\n\r\n});\r\n\ndefine('skylark-jquery/queue',[\r\n    \"skylark-langx/langx\",\r\n    \"./core\",\r\n    \"./callbacks\"\r\n], function(langx, $) {\r\n\r\n // jQuery Data object\r\n  var rbrace = /(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/,\r\n      rmultiDash = /([A-Z])/g,\r\n      expando = \"Sky\" + ( '1.0' + Math.random() ).replace( /\\D/g, \"\"),\r\n      optionsCache = {},\r\n      core_rnotwhite = /\\S+/g,\r\n      core_deletedIds = [],\r\n      core_push = core_deletedIds.push;\r\n\r\n// Convert String-formatted options into Object-formatted ones and store in cache\r\n  function createOptions( options ) {\r\n    var object = optionsCache[ options ] = {};\r\n    $.each( options.match( core_rnotwhite ) || [], function( _, flag ) {\r\n      object[ flag ] = true;\r\n    });\r\n    return object;\r\n  }\r\n\r\n  function isArraylike( obj ) {\r\n    var length = obj.length,\r\n        type = $.type( obj );\r\n\r\n    if ( $.isWindow( obj ) ) {\r\n      return false;\r\n    }\r\n\r\n    if ( obj.nodeType === 1 && length ) {\r\n      return true;\r\n    }\r\n\r\n    return type === \"array\" || type !== \"function\" &&\r\n        ( length === 0 ||\r\n            typeof length === \"number\" && length > 0 && ( length - 1 ) in obj );\r\n  }\r\n\r\n  \r\n\r\n  function Data() {\r\n    // Support: Android < 4,\r\n    // Old WebKit does not have Object.preventExtensions/freeze method,\r\n    // return new empty object instead with no [[set]] accessor\r\n    Object.defineProperty( this.cache = {}, 0, {\r\n      get: function() {\r\n        return {};\r\n      }\r\n    });\r\n\r\n    this.expando = expando + Math.random();\r\n  }\r\n\r\n  Data.uid = 1;\r\n\r\n  Data.accepts = function( owner ) {\r\n    // Accepts only:\r\n    //  - Node\r\n    //    - Node.ELEMENT_NODE\r\n    //    - Node.DOCUMENT_NODE\r\n    //  - Object\r\n    //    - Any\r\n    return owner.nodeType ?\r\n        owner.nodeType === 1 || owner.nodeType === 9 : true;\r\n  };\r\n\r\n  Data.prototype = {\r\n    key: function( owner ) {\r\n      // We can accept data for non-element nodes in modern browsers,\r\n      // but we should not, see #8335.\r\n      // Always return the key for a frozen object.\r\n      if ( !Data.accepts( owner ) ) {\r\n        return 0;\r\n      }\r\n\r\n      var descriptor = {},\r\n      // Check if the owner object already has a cache key\r\n          unlock = owner[ this.expando ];\r\n\r\n      // If not, create one\r\n      if ( !unlock ) {\r\n        unlock = Data.uid++;\r\n\r\n        // Secure it in a non-enumerable, non-writable property\r\n        try {\r\n          descriptor[ this.expando ] = { value: unlock };\r\n          Object.defineProperties( owner, descriptor );\r\n\r\n          // Support: Android < 4\r\n          // Fallback to a less secure definition\r\n        } catch ( e ) {\r\n          descriptor[ this.expando ] = unlock;\r\n          $.extend( owner, descriptor );\r\n        }\r\n      }\r\n\r\n      // Ensure the cache object\r\n      if ( !this.cache[ unlock ] ) {\r\n        this.cache[ unlock ] = {};\r\n      }\r\n\r\n      return unlock;\r\n    },\r\n    set: function( owner, data, value ) {\r\n      var prop,\r\n      // There may be an unlock assigned to this node,\r\n      // if there is no entry for this \"owner\", create one inline\r\n      // and set the unlock as though an owner entry had always existed\r\n          unlock = this.key( owner ),\r\n          cache = this.cache[ unlock ];\r\n\r\n      // Handle: [ owner, key, value ] args\r\n      if ( typeof data === \"string\" ) {\r\n        cache[ data ] = value;\r\n\r\n        // Handle: [ owner, { properties } ] args\r\n      } else {\r\n        // Fresh assignments by object are shallow copied\r\n        if ( $.isEmptyObject( cache ) ) {\r\n          $.extend( this.cache[ unlock ], data );\r\n          // Otherwise, copy the properties one-by-one to the cache object\r\n        } else {\r\n          for ( prop in data ) {\r\n            cache[ prop ] = data[ prop ];\r\n          }\r\n        }\r\n      }\r\n      return cache;\r\n    },\r\n    get: function( owner, key ) {\r\n      // Either a valid cache is found, or will be created.\r\n      // New caches will be created and the unlock returned,\r\n      // allowing direct access to the newly created\r\n      // empty data object. A valid owner object must be provided.\r\n      var cache = this.cache[ this.key( owner ) ];\r\n\r\n      return key === undefined ?\r\n          cache : cache[ key ];\r\n    },\r\n    access: function( owner, key, value ) {\r\n      var stored;\r\n      // In cases where either:\r\n      //\r\n      //   1. No key was specified\r\n      //   2. A string key was specified, but no value provided\r\n      //\r\n      // Take the \"read\" path and allow the get method to determine\r\n      // which value to return, respectively either:\r\n      //\r\n      //   1. The entire cache object\r\n      //   2. The data stored at the key\r\n      //\r\n      if ( key === undefined ||\r\n          ((key && typeof key === \"string\") && value === undefined) ) {\r\n\r\n        stored = this.get( owner, key );\r\n\r\n        return stored !== undefined ?\r\n            stored : this.get( owner, $.camelCase(key) );\r\n      }\r\n\r\n      // [*]When the key is not a string, or both a key and value\r\n      // are specified, set or extend (existing objects) with either:\r\n      //\r\n      //   1. An object of properties\r\n      //   2. A key and value\r\n      //\r\n      this.set( owner, key, value );\r\n\r\n      // Since the \"set\" path can have two possible entry points\r\n      // return the expected data based on which path was taken[*]\r\n      return value !== undefined ? value : key;\r\n    },\r\n    remove: function( owner, key ) {\r\n      var i, name, camel,\r\n          unlock = this.key( owner ),\r\n          cache = this.cache[ unlock ];\r\n\r\n      if ( key === undefined ) {\r\n        this.cache[ unlock ] = {};\r\n\r\n      } else {\r\n        // Support array or space separated string of keys\r\n        if ( $.isArray( key ) ) {\r\n          // If \"name\" is an array of keys...\r\n          // When data is initially created, via (\"key\", \"val\") signature,\r\n          // keys will be converted to camelCase.\r\n          // Since there is no way to tell _how_ a key was added, remove\r\n          // both plain key and camelCase key. #12786\r\n          // This will only penalize the array argument path.\r\n          name = key.concat( key.map( $.camelCase ) );\r\n        } else {\r\n          camel = $.camelCase( key );\r\n          // Try the string as a key before any manipulation\r\n          if ( key in cache ) {\r\n            name = [ key, camel ];\r\n          } else {\r\n            // If a key with the spaces exists, use it.\r\n            // Otherwise, create an array by matching non-whitespace\r\n            name = camel;\r\n            name = name in cache ?\r\n                [ name ] : ( name.match( core_rnotwhite ) || [] );\r\n          }\r\n        }\r\n\r\n        i = name.length;\r\n        while ( i-- ) {\r\n          delete cache[ name[ i ] ];\r\n        }\r\n      }\r\n    },\r\n    hasData: function( owner ) {\r\n      return !$.isEmptyObject(\r\n          this.cache[ owner[ this.expando ] ] || {}\r\n      );\r\n    },\r\n    discard: function( owner ) {\r\n      if ( owner[ this.expando ] ) {\r\n        delete this.cache[ owner[ this.expando ] ];\r\n      }\r\n    }\r\n  };\r\n\r\n  var data_priv = new Data();\r\n\r\n  $.extend($, {\r\n    queue: function( elem, type, data ) {\r\n      var queue;\r\n\r\n      if ( elem ) {\r\n        type = ( type || \"fx\" ) + \"queue\";\r\n        queue = data_priv.get( elem, type );\r\n\r\n        // Speed up dequeue by getting out quickly if this is just a lookup\r\n        if ( data ) {\r\n          if ( !queue || $.isArray( data ) ) {\r\n            queue = data_priv.access( elem, type, $.makeArray(data) );\r\n          } else {\r\n            queue.push( data );\r\n          }\r\n        }\r\n        return queue || [];\r\n      }\r\n    },\r\n\r\n    dequeue: function( elem, type ) {\r\n      type = type || \"fx\";\r\n\r\n      var queue = $.queue( elem, type ),\r\n          startLength = queue.length,\r\n          fn = queue.shift(),\r\n          hooks = $._queueHooks( elem, type ),\r\n          next = function() {\r\n            $.dequeue( elem, type );\r\n          };\r\n\r\n      // If the fx queue is dequeued, always remove the progress sentinel\r\n      if ( fn === \"inprogress\" ) {\r\n        fn = queue.shift();\r\n        startLength--;\r\n      }\r\n\r\n      if ( fn ) {\r\n\r\n        // Add a progress sentinel to prevent the fx queue from being\r\n        // automatically dequeued\r\n        if ( type === \"fx\" ) {\r\n          queue.unshift( \"inprogress\" );\r\n        }\r\n\r\n        // clear up the last queue stop function\r\n        delete hooks.stop;\r\n        fn.call( elem, next, hooks );\r\n      }\r\n\r\n      if ( !startLength && hooks ) {\r\n        hooks.empty.fire();\r\n      }\r\n    },\r\n\r\n    // not intended for public consumption - generates a queueHooks object, or returns the current one\r\n    _queueHooks: function( elem, type ) {\r\n      var key = type + \"queueHooks\";\r\n      return data_priv.get( elem, key ) || data_priv.access( elem, key, {\r\n        empty: $.Callbacks(\"once memory\").add(function() {\r\n          data_priv.remove( elem, [ type + \"queue\", key ] );\r\n        })\r\n      });\r\n    },\r\n\r\n    // array operations\r\n    makeArray: function( arr, results ) {\r\n      var ret = results || [];\r\n\r\n      if ( arr != null ) {\r\n        if ( isArraylike( Object(arr) ) ) {\r\n          $.merge( ret,\r\n              typeof arr === \"string\" ?\r\n                  [ arr ] : arr\r\n          );\r\n        } else {\r\n          core_push.call( ret, arr );\r\n        }\r\n      }\r\n\r\n      return ret;\r\n    },\r\n    merge: function( first, second ) {\r\n      var l = second.length,\r\n          i = first.length,\r\n          j = 0;\r\n\r\n      if ( typeof l === \"number\" ) {\r\n        for ( ; j < l; j++ ) {\r\n          first[ i++ ] = second[ j ];\r\n        }\r\n      } else {\r\n        while ( second[j] !== undefined ) {\r\n          first[ i++ ] = second[ j++ ];\r\n        }\r\n      }\r\n\r\n      first.length = i;\r\n\r\n      return first;\r\n    }\r\n  });\r\n\r\n  $.extend($.fn, {\r\n    queue: function( type, data ) {\r\n      var setter = 2;\r\n\r\n      if ( typeof type !== \"string\" ) {\r\n        data = type;\r\n        type = \"fx\";\r\n        setter--;\r\n      }\r\n\r\n      if ( arguments.length < setter ) {\r\n        return $.queue( this[0], type );\r\n      }\r\n\r\n      return data === undefined ?\r\n          this :\r\n          this.each(function() {\r\n            var queue = $.queue( this, type, data );\r\n\r\n            // ensure a hooks for this queue\r\n            $._queueHooks( this, type );\r\n\r\n            if ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\r\n              $.dequeue( this, type );\r\n            }\r\n          });\r\n    },\r\n    dequeue: function( type ) {\r\n      return this.each(function() {\r\n        $.dequeue( this, type );\r\n      });\r\n    },\r\n    // Based off of the plugin by Clint Helfers, with permission.\r\n    // http://blindsignals.com/index.php/2009/07/jquery-delay/\r\n    delay: function( time, type ) {\r\n      time = $.fx ? $.fx.speeds[ time ] || time : time;\r\n      type = type || \"fx\";\r\n\r\n      return this.queue( type, function( next, hooks ) {\r\n        var timeout = setTimeout( next, time );\r\n        hooks.stop = function() {\r\n          clearTimeout( timeout );\r\n        };\r\n      });\r\n    },\r\n    clearQueue: function( type ) {\r\n      return this.queue( type || \"fx\", [] );\r\n    },\r\n    // Get a promise resolved when queues of a certain type\r\n    // are emptied (fx is the type by default)\r\n    promise: function( type, obj ) {\r\n      var tmp,\r\n          count = 1,\r\n          defer = $.Deferred(),\r\n          elements = this,\r\n          i = this.length,\r\n          resolve = function() {\r\n            if ( !( --count ) ) {\r\n              defer.resolveWith( elements, [ elements ] );\r\n            }\r\n          };\r\n\r\n      if ( typeof type !== \"string\" ) {\r\n        obj = type;\r\n        type = undefined;\r\n      }\r\n      type = type || \"fx\";\r\n\r\n      while( i-- ) {\r\n        tmp = data_priv.get( elements[ i ], type + \"queueHooks\" );\r\n        if ( tmp && tmp.empty ) {\r\n          count++;\r\n          tmp.empty.add( resolve );\r\n        }\r\n      }\r\n      resolve();\r\n      return defer.promise( obj );\r\n    }\r\n  });\r\n\r\n  return $;\r\n\r\n});\r\n\ndefine('skylark-domx-plugins-base/plugins',[\r\n    \"skylark-langx-ns\"\r\n], function(skylark) {\r\n    \"use strict\";\r\n\r\n    var pluginKlasses = {},\r\n        shortcuts = {};\r\n\r\n\r\n    return  skylark.attach(\"domx.plugins\",{\r\n        pluginKlasses,\r\n        shortcuts\r\n    });\r\n});\ndefine('skylark-langx-events/Emitter',[\r\n  \"skylark-langx-types\",\r\n  \"skylark-langx-objects\",\r\n  \"skylark-langx-arrays\",\r\n  \"skylark-langx-klass\",\r\n  \"./events\",\r\n  \"./event\",\r\n  \"./listener\"\r\n],function(types,objects,arrays,klass,events,Event,Listener){\r\n    var slice = Array.prototype.slice,\r\n        compact = arrays.compact,\r\n        isDefined = types.isDefined,\r\n        isPlainObject = types.isPlainObject,\r\n        isFunction = types.isFunction,\r\n        isString = types.isString,\r\n        isEmptyObject = types.isEmptyObject,\r\n        mixin = objects.mixin,\r\n        safeMixin = objects.safeMixin;\r\n\r\n    function parse(event) {\r\n        var segs = (\"\" + event).split(\".\");\r\n        return {\r\n            name: segs[0],\r\n            ns: segs.slice(1).join(\" \")\r\n        };\r\n    }\r\n\r\n    \r\n    var queues  = new Map();\r\n\r\n\r\n    var Emitter = Listener.inherit({\r\n        _prepareArgs : function(e,args) {\r\n            if (isDefined(args)) {\r\n                args = [e].concat(args);\r\n            } else {\r\n                args = [e];\r\n            }\r\n            return args;\r\n        },\r\n\r\n        on: function(events, selector, data, callback, ctx, /*used internally*/ one) {\r\n            var self = this,\r\n                _hub = this._hub || (this._hub = {});\r\n\r\n            if (isPlainObject(events)) {\r\n                ctx = callback;\r\n                each(events, function(type, fn) {\r\n                    self.on(type, selector, data, fn, ctx, one);\r\n                });\r\n                return this;\r\n            }\r\n\r\n            if (!isString(selector) && !isFunction(callback)) {\r\n                ctx = callback;\r\n                callback = data;\r\n                data = selector;\r\n                selector = undefined;\r\n            }\r\n\r\n            if (isFunction(data)) {\r\n                ctx = callback;\r\n                callback = data;\r\n                data = null;\r\n            }\r\n\r\n            if (!callback ) {\r\n                throw new Error(\"No callback function\");\r\n            } else if (!isFunction(callback)) {\r\n                throw new Error(\"The callback  is not afunction\");\r\n            }\r\n\r\n            if (isString(events)) {\r\n                events = events.split(/\\s/)\r\n            }\r\n\r\n            events.forEach(function(event) {\r\n                var parsed = parse(event),\r\n                    name = parsed.name,\r\n                    ns = parsed.ns;\r\n\r\n                (_hub[name] || (_hub[name] = [])).push({\r\n                    fn: callback,\r\n                    selector: selector,\r\n                    data: data,\r\n                    ctx: ctx,\r\n                    ns : ns,\r\n                    one: one\r\n                });\r\n            });\r\n\r\n            return this;\r\n        },\r\n\r\n        one: function(events, selector, data, callback, ctx) {\r\n            return this.on(events, selector, data, callback, ctx, 1);\r\n        },\r\n\r\n        emit: function(e /*,argument list*/ ) {\r\n            if (!this._hub) {\r\n                return this;\r\n            }\r\n\r\n            var self = this;\r\n\r\n            if (isString(e)) {\r\n                e = new Event(e); //new CustomEvent(e);\r\n            }\r\n\r\n            Object.defineProperty(e,\"target\",{\r\n                value : this\r\n            });\r\n\r\n            var args = slice.call(arguments, 1);\r\n\r\n            args = this._prepareArgs(e,args);\r\n\r\n            [e.type || e.name, \"all\"].forEach(function(eventName) {\r\n                var parsed = parse(eventName),\r\n                    name = parsed.name,\r\n                    ns = parsed.ns;\r\n\r\n                var listeners = self._hub[name];\r\n                if (!listeners) {\r\n                    return;\r\n                }\r\n\r\n                var len = listeners.length,\r\n                    reCompact = false;\r\n\r\n                for (var i = 0; i < len; i++) {\r\n                    if (e.isImmediatePropagationStopped && e.isImmediatePropagationStopped()) {\r\n                        return this;\r\n                    }\r\n                    var listener = listeners[i];\r\n                    if (ns && (!listener.ns ||  !listener.ns.startsWith(ns))) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (listener.data) {\r\n                        e.data = mixin({}, listener.data, e.data);\r\n                    }\r\n                    if (args.length == 2 && isPlainObject(args[1])) {\r\n                        e.data = e.data || {};\r\n                        mixin(e.data,args[1]);\r\n                    }\r\n\r\n                    listener.fn.apply(listener.ctx, args);\r\n                    if (listener.one) {\r\n                        listeners[i] = null;\r\n                        reCompact = true;\r\n                    }\r\n                }\r\n\r\n                if (reCompact) {\r\n                    self._hub[eventName] = compact(listeners);\r\n                }\r\n\r\n            });\r\n            return this;\r\n        },\r\n\r\n        queueEmit : function (event) {\r\n            const type = event.type || event;\r\n            let map = queues.get(this);\r\n            if (!map) {\r\n                map = new Map();\r\n                queues.set(this, map);\r\n            }\r\n            const oldTimeout = map.get(type);\r\n            map.delete(type);\r\n            window.clearTimeout(oldTimeout);\r\n            const timeout = window.setTimeout(() => {\r\n                if (map.size === 0) {\r\n                    map = null;\r\n                    queues.delete(this);\r\n                }\r\n                this.trigger(event);\r\n            }, 0);\r\n            map.set(type, timeout);\r\n        },\r\n\r\n        listened: function(event) {\r\n            var evtArr = ((this._hub || (this._events = {}))[event] || []);\r\n            return evtArr.length > 0;\r\n        },\r\n\r\n        off: function(events, callback) {\r\n            if (!events) {\r\n              this._hub = null;\r\n              return;\r\n            }\r\n            var _hub = this._hub || (this._hub = {});\r\n            if (isString(events)) {\r\n                events = events.split(/\\s/)\r\n            }\r\n\r\n            events.forEach(function(event) {\r\n                var parsed = parse(event),\r\n                    name = parsed.name,\r\n                    ns = parsed.ns;\r\n\r\n                var evts = _hub[name];\r\n\r\n                if (evts) {\r\n                    var liveEvents = [];\r\n\r\n                    if (callback || ns) {\r\n                        for (var i = 0, len = evts.length; i < len; i++) {\r\n                            \r\n                            if (callback && evts[i].fn !== callback && evts[i].fn._ !== callback) {\r\n                                liveEvents.push(evts[i]);\r\n                                continue;\r\n                            } \r\n\r\n                            if (ns && (!evts[i].ns || evts[i].ns.indexOf(ns)!=0)) {\r\n                                liveEvents.push(evts[i]);\r\n                                continue;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (liveEvents.length) {\r\n                        _hub[name] = liveEvents;\r\n                    } else {\r\n                        delete _hub[name];\r\n                    }\r\n\r\n                }\r\n            });\r\n\r\n            return this;\r\n        },\r\n\r\n        trigger  : function() {\r\n            return this.emit.apply(this,arguments);\r\n        },\r\n\r\n        queueTrigger : function (event) {\r\n            return this.queueEmit.apply(this,arguments);\r\n        }\r\n\r\n    });\r\n\r\n\r\n    return events.Emitter = Emitter;\r\n\r\n});\ndefine('skylark-domx-animates/animate',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-styler\",\r\n    \"skylark-domx-eventer\",\r\n    \"./animates\"\r\n], function(langx, styler, eventer,animates) {\r\n\r\n\r\n    function animate(elm,keyframes/*className*/,options) {\r\n        if (langx.isString(keyframes)) {\r\n            let className = keyframes;\r\n            if (animates.animateBaseClass) {\r\n              className = animates.animateBaseClass + \" \" + className;\r\n            }\r\n            styler.addClass(elm,className);\r\n            eventer.one(elm,animates.animationEnd, function() {\r\n                styler.removeClass(elm,className);\r\n            });\r\n            return this;\r\n        } else {\r\n            return elm.animate(keyframes,options);\r\n        }\r\n\r\n    }\r\n    \r\n    return animates.animate = animate;\r\n });\ndefine('skylark-domx-animates/main',[\r\n\t\"./animates\",\r\n \t\"skylark-domx-velm\",\r\n\t\"skylark-domx-query\",\r\n   \"./animation\",\r\n    \"./animate\"\r\n],function(animates,velm,$){\r\n    // from ./aanimates\r\n    velm.delegate([\r\n        \"animate\"\r\n    ], animates);\r\n\r\n    $.fn.animate =  $.wraps.wrapper_every_act(animates.animate, animates);\r\n\r\n\treturn animates;\r\n});\ndefine('skylark-domx-animates', ['skylark-domx-animates/main'], function (main) { return main; });\n\ndefine('skylark-domx/animates',[\r\n    \"skylark-domx-animates\"\r\n], function( animates) {\r\n    return animates;\r\n});\ndefine('skylark-domx/browser',[\r\n    \"skylark-domx-browser\"\r\n], function(browser) {\r\n    \"use strict\";\r\n\r\n    return browser;\r\n});\r\n\ndefine('skylark-domx-css/css',[\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-noder\"\r\n], function(skylark, langx, noder) {\r\n    \"use strict\";\r\n\r\n    var head = document.getElementsByTagName(\"head\")[0],\r\n        count = 0,\r\n        sheetsByUrl = {},\r\n        sheetsById = {},\r\n        defaultSheetId = _createStyleSheet(),\r\n        defaultSheet = sheetsById[defaultSheetId],\r\n        rulesPropName = (\"cssRules\" in defaultSheet) ? \"cssRules\" : \"rules\",\r\n        insertRuleFunc,\r\n        deleteRuleFunc = defaultSheet.deleteRule || defaultSheet.removeRule;\r\n\r\n    if (defaultSheet.insertRule) {\r\n        var _insertRule = defaultSheet.insertRule;\r\n        insertRuleFunc = function(selector, css, index) {\r\n            _insertRule.call(this, selector + \"{\" + css + \"}\", index);\r\n        };\r\n    } else {\r\n        insertRuleFunc = defaultSheet.addRule;\r\n    }\r\n\r\n    function normalizeSelector(selectorText) {\r\n        var selector = [],\r\n            last, len;\r\n        last = defaultSheet[rulesPropName].length;\r\n        insertRuleFunc.call(defaultSheet, selectorText, ';');\r\n        len = defaultSheet[rulesPropName].length;\r\n        for (var i = len - 1; i >= last; i--) {\r\n            selector.push(_sheet[_rules][i].selectorText);\r\n            deleteRuleFunc.call(defaultSheet, i);\r\n        }\r\n        return selector.reverse().join(', ');\r\n    }\r\n\r\n    /*\r\n     * create a stylesheet element.\r\n     * @param {Boolean} external\r\n     * @param {Object} options\r\n     * @param {String} [options.media = null]\r\n     */\r\n    function _createStyleSheet(external,options ) {\r\n        var node,\r\n            props = {\r\n                type : \"text/css\"\r\n            },\r\n            id = (count++);\r\n\r\n        options = options || {};\r\n        if (options.media) {\r\n            props.media = options.media;\r\n        }\r\n\r\n        if (external) {\r\n            node = noder.create(\"link\",langx.mixin(props,{\r\n                rel  : \"stylesheet\",\r\n                async : false\r\n            }));\r\n        } else {\r\n            node = noder.createElement(\"style\",props);\r\n        }\r\n\r\n        noder.append(head,node);\r\n        sheetsById[id] = {\r\n            id : id,\r\n            node :node\r\n        };\r\n\r\n        return id;\r\n    }\r\n\r\n    function createStyleSheet(css,options) {\r\n        if (!options) {\r\n            options = {};\r\n        }\r\n        var sheetId = _createStyleSheet(false,options);\r\n        if (css) {\r\n            addSheetRules(sheetId,css);\r\n        }\r\n\r\n        return sheetId;\r\n    }\r\n\r\n    function loadStyleSheet(url, options,loadedCallback, errorCallback) {\r\n        if (langx.isFunction(options)) {\r\n            errorCallback = loadedCallback;\r\n            loadedCallback = options;\r\n            options = {};\r\n        }\r\n        var sheet = sheetsByUrl[url];\r\n        if (!sheet) {\r\n            var sheetId = _createStyleSheet(true,options);\r\n\r\n            sheet = sheetsByUrl[url] = sheetsById[sheetId];\r\n            langx.mixin(sheet,{\r\n                state: 0, //0:unload,1:loaded,-1:loaderror\r\n                url : url,\r\n                deferred : new langx.Deferred()\r\n            });\r\n\r\n            var node = sheet.node;\r\n\r\n            startTime = new Date().getTime();\r\n\r\n            node.onload = function() {\r\n                sheet.state = 1;\r\n                sheet.deferred.resolve(sheet.id);\r\n            },\r\n            node.onerror = function(e) {\r\n                sheet.state = -1;\r\n                sheet.deferred.reject(e);\r\n            };\r\n\r\n            node.href = sheet.url;\r\n        }\r\n        if (loadedCallback || errorCallback) {\r\n            sheet.deferred.promise.then(loadedCallback,errorCallback);\r\n        }\r\n        return sheet.id;\r\n    }\r\n\r\n    function deleteSheetRule(sheetId, rule) {\r\n        var sheet = sheetsById[sheetId];\r\n        if (langx.isNumber(rule)) {\r\n            deleteRuleFunc.call(sheet, rule);\r\n        } else {\r\n            langx.each(sheet[rulesPropName], function(i, _rule) {\r\n                if (rule === _rule) {\r\n                    deleteRuleFunc.call(sheet, i);\r\n                    return false;\r\n                }\r\n            });\r\n        }\r\n        return this;\r\n    }\r\n\r\n    function deleteRule(rule) {\r\n        deleteSheetRule(defaultSheetId, rule);\r\n        return this;\r\n    }\r\n\r\n    function removeStyleSheet(sheetId) {\r\n        if (sheetId === defaultSheetId) {\r\n            throw new Error(\"The default stylesheet can not be deleted\");\r\n        }\r\n        var sheet = sheetsById[sheetId];\r\n        delete sheetsById[sheetId];\r\n\r\n        noder.remove(sheet.node);\r\n        return this;\r\n    }\r\n\r\n    /*\r\n     * insert a rule to the default stylesheet.\r\n     * @param {String} selector\r\n     * @param {String} css\r\n     * @param {Number} index \r\n     */\r\n    function insertRule(selector, css, index) {\r\n        return this.insertSheetRule(defaultSheetId, selector, css, index);\r\n    }\r\n\r\n    /*\r\n     * Add rules to the default stylesheet.\r\n     * @param {Object} rules\r\n     */\r\n    function addRules(rules) {\r\n        return this.addRules(defaultSheetId,rules);\r\n    }\r\n\r\n    /*\r\n     * insert a rule to the stylesheet specified by sheetId.\r\n     * @param {Number} sheetId  \r\n     * @param {String} selector\r\n     * @param {String} css\r\n     * @param {Number} index \r\n     */\r\n    function insertSheetRule(sheetId, selector, css, index) {\r\n        if (!selector || !css) {\r\n            return -1;\r\n        }\r\n\r\n        var sheet = sheetsById[sheetId];\r\n        index = index || sheet[rulesPropName].length;\r\n\r\n        return insertRuleFunc.call(sheet, selector, css, index);\r\n    }\r\n\r\n    /*\r\n     * Add  rules to stylesheet.\r\n     * @param {Number} sheetId  \r\n     * @param {Object|String} rules\r\n     * @return this\r\n     * @example insertSheetRules(sheetId,{\r\n     * \r\n     * });\r\n     */\r\n    function addSheetRules(sheetId,rules) {\r\n        var sheet = sheetsById[sheetId],\r\n            css;\r\n        if (langx.isString(rules)) {\r\n            css = rules;\r\n        } else {\r\n            css = toString(rules);\r\n        }\r\n\r\n        noder.append(sheet.node,noder.createTextNode(css));\r\n        \r\n        return this;\r\n    }\r\n\r\n    function isAtRule(str) {\r\n        return str.startsWith(\"@\");\r\n    }\r\n\r\n    function toString(json){\r\n        var adjust = function(parentName,name,depth) {\r\n            if (parentName) {\r\n                if (isAtRule(parentName)) {\r\n                    depth += 1;\r\n                } else {\r\n                    name =  parentName + \" \" + name;\r\n                }                \r\n            }\r\n            return {\r\n                name : name,\r\n                depth : depth\r\n            }\r\n        };\r\n\r\n        var strNode = function (name, values, depth) {\r\n            var str = \"\",\r\n                atFlg = isAtRule(name);\r\n\r\n\r\n            if (isAtRule(name)) {\r\n                // at rule\r\n                if (langx.isString(values)) {\r\n                    // an at rule without block\r\n                    // ex: (1) @charset 'utf8';\r\n                    str = css.SPACE.repeat(depth) + name.trim() + \" \\\"\" + values.trim() + \" \\\";\\n\";\r\n                } else {\r\n                    // an at rule with block, ex :\r\n                    //  @media 'screen' {\r\n                    //  }\r\n                    str += css.SPACE.repeat(depth) + name.trim() + \" {\\n\";\r\n                    str += strNode(\"\",values,depth+1);\r\n                    str += css.SPACE.repeat(depth) + \" }\\n\";\r\n                }\r\n            } else {\r\n                // a selector or a property\r\n                if (langx.isString(values)) {\r\n                    // a css property \r\n                    // ex : (1) font-color : red;\r\n                    str = css.SPACE.repeat(depth) + name.trim() ;\r\n                    if (atFlg) {\r\n                        str = str +  \" \\\"\" + values.trim() + \" \\\";\\n\";\r\n                    } else {\r\n                        str = str + ': ' + values.trim() + \";\\n\";\r\n                    }\r\n\r\n                } else {\r\n                    // a selector rule \r\n                    // ex : (1) .class1 : {\r\n                    //            font-color : red;\r\n                    //          }\r\n                    if (langx.isArray(values)) {\r\n                        // array for ordering\r\n                        for (var n =0; n<values.length; n ++) {\r\n                           str +=  strNode(name,values[n],depth);\r\n                        }\r\n                    } else {\r\n                        // plain object\r\n\r\n                        if (name) {\r\n                            str += css.SPACE.repeat(depth) + name.trim() + \" {\\n\";\r\n\r\n                            for (var n in values) {\r\n                                var value =values[n];\r\n                                if (langx.isString(value)) {\r\n                                    // css property\r\n                                    str += strNode(n,value,depth+1)\r\n                                }\r\n                            }\r\n\r\n                            str += css.SPACE.repeat(depth) + \"}\\n\";\r\n                        }\r\n\r\n                        for (var n in values) {\r\n                            var value =values[n];\r\n                            if (!langx.isString(value)) {\r\n                                var adjusted = adjust(name,n,depth);\r\n                                str +=  strNode(adjusted.name,value,adjusted.depth);\r\n                            } \r\n                        }\r\n\r\n                    }\r\n                }\r\n            }   \r\n\r\n            return str;\r\n        };\r\n\r\n\r\n        return strNode(\"\",json,0);\r\n    }\r\n \r\n\r\n    function css() {\r\n        return css;\r\n    }\r\n\r\n    langx.mixin(css, {\r\n        SPACE : \"\\t\",\r\n\r\n        addRules : addRules,\r\n\r\n        addSheetRules : addSheetRules,\r\n\r\n        createStyleSheet: createStyleSheet,\r\n\r\n        deleteSheetRule : deleteSheetRule,\r\n\r\n        deleteRule : deleteRule,\r\n\r\n        insertRule : insertRule,\r\n\r\n        insertSheetRule : insertSheetRule,\r\n\r\n        loadStyleSheet : loadStyleSheet,\r\n\r\n        removeStyleSheet : removeStyleSheet,\r\n\r\n        toString : toString\r\n    });\r\n\r\n    return skylark.attach(\"domx.css\", css);\r\n});\r\n\ndefine('skylark-domx-css/main',[\r\n\t\"./css\"\r\n],function(css){\r\n\treturn css;\r\n});\ndefine('skylark-domx-css', ['skylark-domx-css/main'], function (main) { return main; });\n\ndefine('skylark-domx/css',[\r\n    \"skylark-domx-css\"\r\n], function( css) {\r\n    \"use strict\";\r\n\r\n     return css;\r\n});\r\n\ndefine('skylark-domx/data',[\r\n    \"skylark-domx-data\"\r\n], function( data) {\r\n \r\n    return data;\r\n});\ndefine('skylark-domx/eventer',[\r\n    \"skylark-domx-eventer\"\r\n], function( eventer) {\r\n \r\n    return eventer;\r\n});\ndefine('skylark-domx/finder',[\r\n    \"skylark-domx-finder\"\r\n], function( finder) {\r\n\r\n    return finder;\r\n});\ndefine('skylark-domx/fx',[\r\n    \"skylark-domx-fx\"\r\n], function( fx) {\r\n    return fx;\r\n});\ndefine('skylark-domx/geom',[\r\n    \"skylark-domx-geom\"\r\n], function( geom) {\r\n\r\n    return geom;\r\n});\ndefine('skylark-domx-iframes/iframes',[\r\n\t\"skylark-langx-ns\"\r\n],function(skylark){\r\n\treturn skylark.attach(\"domx.iframes\");\r\n});\ndefine('skylark-domx-iframes/create',[\r\n  \"skylark-domx-noder\",\r\n  \"./iframes\"\r\n],function(noder,iframes){\r\n  'use strict';\r\n\r\n  function create(options,parentElm) {\r\n  \t  options = options || {\r\n  \t  };\r\n\r\n  \t  let props = {},\r\n  \t  \t  attrs = {};\r\n\r\n  \t  if (options.id) {\r\n  \t  \tprops.id = options.id;\r\n  \t  };\r\n\r\n  \t  if (options.url) {\r\n  \t  \tprops.src = options.url;\r\n  \t  };\r\n\r\n  \t  if (options.style) {\r\n  \t  \tprops.style = options.style;\r\n  \t  }\r\n\r\n  \t  if (options.onload) {\r\n  \t  \tprops.onload = options.onload;\r\n  \t  }\r\n\r\n  \t  if (options.onerror) {\r\n  \t  \tprops.onload = options.onerror;\r\n  \t  }\r\n\r\n  \t  if (options.className) {\r\n  \t  \tprops.className = options.className;\r\n  \t  }\r\n\r\n  \t  if (options.sandbox) {\r\n  \t  \tattrs.sandbox = options.sandbox;\r\n  \t  }\r\n\r\n  \t  if (options.frameBorder) {\r\n  \t  \tattrs.frameBorder = options.frameBorder;  \t  \t\r\n  \t  }\r\n\r\n  \t  if (options.name) {\r\n  \t  \tattrs.name = options.name;\r\n  \t  }\r\n\r\n  \t  /*\r\n      // Basic mode\r\n      // This adds the runner iframe to the page. It's only run once.\r\n      //if (!$live.find('iframe').length) {\r\n        iframe = noder.create(\"iframe\",{\r\n          ///iframe.src = jsbin.runner;\r\n          src : this.options.runnerUrl\r\n        },{\r\n          \"class\" : \"stretch\",\r\n          \"sandbox\", \"allow-modals allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts\",\r\n          \"frameBorder\": '0',\r\n          \"name\", \"<proxy>\",\r\n        },this._elm);\r\n\r\n        try {\r\n          ///iframe.contentWindow.name = '/' + jsbin.state.code + '/' + jsbin.state.revision;\r\n          iframe.contentWindow.name  = this.options.runnerName;\r\n        } catch (e) {\r\n          // ^- this shouldn't really fail, but if we're honest, it's a fucking mystery as to why it even works.\r\n          // problem is: if this throws (because iframe.contentWindow is undefined), then the execution exits\r\n          // and `var renderLivePreview` is set to undefined. The knock on effect is that the calls to renderLivePreview\r\n          // then fail, and jsbin doesn't boot up. Tears all round, so we catch.\r\n        }\r\n      //}\r\n\r\n      iframe.onload = () => {\r\n        if (window.postMessage) {\r\n          // setup postMessage listening to the runner\r\n          $window.on('message', (event) => {\r\n            this.handleMessage(event.originalEvent)\r\n          });\r\n          this.setup(iframe);\r\n          this._inited.resolve();\r\n        }\r\n      };\r\n\r\n      iframe.onerror = err => {\r\n        this._inited.reject(err);\r\n      };\r\n\r\n      */\r\n\r\n      let iframe = noder.create(\"iframe\",props,attrs,parentElm);\r\n\r\n      if (options.contentWindowName) {\r\n      \tiframe.contentWindow.name = options.contentWindowName;\r\n      }\r\n\r\n      return iframe;\r\n  }\r\n\r\n  return iframes.create = create;\r\n});\ndefine('skylark-domx-iframes/hook-sizing',[\r\n  \"skylark-domx-eventer\",\r\n  \"./iframes\"\r\n],function(eventer,iframes){\r\n  'use strict';\r\n\r\n  function hookSizing(iframe) {\r\n    var onmessage = function (event) {\r\n      if (!event) { event = window.event; }\r\n      ///TODO : how check message source\r\n      // * 1 to coerse to number, and + 2 to compensate for border\r\n      iframe.style.height = (event.data.height * 1 + 2) + 'px';\r\n    };\r\n\r\n    eventer.on(window,'message', onmessage);\r\n  }\r\n\r\n  return iframes.hookSizing = hookSizing;\r\n\r\n});\ndefine('skylark-domx-iframes/load-real',[\r\n  \"skylark-domx-noder\",\r\n  \"skylark-domx-data\",\r\n  \"./iframes\",\r\n  \"./hook-sizing\"\r\n],function(noder,datax,iframes,hookSizing){\r\n\r\n  function loadReal(iframe,options) {\r\n    options = options || {};\r\n    var clone = noder.clone(iframe);\r\n    var url = options.url;\r\n    if (!url) {\r\n      url = datax.attr(clone,options.urlAttrName || 'data-url');\r\n    }\r\n    url = url.split('&')[0];\r\n    datax.prop(clone,\"src\",url);\r\n    datax.prop(clone,\"_src\",url); // support for google slide embed\r\n    noder.replace(clone,ifame);\r\n    ///hookSizing(clone);\r\n  }\r\n\r\n  return iframes.loadReal = loadReal;  \r\n});\ndefine('skylark-domx-iframes/lazy-load',[\r\n\t\"skylark-domx-eventer\",\r\n\t\"skylark-domx-data\",\r\n\t\"skylark-domx-geom\",\r\n\t\"./iframes\",\r\n\t\"./load-real\"\r\n],function(eventer,datax,geom,iframes,loadReal){\r\n\tvar pending;\r\n\r\n\r\n  \tfunction check() {\r\n\t    var i = 0;\r\n\t    var todo = [];\r\n\t    for (i = 0; i < pending.length; i++) {\r\n\t      if (geom.inview(pending[i], 400)) {\r\n\t        todo.unshift({ iframe: pending[i], i: i });\r\n\t      }\r\n\t    }\r\n\r\n\t    for (i = todo.length -1 ; i >=0 ; i--) {\r\n\t      pending.splice(todo[i].i, 1);\r\n\t      loadReal(todo[i].iframe);\r\n\t    }\r\n  \t}\r\n\r\n\tfunction init() {\r\n\t\tif (pending) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tpending = [];\r\n\r\n\t\teventer.on(window,\"scroll\",function(){\r\n\t\t\tcheck();\r\n\t\t});\r\n\t}\r\n\r\n\tfunction lazyLoad(iframe,options) {\r\n\t\tinit();\r\n\r\n\t\toptions = options || {};\r\n\t\r\n      \t///iframe.setAttribute('data-url', url);\r\n      \t///iframe.src = 'https://jsbin.com/embed-holding';\r\n      \tif (options.url) {\r\n      \t\tdatax.attr(iframe,(options.urlAttrName || \"data-url\"),options.url)\r\n      \t}\r\n\r\n      \tif (options.holdingUrl) {\r\n      \t\tdatax.prop(iframe,\"src\",options.holdingUrl)      \t\t\r\n      \t}\r\n\r\n\t\tpending.push(iframe);\r\n\t}\r\n\r\n\treturn iframes.lazyLoad = lazyLoad\r\n});\ndefine('skylark-domx-iframes/replace',[\r\n  \"skylark-langx-urls/get-query\",\r\n  \"skylark-domx-noder\",\r\n  \"skylark-domx-geom\",\r\n  \"skylark-domx-styler\",\r\n  \"./iframes\",\r\n  \"./create\",\r\n  \"./load-real\",\r\n  \"./lazy-load\"\r\n],function(getQuery,noder,geom,styler,iframes,create,loadReal,lazyLoad){\r\n  'use strict';\r\n  \r\n  function replace(link,options) {\r\n    options = options || {};\r\n\r\n    /*\r\n    var iframe = noder.createElement('iframe',{\r\n      \"className\" : link.className, // inherit all the classes from the link\r\n      \"id\" : link.id, // also inherit, giving more style control to the user\r\n      \"style\" : { \"border\" : '1px solid #aaa'}\r\n    });\r\n    */\r\n\r\n    var ifarme =create({\r\n      \"className\" : link.className, // inherit all the classes from the link\r\n      \"id\" : link.id, // also inherit, giving more style control to the user\r\n      \"style\" : { \r\n        \"border\" : '1px solid #aaa'\r\n      }\r\n    });\r\n    ///var url = link.href.replace(/edit/, 'embed');\r\n    var url = options.url || link.href,\r\n        size = options.size || getQuery(link.search),\r\n        holdingUrl = options.holdingUrl;\r\n\r\n    styler.css(iframe,\"width\", size.width || '100%');\r\n    styler.css(iframe,\"minHeight\", size.height || '300px');\r\n    if (size.height) {\r\n      styler.css(iframe,\"maxHeight\", size.height);\r\n    }\r\n\r\n    // track when it comes into view and reload\r\n    if (geom.inview(link, 100)) {\r\n      // the iframe is full view, let's render it\r\n      ///iframe.src = url.split('&')[0];\r\n      ///iframe._src = url.split('&')[0]; // support for google slide embed\r\n      ///hookMessaging(iframe);\r\n      loadReal(iframe,{url})\r\n    } else {\r\n      ///iframe.setAttribute('data-url', url);\r\n      ///iframe.src = 'https://jsbin.com/embed-holding';\r\n      ///pending.push(iframe);\r\n      lazyLoad(iframe,{\r\n        url,\r\n        holdingUrl\r\n      });\r\n\r\n    }\r\n\r\n    noder.replace(iframe, link);\r\n  }\r\n\r\n  return iframes.replace = replace;\r\n});\ndefine('skylark-domx-iframes/main',[\r\n\t\"./iframes\",\r\n\t\"./create\",\r\n\t\"./lazy-load\",\r\n\t\"./load-real\",\r\n\t\"./replace\"\r\n],function(){\r\n\t\r\n});\ndefine('skylark-domx-iframes', ['skylark-domx-iframes/main'], function (main) { return main; });\n\ndefine('skylark-domx/iframes',[\r\n    \"skylark-domx-iframes\"\r\n], function( iframes) {\r\n    return iframes;\r\n});\ndefine('skylark-domx-lists/lists',[\r\n\t\"skylark-langx-ns\",\r\n\t\"skylark-domx-query\",\r\n\t\"skylark-domx-data\",\r\n\t\"skylark-domx-geom\",\r\n\t\"skylark-domx-finder\",\r\n\t\"skylark-domx-noder\",\r\n\t\"skylark-domx-styler\"\r\n],function(skylark){\r\n\treturn skylark.attach(\"domx.lists\");\r\n});\ndefine('skylark-domx-lists/multitier',[\r\n\t\"skylark-langx\",\r\n\t\"skylark-domx-query\",\r\n\t\"./lists\"\r\n],function(langx,$,lists){\r\n  'use strict'\r\n\r\n\tfunction multitier(elm,options) {\r\n\t\toptions = langx.mixin({\r\n\r\n\t\t\tclasses : {\r\n\t\t\t\tactive : \"active\",\r\n\t\t\t\tcollapse : \"collapse\",\r\n\t\t\t\tin : \"in\",\r\n\t\t\t},\r\n\r\n\t\t\tselectors : {\r\n\t\t\t\titem : \"li\",                   // \".list-group-item\"\r\n\t\t\t\tsublist : \"ul\",  // \"> .list-group\"\r\n\t\t\t\thasSublist : \":has(ul)\",\r\n\t\t\t\thandler : \" > a\"\r\n\t\t\t},\r\n\r\n\r\n\t\t\tmode   : \"\",  // \"tree\" or \"accordion\" or \"popover\"\r\n\r\n\t\t\tlevels : 2,\r\n\r\n\t\t\ttogglable : false,\r\n\t\t\tmultiExpand : false,\r\n\r\n\t\t\t/*\r\n\t\t\tshow : function($el) {\r\n\t\t\t\t$el.show();\r\n\t\t\t},\r\n\r\n\t\t\thide : function($el) {\r\n\t\t\t\t//$el.hide();\r\n\t\t\t\t$el.add\r\n\t\t\t},\r\n\r\n\t\t\ttoggle : function($el) {\r\n\t\t\t\t$el.toggle();\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t},options,true);\r\n\r\n    var itemSelector = options.selectors.item,\r\n        $items = $(itemSelector,elm),\r\n\r\n        activeClass = options.classes.active,\r\n        activeSelector = \".\" + activeClass,\r\n\r\n\t\tmultitierMode = options.mode,\r\n\r\n        sublistSelector = options.selectors.sublist,  \r\n        togglable = options.togglable,   \r\n        multiExpand = options.multiExpand,\r\n        handlerSelector = options.selectors.handler,\r\n\r\n        collapseClass = options.classes.collapse,\r\n        inClass = options.classes.in,\r\n        inSelector = \".\" + inClass,\r\n\r\n        show = options.show || function($el) {\r\n        \t$el.addClass(inClass);\r\n        },\r\n        hide = options.hide || function($el) {\r\n        \t$el.addClass(collapseClass).removeClass(inClass);\r\n\r\n        },\r\n        toggle = options.toggle || function($el) {\r\n\t\t\tif ($el.hasClass(inClass)) {\r\n\t\t\t\thide($el);\r\n\t\t\t} else {\r\n\t\t\t\tshow($el);\r\n\t\t\t}\r\n        };\r\n\r\n     $items.find(handlerSelector).on(\"click.multitier\", function(e) {\r\n          e.preventDefault();\r\n\r\n          let $children,\r\n          \t  $clickedItem =  $(this).closest(itemSelector);\r\n\r\n          if (!multiExpand) {\r\n              ///langx.scall($(this).closest(itemSelector).siblings().removeClass(\"active\").children(sublistSelector+\".in\").plugin(\"domx.toggles.collapse\"),\"hide\");\r\n              //$clildren = $(this).closest(itemSelector).siblings().removeClass(activeClass).children(sublistSelector+\".\"+options.classes.in);\r\n              $children = $clickedItem.siblings().removeClass(activeClass).children(sublistSelector);\r\n              if ($children) {\r\n\t              hide($children);\r\n              }\r\n          }\r\n          //$(this).closest(itemSelector).toggleClass(activeClass).children(sublistSelector).plugin(\"domx.toggles.collapse\").toggle();\r\n          let isActiveItem = $clickedItem.hasClass(activeClass);\r\n          if (!isActiveItem || togglable) {\r\n\t          $children = $clickedItem.children(options.selectors.sublist);\r\n\t          if (isActiveItem) {\r\n\t\t\t\t$clickedItem.removeClass(activeClass);\r\n\t\t\t\thide($children)  \t\r\n\t          } else {\r\n\t\t\t\t$clickedItem.addClass(activeClass);\r\n\t\t\t\tshow($children)  \t\r\n\t          }\r\n\r\n          }\r\n      });\r\n\r\n      hide($items.has(sublistSelector).children(sublistSelector));\r\n\r\n      show($items.filter(activeSelector).has(sublistSelector).children(sublistSelector))\r\n\r\n\r\n\t}\r\n\r\n\treturn lists.multitier = multitier\r\n});\ndefine('skylark-domx-lists/main',[\r\n\t\"./lists\",\r\n\t\"./multitier\"\r\n],function(lists){\r\n\treturn lists;\r\n});\ndefine('skylark-domx-lists', ['skylark-domx-lists/main'], function (main) { return main; });\n\ndefine('skylark-domx/lists',[\r\n    \"skylark-domx-lists\"\r\n], function( lists) {\r\n\r\n    return lists;\r\n});\ndefine('skylark-domx/noder',[\r\n    \"skylark-domx-noder\"\r\n], function( noder) {\r\n\r\n    return noder;\r\n});\ndefine('skylark-domx/styler',[\r\n    \"skylark-domx-styler\"\r\n], function( styler) {\r\n\r\n    return styler;\r\n});\ndefine('skylark-domx/query',[\r\n    \"skylark-domx-query\",\r\n    \"./data\",\r\n    \"./eventer\",\r\n    \"./fx\",\r\n    \"./geom\",\r\n    \"./styler\"\r\n], function( query) {\r\n\r\n    return query;\r\n\r\n});\ndefine('skylark-domx-transforms/transforms',[\n    \"skylark-langx/skylark\",\n    \"skylark-langx/langx\",\n    \"skylark-domx-browser\",\n    \"skylark-domx-data\",\n    \"skylark-domx-styler\"\n], function(skylark,langx,browser,datax,styler) {\n  var css3Transform = browser.normalizeCssProperty(\"transform\");\n\n  function getMatrix(radian, x, y) {\n    var Cos = Math.cos(radian), Sin = Math.sin(radian);\n    return {\n      M11: Cos * x, \n      M12: -Sin * y,\n      M21: Sin * x, \n      M22: Cos * y\n    };\n  }\n\n  function getZoom(scale, zoom) {\n      return scale > 0 && scale > -zoom ? zoom :\n        scale < 0 && scale < zoom ? -zoom : 0;\n  }\n\n  function change(el,d) {\n      var matrix = getMatrix(d.radian, d.y, d.x);\n      styler.css(el,css3Transform, \"matrix(\"\n        + matrix.M11.toFixed(16) + \",\" + matrix.M21.toFixed(16) + \",\"\n        + matrix.M12.toFixed(16) + \",\" + matrix.M22.toFixed(16) + \", 0, 0)\"\n      );      \n  }\n\n  function transformData(el,d) {\n    if (d) {\n      datax.data(el,\"transform\",d);\n    } else {\n      d = datax.data(el,\"transform\") || {};\n      d.radian = d.radian || 0;\n      d.x = d.x || 1;\n      d.y = d.y || 1;\n      d.zoom = d.zoom || 1;\n      return d;     \n    }\n  }\n\n  var calcs = {\n    //Vertical flip\n    vertical : function (d) {\n        d.radian = Math.PI - d.radian; \n        d.y *= -1;\n    },\n\n   //Horizontal flip\n    horizontal : function (d) {\n        d.radian = Math.PI - d.radian; \n        d.x *= -1;\n    },\n\n    //Rotate according to angle\n    rotate : function (d,degress) {\n        d.radian = degress * Math.PI / 180;; \n    },\n\n    //Turn left 90 degrees\n    left : function (d) {\n        d.radian -= Math.PI / 2; \n    },\n\n    //Turn right 90 degrees\n    right : function (d) {\n        d.radian += Math.PI / 2; \n    },\n \n    //zoom\n    scale: function (d,zoom) {\n        var hZoom = getZoom(d.y, zoom), vZoom = getZoom(d.x, zoom);\n        if (hZoom && vZoom) {\n          d.y += hZoom; \n          d.x += vZoom;\n        }\n    }, \n\n    //zoom in\n    zoomin: function (d) { \n      calcs.scale(d,0.1); \n    },\n    \n    //zoom out\n    zoomout: function (d) { \n      calcs.scale(d,-0.1); \n    }\n\n  };\n  \n  \n  function _createApiMethod(calcFunc) {\n    return function() {\n      var args = langx.makeArray(arguments),\n        el = args.shift(),\n          d = transformData(el);\n        args.unshift(d);\n        calcFunc.apply(this,args)\n        change(el,d);\n        transformData(el,d);\n    }\n  }\n  \n\n  function matrix(el) {\n    var appliedTransforms = '';\n    do {\n      var transform = styler.css(el, 'transform');\n\n      if (transform && transform !== 'none') {\n        appliedTransforms = transform + ' ' + appliedTransforms;\n      }\n      /* jshint boss:true */\n    } while (el = el.parentElement);\n\n    if (window.DOMMatrix) {\n      return new DOMMatrix(appliedTransforms);\n    } else if (window.WebKitCSSMatrix) {\n      return new WebKitCSSMatrix(appliedTransforms);\n    } else if (window.CSSMatrix) {\n      return new CSSMatrix(appliedTransforms);\n    }\n  }\n   \n  function transforms() {\n    return transforms;\n  }\n\n  [\"vertical\",\"horizontal\",\"rotate\",\"left\",\"right\",\"scale\",\"zoom\",\"zoomin\",\"zoomout\"].forEach(function(name){\n    transforms[name] = _createApiMethod(calcs[name]);\n  });\n\n  langx.mixin(transforms, {\n    reset : function(el) {\n      var d = {\n        x : 1,\n        y : 1,\n        radian : 0,\n      }\n      change(el,d);\n      transformData(el,d);\n    },\n    matrix\n  });\n\n\n  return skylark.attach(\"domx.transforms\", transforms);\n});\n\ndefine('skylark-domx-transforms/main',[\n\t\"./transforms\"\n],function(transforms){\n\treturn transforms;\n});\ndefine('skylark-domx-transforms', ['skylark-domx-transforms/main'], function (main) { return main; });\n\ndefine('skylark-domx/transforms',[\r\n    \"skylark-domx-transforms\"\r\n], function(transforms) {\r\n  return transforms;\r\n});\r\n\ndefine('skylark-domx/transits',[\r\n    \"skylark-domx-transits\"\r\n], function( transits) {\r\n    return transits;\r\n});\ndefine('skylark-domx/velm',[\r\n    \"skylark-domx-velm\",\r\n    \"./data\",\r\n    \"./eventer\",\r\n    \"./fx\",\r\n    \"./geom\",\r\n    \"./styler\"\r\n], function( velm) {\r\n     return velm;\r\n});\ndefine('skylark-domx/main',[\r\n    \"./animates\",\r\n    \"./browser\",\r\n    \"./css\",\r\n    \"./data\",\r\n    \"./eventer\",\r\n    \"./finder\",\r\n    \"./fx\",\r\n    \"./geom\",\r\n    \"./iframes\",\r\n    \"./lists\",\r\n    \"./noder\",\r\n    \"./query\",\r\n    \"./styler\",\r\n    \"./transforms\",\r\n    \"./transits\",\r\n    \"./velm\"\r\n], function(animates,browser,css,data,eventer,finder,fx,geom,iframes,lists,noder,query,styler,transforms,transits,velm) {\r\n    return {\r\n        animates,\r\n        browser,\r\n        css,\r\n        data,\r\n        eventer,\r\n        finder,\r\n        geom,\r\n        lists,\r\n        noder,\r\n        iframes,\r\n        query,\r\n        styler,\r\n        transforms,\r\n        transits,\r\n        velm\r\n    };\r\n})\r\n;\ndefine('skylark-domx', ['skylark-domx/main'], function (main) { return main; });\n\ndefine('skylark-domx-plugins-base/plugin',[\r\n    \"skylark-langx-ns\",\r\n    \"skylark-langx-types\",\r\n    \"skylark-langx-objects\",\r\n    \"skylark-langx-funcs\",\r\n    \"skylark-langx-events/Emitter\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-data\",\r\n    \"skylark-domx-eventer\",\r\n    \"skylark-domx-finder\",\r\n    \"skylark-domx-geom\",\r\n    \"skylark-domx-styler\",\r\n    \"skylark-domx-fx\",\r\n    \"skylark-domx-query\",\r\n    \"skylark-domx-velm\",\r\n    \"skylark-domx\",\r\n    \"./plugins\"\r\n], function(\r\n    skylark,\r\n    types,\r\n    objects,\r\n    funcs,\r\n    Emitter, \r\n    noder, \r\n    datax, \r\n    eventer, \r\n    finder, \r\n    geom, \r\n    styler, \r\n    fx, \r\n    $, \r\n    elmx,\r\n    domx,\r\n    plugins\r\n) {\r\n    \"use strict\";\r\n\r\n    var slice = Array.prototype.slice,\r\n        concat = Array.prototype.concat;\r\n\r\n    function parentClass(ctor){\r\n        if (ctor.hasOwnProperty(\"superclass\")) {\r\n            return ctor.superclass;\r\n        }\r\n\r\n        return Object.getPrototypeOf(ctor);\r\n    }\r\n\r\n \r\n    var Plugin =   Emitter.inherit({\r\n        klassName: \"Plugin\",\r\n\r\n        _domx : domx,\r\n\r\n        _construct : function(elm,options) {\r\n           this._elm = elm;\r\n           this._initOptions(options);\r\n        },\r\n\r\n        _initOptions : function(options) {\r\n          var ctor = this.constructor,\r\n              cache = ctor.cache = (ctor.hasOwnProperty(\"cache\") ? ctor.cache : {}),\r\n              defaults = cache.defaults;\r\n          if (!defaults) {\r\n            var  ctors = [];\r\n            do {\r\n              ctors.unshift(ctor);\r\n              if (ctor === Plugin) {\r\n                break;\r\n              }\r\n              ctor = parentClass(ctor);\r\n            } while (ctor);\r\n\r\n            defaults = cache.defaults = {};\r\n            for (var i=0;i<ctors.length;i++) {\r\n              ctor = ctors[i];\r\n              if (ctor.prototype.hasOwnProperty(\"options\")) {\r\n                objects.mixin(defaults,ctor.prototype.options,true);\r\n              }\r\n              if (ctor.hasOwnProperty(\"options\")) {\r\n                objects.mixin(defaults,ctor.options,true);\r\n              }\r\n            }\r\n          }\r\n          Object.defineProperty(this,\"options\",{\r\n            value :objects.mixin({},defaults,options,true)\r\n          });\r\n\r\n          //return this.options = langx.mixin({},defaults,options);\r\n          return this.options;\r\n        },\r\n\r\n\r\n        destroy: function() {\r\n\r\n            this._destroy();\r\n\r\n            // remove all event lisener\r\n            this.unlistenTo();\r\n            // remove data \r\n            datax.removeData(this._elm,this.pluginName );\r\n        },\r\n\r\n        _destroy: funcs.noop,\r\n\r\n        _delay: function( handler, delay ) {\r\n            function handlerProxy() {\r\n                return ( typeof handler === \"string\" ? instance[ handler ] : handler )\r\n                    .apply( instance, arguments );\r\n            }\r\n            var instance = this;\r\n            return setTimeout( handlerProxy, delay || 0 );\r\n        },\r\n\r\n        elmx : function(elm) {\r\n            if (elm) {\r\n                return elmx(elm);\r\n            }\r\n            if (!this._velm) {\r\n                this._velm = elmx(this._elm);\r\n            }\r\n            return this._velm;\r\n        },\r\n\r\n        $ : function(elm) {\r\n            if (elm) {\r\n                return $(elm,this._elm);\r\n            }\r\n            if (!this._$elm) {\r\n                this._$elm = $(this._elm);\r\n            }            \r\n            return this._$elm;\r\n        },\r\n\r\n        option: function( key, value ) {\r\n            var options = key;\r\n            var parts;\r\n            var curOption;\r\n            var i;\r\n\r\n            if ( arguments.length === 0 ) {\r\n\r\n                // Don't return a reference to the internal hash\r\n                return objects.mixin( {}, this.options );\r\n            }\r\n\r\n            if ( typeof key === \"string\" ) {\r\n\r\n                // Handle nested keys, e.g., \"foo.bar\" => { foo: { bar: ___ } }\r\n                options = {};\r\n                parts = key.split( \".\" );\r\n                key = parts.shift();\r\n                if ( parts.length ) {\r\n                    curOption = options[ key ] = objects.mixin( {}, this.options[ key ] );\r\n                    for ( i = 0; i < parts.length - 1; i++ ) {\r\n                        curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};\r\n                        curOption = curOption[ parts[ i ] ];\r\n                    }\r\n                    key = parts.pop();\r\n                    if ( arguments.length === 1 ) {\r\n                        return curOption[ key ] === undefined ? null : curOption[ key ];\r\n                    }\r\n                    curOption[ key ] = value;\r\n                } else {\r\n                    if ( arguments.length === 1 ) {\r\n                        return this.options[ key ] === undefined ? null : this.options[ key ];\r\n                    }\r\n                    options[ key ] = value;\r\n                }\r\n            }\r\n\r\n            this._setOptions( options );\r\n\r\n            return this;\r\n        },\r\n\r\n        _setOptions: function( options ) {\r\n            var key;\r\n\r\n            for ( key in options ) {\r\n                this._setOption( key, options[ key ] );\r\n            }\r\n\r\n            return this;\r\n        },\r\n\r\n        _setOption: function( key, value ) {\r\n\r\n            this.options[ key ] = value;\r\n\r\n            return this;\r\n        },\r\n\r\n        getUID : function (prefix) {\r\n            prefix = prefix || \"plugin\";\r\n            do prefix += ~~(Math.random() * 1000000)\r\n            while (document.getElementById(prefix))\r\n            return prefix;\r\n        },\r\n\r\n        elm : function() {\r\n            return this._elm;\r\n        }\r\n\r\n    });\r\n\r\n\r\n    return  plugins.Plugin = Plugin;\r\n});\ndefine('skylark-domx-plugins-base/instantiate',[\r\n    \"skylark-domx-data\",\r\n    \"./plugins\",\r\n    \"./plugin\"\r\n], function(\r\n    datax, \r\n    plugins,\r\n    Plugin\r\n) {\r\n    \"use strict\";\r\n\r\n    var pluginKlasses = plugins.pluginKlasses;\r\n\r\n    /*\r\n     * Create or get or destory a plugin instance assocated with the element.\r\n     */\r\n    function instantiate(elm,pluginName,options) {\r\n        var pair = pluginName.split(\":\"),\r\n            instanceDataName = pair[1];\r\n        pluginName = pair[0];\r\n\r\n        if (!instanceDataName) {\r\n            instanceDataName = pluginName;\r\n        }\r\n\r\n        var pluginInstance = datax.data( elm, instanceDataName );\r\n\r\n        if (options === \"instance\") {\r\n            return pluginInstance;\r\n        } else if (options === \"destroy\") {\r\n            if (!pluginInstance) {\r\n                throw new Error (\"The plugin instance is not existed\");\r\n            }\r\n            pluginInstance.destroy();\r\n            //datax.removeData( elm, pluginName);\r\n            pluginInstance = undefined;\r\n        } else {\r\n            if (!pluginInstance) {\r\n                if (options !== undefined && typeof options !== \"object\") {\r\n                    throw new Error (\"The options must be a plain object\");\r\n                }\r\n                var pluginKlass = pluginKlasses[pluginName]; \r\n                pluginInstance = new pluginKlass(elm,options);\r\n                datax.data( elm, instanceDataName,pluginInstance );\r\n            } else if (options) {\r\n                pluginInstance.reset(options);\r\n            }\r\n        }\r\n\r\n        return pluginInstance;\r\n    }\r\n\r\n    Plugin.instantiate = function(elm,options) {\r\n        return instantiate(elm,this.prototype.pluginName,options);\r\n    };\r\n\r\n    return  plugins.instantiate = instantiate;\r\n});\ndefine('skylark-domx-plugins-base/shortcutter',[\r\n    \"skylark-langx-types\",\r\n    \"./plugins\",\r\n    \"./instantiate\"\r\n], function(\r\n    types,\r\n    plugins,\r\n    instantiate\r\n) {\r\n    \"use strict\";\r\n\r\n    var slice = Array.prototype.slice;\r\n\r\n    function shortcutter(pluginName,extfn) {\r\n       /*\r\n        * Create or get or destory a plugin instance assocated with the element,\r\n        * and also you can execute the plugin method directory;\r\n        */\r\n        return function (elm,options) {\r\n            var  plugin = instantiate(elm, pluginName,\"instance\");\r\n            if ( options === \"instance\" ) {\r\n              return plugin || null;\r\n            }\r\n\r\n            if (!plugin) {\r\n                plugin = instantiate(elm, pluginName,typeof options == 'object' && options || {});\r\n                if (typeof options != \"string\") {\r\n                  return this;\r\n                }\r\n            } \r\n            if (options) {\r\n                var args = slice.call(arguments,1); //2\r\n                if (extfn) {\r\n                    return extfn.apply(plugin,args);\r\n                } else {\r\n                    if (typeof options == 'string') {\r\n                        var methodName = options;\r\n\r\n                        if ( !plugin ) {\r\n                            throw new Error( \"cannot call methods on \" + pluginName +\r\n                                \" prior to initialization; \" +\r\n                                \"attempted to call method '\" + methodName + \"'\" );\r\n                        }\r\n\r\n                        if ( !types.isFunction( plugin[ methodName ] ) || methodName.charAt( 0 ) === \"_\" ) {\r\n                            throw new Error( \"no such method '\" + methodName + \"' for \" + pluginName +\r\n                                \" plugin instance\" );\r\n                        }\r\n\r\n                        args = slice.call(args,1); //remove method name\r\n\r\n                        var ret = plugin[methodName].apply(plugin,args);\r\n                        if (ret == plugin) {\r\n                          ret = undefined;\r\n                        }\r\n\r\n                        return ret;\r\n                    }                \r\n                }                \r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    return  plugins.shortcutter = shortcutter;\r\n});\ndefine('skylark-domx-plugins-base/register',[\r\n    \"skylark-langx-types\",\r\n    \"skylark-domx-query\",\r\n    \"skylark-domx-velm\",\r\n    \"./plugins\",\r\n    \"./shortcutter\"\r\n], function(\r\n    types,\r\n    $, \r\n    elmx,\r\n    plugins,\r\n    shortcutter\r\n) {\r\n    \"use strict\";\r\n\r\n    var slice = Array.prototype.slice,\r\n        pluginKlasses = plugins.pluginKlasses,\r\n        shortcuts = plugins.shortcuts;\r\n\r\n    /*\r\n     * Register a plugin type\r\n     */\r\n    function register( pluginKlass,shortcutName,instanceDataName,extfn) {\r\n        var pluginName = pluginKlass.prototype.pluginName;\r\n        \r\n        pluginKlasses[pluginName] = pluginKlass;\r\n\r\n        if (shortcutName) {\r\n            if (instanceDataName && types.isFunction(instanceDataName)) {\r\n                extfn = instanceDataName;\r\n                instanceDataName = null;\r\n            } \r\n            if (instanceDataName) {\r\n                pluginName = pluginName + \":\" + instanceDataName;\r\n            }\r\n\r\n            var shortcut = shortcuts[shortcutName] = shortcutter(pluginName,extfn);\r\n                \r\n            $.fn[shortcutName] = function(options) {\r\n                var returnValue = this;\r\n\r\n                if ( !this.length && options === \"instance\" ) {\r\n                  returnValue = undefined;\r\n                } else {\r\n                  var args = slice.call(arguments);\r\n                  this.each(function () {\r\n                    var args2 = slice.call(args);\r\n                    args2.unshift(this);\r\n                    var  ret  = shortcut.apply(undefined,args2);\r\n                    if (ret !== undefined) {\r\n                        returnValue = ret;\r\n                    }\r\n                  });\r\n                }\r\n\r\n                return returnValue;\r\n            };\r\n\r\n            elmx.partial(shortcutName,function(options) {\r\n                var  ret  = shortcut(this._elm,options);\r\n                if (ret === undefined) {\r\n                    ret = this;\r\n                }\r\n                return ret;\r\n            });\r\n\r\n        }\r\n    }\r\n\r\n    return  plugins.register = register;\r\n});\ndefine('skylark-domx-plugins-base/main',[\r\n    \"skylark-domx-query\",\r\n    \"skylark-domx-velm\",\r\n\t\"./plugins\",\r\n\t\"./instantiate\",\r\n\t\"./plugin\",\r\n\t\"./register\",\r\n\t\"./shortcutter\"\r\n],function($,elmx,plugins,instantiate,Plugin,register,shortcutter){\r\n    \"use strict\";\r\n\r\n    var slice = Array.prototype.slice;\r\n\r\n    $.fn.plugin = function(name,options) {\r\n        var args = slice.call( arguments, 1 ),\r\n            self = this,\r\n            returnValue ;\r\n\r\n        this.each(function(){\r\n            returnValue = instantiate.apply(self,[this,name].concat(args));\r\n        });\r\n        return returnValue;\r\n    };\r\n\r\n    elmx.partial(\"plugin\",function(name,options) {\r\n        var args = slice.call( arguments, 1 );\r\n        return instantiate.apply(this,[this._elm,name].concat(args));\r\n    }); \r\n\r\n\treturn plugins;\r\n});\ndefine('skylark-domx-plugins-base', ['skylark-domx-plugins-base/main'], function (main) { return main; });\n\ndefine('skylark-jquery/jquery-plugin',[\r\n\t\"skylark-langx-types\",\r\n\t\"skylark-langx-objects\",\r\n\t\"skylark-langx-arrays\",\r\n\t\"skylark-langx/langx\",\r\n\t\"skylark-domx-data\",\r\n\t\"skylark-domx-eventer\",\r\n\t\"skylark-domx-plugins-base\",\r\n\t\"skylark-domx-query\",\r\n],function(types, objects, arrays, langx, datax, eventer, plugins, $){\r\n\r\n    var pluginUuid = 0;\r\n\r\n\tvar JqPlugin = plugins.Plugin.inherit({\r\n\t\tklassName : \"JqPlugin\",\r\n\r\n        pluginEventPrefix: \"\",\r\n\r\n        options: {\r\n            // Callbacks\r\n            create: null\r\n        },\r\n\r\n        destroy: function() {\r\n            this.overrided();\r\n\r\n            // We can probably remove the unbind calls in 2.0\r\n            // all event bindings should go through this._on()\r\n            this.element\r\n                .off( this.eventNamespace );\r\n\r\n            // Clean up events and states\r\n            this.bindings.off( this.eventNamespace );\r\n        },\r\n\r\n        _construct : function(element,options) {\r\n            //this.options = langx.mixin( {}, this.options );\r\n\r\n            element = $( element || this.defaultElement || this )[ 0 ];\r\n            this.element = $( element );\r\n            this.uuid = pluginUuid++;\r\n            this.eventNamespace = \".\" + this.pluginName + this.uuid;\r\n\r\n            this.bindings = $();\r\n            this.classesElementLookup = {};\r\n\r\n\t\t\tthis.hoverable = $();\r\n\t\t\tthis.focusable = $();\r\n\r\n            if ( element !== this ) {\r\n                datax.data( element, this.pluginName, this );\r\n                this._on( true, this.element, {\r\n                    remove: function( event ) {\r\n                        if ( event.target === element ) {\r\n                            this.destroy();\r\n                        }\r\n                    }\r\n                } );\r\n                this.document = $( element.style ?\r\n\r\n                    // Element within the document\r\n                    element.ownerDocument :\r\n\r\n                    // Element is window or document\r\n                    element.document || element );\r\n                this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );\r\n            }\r\n\r\n            this.overrided(element,options);\r\n\r\n//            this.options = langx.mixin( {},\r\n//                this.options,\r\n//                this._getCreateOptions(),\r\n//                options );\r\n\r\n            this._create();\r\n\r\n            this._trigger( \"create\", null, this._getCreateEventData() );\r\n\r\n            this._init();\r\n        },\r\n\r\n\r\n\t     _initOptions : function(options) {\r\n\t     \toptions = langx.mixin(this._getCreateOptions(),options);\r\n\r\n\t\t\tthis.overrided(options);\r\n\t\t},\r\n\r\n        _getCreateOptions: function() {\r\n            return {};\r\n        },\r\n\r\n        _getCreateEventData: langx.noop,\r\n\r\n\t\t_super : function() {\r\n\t\t\tif (this.overrided) {\r\n\t\t\t\treturn this.overrided.apply(this,arguments);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_superApply : function ( args ) {\r\n\t\t\tif (this.overrided) {\r\n\t\t\t\treturn this.overrided.apply(this,args);\r\n\t\t\t}\r\n\t\t},\r\n\r\n        _create: langx.noop,\r\n\r\n        _init: langx.noop,\r\n\r\n\t\t_classes: function( options ) {\r\n\t\t\tvar full = [];\r\n\t\t\tvar that = this;\r\n\r\n\t\t\toptions = objects.mixin( {\r\n\t\t\t\telement: this.element,\r\n\t\t\t\tclasses: this.options.classes || {}\r\n\t\t\t}, options );\r\n\r\n\r\n\t\t\tfunction bindRemoveEvent() {\r\n\t\t\t\toptions.element.each( function( _, element ) {\r\n\t\t\t\t\tvar isTracked = langx.map( that.classesElementLookup, function( elements ) {\r\n\t\t\t\t\t\treturn elements;\r\n\t\t\t\t\t} )\r\n\t\t\t\t\t\t.some( function(elements ) {\r\n\t\t\t\t\t\t\treturn $(elements).is( element );\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\tif ( !isTracked ) {\r\n\t\t\t\t\t\tthat._on( $( element ), {\r\n\t\t\t\t\t\t\tremove: \"_untrackClassesElement\"\r\n\t\t\t\t\t\t} );\r\n\t\t\t\t\t}\r\n\t\t\t\t} );\r\n\t\t\t}\r\n\r\n\t\t\tfunction processClassString( classes, checkOption ) {\r\n\t\t\t\tvar current, i;\r\n\t\t\t\tfor ( i = 0; i < classes.length; i++ ) {\r\n\t\t\t\t\tcurrent = that.classesElementLookup[ classes[ i ] ] || $();\r\n\t\t\t\t\tif ( options.add ) {\r\n\t\t\t\t\t\tbindRemoveEvent();\r\n\t\t\t\t\t\tcurrent = $( langx.uniq( current.get().concat( options.element.get() ) ) );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcurrent = $( current.not( options.element ).get() );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthat.classesElementLookup[ classes[ i ] ] = current;\r\n\t\t\t\t\tfull.push( classes[ i ] );\r\n\t\t\t\t\tif ( checkOption && options.classes[ classes[ i ] ] ) {\r\n\t\t\t\t\t\tfull.push( options.classes[ classes[ i ] ] );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( options.keys ) {\r\n\t\t\t\tprocessClassString( options.keys.match( /\\S+/g ) || [], true );\r\n\t\t\t}\r\n\t\t\tif ( options.extra ) {\r\n\t\t\t\tprocessClassString( options.extra.match( /\\S+/g ) || [] );\r\n\t\t\t}\r\n\r\n\t\t\treturn full.join( \" \" );\r\n\t\t},\r\n\r\n\t\t_untrackClassesElement: function( event ) {\r\n\t\t\tvar that = this;\r\n\t\t\tlangx.each( that.classesElementLookup, function( key, value ) {\r\n\t\t\t\tif ( arrays.inArray( event.target, value ) !== -1 ) {\r\n\t\t\t\t\tthat.classesElementLookup[ key ] = $( value.not( event.target ).get() );\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\r\n\t\t\tthis._off( $( event.target ) );\r\n\t\t},\r\n\r\n\t\t_removeClass: function( element, keys, extra ) {\r\n\t\t\treturn this._toggleClass( element, keys, extra, false );\r\n\t\t},\r\n\r\n\t\t_addClass: function( element, keys, extra ) {\r\n\t\t\treturn this._toggleClass( element, keys, extra, true );\r\n\t\t},\r\n\r\n\t\t_toggleClass: function( element, keys, extra, add ) {\r\n\t\t\tadd = ( typeof add === \"boolean\" ) ? add : extra;\r\n\t\t\tvar shift = ( typeof element === \"string\" || element === null ),\r\n\t\t\t\toptions = {\r\n\t\t\t\t\textra: shift ? keys : extra,\r\n\t\t\t\t\tkeys: shift ? element : keys,\r\n\t\t\t\t\telement: shift ? this.element : element,\r\n\t\t\t\t\tadd: add\r\n\t\t\t\t};\r\n\t\t\toptions.element.toggleClass( this._classes( options ), add );\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t_on: function( suppressDisabledCheck, element, handlers ) {\r\n\t\t\tvar delegateElement;\r\n\t\t\tvar instance = this;\r\n\r\n\t\t\t// No suppressDisabledCheck flag, shuffle arguments\r\n\t\t\tif ( typeof suppressDisabledCheck !== \"boolean\" ) {\r\n\t\t\t\thandlers = element;\r\n\t\t\t\telement = suppressDisabledCheck;\r\n\t\t\t\tsuppressDisabledCheck = false;\r\n\t\t\t}\r\n\r\n\t\t\t// No element argument, shuffle and use this.element\r\n\t\t\tif ( !handlers ) {\r\n\t\t\t\thandlers = element;\r\n\t\t\t\telement = this.element;\r\n\t\t\t\tdelegateElement = this.widget();\r\n\t\t\t} else {\r\n\t\t\t\telement = delegateElement = $( element );\r\n\t\t\t\tthis.bindings = this.bindings.add( element );\r\n\t\t\t}\r\n\r\n\t\t\tobjects.each( handlers, function( event, handler ) {\r\n\t\t\t\tfunction handlerProxy() {\r\n\r\n\t\t\t\t\t// Allow widgets to customize the disabled handling\r\n\t\t\t\t\t// - disabled as an array instead of boolean\r\n\t\t\t\t\t// - disabled class as method for disabling individual parts\r\n\t\t\t\t\tif ( !suppressDisabledCheck &&\r\n\t\t\t\t\t\t\t( instance.options.disabled === true ||\r\n\t\t\t\t\t\t\t$( this ).hasClass( \"ui-state-disabled\" ) ) ) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn ( typeof handler === \"string\" ? instance[ handler ] : handler )\r\n\t\t\t\t\t\t.apply( instance, arguments );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Copy the guid so direct unbinding works\r\n\t\t\t\tif ( typeof handler !== \"string\" ) {\r\n\t\t\t\t\thandlerProxy.guid = handler.guid =\r\n\t\t\t\t\t\thandler.guid || handlerProxy.guid || $.guid++;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar match = event.match( /^([\\w:-]*)\\s*(.*)$/ );\r\n\t\t\t\tvar eventName = match[ 1 ] + instance.eventNamespace;\r\n\t\t\t\tvar selector = match[ 2 ];\r\n\r\n\t\t\t\tif ( selector ) {\r\n\t\t\t\t\tdelegateElement.on( eventName, selector, handlerProxy );\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement.on( eventName, handlerProxy );\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\t},\r\n\r\n\t\t_off: function( element, eventName ) {\r\n\t\t\teventName = ( eventName || \"\" ).split( \" \" ).join( this.eventNamespace + \" \" ) +\r\n\t\t\t\tthis.eventNamespace;\r\n\t\t\telement.off( eventName );\r\n\r\n\t\t\t// Clear the stack to avoid memory leaks (#10056)\r\n\t\t\tthis.bindings = $( this.bindings.not( element ).get() );\r\n\t\t\tthis.focusable = $( this.focusable.not( element ).get() );\r\n\t\t\tthis.hoverable = $( this.hoverable.not( element ).get() );\r\n\t\t},\r\n\r\n\t\t_trigger: function( type, event, data ) {\r\n\t\t\tvar prop, orig;\r\n\t\t\tvar callback = this.options[ type ];\r\n\r\n\t\t\tdata = data || {};\r\n\t\t\tevent = eventer.proxy( event );\r\n\t\t\tevent.type = ( type === this.widgetEventPrefix ?\r\n\t\t\t\ttype :\r\n\t\t\t\tthis.widgetEventPrefix + type ).toLowerCase();\r\n\r\n\t\t\t// The original event may come from any element\r\n\t\t\t// so we need to reset the target on the new event\r\n\t\t\tevent.target = this.element[ 0 ];\r\n\r\n\t\t\t// Copy original event properties over to the new event\r\n\t\t\torig = event.originalEvent;\r\n\t\t\tif ( orig ) {\r\n\t\t\t\tfor ( prop in orig ) {\r\n\t\t\t\t\tif ( !( prop in event ) ) {\r\n\t\t\t\t\t\tevent[ prop ] = orig[ prop ];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.element.trigger( event, data );\r\n\t\t\treturn !( types.isFunction( callback ) &&\r\n\t\t\t\tcallback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||\r\n\t\t\t\tevent.isDefaultPrevented() );\r\n\t\t},\r\n\t\t_hoverable: function( element ) {\r\n\t\t\tthis.hoverable = this.hoverable.add( element );\r\n\t\t\tthis._on( element, {\r\n\t\t\t\tmouseenter: function( event ) {\r\n\t\t\t\t\tthis._addClass( $( event.currentTarget ), null, \"ui-state-hover\" );\r\n\t\t\t\t},\r\n\t\t\t\tmouseleave: function( event ) {\r\n\t\t\t\t\tthis._removeClass( $( event.currentTarget ), null, \"ui-state-hover\" );\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\t},\r\n\r\n\t\t_focusable: function( element ) {\r\n\t\t\tthis.focusable = this.focusable.add( element );\r\n\t\t\tthis._on( element, {\r\n\t\t\t\tfocusin: function( event ) {\r\n\t\t\t\t\tthis._addClass( $( event.currentTarget ), null, \"ui-state-focus\" );\r\n\t\t\t\t},\r\n\t\t\t\tfocusout: function( event ) {\r\n\t\t\t\t\tthis._removeClass( $( event.currentTarget ), null, \"ui-state-focus\" );\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\t},\r\n\r\n\r\n\t    enable: function() {\r\n\t      return this._setOptions( { disabled: false } );\r\n\t    },\r\n\r\n\t    disable: function() {\r\n\t      return this._setOptions( { disabled: true } );\r\n\t    }\r\n\r\n\r\n\t});\r\n\r\n\treturn JqPlugin;\r\n});\n/*!\r\n * jQuery UI Widget @VERSION\r\n * http://jqueryui.com\r\n *\r\n * Copyright jQuery Foundation and other contributors\r\n * Released under the MIT license.\r\n * http://jquery.org/license\r\n */\r\n\r\n//>>label: Widget\r\n//>>group: Core\r\n//>>description: Provides a factory for creating stateful widgets with a common API.\r\n//>>docs: http://api.jqueryui.com/jQuery.widget/\r\n//>>demos: http://jqueryui.com/widget/\r\n\r\ndefine( 'skylark-jquery/widget',[ \r\n\t\"skylark-langx/langx\",\r\n\t\"skylark-domx-plugins-base\",\r\n\t\"./core\",\r\n\t\"./jquery-plugin\"\r\n],  function(langx,splugins, $,JqPlugin ) {\r\n\r\n\tvar widgetUuid = 0;\r\n\tvar widgetHasOwnProperty = Array.prototype.hasOwnProperty;\r\n\tvar widgetSlice = Array.prototype.slice;\r\n\r\n\t$.cleanData = ( function( orig ) {\r\n\t\treturn function( elems ) {\r\n\t\t\tvar events, elem, i;\r\n\t\t\tfor ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {\r\n\r\n\t\t\t\t// Only trigger remove when necessary to save time\r\n\t\t\t\tevents = $._data( elem, \"events\" );\r\n\t\t\t\tif ( events && events.remove ) {\r\n\t\t\t\t\t$( elem ).triggerHandler( \"remove\" );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\torig( elems );\r\n\t\t};\r\n\t} )( $.cleanData );\r\n\t\r\n\t$.widget = function( name, base, prototype ) {\r\n\t\tvar existingConstructor, constructor, basePrototype;\r\n\r\n\t\t// ProxiedPrototype allows the provided prototype to remain unmodified\r\n\t\t// so that it can be used as a mixin for multiple widgets (#8876)\r\n\t\tvar proxiedPrototype = {};\r\n\r\n\t\tvar namespace = name.split( \".\" )[ 0 ];\r\n\t\tname = name.split( \".\" )[ 1 ];\r\n\t\tvar fullName = namespace + \"-\" + name;\r\n\r\n\t\tif ( !prototype ) {\r\n\t\t\tprototype = base;\r\n\t\t\tbase = $.Widget;\r\n\t\t}\r\n\r\n\t\tif ( $.isArray( prototype ) ) {\r\n\t\t\tprototype = $.extend.apply( null, [ {} ].concat( prototype ) );\r\n\t\t}\r\n\r\n\t\t// Create selector for plugin\r\n\t\t$.expr.pseudos[ fullName.toLowerCase() ] = function( elem ) {\r\n\t\t\treturn !!$.data( elem, fullName );\r\n\t\t};\r\n\r\n\t\t$[ namespace ] = $[ namespace ] || {};\r\n\r\n\t\texistingConstructor = $[ namespace ][ name ];\r\n\r\n\t\tvar basePrototype = base.prototype,\r\n\t\t\tnewPrototype = {};\r\n\r\n\t\tfor (var key in prototype) {\r\n\t\t\tvar value = prototype[key];\r\n\r\n\t\t\tif ( $.isPlainObject( value ) ) {\r\n\t\t\t\tnewPrototype[ key ] = $.isPlainObject( basePrototype[ key ] ) ?\r\n\t\t\t\t\t$.widget.extend( {}, basePrototype[ key ], value ) :\r\n\r\n\t\t\t\t\t// Don't extend strings, arrays, etc. with objects\r\n\t\t\t\t\t$.widget.extend( {}, value );\r\n\t\t\t} else {\r\n\t\t\t\tnewPrototype[key] = value;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar _proto = $.widget.extend({\r\n\r\n\t\t\t// TODO: remove support for widgetEventPrefix\r\n\t\t\t// always use the name + a colon as the prefix, e.g., draggable:start\r\n\t\t\t// don't prefix for widgets that aren't DOM-based\r\n\t\t\twidgetEventPrefix: existingConstructor ? ( base.prototype.widgetEventPrefix || name ) : name\r\n\t\t}, {\r\n\t\t\toptions : base.prototype.options\r\n\t\t},newPrototype, {\r\n\t\t\tname : fullName,\r\n\t\t\tnamespace: namespace,\r\n\t\t\twidgetName: name,\r\n\t\t\tpluginName : \"jqueryui.\" + (namespace ? namespace + \".\" : \"\") + name,\r\n\t\t\twidgetFullName: fullName\r\n\t\t} );\r\n\r\n\t\tconstructor = $[ namespace ][ name ] = base.inherit(_proto);\r\n\t\t/*\r\n\r\n\t\tconstructor = $[ namespace ][ name ] = function( options, element ) {\r\n\r\n\t\t\t// Allow instantiation without \"new\" keyword\r\n\t\t\tif ( !this._createWidget ) {\r\n\t\t\t\treturn new constructor( options, element );\r\n\t\t\t}\r\n\r\n\t\t\t// Allow instantiation without initializing for simple inheritance\r\n\t\t\t// must use \"new\" keyword (the code above always passes args)\r\n\t\t\tif ( arguments.length ) {\r\n\t\t\t\tthis._createWidget( options, element );\r\n\t\t\t}\r\n\t\t};\r\n\t\t*/\r\n\t\t// Extend with the existing constructor to carry over any static properties\r\n\t\t$.extend( constructor, existingConstructor, {\r\n\t\t\tversion: prototype.version,\r\n\r\n\t\t\t// Copy the object used to create the prototype in case we need to\r\n\t\t\t// redefine the widget later\r\n\t\t\t_proto: _proto,\r\n\r\n\t\t\t// Track widgets that inherit from this widget in case this widget is\r\n\t\t\t// redefined after a widget inherits from it\r\n\t\t\t_childConstructors: []\r\n\t\t} );\r\n\r\n\t\t/*\r\n\t\tbasePrototype = new base();\r\n\r\n\t\t// We need to make the options hash a property directly on the new instance\r\n\t\t// otherwise we'll modify the options hash on the prototype that we're\r\n\t\t// inheriting from\r\n\t\tbasePrototype.options = $.widget.extend( {}, basePrototype.options );\r\n\t\t$.each( prototype, function( prop, value ) {\r\n\t\t\tif ( !$.isFunction( value ) ) {\r\n\t\t\t\tproxiedPrototype[ prop ] = value;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tproxiedPrototype[ prop ] = ( function() {\r\n\t\t\t\tfunction _super() {\r\n\t\t\t\t\treturn base.prototype[ prop ].apply( this, arguments );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction _superApply( args ) {\r\n\t\t\t\t\treturn base.prototype[ prop ].apply( this, args );\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn function() {\r\n\t\t\t\t\tvar __super = this._super;\r\n\t\t\t\t\tvar __superApply = this._superApply;\r\n\t\t\t\t\tvar returnValue;\r\n\r\n\t\t\t\t\tthis._super = _super;\r\n\t\t\t\t\tthis._superApply = _superApply;\r\n\r\n\t\t\t\t\treturnValue = value.apply( this, arguments );\r\n\r\n\t\t\t\t\tthis._super = __super;\r\n\t\t\t\t\tthis._superApply = __superApply;\r\n\r\n\t\t\t\t\treturn returnValue;\r\n\t\t\t\t};\r\n\t\t\t} )();\r\n\t\t} );\r\n\t\tconstructor.prototype = $.widget.extend( basePrototype, {\r\n\r\n\t\t\t// TODO: remove support for widgetEventPrefix\r\n\t\t\t// always use the name + a colon as the prefix, e.g., draggable:start\r\n\t\t\t// don't prefix for widgets that aren't DOM-based\r\n\t\t\twidgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name\r\n\t\t}, proxiedPrototype, {\r\n\t\t\tconstructor: constructor,\r\n\t\t\tnamespace: namespace,\r\n\t\t\twidgetName: name,\r\n\t\t\twidgetFullName: fullName\r\n\t\t} );\r\n\t\t*/\r\n\t\t// If this widget is being redefined then we need to find all widgets that\r\n\t\t// are inheriting from it and redefine all of them so that they inherit from\r\n\t\t// the new version of this widget. We're essentially trying to replace one\r\n\t\t// level in the prototype chain.\r\n\t\tif ( existingConstructor ) {\r\n\t\t\t$.each( existingConstructor._childConstructors, function( i, child ) {\r\n\t\t\t\tvar childPrototype = child.prototype;\r\n\r\n\t\t\t\t// Redefine the child widget using the same prototype that was\r\n\t\t\t\t// originally used, but inherit from the new version of the base\r\n\t\t\t\t$.widget( childPrototype.namespace + \".\" + childPrototype.widgetName, constructor,\r\n\t\t\t\t\tchild._proto );\r\n\t\t\t} );\r\n\r\n\t\t\t// Remove the list of existing child constructors from the old constructor\r\n\t\t\t// so the old child constructors can be garbage collected\r\n\t\t\tdelete existingConstructor._childConstructors;\r\n\t\t} else {\r\n\t\t\tif (base._childConstructors) {\r\n\t\t\t\tbase._childConstructors.push( constructor );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//$.widget.bridge( name, constructor );\r\n\r\n\t\tsplugins.register(constructor,name,fullName);\r\n\r\n\t\treturn constructor;\r\n\t};\r\n\r\n\t$.widget.extend = function( target ) {\r\n\t\tvar input = widgetSlice.call( arguments, 1 );\r\n\t\tvar inputIndex = 0;\r\n\t\tvar inputLength = input.length;\r\n\t\tvar key;\r\n\t\tvar value;\r\n\r\n\t\tfor ( ; inputIndex < inputLength; inputIndex++ ) {\r\n\t\t\tfor ( key in input[ inputIndex ] ) {\r\n\t\t\t\tvalue = input[ inputIndex ][ key ];\r\n\t\t\t\tif ( widgetHasOwnProperty.call( input[ inputIndex ], key ) && value !== undefined ) {\r\n\r\n\t\t\t\t\t// Clone objects\r\n\t\t\t\t\tif ( $.isPlainObject( value ) ) {\r\n\t\t\t\t\t\ttarget[ key ] = $.isPlainObject( target[ key ] ) ?\r\n\t\t\t\t\t\t\t$.widget.extend( {}, target[ key ], value ) :\r\n\r\n\t\t\t\t\t\t\t// Don't extend strings, arrays, etc. with objects\r\n\t\t\t\t\t\t\t$.widget.extend( {}, value );\r\n\r\n\t\t\t\t\t// Copy everything else by reference\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttarget[ key ] = value;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn target;\r\n\t};\r\n\r\n\r\n\t$.Widget = \t JqPlugin.inherit({\r\n\t\twidgetName: \"widget\",\r\n\t\twidgetEventPrefix: \"\",\r\n\t\tdefaultElement: \"<div>\",\r\n\r\n\t\toptions: {\r\n\t\t\tclasses: {},\r\n\t\t\tdisabled: false,\r\n\r\n\t\t\t// Callbacks\r\n\t\t\tcreate: null\r\n\t\t},\r\n\r\n\t\twidget: function() {\r\n\t\t\treturn this.element;\r\n\t\t},\r\n\r\n\t\t_setOption: function( key, value ) {\r\n\t\t\tif ( key === \"classes\" ) {\r\n\t\t\t\tthis._setOptionClasses( value );\r\n\t\t\t}\r\n\r\n\t\t\tthis.options[ key ] = value;\r\n\r\n\t\t\tif ( key === \"disabled\" ) {\r\n\t\t\t\tthis._setOptionDisabled( value );\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t_setOptionClasses: function( value ) {\r\n\t\t\tvar classKey, elements, currentElements;\r\n\r\n\t\t\tfor ( classKey in value ) {\r\n\t\t\t\tcurrentElements = this.classesElementLookup[ classKey ];\r\n\t\t\t\tif ( value[ classKey ] === this.options.classes[ classKey ] ||\r\n\t\t\t\t\t\t!currentElements ||\r\n\t\t\t\t\t\t!currentElements.length ) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// We are doing this to create a new jQuery object because the _removeClass() call\r\n\t\t\t\t// on the next line is going to destroy the reference to the current elements being\r\n\t\t\t\t// tracked. We need to save a copy of this collection so that we can add the new classes\r\n\t\t\t\t// below.\r\n\t\t\t\telements = $( currentElements.get() );\r\n\t\t\t\tthis._removeClass( currentElements, classKey );\r\n\r\n\t\t\t\t// We don't use _addClass() here, because that uses this.options.classes\r\n\t\t\t\t// for generating the string of classes. We want to use the value passed in from\r\n\t\t\t\t// _setOption(), this is the new value of the classes option which was passed to\r\n\t\t\t\t// _setOption(). We pass this value directly to _classes().\r\n\t\t\t\telements.addClass( this._classes( {\r\n\t\t\t\t\telement: elements,\r\n\t\t\t\t\tkeys: classKey,\r\n\t\t\t\t\tclasses: value,\r\n\t\t\t\t\tadd: true\r\n\t\t\t\t} ));\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_setOptionDisabled: function( value ) {\r\n\t\t\tthis._toggleClass( this.widget(), this.widgetFullName + \"-disabled\", null, !!value );\r\n\r\n\t\t\t// If the widget is becoming disabled, then nothing is interactive\r\n\t\t\tif ( value ) {\r\n\t\t\t\tthis._removeClass( this.hoverable, null, \"ui-state-hover\" );\r\n\t\t\t\tthis._removeClass( this.focusable, null, \"ui-state-focus\" );\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tenable: function() {\r\n\t\t\treturn this._setOptions( { disabled: false } );\r\n\t\t},\r\n\r\n\t\tdisable: function() {\r\n\t\t\treturn this._setOptions( { disabled: true } );\r\n\t\t},\r\n\r\n\r\n\t\t_delay: function( handler, delay ) {\r\n\t\t\tfunction handlerProxy() {\r\n\t\t\t\treturn ( typeof handler === \"string\" ? instance[ handler ] : handler )\r\n\t\t\t\t\t.apply( instance, arguments );\r\n\t\t\t}\r\n\t\t\tvar instance = this;\r\n\t\t\treturn setTimeout( handlerProxy, delay || 0 );\r\n\t\t},\r\n\r\n\t\t_hoverable: function( element ) {\r\n\t\t\tthis.hoverable = this.hoverable.add( element );\r\n\t\t\tthis._on( element, {\r\n\t\t\t\tmouseenter: function( event ) {\r\n\t\t\t\t\tthis._addClass( $( event.currentTarget ), null, \"ui-state-hover\" );\r\n\t\t\t\t},\r\n\t\t\t\tmouseleave: function( event ) {\r\n\t\t\t\t\tthis._removeClass( $( event.currentTarget ), null, \"ui-state-hover\" );\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\t},\r\n\r\n\t\t_focusable: function( element ) {\r\n\t\t\tthis.focusable = this.focusable.add( element );\r\n\t\t\tthis._on( element, {\r\n\t\t\t\tfocusin: function( event ) {\r\n\t\t\t\t\tthis._addClass( $( event.currentTarget ), null, \"ui-state-focus\" );\r\n\t\t\t\t},\r\n\t\t\t\tfocusout: function( event ) {\r\n\t\t\t\t\tthis._removeClass( $( event.currentTarget ), null, \"ui-state-focus\" );\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\t}\r\n\r\n\t});\r\n\r\n\t$.Widget._childConstructors = [];\r\n\r\n\t$.each( { show: \"fadeIn\", hide: \"fadeOut\" }, function( method, defaultEffect ) {\r\n\t\t$.Widget.prototype[ \"_\" + method ] = function( element, options, callback ) {\r\n\t\t\tif ( typeof options === \"string\" ) {\r\n\t\t\t\toptions = { effect: options };\r\n\t\t\t}\r\n\r\n\t\t\tvar hasOptions;\r\n\t\t\tvar effectName = !options ?\r\n\t\t\t\tmethod :\r\n\t\t\t\toptions === true || typeof options === \"number\" ?\r\n\t\t\t\t\tdefaultEffect :\r\n\t\t\t\t\toptions.effect || defaultEffect;\r\n\r\n\t\t\toptions = options || {};\r\n\t\t\tif ( typeof options === \"number\" ) {\r\n\t\t\t\toptions = { duration: options };\r\n\t\t\t}\r\n\r\n\t\t\thasOptions = !$.isEmptyObject( options );\r\n\t\t\toptions.complete = callback;\r\n\r\n\t\t\tif ( options.delay ) {\r\n\t\t\t\telement.delay( options.delay );\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {\r\n\t\t\t\telement[ method ]( options );\r\n\t\t\t} else if ( effectName !== method && element[ effectName ] ) {\r\n\t\t\t\telement[ effectName ]( options.duration, options.easing, callback );\r\n\t\t\t} else {\r\n\t\t\t\telement.queue( function( next ) {\r\n\t\t\t\t\t$( this )[ method ]();\r\n\t\t\t\t\tif ( callback ) {\r\n\t\t\t\t\t\tcallback.call( element[ 0 ] );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnext();\r\n\t\t\t\t} );\r\n\t\t\t}\r\n\t\t};\r\n\t} );\r\n\r\n\treturn $.widget;\r\n\r\n});\r\n\ndefine('skylark-jquery/main',[\r\n    \"./core\",\r\n    \"./ajax\",\r\n    \"./callbacks\",\r\n    \"./deferred\",\r\n    \"./queue\",\r\n    \"./jquery-plugin\",\r\n    \"./widget\"\r\n], function($) {\r\n    return $;\r\n});\r\n\ndefine('skylark-jquery', ['skylark-jquery/main'], function (main) { return main; });\n\ndefine('skylark-98js/win98',[\r\n\t\"skylark-langx-ns\",\r\n\t\"skylark-jquery\"\r\n],function(skylark,$){\r\n\twindow.$ = $;\r\n\treturn skylark.attach(\"intg.win98js\");\r\n});\ndefine('skylark-browserfs/libs/process',[],function(){\r\n    // shim for using process in browser\r\n    var process = {};\r\n\r\n    // cached from whatever global is present so that test runners that stub it\r\n    // don't break things.  But we need to wrap it in a try catch in case it is\r\n    // wrapped in strict mode code which doesn't define any globals.  It's inside a\r\n    // function because try/catches deoptimize in certain engines.\r\n\r\n    var cachedSetTimeout;\r\n    var cachedClearTimeout;\r\n\r\n    function defaultSetTimeout() {\r\n        throw new Error('setTimeout has not been defined');\r\n    }\r\n\r\n    function defaultClearTimeout () {\r\n        throw new Error('clearTimeout has not been defined');\r\n    }\r\n\r\n    (function () {\r\n        try {\r\n            if (typeof setTimeout === 'function') {\r\n                cachedSetTimeout = setTimeout;\r\n            } else {\r\n                cachedSetTimeout = defaultSetTimeout;\r\n            }\r\n        } catch (e) {\r\n            cachedSetTimeout = defaultSetTimeout;\r\n        }\r\n        try {\r\n            if (typeof clearTimeout === 'function') {\r\n                cachedClearTimeout = clearTimeout;\r\n            } else {\r\n                cachedClearTimeout = defaultClearTimeout;\r\n            }\r\n        } catch (e) {\r\n            cachedClearTimeout = defaultClearTimeout;\r\n        }\r\n    } ())\r\n\r\n    function runTimeout(fun) {\r\n        if (cachedSetTimeout === setTimeout) {\r\n            //normal enviroments in sane situations\r\n            return setTimeout(fun, 0);\r\n        }\r\n        // if setTimeout wasn't available but was latter defined\r\n        if ((cachedSetTimeout === defaultSetTimeout || !cachedSetTimeout) && setTimeout) {\r\n            cachedSetTimeout = setTimeout;\r\n            return setTimeout(fun, 0);\r\n        }\r\n        try {\r\n            // when when somebody has screwed with setTimeout but no I.E. maddness\r\n            return cachedSetTimeout(fun, 0);\r\n        } catch(e){\r\n            try {\r\n                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\r\n                return cachedSetTimeout.call(null, fun, 0);\r\n            } catch(e){\r\n                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\r\n                return cachedSetTimeout.call(this, fun, 0);\r\n            }\r\n        }\r\n    }\r\n\r\n    function runClearTimeout(marker) {\r\n        if (cachedClearTimeout === clearTimeout) {\r\n            //normal enviroments in sane situations\r\n            return clearTimeout(marker);\r\n        }\r\n        // if clearTimeout wasn't available but was latter defined\r\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\r\n            cachedClearTimeout = clearTimeout;\r\n            return clearTimeout(marker);\r\n        }\r\n        try {\r\n            // when when somebody has screwed with setTimeout but no I.E. maddness\r\n            return cachedClearTimeout(marker);\r\n        } catch (e){\r\n            try {\r\n                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\r\n                return cachedClearTimeout.call(null, marker);\r\n            } catch (e){\r\n                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\r\n                // Some versions of I.E. have different rules for clearTimeout vs setTimeout\r\n                return cachedClearTimeout.call(this, marker);\r\n            }\r\n        }\r\n    }\r\n    \r\n    var queue = [];\r\n    var draining = false;\r\n    var currentQueue;\r\n    var queueIndex = -1;\r\n\r\n    function cleanUpNextTick() {\r\n        if (!draining || !currentQueue) {\r\n            return;\r\n        }\r\n        draining = false;\r\n        if (currentQueue.length) {\r\n            queue = currentQueue.concat(queue);\r\n        } else {\r\n            queueIndex = -1;\r\n        }\r\n        if (queue.length) {\r\n            drainQueue();\r\n        }\r\n    }\r\n\r\n    function drainQueue() {\r\n        if (draining) {\r\n            return;\r\n        }\r\n        var timeout = runTimeout(cleanUpNextTick);\r\n        draining = true;\r\n\r\n        var len = queue.length;\r\n        while(len) {\r\n            currentQueue = queue;\r\n            queue = [];\r\n            while (++queueIndex < len) {\r\n                if (currentQueue) {\r\n                    currentQueue[queueIndex].run();\r\n                }\r\n            }\r\n            queueIndex = -1;\r\n            len = queue.length;\r\n        }\r\n        currentQueue = null;\r\n        draining = false;\r\n        runClearTimeout(timeout);\r\n    }\r\n\r\n    process.nextTick = function (fun) {\r\n        var args = new Array(arguments.length - 1);\r\n        if (arguments.length > 1) {\r\n            for (var i = 1; i < arguments.length; i++) {\r\n                args[i - 1] = arguments[i];\r\n            }\r\n        }\r\n        queue.push(new Item(fun, args));\r\n        if (queue.length === 1 && !draining) {\r\n            runTimeout(drainQueue);\r\n        }\r\n    };\r\n\r\n    // v8 likes predictible objects\r\n    function Item(fun, array) {\r\n        this.fun = fun;\r\n        this.array = array;\r\n    }\r\n    Item.prototype.run = function () {\r\n        this.fun.apply(null, this.array);\r\n    };\r\n    process.title = 'browser';\r\n    process.browser = true;\r\n    process.env = {};\r\n    process.argv = [];\r\n    process.version = ''; // empty string to avoid regexp issues\r\n    process.versions = {};\r\n\r\n    function noop() {}\r\n\r\n    process.on = noop;\r\n    process.addListener = noop;\r\n    process.once = noop;\r\n    process.off = noop;\r\n    process.removeListener = noop;\r\n    process.removeAllListeners = noop;\r\n    process.emit = noop;\r\n    process.prependListener = noop;\r\n    process.prependOnceListener = noop;\r\n\r\n    process.listeners = function (name) { return [] }\r\n\r\n    process.binding = function (name) {\r\n        throw new Error('process.binding is not supported');\r\n    };\r\n\r\n    process.cwd = function () { return '/' };\r\n    process.chdir = function (dir) {\r\n        throw new Error('process.chdir is not supported');\r\n    };\r\n    process.umask = function() { return 0; };\r\n\r\n    return process;\r\n\r\n});\ndefine('skylark-browserfs/libs/base64',[],function(){\r\n  'use strict'\r\n  var exports = {};\r\n\r\n  exports.byteLength = byteLength\r\n  exports.toByteArray = toByteArray\r\n  exports.fromByteArray = fromByteArray\r\n\r\n  var lookup = []\r\n  var revLookup = []\r\n  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\r\n\r\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n  for (var i = 0, len = code.length; i < len; ++i) {\r\n    lookup[i] = code[i]\r\n    revLookup[code.charCodeAt(i)] = i\r\n  }\r\n\r\n  // Support decoding URL-safe base64 strings, as Node.js does.\r\n  // See: https://en.wikipedia.org/wiki/Base64#URL_applications\r\n  revLookup['-'.charCodeAt(0)] = 62\r\n  revLookup['_'.charCodeAt(0)] = 63\r\n\r\n  function getLens (b64) {\r\n    var len = b64.length\r\n\r\n    if (len % 4 > 0) {\r\n      throw new Error('Invalid string. Length must be a multiple of 4')\r\n    }\r\n\r\n    // Trim off extra bytes after placeholder bytes are found\r\n    // See: https://github.com/beatgammit/base64-js/issues/42\r\n    var validLen = b64.indexOf('=')\r\n    if (validLen === -1) validLen = len\r\n\r\n    var placeHoldersLen = validLen === len\r\n      ? 0\r\n      : 4 - (validLen % 4)\r\n\r\n    return [validLen, placeHoldersLen]\r\n  }\r\n\r\n  // base64 is 4/3 + up to two characters of the original data\r\n  function byteLength (b64) {\r\n    var lens = getLens(b64)\r\n    var validLen = lens[0]\r\n    var placeHoldersLen = lens[1]\r\n    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\r\n  }\r\n\r\n  function _byteLength (b64, validLen, placeHoldersLen) {\r\n    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\r\n  }\r\n\r\n  function toByteArray (b64) {\r\n    var tmp\r\n    var lens = getLens(b64)\r\n    var validLen = lens[0]\r\n    var placeHoldersLen = lens[1]\r\n\r\n    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\r\n\r\n    var curByte = 0\r\n\r\n    // if there are placeholders, only get up to the last complete 4 chars\r\n    var len = placeHoldersLen > 0\r\n      ? validLen - 4\r\n      : validLen\r\n\r\n    var i\r\n    for (i = 0; i < len; i += 4) {\r\n      tmp =\r\n        (revLookup[b64.charCodeAt(i)] << 18) |\r\n        (revLookup[b64.charCodeAt(i + 1)] << 12) |\r\n        (revLookup[b64.charCodeAt(i + 2)] << 6) |\r\n        revLookup[b64.charCodeAt(i + 3)]\r\n      arr[curByte++] = (tmp >> 16) & 0xFF\r\n      arr[curByte++] = (tmp >> 8) & 0xFF\r\n      arr[curByte++] = tmp & 0xFF\r\n    }\r\n\r\n    if (placeHoldersLen === 2) {\r\n      tmp =\r\n        (revLookup[b64.charCodeAt(i)] << 2) |\r\n        (revLookup[b64.charCodeAt(i + 1)] >> 4)\r\n      arr[curByte++] = tmp & 0xFF\r\n    }\r\n\r\n    if (placeHoldersLen === 1) {\r\n      tmp =\r\n        (revLookup[b64.charCodeAt(i)] << 10) |\r\n        (revLookup[b64.charCodeAt(i + 1)] << 4) |\r\n        (revLookup[b64.charCodeAt(i + 2)] >> 2)\r\n      arr[curByte++] = (tmp >> 8) & 0xFF\r\n      arr[curByte++] = tmp & 0xFF\r\n    }\r\n\r\n    return arr\r\n  }\r\n\r\n  function tripletToBase64 (num) {\r\n    return lookup[num >> 18 & 0x3F] +\r\n      lookup[num >> 12 & 0x3F] +\r\n      lookup[num >> 6 & 0x3F] +\r\n      lookup[num & 0x3F]\r\n  }\r\n\r\n  function encodeChunk (uint8, start, end) {\r\n    var tmp\r\n    var output = []\r\n    for (var i = start; i < end; i += 3) {\r\n      tmp =\r\n        ((uint8[i] << 16) & 0xFF0000) +\r\n        ((uint8[i + 1] << 8) & 0xFF00) +\r\n        (uint8[i + 2] & 0xFF)\r\n      output.push(tripletToBase64(tmp))\r\n    }\r\n    return output.join('')\r\n  }\r\n\r\n  function fromByteArray (uint8) {\r\n    var tmp\r\n    var len = uint8.length\r\n    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\r\n    var parts = []\r\n    var maxChunkLength = 16383 // must be multiple of 3\r\n\r\n    // go through the array every three bytes, we'll deal with trailing stuff later\r\n    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\r\n      parts.push(encodeChunk(\r\n        uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\r\n      ))\r\n    }\r\n\r\n    // pad the end with zeros, but make sure to not forget the extra bytes\r\n    if (extraBytes === 1) {\r\n      tmp = uint8[len - 1]\r\n      parts.push(\r\n        lookup[tmp >> 2] +\r\n        lookup[(tmp << 4) & 0x3F] +\r\n        '=='\r\n      )\r\n    } else if (extraBytes === 2) {\r\n      tmp = (uint8[len - 2] << 8) + uint8[len - 1]\r\n      parts.push(\r\n        lookup[tmp >> 10] +\r\n        lookup[(tmp >> 4) & 0x3F] +\r\n        lookup[(tmp << 2) & 0x3F] +\r\n        '='\r\n      )\r\n    }\r\n\r\n    return parts.join('')\r\n  }\r\n\r\n  return exports;\r\n});\ndefine('skylark-browserfs/libs/ieee754',[],function(){\r\n  'use strict'\r\n  var exports = {};\r\n\r\n  exports.read = function (buffer, offset, isLE, mLen, nBytes) {\r\n    var e, m\r\n    var eLen = (nBytes * 8) - mLen - 1\r\n    var eMax = (1 << eLen) - 1\r\n    var eBias = eMax >> 1\r\n    var nBits = -7\r\n    var i = isLE ? (nBytes - 1) : 0\r\n    var d = isLE ? -1 : 1\r\n    var s = buffer[offset + i]\r\n\r\n    i += d\r\n\r\n    e = s & ((1 << (-nBits)) - 1)\r\n    s >>= (-nBits)\r\n    nBits += eLen\r\n    for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\r\n\r\n    m = e & ((1 << (-nBits)) - 1)\r\n    e >>= (-nBits)\r\n    nBits += mLen\r\n    for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\r\n\r\n    if (e === 0) {\r\n      e = 1 - eBias\r\n    } else if (e === eMax) {\r\n      return m ? NaN : ((s ? -1 : 1) * Infinity)\r\n    } else {\r\n      m = m + Math.pow(2, mLen)\r\n      e = e - eBias\r\n    }\r\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\r\n  }\r\n\r\n  exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\r\n    var e, m, c\r\n    var eLen = (nBytes * 8) - mLen - 1\r\n    var eMax = (1 << eLen) - 1\r\n    var eBias = eMax >> 1\r\n    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\r\n    var i = isLE ? 0 : (nBytes - 1)\r\n    var d = isLE ? 1 : -1\r\n    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\r\n\r\n    value = Math.abs(value)\r\n\r\n    if (isNaN(value) || value === Infinity) {\r\n      m = isNaN(value) ? 1 : 0\r\n      e = eMax\r\n    } else {\r\n      e = Math.floor(Math.log(value) / Math.LN2)\r\n      if (value * (c = Math.pow(2, -e)) < 1) {\r\n        e--\r\n        c *= 2\r\n      }\r\n      if (e + eBias >= 1) {\r\n        value += rt / c\r\n      } else {\r\n        value += rt * Math.pow(2, 1 - eBias)\r\n      }\r\n      if (value * c >= 2) {\r\n        e++\r\n        c /= 2\r\n      }\r\n\r\n      if (e + eBias >= eMax) {\r\n        m = 0\r\n        e = eMax\r\n      } else if (e + eBias >= 1) {\r\n        m = ((value * c) - 1) * Math.pow(2, mLen)\r\n        e = e + eBias\r\n      } else {\r\n        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\r\n        e = 0\r\n      }\r\n    }\r\n\r\n    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\r\n\r\n    e = (e << mLen) | m\r\n    eLen += mLen\r\n    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\r\n\r\n    buffer[offset + i - d] |= s * 128\r\n  }\r\n\r\n  return exports;\r\n});\r\n\ndefine('skylark-browserfs/libs/buffers',[\r\n  \"./base64\",\r\n  \"./ieee754\"\r\n],function(base64,ieee754){\r\n  /*!\r\n   * The buffer module from node.js, for the browser.\r\n   *\r\n   * @author   Feross Aboukhadijeh <https://feross.org>\r\n   * @license  MIT\r\n   */\r\n  /* eslint-disable no-proto */\r\n\r\n  'use strict'\r\n\r\n  var exports = {};\r\n\r\n  ///var base64 = require('base64-js')\r\n  ///var ieee754 = require('ieee754')\r\n\r\n  exports.Buffer = Buffer\r\n  exports.SlowBuffer = SlowBuffer\r\n  exports.INSPECT_MAX_BYTES = 50\r\n\r\n  var K_MAX_LENGTH = 0x7fffffff\r\n  exports.kMaxLength = K_MAX_LENGTH\r\n\r\n  /**\r\n   * If `Buffer.TYPED_ARRAY_SUPPORT`:\r\n   *   === true    Use Uint8Array implementation (fastest)\r\n   *   === false   Print warning and recommend using `buffer` v4.x which has an Object\r\n   *               implementation (most compatible, even IE6)\r\n   *\r\n   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\r\n   * Opera 11.6+, iOS 4.2+.\r\n   *\r\n   * We report that the browser does not support typed arrays if the are not subclassable\r\n   * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\r\n   * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\r\n   * for __proto__ and has a buggy typed array implementation.\r\n   */\r\n  Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\r\n\r\n  if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\r\n      typeof console.error === 'function') {\r\n    console.error(\r\n      'This browser lacks typed array (Uint8Array) support which is required by ' +\r\n      '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\r\n    )\r\n  }\r\n\r\n  function typedArraySupport () {\r\n    // Can typed array instances can be augmented?\r\n    try {\r\n      var arr = new Uint8Array(1)\r\n      arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\r\n      return arr.foo() === 42\r\n    } catch (e) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  Object.defineProperty(Buffer.prototype, 'parent', {\r\n    get: function () {\r\n      if (!(this instanceof Buffer)) {\r\n        return undefined\r\n      }\r\n      return this.buffer\r\n    }\r\n  })\r\n\r\n  Object.defineProperty(Buffer.prototype, 'offset', {\r\n    get: function () {\r\n      if (!(this instanceof Buffer)) {\r\n        return undefined\r\n      }\r\n      return this.byteOffset\r\n    }\r\n  })\r\n\r\n  function createBuffer (length) {\r\n    if (length > K_MAX_LENGTH) {\r\n      throw new RangeError('Invalid typed array length')\r\n    }\r\n    // Return an augmented `Uint8Array` instance\r\n    var buf = new Uint8Array(length)\r\n    buf.__proto__ = Buffer.prototype\r\n    return buf\r\n  }\r\n\r\n  /**\r\n   * The Buffer constructor returns instances of `Uint8Array` that have their\r\n   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\r\n   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\r\n   * and the `Uint8Array` methods. Square bracket notation works as expected -- it\r\n   * returns a single octet.\r\n   *\r\n   * The `Uint8Array` prototype remains unmodified.\r\n   */\r\n\r\n  function Buffer (arg, encodingOrOffset, length) {\r\n    // Common case.\r\n    if (typeof arg === 'number') {\r\n      if (typeof encodingOrOffset === 'string') {\r\n        throw new Error(\r\n          'If encoding is specified then the first argument must be a string'\r\n        )\r\n      }\r\n      return allocUnsafe(arg)\r\n    }\r\n    return from(arg, encodingOrOffset, length)\r\n  }\r\n\r\n  // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\r\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\r\n      Buffer[Symbol.species] === Buffer) {\r\n    Object.defineProperty(Buffer, Symbol.species, {\r\n      value: null,\r\n      configurable: true,\r\n      enumerable: false,\r\n      writable: false\r\n    })\r\n  }\r\n\r\n  Buffer.poolSize = 8192 // not used by this implementation\r\n\r\n  function from (value, encodingOrOffset, length) {\r\n    if (typeof value === 'number') {\r\n      throw new TypeError('\"value\" argument must not be a number')\r\n    }\r\n\r\n    if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {\r\n      return fromArrayBuffer(value, encodingOrOffset, length)\r\n    }\r\n\r\n    if (typeof value === 'string') {\r\n      return fromString(value, encodingOrOffset)\r\n    }\r\n\r\n    return fromObject(value)\r\n  }\r\n\r\n  /**\r\n   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\r\n   * if value is a number.\r\n   * Buffer.from(str[, encoding])\r\n   * Buffer.from(array)\r\n   * Buffer.from(buffer)\r\n   * Buffer.from(arrayBuffer[, byteOffset[, length]])\r\n   **/\r\n  Buffer.from = function (value, encodingOrOffset, length) {\r\n    return from(value, encodingOrOffset, length)\r\n  }\r\n\r\n  // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\r\n  // https://github.com/feross/buffer/pull/148\r\n  Buffer.prototype.__proto__ = Uint8Array.prototype\r\n  Buffer.__proto__ = Uint8Array\r\n\r\n  function assertSize (size) {\r\n    if (typeof size !== 'number') {\r\n      throw new TypeError('\"size\" argument must be of type number')\r\n    } else if (size < 0) {\r\n      throw new RangeError('\"size\" argument must not be negative')\r\n    }\r\n  }\r\n\r\n  function alloc (size, fill, encoding) {\r\n    assertSize(size)\r\n    if (size <= 0) {\r\n      return createBuffer(size)\r\n    }\r\n    if (fill !== undefined) {\r\n      // Only pay attention to encoding if it's a string. This\r\n      // prevents accidentally sending in a number that would\r\n      // be interpretted as a start offset.\r\n      return typeof encoding === 'string'\r\n        ? createBuffer(size).fill(fill, encoding)\r\n        : createBuffer(size).fill(fill)\r\n    }\r\n    return createBuffer(size)\r\n  }\r\n\r\n  /**\r\n   * Creates a new filled Buffer instance.\r\n   * alloc(size[, fill[, encoding]])\r\n   **/\r\n  Buffer.alloc = function (size, fill, encoding) {\r\n    return alloc(size, fill, encoding)\r\n  }\r\n\r\n  function allocUnsafe (size) {\r\n    assertSize(size)\r\n    return createBuffer(size < 0 ? 0 : checked(size) | 0)\r\n  }\r\n\r\n  /**\r\n   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\r\n   * */\r\n  Buffer.allocUnsafe = function (size) {\r\n    return allocUnsafe(size)\r\n  }\r\n  /**\r\n   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\r\n   */\r\n  Buffer.allocUnsafeSlow = function (size) {\r\n    return allocUnsafe(size)\r\n  }\r\n\r\n  function fromString (string, encoding) {\r\n    if (typeof encoding !== 'string' || encoding === '') {\r\n      encoding = 'utf8'\r\n    }\r\n\r\n    if (!Buffer.isEncoding(encoding)) {\r\n      throw new TypeError('Unknown encoding: ' + encoding)\r\n    }\r\n\r\n    var length = byteLength(string, encoding) | 0\r\n    var buf = createBuffer(length)\r\n\r\n    var actual = buf.write(string, encoding)\r\n\r\n    if (actual !== length) {\r\n      // Writing a hex string, for example, that contains invalid characters will\r\n      // cause everything after the first invalid character to be ignored. (e.g.\r\n      // 'abxxcd' will be treated as 'ab')\r\n      buf = buf.slice(0, actual)\r\n    }\r\n\r\n    return buf\r\n  }\r\n\r\n  function fromArrayLike (array) {\r\n    var length = array.length < 0 ? 0 : checked(array.length) | 0\r\n    var buf = createBuffer(length)\r\n    for (var i = 0; i < length; i += 1) {\r\n      buf[i] = array[i] & 255\r\n    }\r\n    return buf\r\n  }\r\n\r\n  function fromArrayBuffer (array, byteOffset, length) {\r\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\r\n      throw new RangeError('\"offset\" is outside of buffer bounds')\r\n    }\r\n\r\n    if (array.byteLength < byteOffset + (length || 0)) {\r\n      throw new RangeError('\"length\" is outside of buffer bounds')\r\n    }\r\n\r\n    var buf\r\n    if (byteOffset === undefined && length === undefined) {\r\n      buf = new Uint8Array(array)\r\n    } else if (length === undefined) {\r\n      buf = new Uint8Array(array, byteOffset)\r\n    } else {\r\n      buf = new Uint8Array(array, byteOffset, length)\r\n    }\r\n\r\n    // Return an augmented `Uint8Array` instance\r\n    buf.__proto__ = Buffer.prototype\r\n    return buf\r\n  }\r\n\r\n  function fromObject (obj) {\r\n    if (Buffer.isBuffer(obj)) {\r\n      var len = checked(obj.length) | 0\r\n      var buf = createBuffer(len)\r\n\r\n      if (buf.length === 0) {\r\n        return buf\r\n      }\r\n\r\n      obj.copy(buf, 0, 0, len)\r\n      return buf\r\n    }\r\n\r\n    if (obj) {\r\n      if (ArrayBuffer.isView(obj) || 'length' in obj) {\r\n        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\r\n          return createBuffer(0)\r\n        }\r\n        return fromArrayLike(obj)\r\n      }\r\n\r\n      if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\r\n        return fromArrayLike(obj.data)\r\n      }\r\n    }\r\n\r\n    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.')\r\n  }\r\n\r\n  function checked (length) {\r\n    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\r\n    // length is NaN (which is otherwise coerced to zero.)\r\n    if (length >= K_MAX_LENGTH) {\r\n      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\r\n                           'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\r\n    }\r\n    return length | 0\r\n  }\r\n\r\n  function SlowBuffer (length) {\r\n    if (+length != length) { // eslint-disable-line eqeqeq\r\n      length = 0\r\n    }\r\n    return Buffer.alloc(+length)\r\n  }\r\n\r\n  Buffer.isBuffer = function isBuffer (b) {\r\n    return b != null && b._isBuffer === true\r\n  }\r\n\r\n  Buffer.compare = function compare (a, b) {\r\n    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\r\n      throw new TypeError('Arguments must be Buffers')\r\n    }\r\n\r\n    if (a === b) return 0\r\n\r\n    var x = a.length\r\n    var y = b.length\r\n\r\n    for (var i = 0, len = Math.min(x, y); i < len; ++i) {\r\n      if (a[i] !== b[i]) {\r\n        x = a[i]\r\n        y = b[i]\r\n        break\r\n      }\r\n    }\r\n\r\n    if (x < y) return -1\r\n    if (y < x) return 1\r\n    return 0\r\n  }\r\n\r\n  Buffer.isEncoding = function isEncoding (encoding) {\r\n    switch (String(encoding).toLowerCase()) {\r\n      case 'hex':\r\n      case 'utf8':\r\n      case 'utf-8':\r\n      case 'ascii':\r\n      case 'latin1':\r\n      case 'binary':\r\n      case 'base64':\r\n      case 'ucs2':\r\n      case 'ucs-2':\r\n      case 'utf16le':\r\n      case 'utf-16le':\r\n        return true\r\n      default:\r\n        return false\r\n    }\r\n  }\r\n\r\n  Buffer.concat = function concat (list, length) {\r\n    if (!Array.isArray(list)) {\r\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\r\n    }\r\n\r\n    if (list.length === 0) {\r\n      return Buffer.alloc(0)\r\n    }\r\n\r\n    var i\r\n    if (length === undefined) {\r\n      length = 0\r\n      for (i = 0; i < list.length; ++i) {\r\n        length += list[i].length\r\n      }\r\n    }\r\n\r\n    var buffer = Buffer.allocUnsafe(length)\r\n    var pos = 0\r\n    for (i = 0; i < list.length; ++i) {\r\n      var buf = list[i]\r\n      if (ArrayBuffer.isView(buf)) {\r\n        buf = Buffer.from(buf)\r\n      }\r\n      if (!Buffer.isBuffer(buf)) {\r\n        throw new TypeError('\"list\" argument must be an Array of Buffers')\r\n      }\r\n      buf.copy(buffer, pos)\r\n      pos += buf.length\r\n    }\r\n    return buffer\r\n  }\r\n\r\n  function byteLength (string, encoding) {\r\n    if (Buffer.isBuffer(string)) {\r\n      return string.length\r\n    }\r\n    if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {\r\n      return string.byteLength\r\n    }\r\n    if (typeof string !== 'string') {\r\n      string = '' + string\r\n    }\r\n\r\n    var len = string.length\r\n    if (len === 0) return 0\r\n\r\n    // Use a for loop to avoid recursion\r\n    var loweredCase = false\r\n    for (;;) {\r\n      switch (encoding) {\r\n        case 'ascii':\r\n        case 'latin1':\r\n        case 'binary':\r\n          return len\r\n        case 'utf8':\r\n        case 'utf-8':\r\n        case undefined:\r\n          return utf8ToBytes(string).length\r\n        case 'ucs2':\r\n        case 'ucs-2':\r\n        case 'utf16le':\r\n        case 'utf-16le':\r\n          return len * 2\r\n        case 'hex':\r\n          return len >>> 1\r\n        case 'base64':\r\n          return base64ToBytes(string).length\r\n        default:\r\n          if (loweredCase) return utf8ToBytes(string).length // assume utf8\r\n          encoding = ('' + encoding).toLowerCase()\r\n          loweredCase = true\r\n      }\r\n    }\r\n  }\r\n  Buffer.byteLength = byteLength\r\n\r\n  function slowToString (encoding, start, end) {\r\n    var loweredCase = false\r\n\r\n    // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\r\n    // property of a typed array.\r\n\r\n    // This behaves neither like String nor Uint8Array in that we set start/end\r\n    // to their upper/lower bounds if the value passed is out of range.\r\n    // undefined is handled specially as per ECMA-262 6th Edition,\r\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\r\n    if (start === undefined || start < 0) {\r\n      start = 0\r\n    }\r\n    // Return early if start > this.length. Done here to prevent potential uint32\r\n    // coercion fail below.\r\n    if (start > this.length) {\r\n      return ''\r\n    }\r\n\r\n    if (end === undefined || end > this.length) {\r\n      end = this.length\r\n    }\r\n\r\n    if (end <= 0) {\r\n      return ''\r\n    }\r\n\r\n    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\r\n    end >>>= 0\r\n    start >>>= 0\r\n\r\n    if (end <= start) {\r\n      return ''\r\n    }\r\n\r\n    if (!encoding) encoding = 'utf8'\r\n\r\n    while (true) {\r\n      switch (encoding) {\r\n        case 'hex':\r\n          return hexSlice(this, start, end)\r\n\r\n        case 'utf8':\r\n        case 'utf-8':\r\n          return utf8Slice(this, start, end)\r\n\r\n        case 'ascii':\r\n          return asciiSlice(this, start, end)\r\n\r\n        case 'latin1':\r\n        case 'binary':\r\n          return latin1Slice(this, start, end)\r\n\r\n        case 'base64':\r\n          return base64Slice(this, start, end)\r\n\r\n        case 'ucs2':\r\n        case 'ucs-2':\r\n        case 'utf16le':\r\n        case 'utf-16le':\r\n          return utf16leSlice(this, start, end)\r\n\r\n        default:\r\n          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\r\n          encoding = (encoding + '').toLowerCase()\r\n          loweredCase = true\r\n      }\r\n    }\r\n  }\r\n\r\n  // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\r\n  // to detect a Buffer instance. It's not possible to use `instanceof Buffer`\r\n  // reliably in a browserify context because there could be multiple different\r\n  // copies of the 'buffer' package in use. This method works even for Buffer\r\n  // instances that were created from another copy of the `buffer` package.\r\n  // See: https://github.com/feross/buffer/issues/154\r\n  Buffer.prototype._isBuffer = true\r\n\r\n  function swap (b, n, m) {\r\n    var i = b[n]\r\n    b[n] = b[m]\r\n    b[m] = i\r\n  }\r\n\r\n  Buffer.prototype.swap16 = function swap16 () {\r\n    var len = this.length\r\n    if (len % 2 !== 0) {\r\n      throw new RangeError('Buffer size must be a multiple of 16-bits')\r\n    }\r\n    for (var i = 0; i < len; i += 2) {\r\n      swap(this, i, i + 1)\r\n    }\r\n    return this\r\n  }\r\n\r\n  Buffer.prototype.swap32 = function swap32 () {\r\n    var len = this.length\r\n    if (len % 4 !== 0) {\r\n      throw new RangeError('Buffer size must be a multiple of 32-bits')\r\n    }\r\n    for (var i = 0; i < len; i += 4) {\r\n      swap(this, i, i + 3)\r\n      swap(this, i + 1, i + 2)\r\n    }\r\n    return this\r\n  }\r\n\r\n  Buffer.prototype.swap64 = function swap64 () {\r\n    var len = this.length\r\n    if (len % 8 !== 0) {\r\n      throw new RangeError('Buffer size must be a multiple of 64-bits')\r\n    }\r\n    for (var i = 0; i < len; i += 8) {\r\n      swap(this, i, i + 7)\r\n      swap(this, i + 1, i + 6)\r\n      swap(this, i + 2, i + 5)\r\n      swap(this, i + 3, i + 4)\r\n    }\r\n    return this\r\n  }\r\n\r\n  Buffer.prototype.toString = function toString () {\r\n    var length = this.length\r\n    if (length === 0) return ''\r\n    if (arguments.length === 0) return utf8Slice(this, 0, length)\r\n    return slowToString.apply(this, arguments)\r\n  }\r\n\r\n  Buffer.prototype.toLocaleString = Buffer.prototype.toString\r\n\r\n  Buffer.prototype.equals = function equals (b) {\r\n    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\r\n    if (this === b) return true\r\n    return Buffer.compare(this, b) === 0\r\n  }\r\n\r\n  Buffer.prototype.inspect = function inspect () {\r\n    var str = ''\r\n    var max = exports.INSPECT_MAX_BYTES\r\n    if (this.length > 0) {\r\n      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\r\n      if (this.length > max) str += ' ... '\r\n    }\r\n    return '<Buffer ' + str + '>'\r\n  }\r\n\r\n  Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\r\n    if (!Buffer.isBuffer(target)) {\r\n      throw new TypeError('Argument must be a Buffer')\r\n    }\r\n\r\n    if (start === undefined) {\r\n      start = 0\r\n    }\r\n    if (end === undefined) {\r\n      end = target ? target.length : 0\r\n    }\r\n    if (thisStart === undefined) {\r\n      thisStart = 0\r\n    }\r\n    if (thisEnd === undefined) {\r\n      thisEnd = this.length\r\n    }\r\n\r\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\r\n      throw new RangeError('out of range index')\r\n    }\r\n\r\n    if (thisStart >= thisEnd && start >= end) {\r\n      return 0\r\n    }\r\n    if (thisStart >= thisEnd) {\r\n      return -1\r\n    }\r\n    if (start >= end) {\r\n      return 1\r\n    }\r\n\r\n    start >>>= 0\r\n    end >>>= 0\r\n    thisStart >>>= 0\r\n    thisEnd >>>= 0\r\n\r\n    if (this === target) return 0\r\n\r\n    var x = thisEnd - thisStart\r\n    var y = end - start\r\n    var len = Math.min(x, y)\r\n\r\n    var thisCopy = this.slice(thisStart, thisEnd)\r\n    var targetCopy = target.slice(start, end)\r\n\r\n    for (var i = 0; i < len; ++i) {\r\n      if (thisCopy[i] !== targetCopy[i]) {\r\n        x = thisCopy[i]\r\n        y = targetCopy[i]\r\n        break\r\n      }\r\n    }\r\n\r\n    if (x < y) return -1\r\n    if (y < x) return 1\r\n    return 0\r\n  }\r\n\r\n  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\r\n  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.\r\n  //\r\n  // Arguments:\r\n  // - buffer - a Buffer to search\r\n  // - val - a string, Buffer, or number\r\n  // - byteOffset - an index into `buffer`; will be clamped to an int32\r\n  // - encoding - an optional encoding, relevant is val is a string\r\n  // - dir - true for indexOf, false for lastIndexOf\r\n  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\r\n    // Empty buffer means no match\r\n    if (buffer.length === 0) return -1\r\n\r\n    // Normalize byteOffset\r\n    if (typeof byteOffset === 'string') {\r\n      encoding = byteOffset\r\n      byteOffset = 0\r\n    } else if (byteOffset > 0x7fffffff) {\r\n      byteOffset = 0x7fffffff\r\n    } else if (byteOffset < -0x80000000) {\r\n      byteOffset = -0x80000000\r\n    }\r\n    byteOffset = +byteOffset  // Coerce to Number.\r\n    if (numberIsNaN(byteOffset)) {\r\n      // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\r\n      byteOffset = dir ? 0 : (buffer.length - 1)\r\n    }\r\n\r\n    // Normalize byteOffset: negative offsets start from the end of the buffer\r\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset\r\n    if (byteOffset >= buffer.length) {\r\n      if (dir) return -1\r\n      else byteOffset = buffer.length - 1\r\n    } else if (byteOffset < 0) {\r\n      if (dir) byteOffset = 0\r\n      else return -1\r\n    }\r\n\r\n    // Normalize val\r\n    if (typeof val === 'string') {\r\n      val = Buffer.from(val, encoding)\r\n    }\r\n\r\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\r\n    if (Buffer.isBuffer(val)) {\r\n      // Special case: looking for empty string/buffer always fails\r\n      if (val.length === 0) {\r\n        return -1\r\n      }\r\n      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\r\n    } else if (typeof val === 'number') {\r\n      val = val & 0xFF // Search for a byte value [0-255]\r\n      if (typeof Uint8Array.prototype.indexOf === 'function') {\r\n        if (dir) {\r\n          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\r\n        } else {\r\n          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\r\n        }\r\n      }\r\n      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\r\n    }\r\n\r\n    throw new TypeError('val must be string, number or Buffer')\r\n  }\r\n\r\n  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {\r\n    var indexSize = 1\r\n    var arrLength = arr.length\r\n    var valLength = val.length\r\n\r\n    if (encoding !== undefined) {\r\n      encoding = String(encoding).toLowerCase()\r\n      if (encoding === 'ucs2' || encoding === 'ucs-2' ||\r\n          encoding === 'utf16le' || encoding === 'utf-16le') {\r\n        if (arr.length < 2 || val.length < 2) {\r\n          return -1\r\n        }\r\n        indexSize = 2\r\n        arrLength /= 2\r\n        valLength /= 2\r\n        byteOffset /= 2\r\n      }\r\n    }\r\n\r\n    function read (buf, i) {\r\n      if (indexSize === 1) {\r\n        return buf[i]\r\n      } else {\r\n        return buf.readUInt16BE(i * indexSize)\r\n      }\r\n    }\r\n\r\n    var i\r\n    if (dir) {\r\n      var foundIndex = -1\r\n      for (i = byteOffset; i < arrLength; i++) {\r\n        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\r\n          if (foundIndex === -1) foundIndex = i\r\n          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\r\n        } else {\r\n          if (foundIndex !== -1) i -= i - foundIndex\r\n          foundIndex = -1\r\n        }\r\n      }\r\n    } else {\r\n      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\r\n      for (i = byteOffset; i >= 0; i--) {\r\n        var found = true\r\n        for (var j = 0; j < valLength; j++) {\r\n          if (read(arr, i + j) !== read(val, j)) {\r\n            found = false\r\n            break\r\n          }\r\n        }\r\n        if (found) return i\r\n      }\r\n    }\r\n\r\n    return -1\r\n  }\r\n\r\n  Buffer.prototype.includes = function includes (val, byteOffset, encoding) {\r\n    return this.indexOf(val, byteOffset, encoding) !== -1\r\n  }\r\n\r\n  Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\r\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\r\n  }\r\n\r\n  Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\r\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\r\n  }\r\n\r\n  function hexWrite (buf, string, offset, length) {\r\n    offset = Number(offset) || 0\r\n    var remaining = buf.length - offset\r\n    if (!length) {\r\n      length = remaining\r\n    } else {\r\n      length = Number(length)\r\n      if (length > remaining) {\r\n        length = remaining\r\n      }\r\n    }\r\n\r\n    var strLen = string.length\r\n\r\n    if (length > strLen / 2) {\r\n      length = strLen / 2\r\n    }\r\n    for (var i = 0; i < length; ++i) {\r\n      var parsed = parseInt(string.substr(i * 2, 2), 16)\r\n      if (numberIsNaN(parsed)) return i\r\n      buf[offset + i] = parsed\r\n    }\r\n    return i\r\n  }\r\n\r\n  function utf8Write (buf, string, offset, length) {\r\n    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\r\n  }\r\n\r\n  function asciiWrite (buf, string, offset, length) {\r\n    return blitBuffer(asciiToBytes(string), buf, offset, length)\r\n  }\r\n\r\n  function latin1Write (buf, string, offset, length) {\r\n    return asciiWrite(buf, string, offset, length)\r\n  }\r\n\r\n  function base64Write (buf, string, offset, length) {\r\n    return blitBuffer(base64ToBytes(string), buf, offset, length)\r\n  }\r\n\r\n  function ucs2Write (buf, string, offset, length) {\r\n    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\r\n  }\r\n\r\n  Buffer.prototype.write = function write (string, offset, length, encoding) {\r\n    // Buffer#write(string)\r\n    if (offset === undefined) {\r\n      encoding = 'utf8'\r\n      length = this.length\r\n      offset = 0\r\n    // Buffer#write(string, encoding)\r\n    } else if (length === undefined && typeof offset === 'string') {\r\n      encoding = offset\r\n      length = this.length\r\n      offset = 0\r\n    // Buffer#write(string, offset[, length][, encoding])\r\n    } else if (isFinite(offset)) {\r\n      offset = offset >>> 0\r\n      if (isFinite(length)) {\r\n        length = length >>> 0\r\n        if (encoding === undefined) encoding = 'utf8'\r\n      } else {\r\n        encoding = length\r\n        length = undefined\r\n      }\r\n    } else {\r\n      throw new Error(\r\n        'Buffer.write(string, encoding, offset[, length]) is no longer supported'\r\n      )\r\n    }\r\n\r\n    var remaining = this.length - offset\r\n    if (length === undefined || length > remaining) length = remaining\r\n\r\n    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\r\n      throw new RangeError('Attempt to write outside buffer bounds')\r\n    }\r\n\r\n    if (!encoding) encoding = 'utf8'\r\n\r\n    var loweredCase = false\r\n    for (;;) {\r\n      switch (encoding) {\r\n        case 'hex':\r\n          return hexWrite(this, string, offset, length)\r\n\r\n        case 'utf8':\r\n        case 'utf-8':\r\n          return utf8Write(this, string, offset, length)\r\n\r\n        case 'ascii':\r\n          return asciiWrite(this, string, offset, length)\r\n\r\n        case 'latin1':\r\n        case 'binary':\r\n          return latin1Write(this, string, offset, length)\r\n\r\n        case 'base64':\r\n          // Warning: maxLength not taken into account in base64Write\r\n          return base64Write(this, string, offset, length)\r\n\r\n        case 'ucs2':\r\n        case 'ucs-2':\r\n        case 'utf16le':\r\n        case 'utf-16le':\r\n          return ucs2Write(this, string, offset, length)\r\n\r\n        default:\r\n          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\r\n          encoding = ('' + encoding).toLowerCase()\r\n          loweredCase = true\r\n      }\r\n    }\r\n  }\r\n\r\n  Buffer.prototype.toJSON = function toJSON () {\r\n    return {\r\n      type: 'Buffer',\r\n      data: Array.prototype.slice.call(this._arr || this, 0)\r\n    }\r\n  }\r\n\r\n  function base64Slice (buf, start, end) {\r\n    if (start === 0 && end === buf.length) {\r\n      return base64.fromByteArray(buf)\r\n    } else {\r\n      return base64.fromByteArray(buf.slice(start, end))\r\n    }\r\n  }\r\n\r\n  function utf8Slice (buf, start, end) {\r\n    end = Math.min(buf.length, end)\r\n    var res = []\r\n\r\n    var i = start\r\n    while (i < end) {\r\n      var firstByte = buf[i]\r\n      var codePoint = null\r\n      var bytesPerSequence = (firstByte > 0xEF) ? 4\r\n        : (firstByte > 0xDF) ? 3\r\n        : (firstByte > 0xBF) ? 2\r\n        : 1\r\n\r\n      if (i + bytesPerSequence <= end) {\r\n        var secondByte, thirdByte, fourthByte, tempCodePoint\r\n\r\n        switch (bytesPerSequence) {\r\n          case 1:\r\n            if (firstByte < 0x80) {\r\n              codePoint = firstByte\r\n            }\r\n            break\r\n          case 2:\r\n            secondByte = buf[i + 1]\r\n            if ((secondByte & 0xC0) === 0x80) {\r\n              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\r\n              if (tempCodePoint > 0x7F) {\r\n                codePoint = tempCodePoint\r\n              }\r\n            }\r\n            break\r\n          case 3:\r\n            secondByte = buf[i + 1]\r\n            thirdByte = buf[i + 2]\r\n            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\r\n              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\r\n              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\r\n                codePoint = tempCodePoint\r\n              }\r\n            }\r\n            break\r\n          case 4:\r\n            secondByte = buf[i + 1]\r\n            thirdByte = buf[i + 2]\r\n            fourthByte = buf[i + 3]\r\n            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\r\n              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\r\n              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\r\n                codePoint = tempCodePoint\r\n              }\r\n            }\r\n        }\r\n      }\r\n\r\n      if (codePoint === null) {\r\n        // we did not generate a valid codePoint so insert a\r\n        // replacement char (U+FFFD) and advance only 1 byte\r\n        codePoint = 0xFFFD\r\n        bytesPerSequence = 1\r\n      } else if (codePoint > 0xFFFF) {\r\n        // encode to utf16 (surrogate pair dance)\r\n        codePoint -= 0x10000\r\n        res.push(codePoint >>> 10 & 0x3FF | 0xD800)\r\n        codePoint = 0xDC00 | codePoint & 0x3FF\r\n      }\r\n\r\n      res.push(codePoint)\r\n      i += bytesPerSequence\r\n    }\r\n\r\n    return decodeCodePointsArray(res)\r\n  }\r\n\r\n  // Based on http://stackoverflow.com/a/22747272/680742, the browser with\r\n  // the lowest limit is Chrome, with 0x10000 args.\r\n  // We go 1 magnitude less, for safety\r\n  var MAX_ARGUMENTS_LENGTH = 0x1000\r\n\r\n  function decodeCodePointsArray (codePoints) {\r\n    var len = codePoints.length\r\n    if (len <= MAX_ARGUMENTS_LENGTH) {\r\n      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\r\n    }\r\n\r\n    // Decode in chunks to avoid \"call stack size exceeded\".\r\n    var res = ''\r\n    var i = 0\r\n    while (i < len) {\r\n      res += String.fromCharCode.apply(\r\n        String,\r\n        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\r\n      )\r\n    }\r\n    return res\r\n  }\r\n\r\n  function asciiSlice (buf, start, end) {\r\n    var ret = ''\r\n    end = Math.min(buf.length, end)\r\n\r\n    for (var i = start; i < end; ++i) {\r\n      ret += String.fromCharCode(buf[i] & 0x7F)\r\n    }\r\n    return ret\r\n  }\r\n\r\n  function latin1Slice (buf, start, end) {\r\n    var ret = ''\r\n    end = Math.min(buf.length, end)\r\n\r\n    for (var i = start; i < end; ++i) {\r\n      ret += String.fromCharCode(buf[i])\r\n    }\r\n    return ret\r\n  }\r\n\r\n  function hexSlice (buf, start, end) {\r\n    var len = buf.length\r\n\r\n    if (!start || start < 0) start = 0\r\n    if (!end || end < 0 || end > len) end = len\r\n\r\n    var out = ''\r\n    for (var i = start; i < end; ++i) {\r\n      out += toHex(buf[i])\r\n    }\r\n    return out\r\n  }\r\n\r\n  function utf16leSlice (buf, start, end) {\r\n    var bytes = buf.slice(start, end)\r\n    var res = ''\r\n    for (var i = 0; i < bytes.length; i += 2) {\r\n      res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\r\n    }\r\n    return res\r\n  }\r\n\r\n  Buffer.prototype.slice = function slice (start, end) {\r\n    var len = this.length\r\n    start = ~~start\r\n    end = end === undefined ? len : ~~end\r\n\r\n    if (start < 0) {\r\n      start += len\r\n      if (start < 0) start = 0\r\n    } else if (start > len) {\r\n      start = len\r\n    }\r\n\r\n    if (end < 0) {\r\n      end += len\r\n      if (end < 0) end = 0\r\n    } else if (end > len) {\r\n      end = len\r\n    }\r\n\r\n    if (end < start) end = start\r\n\r\n    var newBuf = this.subarray(start, end)\r\n    // Return an augmented `Uint8Array` instance\r\n    newBuf.__proto__ = Buffer.prototype\r\n    return newBuf\r\n  }\r\n\r\n  /*\r\n   * Need to make sure that buffer isn't trying to write out of bounds.\r\n   */\r\n  function checkOffset (offset, ext, length) {\r\n    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\r\n    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\r\n  }\r\n\r\n  Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n    var val = this[offset]\r\n    var mul = 1\r\n    var i = 0\r\n    while (++i < byteLength && (mul *= 0x100)) {\r\n      val += this[offset + i] * mul\r\n    }\r\n\r\n    return val\r\n  }\r\n\r\n  Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) {\r\n      checkOffset(offset, byteLength, this.length)\r\n    }\r\n\r\n    var val = this[offset + --byteLength]\r\n    var mul = 1\r\n    while (byteLength > 0 && (mul *= 0x100)) {\r\n      val += this[offset + --byteLength] * mul\r\n    }\r\n\r\n    return val\r\n  }\r\n\r\n  Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 1, this.length)\r\n    return this[offset]\r\n  }\r\n\r\n  Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 2, this.length)\r\n    return this[offset] | (this[offset + 1] << 8)\r\n  }\r\n\r\n  Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 2, this.length)\r\n    return (this[offset] << 8) | this[offset + 1]\r\n  }\r\n\r\n  Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n    return ((this[offset]) |\r\n        (this[offset + 1] << 8) |\r\n        (this[offset + 2] << 16)) +\r\n        (this[offset + 3] * 0x1000000)\r\n  }\r\n\r\n  Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n    return (this[offset] * 0x1000000) +\r\n      ((this[offset + 1] << 16) |\r\n      (this[offset + 2] << 8) |\r\n      this[offset + 3])\r\n  }\r\n\r\n  Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n    var val = this[offset]\r\n    var mul = 1\r\n    var i = 0\r\n    while (++i < byteLength && (mul *= 0x100)) {\r\n      val += this[offset + i] * mul\r\n    }\r\n    mul *= 0x80\r\n\r\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength)\r\n\r\n    return val\r\n  }\r\n\r\n  Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n    var i = byteLength\r\n    var mul = 1\r\n    var val = this[offset + --i]\r\n    while (i > 0 && (mul *= 0x100)) {\r\n      val += this[offset + --i] * mul\r\n    }\r\n    mul *= 0x80\r\n\r\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength)\r\n\r\n    return val\r\n  }\r\n\r\n  Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 1, this.length)\r\n    if (!(this[offset] & 0x80)) return (this[offset])\r\n    return ((0xff - this[offset] + 1) * -1)\r\n  }\r\n\r\n  Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 2, this.length)\r\n    var val = this[offset] | (this[offset + 1] << 8)\r\n    return (val & 0x8000) ? val | 0xFFFF0000 : val\r\n  }\r\n\r\n  Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 2, this.length)\r\n    var val = this[offset + 1] | (this[offset] << 8)\r\n    return (val & 0x8000) ? val | 0xFFFF0000 : val\r\n  }\r\n\r\n  Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n    return (this[offset]) |\r\n      (this[offset + 1] << 8) |\r\n      (this[offset + 2] << 16) |\r\n      (this[offset + 3] << 24)\r\n  }\r\n\r\n  Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n    return (this[offset] << 24) |\r\n      (this[offset + 1] << 16) |\r\n      (this[offset + 2] << 8) |\r\n      (this[offset + 3])\r\n  }\r\n\r\n  Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n    return ieee754.read(this, offset, true, 23, 4)\r\n  }\r\n\r\n  Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n    return ieee754.read(this, offset, false, 23, 4)\r\n  }\r\n\r\n  Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 8, this.length)\r\n    return ieee754.read(this, offset, true, 52, 8)\r\n  }\r\n\r\n  Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 8, this.length)\r\n    return ieee754.read(this, offset, false, 52, 8)\r\n  }\r\n\r\n  function checkInt (buf, value, offset, ext, max, min) {\r\n    if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\r\n    if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\r\n    if (offset + ext > buf.length) throw new RangeError('Index out of range')\r\n  }\r\n\r\n  Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) {\r\n      var maxBytes = Math.pow(2, 8 * byteLength) - 1\r\n      checkInt(this, value, offset, byteLength, maxBytes, 0)\r\n    }\r\n\r\n    var mul = 1\r\n    var i = 0\r\n    this[offset] = value & 0xFF\r\n    while (++i < byteLength && (mul *= 0x100)) {\r\n      this[offset + i] = (value / mul) & 0xFF\r\n    }\r\n\r\n    return offset + byteLength\r\n  }\r\n\r\n  Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) {\r\n      var maxBytes = Math.pow(2, 8 * byteLength) - 1\r\n      checkInt(this, value, offset, byteLength, maxBytes, 0)\r\n    }\r\n\r\n    var i = byteLength - 1\r\n    var mul = 1\r\n    this[offset + i] = value & 0xFF\r\n    while (--i >= 0 && (mul *= 0x100)) {\r\n      this[offset + i] = (value / mul) & 0xFF\r\n    }\r\n\r\n    return offset + byteLength\r\n  }\r\n\r\n  Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\r\n    this[offset] = (value & 0xff)\r\n    return offset + 1\r\n  }\r\n\r\n  Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n    return offset + 2\r\n  }\r\n\r\n  Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\r\n    this[offset] = (value >>> 8)\r\n    this[offset + 1] = (value & 0xff)\r\n    return offset + 2\r\n  }\r\n\r\n  Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\r\n    this[offset + 3] = (value >>> 24)\r\n    this[offset + 2] = (value >>> 16)\r\n    this[offset + 1] = (value >>> 8)\r\n    this[offset] = (value & 0xff)\r\n    return offset + 4\r\n  }\r\n\r\n  Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\r\n    this[offset] = (value >>> 24)\r\n    this[offset + 1] = (value >>> 16)\r\n    this[offset + 2] = (value >>> 8)\r\n    this[offset + 3] = (value & 0xff)\r\n    return offset + 4\r\n  }\r\n\r\n  Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) {\r\n      var limit = Math.pow(2, (8 * byteLength) - 1)\r\n\r\n      checkInt(this, value, offset, byteLength, limit - 1, -limit)\r\n    }\r\n\r\n    var i = 0\r\n    var mul = 1\r\n    var sub = 0\r\n    this[offset] = value & 0xFF\r\n    while (++i < byteLength && (mul *= 0x100)) {\r\n      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\r\n        sub = 1\r\n      }\r\n      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\r\n    }\r\n\r\n    return offset + byteLength\r\n  }\r\n\r\n  Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) {\r\n      var limit = Math.pow(2, (8 * byteLength) - 1)\r\n\r\n      checkInt(this, value, offset, byteLength, limit - 1, -limit)\r\n    }\r\n\r\n    var i = byteLength - 1\r\n    var mul = 1\r\n    var sub = 0\r\n    this[offset + i] = value & 0xFF\r\n    while (--i >= 0 && (mul *= 0x100)) {\r\n      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\r\n        sub = 1\r\n      }\r\n      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\r\n    }\r\n\r\n    return offset + byteLength\r\n  }\r\n\r\n  Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\r\n    if (value < 0) value = 0xff + value + 1\r\n    this[offset] = (value & 0xff)\r\n    return offset + 1\r\n  }\r\n\r\n  Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n    return offset + 2\r\n  }\r\n\r\n  Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\r\n    this[offset] = (value >>> 8)\r\n    this[offset + 1] = (value & 0xff)\r\n    return offset + 2\r\n  }\r\n\r\n  Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n    this[offset + 2] = (value >>> 16)\r\n    this[offset + 3] = (value >>> 24)\r\n    return offset + 4\r\n  }\r\n\r\n  Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\r\n    if (value < 0) value = 0xffffffff + value + 1\r\n    this[offset] = (value >>> 24)\r\n    this[offset + 1] = (value >>> 16)\r\n    this[offset + 2] = (value >>> 8)\r\n    this[offset + 3] = (value & 0xff)\r\n    return offset + 4\r\n  }\r\n\r\n  function checkIEEE754 (buf, value, offset, ext, max, min) {\r\n    if (offset + ext > buf.length) throw new RangeError('Index out of range')\r\n    if (offset < 0) throw new RangeError('Index out of range')\r\n  }\r\n\r\n  function writeFloat (buf, value, offset, littleEndian, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) {\r\n      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\r\n    }\r\n    ieee754.write(buf, value, offset, littleEndian, 23, 4)\r\n    return offset + 4\r\n  }\r\n\r\n  Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\r\n    return writeFloat(this, value, offset, true, noAssert)\r\n  }\r\n\r\n  Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\r\n    return writeFloat(this, value, offset, false, noAssert)\r\n  }\r\n\r\n  function writeDouble (buf, value, offset, littleEndian, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) {\r\n      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\r\n    }\r\n    ieee754.write(buf, value, offset, littleEndian, 52, 8)\r\n    return offset + 8\r\n  }\r\n\r\n  Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\r\n    return writeDouble(this, value, offset, true, noAssert)\r\n  }\r\n\r\n  Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\r\n    return writeDouble(this, value, offset, false, noAssert)\r\n  }\r\n\r\n  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\r\n  Buffer.prototype.copy = function copy (target, targetStart, start, end) {\r\n    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\r\n    if (!start) start = 0\r\n    if (!end && end !== 0) end = this.length\r\n    if (targetStart >= target.length) targetStart = target.length\r\n    if (!targetStart) targetStart = 0\r\n    if (end > 0 && end < start) end = start\r\n\r\n    // Copy 0 bytes; we're done\r\n    if (end === start) return 0\r\n    if (target.length === 0 || this.length === 0) return 0\r\n\r\n    // Fatal error conditions\r\n    if (targetStart < 0) {\r\n      throw new RangeError('targetStart out of bounds')\r\n    }\r\n    if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\r\n    if (end < 0) throw new RangeError('sourceEnd out of bounds')\r\n\r\n    // Are we oob?\r\n    if (end > this.length) end = this.length\r\n    if (target.length - targetStart < end - start) {\r\n      end = target.length - targetStart + start\r\n    }\r\n\r\n    var len = end - start\r\n\r\n    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\r\n      // Use built-in when available, missing from IE11\r\n      this.copyWithin(targetStart, start, end)\r\n    } else if (this === target && start < targetStart && targetStart < end) {\r\n      // descending copy from end\r\n      for (var i = len - 1; i >= 0; --i) {\r\n        target[i + targetStart] = this[i + start]\r\n      }\r\n    } else {\r\n      Uint8Array.prototype.set.call(\r\n        target,\r\n        this.subarray(start, end),\r\n        targetStart\r\n      )\r\n    }\r\n\r\n    return len\r\n  }\r\n\r\n  // Usage:\r\n  //    buffer.fill(number[, offset[, end]])\r\n  //    buffer.fill(buffer[, offset[, end]])\r\n  //    buffer.fill(string[, offset[, end]][, encoding])\r\n  Buffer.prototype.fill = function fill (val, start, end, encoding) {\r\n    // Handle string cases:\r\n    if (typeof val === 'string') {\r\n      if (typeof start === 'string') {\r\n        encoding = start\r\n        start = 0\r\n        end = this.length\r\n      } else if (typeof end === 'string') {\r\n        encoding = end\r\n        end = this.length\r\n      }\r\n      if (encoding !== undefined && typeof encoding !== 'string') {\r\n        throw new TypeError('encoding must be a string')\r\n      }\r\n      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\r\n        throw new TypeError('Unknown encoding: ' + encoding)\r\n      }\r\n      if (val.length === 1) {\r\n        var code = val.charCodeAt(0)\r\n        if ((encoding === 'utf8' && code < 128) ||\r\n            encoding === 'latin1') {\r\n          // Fast path: If `val` fits into a single byte, use that numeric value.\r\n          val = code\r\n        }\r\n      }\r\n    } else if (typeof val === 'number') {\r\n      val = val & 255\r\n    }\r\n\r\n    // Invalid ranges are not set to a default, so can range check early.\r\n    if (start < 0 || this.length < start || this.length < end) {\r\n      throw new RangeError('Out of range index')\r\n    }\r\n\r\n    if (end <= start) {\r\n      return this\r\n    }\r\n\r\n    start = start >>> 0\r\n    end = end === undefined ? this.length : end >>> 0\r\n\r\n    if (!val) val = 0\r\n\r\n    var i\r\n    if (typeof val === 'number') {\r\n      for (i = start; i < end; ++i) {\r\n        this[i] = val\r\n      }\r\n    } else {\r\n      var bytes = Buffer.isBuffer(val)\r\n        ? val\r\n        : new Buffer(val, encoding)\r\n      var len = bytes.length\r\n      if (len === 0) {\r\n        throw new TypeError('The value \"' + val +\r\n          '\" is invalid for argument \"value\"')\r\n      }\r\n      for (i = 0; i < end - start; ++i) {\r\n        this[i + start] = bytes[i % len]\r\n      }\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  // HELPER FUNCTIONS\r\n  // ================\r\n\r\n  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\r\n\r\n  function base64clean (str) {\r\n    // Node takes equal signs as end of the Base64 encoding\r\n    str = str.split('=')[0]\r\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\r\n    str = str.trim().replace(INVALID_BASE64_RE, '')\r\n    // Node converts strings with length < 2 to ''\r\n    if (str.length < 2) return ''\r\n    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\r\n    while (str.length % 4 !== 0) {\r\n      str = str + '='\r\n    }\r\n    return str\r\n  }\r\n\r\n  function toHex (n) {\r\n    if (n < 16) return '0' + n.toString(16)\r\n    return n.toString(16)\r\n  }\r\n\r\n  function utf8ToBytes (string, units) {\r\n    units = units || Infinity\r\n    var codePoint\r\n    var length = string.length\r\n    var leadSurrogate = null\r\n    var bytes = []\r\n\r\n    for (var i = 0; i < length; ++i) {\r\n      codePoint = string.charCodeAt(i)\r\n\r\n      // is surrogate component\r\n      if (codePoint > 0xD7FF && codePoint < 0xE000) {\r\n        // last char was a lead\r\n        if (!leadSurrogate) {\r\n          // no lead yet\r\n          if (codePoint > 0xDBFF) {\r\n            // unexpected trail\r\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n            continue\r\n          } else if (i + 1 === length) {\r\n            // unpaired lead\r\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n            continue\r\n          }\r\n\r\n          // valid lead\r\n          leadSurrogate = codePoint\r\n\r\n          continue\r\n        }\r\n\r\n        // 2 leads in a row\r\n        if (codePoint < 0xDC00) {\r\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n          leadSurrogate = codePoint\r\n          continue\r\n        }\r\n\r\n        // valid surrogate pair\r\n        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\r\n      } else if (leadSurrogate) {\r\n        // valid bmp char, but last char was a lead\r\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n      }\r\n\r\n      leadSurrogate = null\r\n\r\n      // encode utf8\r\n      if (codePoint < 0x80) {\r\n        if ((units -= 1) < 0) break\r\n        bytes.push(codePoint)\r\n      } else if (codePoint < 0x800) {\r\n        if ((units -= 2) < 0) break\r\n        bytes.push(\r\n          codePoint >> 0x6 | 0xC0,\r\n          codePoint & 0x3F | 0x80\r\n        )\r\n      } else if (codePoint < 0x10000) {\r\n        if ((units -= 3) < 0) break\r\n        bytes.push(\r\n          codePoint >> 0xC | 0xE0,\r\n          codePoint >> 0x6 & 0x3F | 0x80,\r\n          codePoint & 0x3F | 0x80\r\n        )\r\n      } else if (codePoint < 0x110000) {\r\n        if ((units -= 4) < 0) break\r\n        bytes.push(\r\n          codePoint >> 0x12 | 0xF0,\r\n          codePoint >> 0xC & 0x3F | 0x80,\r\n          codePoint >> 0x6 & 0x3F | 0x80,\r\n          codePoint & 0x3F | 0x80\r\n        )\r\n      } else {\r\n        throw new Error('Invalid code point')\r\n      }\r\n    }\r\n\r\n    return bytes\r\n  }\r\n\r\n  function asciiToBytes (str) {\r\n    var byteArray = []\r\n    for (var i = 0; i < str.length; ++i) {\r\n      // Node's code seems to be doing this and not & 0x7F..\r\n      byteArray.push(str.charCodeAt(i) & 0xFF)\r\n    }\r\n    return byteArray\r\n  }\r\n\r\n  function utf16leToBytes (str, units) {\r\n    var c, hi, lo\r\n    var byteArray = []\r\n    for (var i = 0; i < str.length; ++i) {\r\n      if ((units -= 2) < 0) break\r\n\r\n      c = str.charCodeAt(i)\r\n      hi = c >> 8\r\n      lo = c % 256\r\n      byteArray.push(lo)\r\n      byteArray.push(hi)\r\n    }\r\n\r\n    return byteArray\r\n  }\r\n\r\n  function base64ToBytes (str) {\r\n    return base64.toByteArray(base64clean(str))\r\n  }\r\n\r\n  function blitBuffer (src, dst, offset, length) {\r\n    for (var i = 0; i < length; ++i) {\r\n      if ((i + offset >= dst.length) || (i >= src.length)) break\r\n      dst[i + offset] = src[i]\r\n    }\r\n    return i\r\n  }\r\n\r\n  // ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check\r\n  // but they should be treated as valid. See: https://github.com/feross/buffer/issues/166\r\n  function isArrayBuffer (obj) {\r\n    return obj instanceof ArrayBuffer ||\r\n      (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&\r\n        typeof obj.byteLength === 'number')\r\n  }\r\n\r\n  function numberIsNaN (obj) {\r\n    return obj !== obj // eslint-disable-line no-self-compare\r\n  }\r\n\r\n  return exports;\r\n\r\n});\ndefine('skylark-browserfs/core/api_error',[\n  '../libs/buffers'\n],function (buffers) {\n    const { Buffer } = buffers;\n\n    /**\n     * Standard libc error codes. Add more to this enum and ErrorStrings as they are\n     * needed.\n     * @url http://www.gnu.org/software/libc/manual/html_node/Error-Codes.html\n     */\n    var ErrorCode;\n    (function (ErrorCode) {\n        ErrorCode[ErrorCode[\"EPERM\"] = 1] = \"EPERM\";\n        ErrorCode[ErrorCode[\"ENOENT\"] = 2] = \"ENOENT\";\n        ErrorCode[ErrorCode[\"EIO\"] = 5] = \"EIO\";\n        ErrorCode[ErrorCode[\"EBADF\"] = 9] = \"EBADF\";\n        ErrorCode[ErrorCode[\"EACCES\"] = 13] = \"EACCES\";\n        ErrorCode[ErrorCode[\"EBUSY\"] = 16] = \"EBUSY\";\n        ErrorCode[ErrorCode[\"EEXIST\"] = 17] = \"EEXIST\";\n        ErrorCode[ErrorCode[\"ENOTDIR\"] = 20] = \"ENOTDIR\";\n        ErrorCode[ErrorCode[\"EISDIR\"] = 21] = \"EISDIR\";\n        ErrorCode[ErrorCode[\"EINVAL\"] = 22] = \"EINVAL\";\n        ErrorCode[ErrorCode[\"EFBIG\"] = 27] = \"EFBIG\";\n        ErrorCode[ErrorCode[\"ENOSPC\"] = 28] = \"ENOSPC\";\n        ErrorCode[ErrorCode[\"EROFS\"] = 30] = \"EROFS\";\n        ErrorCode[ErrorCode[\"ENOTEMPTY\"] = 39] = \"ENOTEMPTY\";\n        ErrorCode[ErrorCode[\"ENOTSUP\"] = 95] = \"ENOTSUP\";\n    })(ErrorCode || (ErrorCode = {}));\n\n    /* tslint:disable:variable-name */\n    /**\n     * Strings associated with each error code.\n     * @hidden\n     */\n    const ErrorStrings = {};\n    ErrorStrings[ErrorCode.EPERM] = 'Operation not permitted.';\n    ErrorStrings[ErrorCode.ENOENT] = 'No such file or directory.';\n    ErrorStrings[ErrorCode.EIO] = 'Input/output error.';\n    ErrorStrings[ErrorCode.EBADF] = 'Bad file descriptor.';\n    ErrorStrings[ErrorCode.EACCES] = 'Permission denied.';\n    ErrorStrings[ErrorCode.EBUSY] = 'Resource busy or locked.';\n    ErrorStrings[ErrorCode.EEXIST] = 'File exists.';\n    ErrorStrings[ErrorCode.ENOTDIR] = 'File is not a directory.';\n    ErrorStrings[ErrorCode.EISDIR] = 'File is a directory.';\n    ErrorStrings[ErrorCode.EINVAL] = 'Invalid argument.';\n    ErrorStrings[ErrorCode.EFBIG] = 'File is too big.';\n    ErrorStrings[ErrorCode.ENOSPC] = 'No space left on disk.';\n    ErrorStrings[ErrorCode.EROFS] = 'Cannot modify a read-only file system.';\n    ErrorStrings[ErrorCode.ENOTEMPTY] = 'Directory is not empty.';\n    ErrorStrings[ErrorCode.ENOTSUP] = 'Operation is not supported.';\n\n    /* tslint:enable:variable-name */\n    /**\n     * Represents a BrowserFS error. Passed back to applications after a failed\n     * call to the BrowserFS API.\n     */\n    class ApiError extends Error {\n        /**\n         * Represents a BrowserFS error. Passed back to applications after a failed\n         * call to the BrowserFS API.\n         *\n         * Error codes mirror those returned by regular Unix file operations, which is\n         * what Node returns.\n         * @constructor ApiError\n         * @param type The type of the error.\n         * @param [message] A descriptive error message.\n         */\n        constructor(type, message = ErrorStrings[type], path) {\n            super(message);\n            // Unsupported.\n            this.syscall = \"\";\n            this.errno = type;\n            this.code = ErrorCode[type];\n            this.path = path;\n            this.stack = new Error().stack;\n            this.message = `Error: ${this.code}: ${message}${this.path ? `, '${this.path}'` : ''}`;\n        }\n        static fromJSON(json) {\n            const err = new ApiError(0);\n            err.errno = json.errno;\n            err.code = json.code;\n            err.path = json.path;\n            err.stack = json.stack;\n            err.message = json.message;\n            return err;\n        }\n        /**\n         * Creates an ApiError object from a buffer.\n         */\n        static fromBuffer(buffer, i = 0) {\n            return ApiError.fromJSON(JSON.parse(buffer.toString('utf8', i + 4, i + 4 + buffer.readUInt32LE(i))));\n        }\n        static FileError(code, p) {\n            return new ApiError(code, ErrorStrings[code], p);\n        }\n        static ENOENT(path) {\n            return this.FileError(ErrorCode.ENOENT, path);\n        }\n        static EEXIST(path) {\n            return this.FileError(ErrorCode.EEXIST, path);\n        }\n        static EISDIR(path) {\n            return this.FileError(ErrorCode.EISDIR, path);\n        }\n        static ENOTDIR(path) {\n            return this.FileError(ErrorCode.ENOTDIR, path);\n        }\n        static EPERM(path) {\n            return this.FileError(ErrorCode.EPERM, path);\n        }\n        static ENOTEMPTY(path) {\n            return this.FileError(ErrorCode.ENOTEMPTY, path);\n        }\n        /**\n         * @return A friendly error message.\n         */\n        toString() {\n            return this.message;\n        }\n        toJSON() {\n            return {\n                errno: this.errno,\n                code: this.code,\n                path: this.path,\n                stack: this.stack,\n                message: this.message\n            };\n        }\n        /**\n         * Writes the API error into a buffer.\n         */\n        writeToBuffer(buffer = Buffer.alloc(this.bufferSize()), i = 0) {\n            const bytesWritten = buffer.write(JSON.stringify(this.toJSON()), i + 4);\n            buffer.writeUInt32LE(bytesWritten, i);\n            return buffer;\n        }\n        /**\n         * The size of the API error in buffer-form in bytes.\n         */\n        bufferSize() {\n            // 4 bytes for string length.\n            return 4 + Buffer.byteLength(JSON.stringify(this.toJSON()));\n        }\n    }\n\n    return {\n        ApiError,\n        ErrorCode,\n        ErrorStrings\n    };\n});\ndefine('skylark-browserfs/core/file_flag',['./api_error'], function (api_error) {\n    'use strict';\n\n  const { ErrorCode, ApiError } = api_error;\n\n  var ActionType;\n  (function (ActionType) {\n      // Indicates that the code should not do anything.\n      ActionType[ActionType[\"NOP\"] = 0] = \"NOP\";\n      // Indicates that the code should throw an exception.\n      ActionType[ActionType[\"THROW_EXCEPTION\"] = 1] = \"THROW_EXCEPTION\";\n      // Indicates that the code should truncate the file, but only if it is a file.\n      ActionType[ActionType[\"TRUNCATE_FILE\"] = 2] = \"TRUNCATE_FILE\";\n      // Indicates that the code should create the file.\n      ActionType[ActionType[\"CREATE_FILE\"] = 3] = \"CREATE_FILE\";\n  })(ActionType || (ActionType = {}));\n  /**\n   * Represents one of the following file flags. A convenience object.\n   *\n   * * `'r'` - Open file for reading. An exception occurs if the file does not exist.\n   * * `'r+'` - Open file for reading and writing. An exception occurs if the file does not exist.\n   * * `'rs'` - Open file for reading in synchronous mode. Instructs the filesystem to not cache writes.\n   * * `'rs+'` - Open file for reading and writing, and opens the file in synchronous mode.\n   * * `'w'` - Open file for writing. The file is created (if it does not exist) or truncated (if it exists).\n   * * `'wx'` - Like 'w' but opens the file in exclusive mode.\n   * * `'w+'` - Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).\n   * * `'wx+'` - Like 'w+' but opens the file in exclusive mode.\n   * * `'a'` - Open file for appending. The file is created if it does not exist.\n   * * `'ax'` - Like 'a' but opens the file in exclusive mode.\n   * * `'a+'` - Open file for reading and appending. The file is created if it does not exist.\n   * * `'ax+'` - Like 'a+' but opens the file in exclusive mode.\n   *\n   * Exclusive mode ensures that the file path is newly created.\n   */\n  class FileFlag {\n      /**\n       * This should never be called directly.\n       * @param modeStr The string representing the mode\n       * @throw when the mode string is invalid\n       */\n      constructor(flagStr) {\n          this.flagStr = flagStr;\n          if (FileFlag.validFlagStrs.indexOf(flagStr) < 0) {\n              throw new ApiError(ErrorCode.EINVAL, \"Invalid flag: \" + flagStr);\n          }\n      }\n      /**\n       * Get an object representing the given file flag.\n       * @param modeStr The string representing the flag\n       * @return The FileFlag object representing the flag\n       * @throw when the flag string is invalid\n       */\n      static getFileFlag(flagStr) {\n          // Check cache first.\n          if (FileFlag.flagCache.hasOwnProperty(flagStr)) {\n              return FileFlag.flagCache[flagStr];\n          }\n          return FileFlag.flagCache[flagStr] = new FileFlag(flagStr);\n      }\n      /**\n       * Get the underlying flag string for this flag.\n       */\n      getFlagString() {\n          return this.flagStr;\n      }\n      /**\n       * Returns true if the file is readable.\n       */\n      isReadable() {\n          return this.flagStr.indexOf('r') !== -1 || this.flagStr.indexOf('+') !== -1;\n      }\n      /**\n       * Returns true if the file is writeable.\n       */\n      isWriteable() {\n          return this.flagStr.indexOf('w') !== -1 || this.flagStr.indexOf('a') !== -1 || this.flagStr.indexOf('+') !== -1;\n      }\n      /**\n       * Returns true if the file mode should truncate.\n       */\n      isTruncating() {\n          return this.flagStr.indexOf('w') !== -1;\n      }\n      /**\n       * Returns true if the file is appendable.\n       */\n      isAppendable() {\n          return this.flagStr.indexOf('a') !== -1;\n      }\n      /**\n       * Returns true if the file is open in synchronous mode.\n       */\n      isSynchronous() {\n          return this.flagStr.indexOf('s') !== -1;\n      }\n      /**\n       * Returns true if the file is open in exclusive mode.\n       */\n      isExclusive() {\n          return this.flagStr.indexOf('x') !== -1;\n      }\n      /**\n       * Returns one of the static fields on this object that indicates the\n       * appropriate response to the path existing.\n       */\n      pathExistsAction() {\n          if (this.isExclusive()) {\n              return ActionType.THROW_EXCEPTION;\n          }\n          else if (this.isTruncating()) {\n              return ActionType.TRUNCATE_FILE;\n          }\n          else {\n              return ActionType.NOP;\n          }\n      }\n      /**\n       * Returns one of the static fields on this object that indicates the\n       * appropriate response to the path not existing.\n       */\n      pathNotExistsAction() {\n          if ((this.isWriteable() || this.isAppendable()) && this.flagStr !== 'r+') {\n              return ActionType.CREATE_FILE;\n          }\n          else {\n              return ActionType.THROW_EXCEPTION;\n          }\n      }\n  }\n  // Contains cached FileMode instances.\n  FileFlag.flagCache = {};\n  // Array of valid mode strings.\n  FileFlag.validFlagStrs = ['r', 'r+', 'rs', 'rs+', 'w', 'wx', 'w+', 'wx+', 'a', 'ax', 'a+', 'ax+'];\n\n\n\n    return {\n        ActionType: ActionType,\n        FileFlag: FileFlag\n    };\n});\ndefine('skylark-browserfs/libs/path',[],function(){\r\n\tvar splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\n\r\n\tfunction posixSplitPath(filename) {\r\n\t    var out = splitPathRe.exec(filename);\r\n\t    out.shift();\r\n\t    return out;\r\n\t}\r\n\t/**\r\n\t * Emulates Node's `path` module. This module contains utilities for handling and\r\n\t * transforming file paths. **All** of these methods perform only string\r\n\t * transformations. The file system is not consulted to check whether paths are\r\n\t * valid.\r\n\t * @see http://nodejs.org/api/path.html\r\n\t * @class\r\n\t */\r\n\tvar path = (function () {\r\n\t    function path() {\r\n\t    }\r\n\t    /**\r\n\t     * Normalize a string path, taking care of '..' and '.' parts.\r\n\t     *\r\n\t     * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.\r\n\t     * @example Usage example\r\n\t     *   path.normalize('/foo/bar//baz/asdf/quux/..')\r\n\t     *   // returns\r\n\t     *   '/foo/bar/baz/asdf'\r\n\t     * @param [String] p The path to normalize.\r\n\t     * @return [String]\r\n\t     */\r\n\t    path.normalize = function (p) {\r\n\t        // Special case: '' -> '.'\r\n\t        if (p === '') {\r\n\t            p = '.';\r\n\t        }\r\n\t        // It's very important to know if the path is relative or not, since it\r\n\t        // changes how we process .. and reconstruct the split string.\r\n\t        var absolute = p.charAt(0) === path.sep;\r\n\t        // Remove repeated //s\r\n\t        p = path._removeDuplicateSeps(p);\r\n\t        // Try to remove as many '../' as possible, and remove '.' completely.\r\n\t        var components = p.split(path.sep);\r\n\t        var goodComponents = [];\r\n\t        for (var idx = 0; idx < components.length; idx++) {\r\n\t            var c = components[idx];\r\n\t            if (c === '.') {\r\n\t                continue;\r\n\t            }\r\n\t            else if (c === '..' && (absolute || (!absolute && goodComponents.length > 0 && goodComponents[0] !== '..'))) {\r\n\t                // In the absolute case: Path is relative to root, so we may pop even if\r\n\t                // goodComponents is empty (e.g. /../ => /)\r\n\t                // In the relative case: We're getting rid of a directory that preceded\r\n\t                // it (e.g. /foo/../bar -> /bar)\r\n\t                goodComponents.pop();\r\n\t            }\r\n\t            else {\r\n\t                goodComponents.push(c);\r\n\t            }\r\n\t        }\r\n\t        // Add in '.' when it's a relative path with no other nonempty components.\r\n\t        // Possible results: '.' and './' (input: [''] or [])\r\n\t        // @todo Can probably simplify this logic.\r\n\t        if (!absolute && goodComponents.length < 2) {\r\n\t            switch (goodComponents.length) {\r\n\t                case 1:\r\n\t                    if (goodComponents[0] === '') {\r\n\t                        goodComponents.unshift('.');\r\n\t                    }\r\n\t                    break;\r\n\t                default:\r\n\t                    goodComponents.push('.');\r\n\t            }\r\n\t        }\r\n\t        p = goodComponents.join(path.sep);\r\n\t        if (absolute && p.charAt(0) !== path.sep) {\r\n\t            p = path.sep + p;\r\n\t        }\r\n\t        return p;\r\n\t    };\r\n\t    /**\r\n\t     * Join all arguments together and normalize the resulting path.\r\n\t     *\r\n\t     * Arguments must be strings.\r\n\t     * @example Usage\r\n\t     *   path.join('/foo', 'bar', 'baz/asdf', 'quux', '..')\r\n\t     *   // returns\r\n\t     *   '/foo/bar/baz/asdf'\r\n\t     *\r\n\t     *   path.join('foo', {}, 'bar')\r\n\t     *   // throws exception\r\n\t     *   TypeError: Arguments to path.join must be strings\r\n\t     * @param [String,...] paths Each component of the path\r\n\t     * @return [String]\r\n\t     */\r\n\t    path.join = function () {\r\n\t        var paths = [];\r\n\t        for (var _i = 0; _i < arguments.length; _i++) {\r\n\t            paths[_i - 0] = arguments[_i];\r\n\t        }\r\n\t        // Required: Prune any non-strings from the path. I also prune empty segments\r\n\t        // so we can do a simple join of the array.\r\n\t        var processed = [];\r\n\t        for (var i = 0; i < paths.length; i++) {\r\n\t            var segment = paths[i];\r\n\t            if (typeof segment !== 'string') {\r\n\t                throw new TypeError(\"Invalid argument type to path.join: \" + (typeof segment));\r\n\t            }\r\n\t            else if (segment !== '') {\r\n\t                processed.push(segment);\r\n\t            }\r\n\t        }\r\n\t        return path.normalize(processed.join(path.sep));\r\n\t    };\r\n\t    /**\r\n\t     * Resolves to to an absolute path.\r\n\t     *\r\n\t     * If to isn't already absolute from arguments are prepended in right to left\r\n\t     * order, until an absolute path is found. If after using all from paths still\r\n\t     * no absolute path is found, the current working directory is used as well.\r\n\t     * The resulting path is normalized, and trailing slashes are removed unless\r\n\t     * the path gets resolved to the root directory. Non-string arguments are\r\n\t     * ignored.\r\n\t     *\r\n\t     * Another way to think of it is as a sequence of cd commands in a shell.\r\n\t     *\r\n\t     *     path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile')\r\n\t     *\r\n\t     * Is similar to:\r\n\t     *\r\n\t     *     cd foo/bar\r\n\t     *     cd /tmp/file/\r\n\t     *     cd ..\r\n\t     *     cd a/../subfile\r\n\t     *     pwd\r\n\t     *\r\n\t     * The difference is that the different paths don't need to exist and may also\r\n\t     * be files.\r\n\t     * @example Usage example\r\n\t     *   path.resolve('/foo/bar', './baz')\r\n\t     *   // returns\r\n\t     *   '/foo/bar/baz'\r\n\t     *\r\n\t     *   path.resolve('/foo/bar', '/tmp/file/')\r\n\t     *   // returns\r\n\t     *   '/tmp/file'\r\n\t     *\r\n\t     *   path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')\r\n\t     *   // if currently in /home/myself/node, it returns\r\n\t     *   '/home/myself/node/wwwroot/static_files/gif/image.gif'\r\n\t     * @param [String,...] paths\r\n\t     * @return [String]\r\n\t     */\r\n\t    path.resolve = function () {\r\n\t        var paths = [];\r\n\t        for (var _i = 0; _i < arguments.length; _i++) {\r\n\t            paths[_i - 0] = arguments[_i];\r\n\t        }\r\n\t        // Monitor for invalid paths, throw out empty paths, and look for the *last*\r\n\t        // absolute path that we see.\r\n\t        var processed = [];\r\n\t        for (var i = 0; i < paths.length; i++) {\r\n\t            var p = paths[i];\r\n\t            if (typeof p !== 'string') {\r\n\t                throw new TypeError(\"Invalid argument type to path.join: \" + (typeof p));\r\n\t            }\r\n\t            else if (p !== '') {\r\n\t                // Remove anything that has occurred before this absolute path, as it\r\n\t                // doesn't matter.\r\n\t                if (p.charAt(0) === path.sep) {\r\n\t                    processed = [];\r\n\t                }\r\n\t                processed.push(p);\r\n\t            }\r\n\t        }\r\n\t        // Special: Remove trailing slash unless it's the root\r\n\t        var resolved = path.normalize(processed.join(path.sep));\r\n\t        if (resolved.length > 1 && resolved.charAt(resolved.length - 1) === path.sep) {\r\n\t            return resolved.substr(0, resolved.length - 1);\r\n\t        }\r\n\t        // Special: If it doesn't start with '/', it's relative and we need to append\r\n\t        // the current directory.\r\n\t        if (resolved.charAt(0) !== path.sep) {\r\n\t            // Remove ./, since we're going to append the current directory.\r\n\t            if (resolved.charAt(0) === '.' && (resolved.length === 1 || resolved.charAt(1) === path.sep)) {\r\n\t                resolved = resolved.length === 1 ? '' : resolved.substr(2);\r\n\t            }\r\n\t            // Append the current directory, which *must* be an absolute path.\r\n\t            var cwd = process.cwd();\r\n\t            if (resolved !== '') {\r\n\t                // cwd will never end in a /... unless it's the root.\r\n\t                resolved = this.normalize(cwd + (cwd !== '/' ? path.sep : '') + resolved);\r\n\t            }\r\n\t            else {\r\n\t                resolved = cwd;\r\n\t            }\r\n\t        }\r\n\t        return resolved;\r\n\t    };\r\n\t    /**\r\n\t     * Solve the relative path from from to to.\r\n\t     *\r\n\t     * At times we have two absolute paths, and we need to derive the relative path\r\n\t     * from one to the other. This is actually the reverse transform of\r\n\t     * path.resolve, which means we see that:\r\n\t     *\r\n\t     *    path.resolve(from, path.relative(from, to)) == path.resolve(to)\r\n\t     *\r\n\t     * @example Usage example\r\n\t     *   path.relative('C:\\\\orandea\\\\test\\\\aaa', 'C:\\\\orandea\\\\impl\\\\bbb')\r\n\t     *   // returns\r\n\t     *   '..\\\\..\\\\impl\\\\bbb'\r\n\t     *\r\n\t     *   path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')\r\n\t     *   // returns\r\n\t     *   '../../impl/bbb'\r\n\t     * @param [String] from\r\n\t     * @param [String] to\r\n\t     * @return [String]\r\n\t     */\r\n\t    path.relative = function (from, to) {\r\n\t        var i;\r\n\t        // Alright. Let's resolve these two to absolute paths and remove any\r\n\t        // weirdness.\r\n\t        from = path.resolve(from);\r\n\t        to = path.resolve(to);\r\n\t        var fromSegs = from.split(path.sep);\r\n\t        var toSegs = to.split(path.sep);\r\n\t        // Remove the first segment on both, as it's '' (both are absolute paths)\r\n\t        toSegs.shift();\r\n\t        fromSegs.shift();\r\n\t        // There are two segments to this path:\r\n\t        // * Going *up* the directory hierarchy with '..'\r\n\t        // * Going *down* the directory hierarchy with foo/baz/bat.\r\n\t        var upCount = 0;\r\n\t        var downSegs = [];\r\n\t        // Figure out how many things in 'from' are shared with 'to'.\r\n\t        for (i = 0; i < fromSegs.length; i++) {\r\n\t            var seg = fromSegs[i];\r\n\t            if (seg === toSegs[i]) {\r\n\t                continue;\r\n\t            }\r\n\t            // The rest of 'from', including the current element, indicates how many\r\n\t            // directories we need to go up.\r\n\t            upCount = fromSegs.length - i;\r\n\t            break;\r\n\t        }\r\n\t        // The rest of 'to' indicates where we need to change to. We place this\r\n\t        // outside of the loop, as toSegs.length may be greater than fromSegs.length.\r\n\t        downSegs = toSegs.slice(i);\r\n\t        // Special case: If 'from' is '/'\r\n\t        if (fromSegs.length === 1 && fromSegs[0] === '') {\r\n\t            upCount = 0;\r\n\t        }\r\n\t        // upCount can't be greater than the number of fromSegs\r\n\t        // (cd .. from / is still /)\r\n\t        if (upCount > fromSegs.length) {\r\n\t            upCount = fromSegs.length;\r\n\t        }\r\n\t        // Create the final string!\r\n\t        var rv = '';\r\n\t        for (i = 0; i < upCount; i++) {\r\n\t            rv += '../';\r\n\t        }\r\n\t        rv += downSegs.join(path.sep);\r\n\t        // Special case: Remove trailing '/'. Happens if it's all up and no down.\r\n\t        if (rv.length > 1 && rv.charAt(rv.length - 1) === path.sep) {\r\n\t            rv = rv.substr(0, rv.length - 1);\r\n\t        }\r\n\t        return rv;\r\n\t    };\r\n\t    /**\r\n\t     * Return the directory name of a path. Similar to the Unix `dirname` command.\r\n\t     *\r\n\t     * Note that BrowserFS does not validate if the path is actually a valid\r\n\t     * directory.\r\n\t     * @example Usage example\r\n\t     *   path.dirname('/foo/bar/baz/asdf/quux')\r\n\t     *   // returns\r\n\t     *   '/foo/bar/baz/asdf'\r\n\t     * @param [String] p The path to get the directory name of.\r\n\t     * @return [String]\r\n\t     */\r\n\t    path.dirname = function (p) {\r\n\t        // We get rid of //, but we don't modify anything else (e.g. any extraneous .\r\n\t        // and ../ are kept intact)\r\n\t        p = path._removeDuplicateSeps(p);\r\n\t        var absolute = p.charAt(0) === path.sep;\r\n\t        var sections = p.split(path.sep);\r\n\t        // Do 1 if it's /foo/bar, 2 if it's /foo/bar/\r\n\t        if (sections.pop() === '' && sections.length > 0) {\r\n\t            sections.pop();\r\n\t        }\r\n\t        // # of sections needs to be > 1 if absolute, since the first section is '' for '/'.\r\n\t        // If not absolute, the first section is the first part of the path, and is OK\r\n\t        // to return.\r\n\t        if (sections.length > 1 || (sections.length === 1 && !absolute)) {\r\n\t            return sections.join(path.sep);\r\n\t        }\r\n\t        else if (absolute) {\r\n\t            return path.sep;\r\n\t        }\r\n\t        else {\r\n\t            return '.';\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Return the last portion of a path. Similar to the Unix basename command.\r\n\t     * @example Usage example\r\n\t     *   path.basename('/foo/bar/baz/asdf/quux.html')\r\n\t     *   // returns\r\n\t     *   'quux.html'\r\n\t     *\r\n\t     *   path.basename('/foo/bar/baz/asdf/quux.html', '.html')\r\n\t     *   // returns\r\n\t     *   'quux'\r\n\t     * @param [String] p\r\n\t     * @param [String?] ext\r\n\t     * @return [String]\r\n\t     */\r\n\t    path.basename = function (p, ext) {\r\n\t        if (ext === void 0) { ext = \"\"; }\r\n\t        // Special case: Normalize will modify this to '.'\r\n\t        if (p === '') {\r\n\t            return p;\r\n\t        }\r\n\t        // Normalize the string first to remove any weirdness.\r\n\t        p = path.normalize(p);\r\n\t        // Get the last part of the string.\r\n\t        var sections = p.split(path.sep);\r\n\t        var lastPart = sections[sections.length - 1];\r\n\t        // Special case: If it's empty, then we have a string like so: foo/\r\n\t        // Meaning, 'foo' is guaranteed to be a directory.\r\n\t        if (lastPart === '' && sections.length > 1) {\r\n\t            return sections[sections.length - 2];\r\n\t        }\r\n\t        // Remove the extension, if need be.\r\n\t        if (ext.length > 0) {\r\n\t            var lastPartExt = lastPart.substr(lastPart.length - ext.length);\r\n\t            if (lastPartExt === ext) {\r\n\t                return lastPart.substr(0, lastPart.length - ext.length);\r\n\t            }\r\n\t        }\r\n\t        return lastPart;\r\n\t    };\r\n\t    /**\r\n\t     * Return the extension of the path, from the last '.' to end of string in the\r\n\t     * last portion of the path. If there is no '.' in the last portion of the path\r\n\t     * or the first character of it is '.', then it returns an empty string.\r\n\t     * @example Usage example\r\n\t     *   path.extname('index.html')\r\n\t     *   // returns\r\n\t     *   '.html'\r\n\t     *\r\n\t     *   path.extname('index.')\r\n\t     *   // returns\r\n\t     *   '.'\r\n\t     *\r\n\t     *   path.extname('index')\r\n\t     *   // returns\r\n\t     *   ''\r\n\t     * @param [String] p\r\n\t     * @return [String]\r\n\t     */\r\n\t    path.extname = function (p) {\r\n\t        p = path.normalize(p);\r\n\t        var sections = p.split(path.sep);\r\n\t        p = sections.pop();\r\n\t        // Special case: foo/file.ext/ should return '.ext'\r\n\t        if (p === '' && sections.length > 0) {\r\n\t            p = sections.pop();\r\n\t        }\r\n\t        if (p === '..') {\r\n\t            return '';\r\n\t        }\r\n\t        var i = p.lastIndexOf('.');\r\n\t        if (i === -1 || i === 0) {\r\n\t            return '';\r\n\t        }\r\n\t        return p.substr(i);\r\n\t    };\r\n\t    /**\r\n\t     * Checks if the given path is an absolute path.\r\n\t     *\r\n\t     * Despite not being documented, this is a tested part of Node's path API.\r\n\t     * @param [String] p\r\n\t     * @return [Boolean] True if the path appears to be an absolute path.\r\n\t     */\r\n\t    path.isAbsolute = function (p) {\r\n\t        return p.length > 0 && p.charAt(0) === path.sep;\r\n\t    };\r\n\t    /**\r\n\t     * Unknown. Undocumented.\r\n\t     */\r\n\t    path._makeLong = function (p) {\r\n\t        return p;\r\n\t    };\r\n\t    /**\r\n\t     * Returns an object from a path string.\r\n\t     */\r\n\t    path.parse = function (p) {\r\n\t        var allParts = posixSplitPath(p);\r\n\t        return {\r\n\t            root: allParts[0],\r\n\t            dir: allParts[0] + allParts[1].slice(0, -1),\r\n\t            base: allParts[2],\r\n\t            ext: allParts[3],\r\n\t            name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\r\n\t        };\r\n\t    };\r\n\t    path.format = function (pathObject) {\r\n\t        if (pathObject === null || typeof pathObject !== 'object') {\r\n\t            throw new TypeError(\"Parameter 'pathObject' must be an object, not \" + typeof pathObject);\r\n\t        }\r\n\t        var root = pathObject.root || '';\r\n\t        if (typeof root !== 'string') {\r\n\t            throw new TypeError(\"'pathObject.root' must be a string or undefined, not \" +\r\n\t                typeof pathObject.root);\r\n\t        }\r\n\t        var dir = pathObject.dir ? pathObject.dir + path.sep : '';\r\n\t        var base = pathObject.base || '';\r\n\t        return dir + base;\r\n\t    };\r\n\t    path._removeDuplicateSeps = function (p) {\r\n\t        p = p.replace(this._replaceRegex, this.sep);\r\n\t        return p;\r\n\t    };\r\n\t    // The platform-specific file separator. BrowserFS uses `/`.\r\n\t    path.sep = '/';\r\n\t    path._replaceRegex = new RegExp(\"//+\", 'g');\r\n\t    // The platform-specific path delimiter. BrowserFS uses `:`.\r\n\t    path.delimiter = ':';\r\n\t    path.posix = path;\r\n\t    // XXX: Typing hack. We don't actually support win32.\r\n\t    path.win32 = path;\r\n\t    return path;\r\n\t}());\r\n\r\n\r\n\treturn path;\r\n});\ndefine('skylark-browserfs/core/node_fs_stats',[\n    '../libs/buffers'\n],function (buffers) {\n    'use strict';\n    const { Buffer } = buffers;\n\n    /**\n     * Indicates the type of the given file. Applied to 'mode'.\n     */\n    var FileType;\n    (function (FileType) {\n        FileType[FileType[\"FILE\"] = 32768] = \"FILE\";\n        FileType[FileType[\"DIRECTORY\"] = 16384] = \"DIRECTORY\";\n        FileType[FileType[\"SYMLINK\"] = 40960] = \"SYMLINK\";\n    })(FileType || (FileType = {}));\n\n    /**\n     * Emulation of Node's `fs.Stats` object.\n     *\n     * Attribute descriptions are from `man 2 stat'\n     * @see http://nodejs.org/api/fs.html#fs_class_fs_stats\n     * @see http://man7.org/linux/man-pages/man2/stat.2.html\n     */\n    class Stats {\n        /**\n         * Provides information about a particular entry in the file system.\n         * @param itemType Type of the item (FILE, DIRECTORY, SYMLINK, or SOCKET)\n         * @param size Size of the item in bytes. For directories/symlinks,\n         *   this is normally the size of the struct that represents the item.\n         * @param mode Unix-style file mode (e.g. 0o644)\n         * @param atimeMs time of last access, in milliseconds since epoch\n         * @param mtimeMs time of last modification, in milliseconds since epoch\n         * @param ctimeMs time of last time file status was changed, in milliseconds since epoch\n         * @param birthtimeMs time of file creation, in milliseconds since epoch\n         */\n        constructor(itemType, size, mode, atimeMs, mtimeMs, ctimeMs, birthtimeMs) {\n            /**\n             * UNSUPPORTED ATTRIBUTES\n             * I assume no one is going to need these details, although we could fake\n             * appropriate values if need be.\n             */\n            // ID of device containing file\n            this.dev = 0;\n            // inode number\n            this.ino = 0;\n            // device ID (if special file)\n            this.rdev = 0;\n            // number of hard links\n            this.nlink = 1;\n            // blocksize for file system I/O\n            this.blksize = 4096;\n            // @todo Maybe support these? atm, it's a one-user filesystem.\n            // user ID of owner\n            this.uid = 0;\n            // group ID of owner\n            this.gid = 0;\n            // XXX: Some file systems stash data on stats objects.\n            this.fileData = null;\n            this.size = size;\n            let currentTime = 0;\n            if (typeof (atimeMs) !== 'number') {\n                currentTime = Date.now();\n                atimeMs = currentTime;\n            }\n            if (typeof (mtimeMs) !== 'number') {\n                if (!currentTime) {\n                    currentTime = Date.now();\n                }\n                mtimeMs = currentTime;\n            }\n            if (typeof (ctimeMs) !== 'number') {\n                if (!currentTime) {\n                    currentTime = Date.now();\n                }\n                ctimeMs = currentTime;\n            }\n            if (typeof (birthtimeMs) !== 'number') {\n                if (!currentTime) {\n                    currentTime = Date.now();\n                }\n                birthtimeMs = currentTime;\n            }\n            this.atimeMs = atimeMs;\n            this.ctimeMs = ctimeMs;\n            this.mtimeMs = mtimeMs;\n            this.birthtimeMs = birthtimeMs;\n            if (!mode) {\n                switch (itemType) {\n                    case FileType.FILE:\n                        this.mode = 0x1a4;\n                        break;\n                    case FileType.DIRECTORY:\n                    default:\n                        this.mode = 0x1ff;\n                }\n            }\n            else {\n                this.mode = mode;\n            }\n            // number of 512B blocks allocated\n            this.blocks = Math.ceil(size / 512);\n            // Check if mode also includes top-most bits, which indicate the file's\n            // type.\n            if (this.mode < 0x1000) {\n                this.mode |= itemType;\n            }\n        }\n        static fromBuffer(buffer) {\n            const size = buffer.readUInt32LE(0), mode = buffer.readUInt32LE(4), atime = buffer.readDoubleLE(8), mtime = buffer.readDoubleLE(16), ctime = buffer.readDoubleLE(24);\n            return new Stats(mode & 0xF000, size, mode & 0xFFF, atime, mtime, ctime);\n        }\n        /**\n         * Clones the stats object.\n         */\n        static clone(s) {\n            return new Stats(s.mode & 0xF000, s.size, s.mode & 0xFFF, s.atimeMs, s.mtimeMs, s.ctimeMs, s.birthtimeMs);\n        }\n        get atime() {\n            return new Date(this.atimeMs);\n        }\n        get mtime() {\n            return new Date(this.mtimeMs);\n        }\n        get ctime() {\n            return new Date(this.ctimeMs);\n        }\n        get birthtime() {\n            return new Date(this.birthtimeMs);\n        }\n        toBuffer() {\n            const buffer = Buffer.alloc(32);\n            buffer.writeUInt32LE(this.size, 0);\n            buffer.writeUInt32LE(this.mode, 4);\n            buffer.writeDoubleLE(this.atime.getTime(), 8);\n            buffer.writeDoubleLE(this.mtime.getTime(), 16);\n            buffer.writeDoubleLE(this.ctime.getTime(), 24);\n            return buffer;\n        }\n        /**\n         * @return [Boolean] True if this item is a file.\n         */\n        isFile() {\n            return (this.mode & 0xF000) === FileType.FILE;\n        }\n        /**\n         * @return [Boolean] True if this item is a directory.\n         */\n        isDirectory() {\n            return (this.mode & 0xF000) === FileType.DIRECTORY;\n        }\n        /**\n         * @return [Boolean] True if this item is a symbolic link (only valid through lstat)\n         */\n        isSymbolicLink() {\n            return (this.mode & 0xF000) === FileType.SYMLINK;\n        }\n        /**\n         * Change the mode of the file. We use this helper function to prevent messing\n         * up the type of the file, which is encoded in mode.\n         */\n        chmod(mode) {\n            this.mode = (this.mode & 0xF000) | mode;\n        }\n        // We don't support the following types of files.\n        isSocket() {\n            return false;\n        }\n        isBlockDevice() {\n            return false;\n        }\n        isCharacterDevice() {\n            return false;\n        }\n        isFIFO() {\n            return false;\n        }\n    }\n\n\n    return {\n        FileType,\n        Stats\n    }\n});\ndefine('skylark-browserfs/core/global',[],function () {\n    'use strict';\n    const toExport = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : global;\n    return toExport;\n});\ndefine('skylark-browserfs/generic/setImmediate',['../core/global'], function (global) {\n    'use strict';\n    /**\n     * @hidden\n     */\n    let bfsSetImmediate;\n    if (typeof (setImmediate) !== \"undefined\") {\n        bfsSetImmediate = setImmediate;\n    }\n    else {\n        const gScope = global;\n        const timeouts = [];\n        const messageName = \"zero-timeout-message\";\n        const canUsePostMessage = function () {\n            if (typeof gScope.importScripts !== 'undefined' || !gScope.postMessage) {\n                return false;\n            }\n            let postMessageIsAsync = true;\n            const oldOnMessage = gScope.onmessage;\n            gScope.onmessage = function () {\n                postMessageIsAsync = false;\n            };\n            gScope.postMessage('', '*');\n            gScope.onmessage = oldOnMessage;\n            return postMessageIsAsync;\n        };\n        if (canUsePostMessage()) {\n            bfsSetImmediate = function (fn) {\n                timeouts.push(fn);\n                gScope.postMessage(messageName, \"*\");\n            };\n            const handleMessage = function (event) {\n                if (event.source === self && event.data === messageName) {\n                    if (event.stopPropagation) {\n                        event.stopPropagation();\n                    }\n                    else {\n                        event.cancelBubble = true;\n                    }\n                    if (timeouts.length > 0) {\n                        const fn = timeouts.shift();\n                        return fn();\n                    }\n                }\n            };\n            if (gScope.addEventListener) {\n                gScope.addEventListener('message', handleMessage, true);\n            }\n            else {\n                gScope.attachEvent('onmessage', handleMessage);\n            }\n        }\n        else if (gScope.MessageChannel) {\n            // WebWorker MessageChannel\n            const channel = new gScope.MessageChannel();\n            channel.port1.onmessage = (event) => {\n                if (timeouts.length > 0) {\n                    return timeouts.shift()();\n                }\n            };\n            bfsSetImmediate = (fn) => {\n                timeouts.push(fn);\n                channel.port2.postMessage('');\n            };\n        }\n        else {\n            bfsSetImmediate = function (fn) {\n                return setTimeout(fn, 0);\n            };\n        }\n    }\n\n    return bfsSetImmediate;\n});\ndefine('skylark-browserfs/core/FS',[\n    '../libs/buffers',\n    './api_error',\n    './file_flag',\n    '../libs/path',\n    './node_fs_stats',\n    '../generic/setImmediate'\n], function (buffers,api_error, file_flag, path, node_fs_stats, setImmediate) {\n    'use strict';\n\n    const { ApiError, ErrorCode } = api_error;\n    const { FileFlag } = file_flag;\n    const {Stats} = node_fs_stats;\n    const { Buffer } = buffers;\n\n    /** Used for unit testing. Defaults to a NOP. */\n    let wrapCbHook = function (cb, numArgs) {\n        return cb;\n    };\n    /**\n     * Wraps a callback function, ensuring it is invoked through setImmediate.\n     * @hidden\n     */\n    function wrapCb(cb, numArgs) {\n        if (typeof cb !== 'function') {\n            throw new Error('Callback must be a function.');\n        }\n        const hookedCb = wrapCbHook(cb, numArgs);\n        // We could use `arguments`, but Function.call/apply is expensive. And we only\n        // need to handle 1-3 arguments\n        switch (numArgs) {\n            case 1:\n                return function (arg1) {\n                    setImmediate(function () {\n                        return hookedCb(arg1);\n                    });\n                };\n            case 2:\n                return function (arg1, arg2) {\n                    setImmediate(function () {\n                        return hookedCb(arg1, arg2);\n                    });\n                };\n            case 3:\n                return function (arg1, arg2, arg3) {\n                    setImmediate(function () {\n                        return hookedCb(arg1, arg2, arg3);\n                    });\n                };\n            default:\n                throw new Error('Invalid invocation of wrapCb.');\n        }\n    }\n    /**\n     * @hidden\n     */\n    function assertRoot(fs) {\n        if (fs) {\n            return fs;\n        }\n        throw new ApiError(ErrorCode.EIO, `Initialize BrowserFS with a file system using BrowserFS.initialize(filesystem)`);\n    }\n    /**\n     * @hidden\n     */\n    function normalizeMode(mode, def) {\n        switch (typeof mode) {\n            case 'number':\n                // (path, flag, mode, cb?)\n                return mode;\n            case 'string':\n                // (path, flag, modeString, cb?)\n                const trueMode = parseInt(mode, 8);\n                if (!isNaN(trueMode)) {\n                    return trueMode;\n                }\n                // Invalid string.\n                return def;\n            default:\n                return def;\n        }\n    }\n    /**\n     * @hidden\n     */\n    function normalizeTime(time) {\n        if (time instanceof Date) {\n            return time;\n        }\n        else if (typeof time === 'number') {\n            return new Date(time * 1000);\n        }\n        else {\n            throw new ApiError(ErrorCode.EINVAL, `Invalid time.`);\n        }\n    }\n    /**\n     * @hidden\n     */\n    function normalizePath(p) {\n        // Node doesn't allow null characters in paths.\n        if (p.indexOf('\\u0000') >= 0) {\n            throw new ApiError(ErrorCode.EINVAL, 'Path must be a string without null bytes.');\n        }\n        else if (p === '') {\n            throw new ApiError(ErrorCode.EINVAL, 'Path must not be empty.');\n        }\n        return path.resolve(p);\n    }\n    /**\n     * @hidden\n     */\n    function normalizeOptions(options, defEnc, defFlag, defMode) {\n        // typeof null === 'object' so special-case handing is needed.\n        switch (options === null ? 'null' : typeof options) {\n            case 'object':\n                return {\n                    encoding: typeof options['encoding'] !== 'undefined' ? options['encoding'] : defEnc,\n                    flag: typeof options['flag'] !== 'undefined' ? options['flag'] : defFlag,\n                    mode: normalizeMode(options['mode'], defMode)\n                };\n            case 'string':\n                return {\n                    encoding: options,\n                    flag: defFlag,\n                    mode: defMode\n                };\n            case 'null':\n            case 'undefined':\n            case 'function':\n                return {\n                    encoding: defEnc,\n                    flag: defFlag,\n                    mode: defMode\n                };\n            default:\n                throw new TypeError(`\"options\" must be a string or an object, got ${typeof options} instead.`);\n        }\n    }\n    /**\n     * The default callback is a NOP.\n     * @hidden\n     * @private\n     */\n    function nopCb() {\n        // NOP.\n    }\n    /**\n     * The node frontend to all filesystems.\n     * This layer handles:\n     *\n     * * Sanity checking inputs.\n     * * Normalizing paths.\n     * * Resetting stack depth for asynchronous operations which may not go through\n     *   the browser by wrapping all input callbacks using `setImmediate`.\n     * * Performing the requested operation through the filesystem or the file\n     *   descriptor, as appropriate.\n     * * Handling optional arguments and setting default arguments.\n     * @see http://nodejs.org/api/fs.html\n     */\n    class FS {\n        constructor() {\n            /* tslint:enable:variable-name */\n            this.F_OK = 0;\n            this.R_OK = 4;\n            this.W_OK = 2;\n            this.X_OK = 1;\n            this.root = null;\n            this.fdMap = {};\n            this.nextFd = 100;\n        }\n        initialize(rootFS) {\n            if (!rootFS.constructor.isAvailable()) {\n                throw new ApiError(ErrorCode.EINVAL, 'Tried to instantiate BrowserFS with an unavailable file system.');\n            }\n            return this.root = rootFS;\n        }\n        /**\n         * converts Date or number to a fractional UNIX timestamp\n         * Grabbed from NodeJS sources (lib/fs.js)\n         */\n        _toUnixTimestamp(time) {\n            if (typeof time === 'number') {\n                return time;\n            }\n            else if (time instanceof Date) {\n                return time.getTime() / 1000;\n            }\n            throw new Error(\"Cannot parse time: \" + time);\n        }\n        /**\n         * **NONSTANDARD**: Grab the FileSystem instance that backs this API.\n         * @return [BrowserFS.FileSystem | null] Returns null if the file system has\n         *   not been initialized.\n         */\n        getRootFS() {\n            if (this.root) {\n                return this.root;\n            }\n            else {\n                return null;\n            }\n        }\n        // FILE OR DIRECTORY METHODS\n        /**\n         * Asynchronous rename. No arguments other than a possible exception are given\n         * to the completion callback.\n         * @param oldPath\n         * @param newPath\n         * @param callback\n         */\n        rename(oldPath, newPath, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                assertRoot(this.root).rename(normalizePath(oldPath), normalizePath(newPath), newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous rename.\n         * @param oldPath\n         * @param newPath\n         */\n        renameSync(oldPath, newPath) {\n            assertRoot(this.root).renameSync(normalizePath(oldPath), normalizePath(newPath));\n        }\n        /**\n         * Test whether or not the given path exists by checking with the file system.\n         * Then call the callback argument with either true or false.\n         * @example Sample invocation\n         *   fs.exists('/etc/passwd', function (exists) {\n         *     util.debug(exists ? \"it's there\" : \"no passwd!\");\n         *   });\n         * @param path\n         * @param callback\n         */\n        exists(path, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                return assertRoot(this.root).exists(normalizePath(path), newCb);\n            }\n            catch (e) {\n                // Doesn't return an error. If something bad happens, we assume it just\n                // doesn't exist.\n                return newCb(false);\n            }\n        }\n        /**\n         * Test whether or not the given path exists by checking with the file system.\n         * @param path\n         * @return [boolean]\n         */\n        existsSync(path) {\n            try {\n                return assertRoot(this.root).existsSync(normalizePath(path));\n            }\n            catch (e) {\n                // Doesn't return an error. If something bad happens, we assume it just\n                // doesn't exist.\n                return false;\n            }\n        }\n        /**\n         * Asynchronous `stat`.\n         * @param path\n         * @param callback\n         */\n        stat(path, cb = nopCb) {\n            const newCb = wrapCb(cb, 2);\n            try {\n                return assertRoot(this.root).stat(normalizePath(path), false, newCb);\n            }\n            catch (e) {\n                return newCb(e);\n            }\n        }\n        /**\n         * Synchronous `stat`.\n         * @param path\n         * @return [BrowserFS.node.fs.Stats]\n         */\n        statSync(path) {\n            return assertRoot(this.root).statSync(normalizePath(path), false);\n        }\n        /**\n         * Asynchronous `lstat`.\n         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\n         * then the link itself is stat-ed, not the file that it refers to.\n         * @param path\n         * @param callback\n         */\n        lstat(path, cb = nopCb) {\n            const newCb = wrapCb(cb, 2);\n            try {\n                return assertRoot(this.root).stat(normalizePath(path), true, newCb);\n            }\n            catch (e) {\n                return newCb(e);\n            }\n        }\n        /**\n         * Synchronous `lstat`.\n         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\n         * then the link itself is stat-ed, not the file that it refers to.\n         * @param path\n         * @return [BrowserFS.node.fs.Stats]\n         */\n        lstatSync(path) {\n            return assertRoot(this.root).statSync(normalizePath(path), true);\n        }\n        truncate(path, arg2 = 0, cb = nopCb) {\n            let len = 0;\n            if (typeof arg2 === 'function') {\n                cb = arg2;\n            }\n            else if (typeof arg2 === 'number') {\n                len = arg2;\n            }\n            const newCb = wrapCb(cb, 1);\n            try {\n                if (len < 0) {\n                    throw new ApiError(ErrorCode.EINVAL);\n                }\n                return assertRoot(this.root).truncate(normalizePath(path), len, newCb);\n            }\n            catch (e) {\n                return newCb(e);\n            }\n        }\n        /**\n         * Synchronous `truncate`.\n         * @param path\n         * @param len\n         */\n        truncateSync(path, len = 0) {\n            if (len < 0) {\n                throw new ApiError(ErrorCode.EINVAL);\n            }\n            return assertRoot(this.root).truncateSync(normalizePath(path), len);\n        }\n        /**\n         * Asynchronous `unlink`.\n         * @param path\n         * @param callback\n         */\n        unlink(path, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                return assertRoot(this.root).unlink(normalizePath(path), newCb);\n            }\n            catch (e) {\n                return newCb(e);\n            }\n        }\n        /**\n         * Synchronous `unlink`.\n         * @param path\n         */\n        unlinkSync(path) {\n            return assertRoot(this.root).unlinkSync(normalizePath(path));\n        }\n        open(path, flag, arg2, cb = nopCb) {\n            const mode = normalizeMode(arg2, 0x1a4);\n            cb = typeof arg2 === 'function' ? arg2 : cb;\n            const newCb = wrapCb(cb, 2);\n            try {\n                assertRoot(this.root).open(normalizePath(path), FileFlag.getFileFlag(flag), mode, (e, file) => {\n                    if (file) {\n                        newCb(e, this.getFdForFile(file));\n                    }\n                    else {\n                        newCb(e);\n                    }\n                });\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous file open.\n         * @see http://www.manpagez.com/man/2/open/\n         * @param path\n         * @param flags\n         * @param mode defaults to `0644`\n         * @return [BrowserFS.File]\n         */\n        openSync(path, flag, mode = 0x1a4) {\n            return this.getFdForFile(assertRoot(this.root).openSync(normalizePath(path), FileFlag.getFileFlag(flag), normalizeMode(mode, 0x1a4)));\n        }\n        readFile(filename, arg2 = {}, cb = nopCb) {\n            const options = normalizeOptions(arg2, null, 'r', null);\n            cb = typeof arg2 === 'function' ? arg2 : cb;\n            const newCb = wrapCb(cb, 2);\n            try {\n                const flag = FileFlag.getFileFlag(options['flag']);\n                if (!flag.isReadable()) {\n                    return newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to readFile must allow for reading.'));\n                }\n                return assertRoot(this.root).readFile(normalizePath(filename), options.encoding, flag, newCb);\n            }\n            catch (e) {\n                return newCb(e);\n            }\n        }\n        readFileSync(filename, arg2 = {}) {\n            const options = normalizeOptions(arg2, null, 'r', null);\n            const flag = FileFlag.getFileFlag(options.flag);\n            if (!flag.isReadable()) {\n                throw new ApiError(ErrorCode.EINVAL, 'Flag passed to readFile must allow for reading.');\n            }\n            return assertRoot(this.root).readFileSync(normalizePath(filename), options.encoding, flag);\n        }\n        writeFile(filename, data, arg3 = {}, cb = nopCb) {\n            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\n            cb = typeof arg3 === 'function' ? arg3 : cb;\n            const newCb = wrapCb(cb, 1);\n            try {\n                const flag = FileFlag.getFileFlag(options.flag);\n                if (!flag.isWriteable()) {\n                    return newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to writeFile must allow for writing.'));\n                }\n                return assertRoot(this.root).writeFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\n            }\n            catch (e) {\n                return newCb(e);\n            }\n        }\n        writeFileSync(filename, data, arg3) {\n            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\n            const flag = FileFlag.getFileFlag(options.flag);\n            if (!flag.isWriteable()) {\n                throw new ApiError(ErrorCode.EINVAL, 'Flag passed to writeFile must allow for writing.');\n            }\n            return assertRoot(this.root).writeFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\n        }\n        appendFile(filename, data, arg3, cb = nopCb) {\n            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\n            cb = typeof arg3 === 'function' ? arg3 : cb;\n            const newCb = wrapCb(cb, 1);\n            try {\n                const flag = FileFlag.getFileFlag(options.flag);\n                if (!flag.isAppendable()) {\n                    return newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to appendFile must allow for appending.'));\n                }\n                assertRoot(this.root).appendFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        appendFileSync(filename, data, arg3) {\n            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\n            const flag = FileFlag.getFileFlag(options.flag);\n            if (!flag.isAppendable()) {\n                throw new ApiError(ErrorCode.EINVAL, 'Flag passed to appendFile must allow for appending.');\n            }\n            return assertRoot(this.root).appendFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\n        }\n        // FILE DESCRIPTOR METHODS\n        /**\n         * Asynchronous `fstat`.\n         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\n         * specified by the file descriptor `fd`.\n         * @param fd\n         * @param callback\n         */\n        fstat(fd, cb = nopCb) {\n            const newCb = wrapCb(cb, 2);\n            try {\n                const file = this.fd2file(fd);\n                file.stat(newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `fstat`.\n         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\n         * specified by the file descriptor `fd`.\n         * @param fd\n         * @return [BrowserFS.node.fs.Stats]\n         */\n        fstatSync(fd) {\n            return this.fd2file(fd).statSync();\n        }\n        /**\n         * Asynchronous close.\n         * @param fd\n         * @param callback\n         */\n        close(fd, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                this.fd2file(fd).close((e) => {\n                    if (!e) {\n                        this.closeFd(fd);\n                    }\n                    newCb(e);\n                });\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous close.\n         * @param fd\n         */\n        closeSync(fd) {\n            this.fd2file(fd).closeSync();\n            this.closeFd(fd);\n        }\n        ftruncate(fd, arg2, cb = nopCb) {\n            const length = typeof arg2 === 'number' ? arg2 : 0;\n            cb = typeof arg2 === 'function' ? arg2 : cb;\n            const newCb = wrapCb(cb, 1);\n            try {\n                const file = this.fd2file(fd);\n                if (length < 0) {\n                    throw new ApiError(ErrorCode.EINVAL);\n                }\n                file.truncate(length, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous ftruncate.\n         * @param fd\n         * @param len\n         */\n        ftruncateSync(fd, len = 0) {\n            const file = this.fd2file(fd);\n            if (len < 0) {\n                throw new ApiError(ErrorCode.EINVAL);\n            }\n            file.truncateSync(len);\n        }\n        /**\n         * Asynchronous fsync.\n         * @param fd\n         * @param callback\n         */\n        fsync(fd, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                this.fd2file(fd).sync(newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous fsync.\n         * @param fd\n         */\n        fsyncSync(fd) {\n            this.fd2file(fd).syncSync();\n        }\n        /**\n         * Asynchronous fdatasync.\n         * @param fd\n         * @param callback\n         */\n        fdatasync(fd, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                this.fd2file(fd).datasync(newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous fdatasync.\n         * @param fd\n         */\n        fdatasyncSync(fd) {\n            this.fd2file(fd).datasyncSync();\n        }\n        write(fd, arg2, arg3, arg4, arg5, cb = nopCb) {\n            let buffer, offset, length, position = null;\n            if (typeof arg2 === 'string') {\n                // Signature 1: (fd, string, [position?, [encoding?]], cb?)\n                let encoding = 'utf8';\n                switch (typeof arg3) {\n                    case 'function':\n                        // (fd, string, cb)\n                        cb = arg3;\n                        break;\n                    case 'number':\n                        // (fd, string, position, encoding?, cb?)\n                        position = arg3;\n                        encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\n                        cb = typeof arg5 === 'function' ? arg5 : cb;\n                        break;\n                    default:\n                        // ...try to find the callback and get out of here!\n                        cb = typeof arg4 === 'function' ? arg4 : typeof arg5 === 'function' ? arg5 : cb;\n                        return cb(new ApiError(ErrorCode.EINVAL, 'Invalid arguments.'));\n                }\n                buffer = Buffer.from(arg2, encoding);\n                offset = 0;\n                length = buffer.length;\n            }\n            else {\n                // Signature 2: (fd, buffer, offset, length, position?, cb?)\n                buffer = arg2;\n                offset = arg3;\n                length = arg4;\n                position = typeof arg5 === 'number' ? arg5 : null;\n                cb = typeof arg5 === 'function' ? arg5 : cb;\n            }\n            const newCb = wrapCb(cb, 3);\n            try {\n                const file = this.fd2file(fd);\n                if (position === undefined || position === null) {\n                    position = file.getPos();\n                }\n                file.write(buffer, offset, length, position, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        writeSync(fd, arg2, arg3, arg4, arg5) {\n            let buffer, offset = 0, length, position;\n            if (typeof arg2 === 'string') {\n                // Signature 1: (fd, string, [position?, [encoding?]])\n                position = typeof arg3 === 'number' ? arg3 : null;\n                const encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\n                offset = 0;\n                buffer = Buffer.from(arg2, encoding);\n                length = buffer.length;\n            }\n            else {\n                // Signature 2: (fd, buffer, offset, length, position?)\n                buffer = arg2;\n                offset = arg3;\n                length = arg4;\n                position = typeof arg5 === 'number' ? arg5 : null;\n            }\n            const file = this.fd2file(fd);\n            if (position === undefined || position === null) {\n                position = file.getPos();\n            }\n            return file.writeSync(buffer, offset, length, position);\n        }\n        read(fd, arg2, arg3, arg4, arg5, cb = nopCb) {\n            let position, offset, length, buffer, newCb;\n            if (typeof arg2 === 'number') {\n                // legacy interface\n                // (fd, length, position, encoding, callback)\n                length = arg2;\n                position = arg3;\n                const encoding = arg4;\n                cb = typeof arg5 === 'function' ? arg5 : cb;\n                offset = 0;\n                buffer = Buffer.alloc(length);\n                // XXX: Inefficient.\n                // Wrap the cb so we shelter upper layers of the API from these\n                // shenanigans.\n                newCb = wrapCb((err, bytesRead, buf) => {\n                    if (err) {\n                        return cb(err);\n                    }\n                    cb(err, buf.toString(encoding), bytesRead);\n                }, 3);\n            }\n            else {\n                buffer = arg2;\n                offset = arg3;\n                length = arg4;\n                position = arg5;\n                newCb = wrapCb(cb, 3);\n            }\n            try {\n                const file = this.fd2file(fd);\n                if (position === undefined || position === null) {\n                    position = file.getPos();\n                }\n                file.read(buffer, offset, length, position, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        readSync(fd, arg2, arg3, arg4, arg5) {\n            let shenanigans = false;\n            let buffer, offset, length, position, encoding = 'utf8';\n            if (typeof arg2 === 'number') {\n                length = arg2;\n                position = arg3;\n                encoding = arg4;\n                offset = 0;\n                buffer = Buffer.alloc(length);\n                shenanigans = true;\n            }\n            else {\n                buffer = arg2;\n                offset = arg3;\n                length = arg4;\n                position = arg5;\n            }\n            const file = this.fd2file(fd);\n            if (position === undefined || position === null) {\n                position = file.getPos();\n            }\n            const rv = file.readSync(buffer, offset, length, position);\n            if (!shenanigans) {\n                return rv;\n            }\n            else {\n                return [buffer.toString(encoding), rv];\n            }\n        }\n        /**\n         * Asynchronous `fchown`.\n         * @param fd\n         * @param uid\n         * @param gid\n         * @param callback\n         */\n        fchown(fd, uid, gid, callback = nopCb) {\n            const newCb = wrapCb(callback, 1);\n            try {\n                this.fd2file(fd).chown(uid, gid, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `fchown`.\n         * @param fd\n         * @param uid\n         * @param gid\n         */\n        fchownSync(fd, uid, gid) {\n            this.fd2file(fd).chownSync(uid, gid);\n        }\n        /**\n         * Asynchronous `fchmod`.\n         * @param fd\n         * @param mode\n         * @param callback\n         */\n        fchmod(fd, mode, cb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n                this.fd2file(fd).chmod(numMode, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `fchmod`.\n         * @param fd\n         * @param mode\n         */\n        fchmodSync(fd, mode) {\n            const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n            this.fd2file(fd).chmodSync(numMode);\n        }\n        /**\n         * Change the file timestamps of a file referenced by the supplied file\n         * descriptor.\n         * @param fd\n         * @param atime\n         * @param mtime\n         * @param callback\n         */\n        futimes(fd, atime, mtime, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                const file = this.fd2file(fd);\n                if (typeof atime === 'number') {\n                    atime = new Date(atime * 1000);\n                }\n                if (typeof mtime === 'number') {\n                    mtime = new Date(mtime * 1000);\n                }\n                file.utimes(atime, mtime, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Change the file timestamps of a file referenced by the supplied file\n         * descriptor.\n         * @param fd\n         * @param atime\n         * @param mtime\n         */\n        futimesSync(fd, atime, mtime) {\n            this.fd2file(fd).utimesSync(normalizeTime(atime), normalizeTime(mtime));\n        }\n        // DIRECTORY-ONLY METHODS\n        /**\n         * Asynchronous `rmdir`.\n         * @param path\n         * @param callback\n         */\n        rmdir(path, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                path = normalizePath(path);\n                assertRoot(this.root).rmdir(path, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `rmdir`.\n         * @param path\n         */\n        rmdirSync(path) {\n            path = normalizePath(path);\n            return assertRoot(this.root).rmdirSync(path);\n        }\n        /**\n         * Asynchronous `mkdir`.\n         * @param path\n         * @param mode defaults to `0777`\n         * @param callback\n         */\n        mkdir(path, mode, cb = nopCb) {\n            if (typeof mode === 'function') {\n                cb = mode;\n                mode = 0x1ff;\n            }\n            const newCb = wrapCb(cb, 1);\n            try {\n                path = normalizePath(path);\n                assertRoot(this.root).mkdir(path, mode, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `mkdir`.\n         * @param path\n         * @param mode defaults to `0777`\n         */\n        mkdirSync(path, mode) {\n            assertRoot(this.root).mkdirSync(normalizePath(path), normalizeMode(mode, 0x1ff));\n        }\n        /**\n         * Asynchronous `readdir`. Reads the contents of a directory.\n         * The callback gets two arguments `(err, files)` where `files` is an array of\n         * the names of the files in the directory excluding `'.'` and `'..'`.\n         * @param path\n         * @param callback\n         */\n        readdir(path, cb = nopCb) {\n            const newCb = wrapCb(cb, 2);\n            try {\n                path = normalizePath(path);\n                assertRoot(this.root).readdir(path, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `readdir`. Reads the contents of a directory.\n         * @param path\n         * @return [String[]]\n         */\n        readdirSync(path) {\n            path = normalizePath(path);\n            return assertRoot(this.root).readdirSync(path);\n        }\n        // SYMLINK METHODS\n        /**\n         * Asynchronous `link`.\n         * @param srcpath\n         * @param dstpath\n         * @param callback\n         */\n        link(srcpath, dstpath, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                srcpath = normalizePath(srcpath);\n                dstpath = normalizePath(dstpath);\n                assertRoot(this.root).link(srcpath, dstpath, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `link`.\n         * @param srcpath\n         * @param dstpath\n         */\n        linkSync(srcpath, dstpath) {\n            srcpath = normalizePath(srcpath);\n            dstpath = normalizePath(dstpath);\n            return assertRoot(this.root).linkSync(srcpath, dstpath);\n        }\n        symlink(srcpath, dstpath, arg3, cb = nopCb) {\n            const type = typeof arg3 === 'string' ? arg3 : 'file';\n            cb = typeof arg3 === 'function' ? arg3 : cb;\n            const newCb = wrapCb(cb, 1);\n            try {\n                if (type !== 'file' && type !== 'dir') {\n                    return newCb(new ApiError(ErrorCode.EINVAL, \"Invalid type: \" + type));\n                }\n                srcpath = normalizePath(srcpath);\n                dstpath = normalizePath(dstpath);\n                assertRoot(this.root).symlink(srcpath, dstpath, type, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `symlink`.\n         * @param srcpath\n         * @param dstpath\n         * @param type can be either `'dir'` or `'file'` (default is `'file'`)\n         */\n        symlinkSync(srcpath, dstpath, type) {\n            if (!type) {\n                type = 'file';\n            }\n            else if (type !== 'file' && type !== 'dir') {\n                throw new ApiError(ErrorCode.EINVAL, \"Invalid type: \" + type);\n            }\n            srcpath = normalizePath(srcpath);\n            dstpath = normalizePath(dstpath);\n            return assertRoot(this.root).symlinkSync(srcpath, dstpath, type);\n        }\n        /**\n         * Asynchronous readlink.\n         * @param path\n         * @param callback\n         */\n        readlink(path, cb = nopCb) {\n            const newCb = wrapCb(cb, 2);\n            try {\n                path = normalizePath(path);\n                assertRoot(this.root).readlink(path, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous readlink.\n         * @param path\n         * @return [String]\n         */\n        readlinkSync(path) {\n            path = normalizePath(path);\n            return assertRoot(this.root).readlinkSync(path);\n        }\n        // PROPERTY OPERATIONS\n        /**\n         * Asynchronous `chown`.\n         * @param path\n         * @param uid\n         * @param gid\n         * @param callback\n         */\n        chown(path, uid, gid, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                path = normalizePath(path);\n                assertRoot(this.root).chown(path, false, uid, gid, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `chown`.\n         * @param path\n         * @param uid\n         * @param gid\n         */\n        chownSync(path, uid, gid) {\n            path = normalizePath(path);\n            assertRoot(this.root).chownSync(path, false, uid, gid);\n        }\n        /**\n         * Asynchronous `lchown`.\n         * @param path\n         * @param uid\n         * @param gid\n         * @param callback\n         */\n        lchown(path, uid, gid, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                path = normalizePath(path);\n                assertRoot(this.root).chown(path, true, uid, gid, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `lchown`.\n         * @param path\n         * @param uid\n         * @param gid\n         */\n        lchownSync(path, uid, gid) {\n            path = normalizePath(path);\n            assertRoot(this.root).chownSync(path, true, uid, gid);\n        }\n        /**\n         * Asynchronous `chmod`.\n         * @param path\n         * @param mode\n         * @param callback\n         */\n        chmod(path, mode, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                const numMode = normalizeMode(mode, -1);\n                if (numMode < 0) {\n                    throw new ApiError(ErrorCode.EINVAL, `Invalid mode.`);\n                }\n                assertRoot(this.root).chmod(normalizePath(path), false, numMode, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `chmod`.\n         * @param path\n         * @param mode\n         */\n        chmodSync(path, mode) {\n            const numMode = normalizeMode(mode, -1);\n            if (numMode < 0) {\n                throw new ApiError(ErrorCode.EINVAL, `Invalid mode.`);\n            }\n            path = normalizePath(path);\n            assertRoot(this.root).chmodSync(path, false, numMode);\n        }\n        /**\n         * Asynchronous `lchmod`.\n         * @param path\n         * @param mode\n         * @param callback\n         */\n        lchmod(path, mode, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                const numMode = normalizeMode(mode, -1);\n                if (numMode < 0) {\n                    throw new ApiError(ErrorCode.EINVAL, `Invalid mode.`);\n                }\n                assertRoot(this.root).chmod(normalizePath(path), true, numMode, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `lchmod`.\n         * @param path\n         * @param mode\n         */\n        lchmodSync(path, mode) {\n            const numMode = normalizeMode(mode, -1);\n            if (numMode < 1) {\n                throw new ApiError(ErrorCode.EINVAL, `Invalid mode.`);\n            }\n            assertRoot(this.root).chmodSync(normalizePath(path), true, numMode);\n        }\n        /**\n         * Change file timestamps of the file referenced by the supplied path.\n         * @param path\n         * @param atime\n         * @param mtime\n         * @param callback\n         */\n        utimes(path, atime, mtime, cb = nopCb) {\n            const newCb = wrapCb(cb, 1);\n            try {\n                assertRoot(this.root).utimes(normalizePath(path), normalizeTime(atime), normalizeTime(mtime), newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Change file timestamps of the file referenced by the supplied path.\n         * @param path\n         * @param atime\n         * @param mtime\n         */\n        utimesSync(path, atime, mtime) {\n            assertRoot(this.root).utimesSync(normalizePath(path), normalizeTime(atime), normalizeTime(mtime));\n        }\n        realpath(path, arg2, cb = nopCb) {\n            const cache = typeof (arg2) === 'object' ? arg2 : {};\n            cb = typeof (arg2) === 'function' ? arg2 : nopCb;\n            const newCb = wrapCb(cb, 2);\n            try {\n                path = normalizePath(path);\n                assertRoot(this.root).realpath(path, cache, newCb);\n            }\n            catch (e) {\n                newCb(e);\n            }\n        }\n        /**\n         * Synchronous `realpath`.\n         * @param path\n         * @param cache An object literal of mapped paths that can be used to\n         *   force a specific path resolution or avoid additional `fs.stat` calls for\n         *   known real paths.\n         * @return [String]\n         */\n        realpathSync(path, cache = {}) {\n            path = normalizePath(path);\n            return assertRoot(this.root).realpathSync(path, cache);\n        }\n        watchFile(filename, arg2, listener = nopCb) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        unwatchFile(filename, listener = nopCb) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        watch(filename, arg2, listener = nopCb) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        access(path, arg2, cb = nopCb) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        accessSync(path, mode) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        createReadStream(path, options) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        createWriteStream(path, options) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        /**\n         * For unit testing. Passes all incoming callbacks to cbWrapper for wrapping.\n         */\n        wrapCallbacks(cbWrapper) {\n            wrapCbHook = cbWrapper;\n        }\n        getFdForFile(file) {\n            const fd = this.nextFd++;\n            this.fdMap[fd] = file;\n            return fd;\n        }\n        fd2file(fd) {\n            const rv = this.fdMap[fd];\n            if (rv) {\n                return rv;\n            }\n            else {\n                throw new ApiError(ErrorCode.EBADF, 'Invalid file descriptor.');\n            }\n        }\n        closeFd(fd) {\n            delete this.fdMap[fd];\n        }\n    }\n    /* tslint:disable:variable-name */\n    // Exported fs.Stats.\n    FS.Stats = Stats;\n    //# sourceMappingURL=FS.js.map\n\n    return FS;\n});\ndefine('skylark-browserfs/core/node_fs',['./FS'], function (FS) {\n    'use strict';\n    let fs = new FS();\n    const _fsMock = {};\n    const fsProto = FS.prototype;\n    const keys = Object.getOwnPropertyNames(fsProto);\n    keys.forEach(key => {\n        if (typeof fs[key] === 'function') {\n            _fsMock[key] = function () {\n                return fs[key].apply(fs, arguments);\n            };\n        } else {\n            _fsMock[key] = fs[key];\n        }\n    });\n    _fsMock['changeFSModule'] = function (newFs) {\n        fs = newFs;\n    };\n    _fsMock['getFSModule'] = function () {\n        return fs;\n    };\n    _fsMock['FS'] = FS;\n    _fsMock['Stats'] = FS.Stats;\n\n    return _fsMock;\n});\ndefine('skylark-browserfs/core/levenshtein',[],function () {\n    'use strict';\n   \n    /*\n     * Levenshtein distance, from the `js-levenshtein` NPM module.\n     * Copied here to avoid complexity of adding another CommonJS module dependency.\n     */\n    function _min(d0, d1, d2, bx, ay) {\n        return d0 < d1 || d2 < d1 ? d0 > d2 ? d2 + 1 : d0 + 1 : bx === ay ? d1 : d1 + 1;\n    }\n\n    /**\n     * Calculates levenshtein distance.\n     * @param a\n     * @param b\n     */    \n     function levenshtein(a, b) {\n        if (a === b) {\n            return 0;\n        }\n        if (a.length > b.length) {\n            const tmp = a;\n            a = b;\n            b = tmp;\n        }\n        let la = a.length;\n        let lb = b.length;\n        while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {\n            la--;\n            lb--;\n        }\n        let offset = 0;\n        while (offset < la && a.charCodeAt(offset) === b.charCodeAt(offset)) {\n            offset++;\n        }\n        la -= offset;\n        lb -= offset;\n        if (la === 0 || lb === 1) {\n            return lb;\n        }\n        const vector = new Array(la << 1);\n        for (let y = 0; y < la;) {\n            vector[la + y] = a.charCodeAt(offset + y);\n            vector[y] = ++y;\n        }\n        let x;\n        let d0;\n        let d1;\n        let d2;\n        let d3;\n        for (x = 0; x + 3 < lb;) {\n            const bx0 = b.charCodeAt(offset + (d0 = x));\n            const bx1 = b.charCodeAt(offset + (d1 = x + 1));\n            const bx2 = b.charCodeAt(offset + (d2 = x + 2));\n            const bx3 = b.charCodeAt(offset + (d3 = x + 3));\n            let dd = x += 4;\n            for (let y = 0; y < la;) {\n                const ay = vector[la + y];\n                const dy = vector[y];\n                d0 = _min(dy, d0, d1, bx0, ay);\n                d1 = _min(d0, d1, d2, bx1, ay);\n                d2 = _min(d1, d2, d3, bx2, ay);\n                dd = _min(d2, d3, dd, bx3, ay);\n                vector[y++] = dd;\n                d3 = d2;\n                d2 = d1;\n                d1 = d0;\n                d0 = dy;\n            }\n        }\n        let dd = 0;\n        for (; x < lb;) {\n            const bx0 = b.charCodeAt(offset + (d0 = x));\n            dd = ++x;\n            for (let y = 0; y < la; y++) {\n                const dy = vector[y];\n                vector[y] = dd = dy < d0 || dd < d0 ? dy > dd ? dd + 1 : dy + 1 : bx0 === vector[la + y] ? d0 : d0 + 1;\n                d0 = dy;\n            }\n        }\n        return dd;\n    }\n\n    return levenshtein;\n});\ndefine('skylark-browserfs/core/util',[\n    '../libs/buffers',\n    './api_error',\n    './levenshtein',\n    '../libs/path'\n], function (buffers,api_error, levenshtein, path) {\n    'use strict';\n\n    const { ErrorCode, ApiError } = api_error;\n    const {Buffer} = buffers;\n\n    function deprecationMessage(print, fsName, opts) {\n        if (print) {\n            // tslint:disable-next-line:no-console\n            console.warn(`[${fsName}] Direct file system constructor usage is deprecated for this file system, and will be removed in the next major version. Please use the '${fsName}.Create(${JSON.stringify(opts)}, callback)' method instead. See https://github.com/jvilk/BrowserFS/issues/176 for more details.`);\n            // tslint:enable-next-line:no-console\n        }\n    }\n    /**\n     * Checks for any IE version, including IE11 which removed MSIE from the\n     * userAgent string.\n     * @hidden\n     */\n    const isIE = typeof navigator !== \"undefined\" && !!(/(msie) ([\\w.]+)/.exec(navigator.userAgent.toLowerCase()) || navigator.userAgent.indexOf('Trident') !== -1);\n    /**\n     * Check if we're in a web worker.\n     * @hidden\n     */\n    const isWebWorker = typeof window === \"undefined\";\n    /**\n     * Throws an exception. Called on code paths that should be impossible.\n     * @hidden\n     */\n    function fail() {\n        throw new Error(\"BFS has reached an impossible code path; please file a bug.\");\n    }\n    /**\n     * Synchronous recursive makedir.\n     * @hidden\n     */\n    function mkdirpSync(p, mode, fs) {\n        if (!fs.existsSync(p)) {\n            mkdirpSync(path.dirname(p), mode, fs);\n            fs.mkdirSync(p, mode);\n        }\n    }\n    /**\n     * Converts a buffer into an array buffer. Attempts to do so in a\n     * zero-copy manner, e.g. the array references the same memory.\n     * @hidden\n     */\n    function buffer2ArrayBuffer(buff) {\n        const u8 = buffer2Uint8array(buff), u8offset = u8.byteOffset, u8Len = u8.byteLength;\n        if (u8offset === 0 && u8Len === u8.buffer.byteLength) {\n            return u8.buffer;\n        }\n        else {\n            return u8.buffer.slice(u8offset, u8offset + u8Len);\n        }\n    }\n    /**\n     * Converts a buffer into a Uint8Array. Attempts to do so in a\n     * zero-copy manner, e.g. the array references the same memory.\n     * @hidden\n     */\n    function buffer2Uint8array(buff) {\n        if (buff instanceof Uint8Array) {\n            // BFS & Node v4.0 buffers *are* Uint8Arrays.\n            return buff;\n        }\n        else {\n            // Uint8Arrays can be constructed from arrayish numbers.\n            // At this point, we assume this isn't a BFS array.\n            return new Uint8Array(buff);\n        }\n    }\n    /**\n     * Converts the given arrayish object into a Buffer. Attempts to\n     * be zero-copy.\n     * @hidden\n     */\n    function arrayish2Buffer(arr) {\n        if (arr instanceof Buffer) {\n            return arr;\n        }\n        else if (arr instanceof Uint8Array) {\n            return uint8Array2Buffer(arr);\n        }\n        else {\n            return Buffer.from(arr);\n        }\n    }\n    /**\n     * Converts the given Uint8Array into a Buffer. Attempts to be zero-copy.\n     * @hidden\n     */\n    function uint8Array2Buffer(u8) {\n        if (u8 instanceof Buffer) {\n            return u8;\n        }\n        else if (u8.byteOffset === 0 && u8.byteLength === u8.buffer.byteLength) {\n            return arrayBuffer2Buffer(u8.buffer);\n        }\n        else {\n            return Buffer.from(u8.buffer, u8.byteOffset, u8.byteLength);\n        }\n    }\n    /**\n     * Converts the given array buffer into a Buffer. Attempts to be\n     * zero-copy.\n     * @hidden\n     */\n    function arrayBuffer2Buffer(ab) {\n        return Buffer.from(ab);\n    }\n    /**\n     * Copies a slice of the given buffer\n     * @hidden\n     */\n    function copyingSlice(buff, start = 0, end = buff.length) {\n        if (start < 0 || end < 0 || end > buff.length || start > end) {\n            throw new TypeError(`Invalid slice bounds on buffer of length ${buff.length}: [${start}, ${end}]`);\n        }\n        if (buff.length === 0) {\n            // Avoid s0 corner case in ArrayBuffer case.\n            return emptyBuffer();\n        }\n        else {\n            const u8 = buffer2Uint8array(buff), s0 = buff[0], newS0 = (s0 + 1) % 0xFF;\n            buff[0] = newS0;\n            if (u8[0] === newS0) {\n                // Same memory. Revert & copy.\n                u8[0] = s0;\n                return uint8Array2Buffer(u8.slice(start, end));\n            }\n            else {\n                // Revert.\n                buff[0] = s0;\n                return uint8Array2Buffer(u8.subarray(start, end));\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    let emptyBuff = null;\n    /**\n     * Returns an empty buffer.\n     * @hidden\n     */\n    function emptyBuffer() {\n        if (emptyBuff) {\n            return emptyBuff;\n        }\n        return emptyBuff = Buffer.alloc(0);\n    }\n    /**\n     * Option validator for a Buffer file system option.\n     * @hidden\n     */\n    function bufferValidator(v, cb) {\n        if (Buffer.isBuffer(v)) {\n            cb();\n        }\n        else {\n            cb(new ApiError(ErrorCode.EINVAL, `option must be a Buffer.`));\n        }\n    }\n    /**\n     * Checks that the given options object is valid for the file system options.\n     * @hidden\n     */\n    function checkOptions(fsType, opts, cb) {\n        const optsInfo = fsType.Options;\n        const fsName = fsType.Name;\n        let pendingValidators = 0;\n        let callbackCalled = false;\n        let loopEnded = false;\n        function validatorCallback(e) {\n            if (!callbackCalled) {\n                if (e) {\n                    callbackCalled = true;\n                    cb(e);\n                }\n                pendingValidators--;\n                if (pendingValidators === 0 && loopEnded) {\n                    cb();\n                }\n            }\n        }\n        // Check for required options.\n        for (const optName in optsInfo) {\n            if (optsInfo.hasOwnProperty(optName)) {\n                const opt = optsInfo[optName];\n                const providedValue = opts[optName];\n                if (providedValue === undefined || providedValue === null) {\n                    if (!opt.optional) {\n                        // Required option, not provided.\n                        // Any incorrect options provided? Which ones are close to the provided one?\n                        // (edit distance 5 === close)\n                        const incorrectOptions = Object.keys(opts).filter((o) => !(o in optsInfo)).map((a) => {\n                            return { str: a, distance: levenshtein(optName, a) };\n                        }).filter((o) => o.distance < 5).sort((a, b) => a.distance - b.distance);\n                        // Validators may be synchronous.\n                        if (callbackCalled) {\n                            return;\n                        }\n                        callbackCalled = true;\n                        return cb(new ApiError(ErrorCode.EINVAL, `[${fsName}] Required option '${optName}' not provided.${incorrectOptions.length > 0 ? ` You provided unrecognized option '${incorrectOptions[0].str}'; perhaps you meant to type '${optName}'.` : ''}\\nOption description: ${opt.description}`));\n                    }\n                    // Else: Optional option, not provided. That is OK.\n                }\n                else {\n                    // Option provided! Check type.\n                    let typeMatches = false;\n                    if (Array.isArray(opt.type)) {\n                        typeMatches = opt.type.indexOf(typeof (providedValue)) !== -1;\n                    }\n                    else {\n                        typeMatches = typeof (providedValue) === opt.type;\n                    }\n                    if (!typeMatches) {\n                        // Validators may be synchronous.\n                        if (callbackCalled) {\n                            return;\n                        }\n                        callbackCalled = true;\n                        return cb(new ApiError(ErrorCode.EINVAL, `[${fsName}] Value provided for option ${optName} is not the proper type. Expected ${Array.isArray(opt.type) ? `one of {${opt.type.join(\", \")}}` : opt.type}, but received ${typeof (providedValue)}\\nOption description: ${opt.description}`));\n                    }\n                    else if (opt.validator) {\n                        pendingValidators++;\n                        opt.validator(providedValue, validatorCallback);\n                    }\n                    // Otherwise: All good!\n                }\n            }\n        }\n        loopEnded = true;\n        if (pendingValidators === 0 && !callbackCalled) {\n            cb();\n        }\n    }\n\n    return {\n        deprecationMessage: deprecationMessage,\n        isIE: isIE,\n        isWebWorker: isWebWorker,\n        fail: fail,\n        mkdirpSync: mkdirpSync,\n        buffer2ArrayBuffer: buffer2ArrayBuffer,\n        buffer2Uint8array: buffer2Uint8array,\n        arrayish2Buffer: arrayish2Buffer,\n        uint8Array2Buffer: uint8Array2Buffer,\n        arrayBuffer2Buffer: arrayBuffer2Buffer,\n        copyingSlice: copyingSlice,\n        emptyBuffer: emptyBuffer,\n        bufferValidator: bufferValidator,\n        checkOptions: checkOptions\n    };\n});\ndefine('skylark-browserfs/generic/emscripten_fs',[\n    '../core/node_fs',\n    '../core/util'\n], function (fs, util) {\n    'use strict';\n    const { uint8Array2Buffer } = util;\n\n    class BFSEmscriptenStreamOps {\n        constructor(fs) {\n            this.fs = fs;\n            this.nodefs = fs.getNodeFS();\n            this.FS = fs.getFS();\n            this.PATH = fs.getPATH();\n            this.ERRNO_CODES = fs.getERRNO_CODES();\n        }\n        open(stream) {\n            const path = this.fs.realPath(stream.node);\n            const FS = this.FS;\n            try {\n                if (FS.isFile(stream.node.mode)) {\n                    stream.nfd = this.nodefs.openSync(path, this.fs.flagsToPermissionString(stream.flags));\n                }\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                throw new FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n        }\n        close(stream) {\n            const FS = this.FS;\n            try {\n                if (FS.isFile(stream.node.mode) && stream.nfd) {\n                    this.nodefs.closeSync(stream.nfd);\n                }\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                throw new FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n        }\n        read(stream, buffer, offset, length, position) {\n            // Avoid copying overhead by reading directly into buffer.\n            try {\n                return this.nodefs.readSync(stream.nfd, uint8Array2Buffer(buffer), offset, length, position);\n            }\n            catch (e) {\n                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n        }\n        write(stream, buffer, offset, length, position) {\n            // Avoid copying overhead.\n            try {\n                return this.nodefs.writeSync(stream.nfd, uint8Array2Buffer(buffer), offset, length, position);\n            }\n            catch (e) {\n                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n        }\n        llseek(stream, offset, whence) {\n            let position = offset;\n            if (whence === 1) { // SEEK_CUR.\n                position += stream.position;\n            }\n            else if (whence === 2) { // SEEK_END.\n                if (this.FS.isFile(stream.node.mode)) {\n                    try {\n                        const stat = this.nodefs.fstatSync(stream.nfd);\n                        position += stat.size;\n                    }\n                    catch (e) {\n                        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n                    }\n                }\n            }\n            if (position < 0) {\n                throw new this.FS.ErrnoError(this.ERRNO_CODES.EINVAL);\n            }\n            stream.position = position;\n            return position;\n        }\n    }\n    class BFSEmscriptenNodeOps {\n        constructor(fs) {\n            this.fs = fs;\n            this.nodefs = fs.getNodeFS();\n            this.FS = fs.getFS();\n            this.PATH = fs.getPATH();\n            this.ERRNO_CODES = fs.getERRNO_CODES();\n        }\n        getattr(node) {\n            const path = this.fs.realPath(node);\n            let stat;\n            try {\n                stat = this.nodefs.lstatSync(path);\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n            return {\n                dev: stat.dev,\n                ino: stat.ino,\n                mode: stat.mode,\n                nlink: stat.nlink,\n                uid: stat.uid,\n                gid: stat.gid,\n                rdev: stat.rdev,\n                size: stat.size,\n                atime: stat.atime,\n                mtime: stat.mtime,\n                ctime: stat.ctime,\n                blksize: stat.blksize,\n                blocks: stat.blocks\n            };\n        }\n        setattr(node, attr) {\n            const path = this.fs.realPath(node);\n            try {\n                if (attr.mode !== undefined) {\n                    this.nodefs.chmodSync(path, attr.mode);\n                    // update the common node structure mode as well\n                    node.mode = attr.mode;\n                }\n                if (attr.timestamp !== undefined) {\n                    const date = new Date(attr.timestamp);\n                    this.nodefs.utimesSync(path, date, date);\n                }\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                // Ignore not supported errors. Emscripten does utimesSync when it\n                // writes files, but never really requires the value to be set.\n                if (e.code !== \"ENOTSUP\") {\n                    throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n                }\n            }\n            if (attr.size !== undefined) {\n                try {\n                    this.nodefs.truncateSync(path, attr.size);\n                }\n                catch (e) {\n                    if (!e.code) {\n                        throw e;\n                    }\n                    throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n                }\n            }\n        }\n        lookup(parent, name) {\n            const path = this.PATH.join2(this.fs.realPath(parent), name);\n            const mode = this.fs.getMode(path);\n            return this.fs.createNode(parent, name, mode);\n        }\n        mknod(parent, name, mode, dev) {\n            const node = this.fs.createNode(parent, name, mode, dev);\n            // create the backing node for this in the fs root as well\n            const path = this.fs.realPath(node);\n            try {\n                if (this.FS.isDir(node.mode)) {\n                    this.nodefs.mkdirSync(path, node.mode);\n                }\n                else {\n                    this.nodefs.writeFileSync(path, '', { mode: node.mode });\n                }\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n            return node;\n        }\n        rename(oldNode, newDir, newName) {\n            const oldPath = this.fs.realPath(oldNode);\n            const newPath = this.PATH.join2(this.fs.realPath(newDir), newName);\n            try {\n                this.nodefs.renameSync(oldPath, newPath);\n                // This logic is missing from the original NodeFS,\n                // causing Emscripten's filesystem to think that the old file still exists.\n                oldNode.name = newName;\n                oldNode.parent = newDir;\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n        }\n        unlink(parent, name) {\n            const path = this.PATH.join2(this.fs.realPath(parent), name);\n            try {\n                this.nodefs.unlinkSync(path);\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n        }\n        rmdir(parent, name) {\n            const path = this.PATH.join2(this.fs.realPath(parent), name);\n            try {\n                this.nodefs.rmdirSync(path);\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n        }\n        readdir(node) {\n            const path = this.fs.realPath(node);\n            try {\n                // Node does not list . and .. in directory listings,\n                // but Emscripten expects it.\n                const contents = this.nodefs.readdirSync(path);\n                contents.push('.', '..');\n                return contents;\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n        }\n        symlink(parent, newName, oldPath) {\n            const newPath = this.PATH.join2(this.fs.realPath(parent), newName);\n            try {\n                this.nodefs.symlinkSync(oldPath, newPath);\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n        }\n        readlink(node) {\n            const path = this.fs.realPath(node);\n            try {\n                return this.nodefs.readlinkSync(path);\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n        }\n    }\n    class BFSEmscriptenFS {\n        constructor(_FS = self['FS'], _PATH = self['PATH'], _ERRNO_CODES = self['ERRNO_CODES'], nodefs = fs) {\n            // This maps the integer permission modes from http://linux.die.net/man/3/open\n            // to node.js-specific file open permission strings at http://nodejs.org/api/fs.html#fs_fs_open_path_flags_mode_callback\n            this.flagsToPermissionStringMap = {\n                0 /*O_RDONLY*/: 'r',\n                1 /*O_WRONLY*/: 'r+',\n                2 /*O_RDWR*/: 'r+',\n                64 /*O_CREAT*/: 'r',\n                65 /*O_WRONLY|O_CREAT*/: 'r+',\n                66 /*O_RDWR|O_CREAT*/: 'r+',\n                129 /*O_WRONLY|O_EXCL*/: 'rx+',\n                193 /*O_WRONLY|O_CREAT|O_EXCL*/: 'rx+',\n                514 /*O_RDWR|O_TRUNC*/: 'w+',\n                577 /*O_WRONLY|O_CREAT|O_TRUNC*/: 'w',\n                578 /*O_CREAT|O_RDWR|O_TRUNC*/: 'w+',\n                705 /*O_WRONLY|O_CREAT|O_EXCL|O_TRUNC*/: 'wx',\n                706 /*O_RDWR|O_CREAT|O_EXCL|O_TRUNC*/: 'wx+',\n                1024 /*O_APPEND*/: 'a',\n                1025 /*O_WRONLY|O_APPEND*/: 'a',\n                1026 /*O_RDWR|O_APPEND*/: 'a+',\n                1089 /*O_WRONLY|O_CREAT|O_APPEND*/: 'a',\n                1090 /*O_RDWR|O_CREAT|O_APPEND*/: 'a+',\n                1153 /*O_WRONLY|O_EXCL|O_APPEND*/: 'ax',\n                1154 /*O_RDWR|O_EXCL|O_APPEND*/: 'ax+',\n                1217 /*O_WRONLY|O_CREAT|O_EXCL|O_APPEND*/: 'ax',\n                1218 /*O_RDWR|O_CREAT|O_EXCL|O_APPEND*/: 'ax+',\n                4096 /*O_RDONLY|O_DSYNC*/: 'rs',\n                4098 /*O_RDWR|O_DSYNC*/: 'rs+'\n            };\n            this.nodefs = nodefs;\n            this.FS = _FS;\n            this.PATH = _PATH;\n            this.ERRNO_CODES = _ERRNO_CODES;\n            this.node_ops = new BFSEmscriptenNodeOps(this);\n            this.stream_ops = new BFSEmscriptenStreamOps(this);\n        }\n        mount(m) {\n            return this.createNode(null, '/', this.getMode(m.opts.root), 0);\n        }\n        createNode(parent, name, mode, dev) {\n            const FS = this.FS;\n            if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {\n                throw new FS.ErrnoError(this.ERRNO_CODES.EINVAL);\n            }\n            const node = FS.createNode(parent, name, mode);\n            node.node_ops = this.node_ops;\n            node.stream_ops = this.stream_ops;\n            return node;\n        }\n        getMode(path) {\n            let stat;\n            try {\n                stat = this.nodefs.lstatSync(path);\n            }\n            catch (e) {\n                if (!e.code) {\n                    throw e;\n                }\n                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);\n            }\n            return stat.mode;\n        }\n        realPath(node) {\n            const parts = [];\n            while (node.parent !== node) {\n                parts.push(node.name);\n                node = node.parent;\n            }\n            parts.push(node.mount.opts.root);\n            parts.reverse();\n            return this.PATH.join.apply(null, parts);\n        }\n        flagsToPermissionString(flags) {\n            let parsedFlags = (typeof flags === \"string\") ? parseInt(flags, 10) : flags;\n            parsedFlags &= 0x1FFF;\n            if (parsedFlags in this.flagsToPermissionStringMap) {\n                return this.flagsToPermissionStringMap[parsedFlags];\n            }\n            else {\n                return flags;\n            }\n        }\n        getNodeFS() {\n            return this.nodefs;\n        }\n        getFS() {\n            return this.FS;\n        }\n        getPATH() {\n            return this.PATH;\n        }\n        getERRNO_CODES() {\n            return this.ERRNO_CODES;\n        }\n    }\n\n    return BFSEmscriptenFS;\n});\ndefine('skylark-browserfs/core/file_system',[\n    '../libs/buffers',\n    './api_error',\n    './file_flag',\n    '../libs/path',\n    './util'\n], function (buffers,api_error, file_flag, path, util) {\n    'use strict';\n\n    const { ApiError, ErrorCode } = api_error;\n    const { FileFlag, ActionType } = file_flag;\n    const { fail } = util;\n\n    /**\n     * Basic filesystem class. Most filesystems should extend this class, as it\n     * provides default implementations for a handful of methods.\n     */\n    class BaseFileSystem {\n        supportsLinks() {\n            return false;\n        }\n        diskSpace(p, cb) {\n            cb(0, 0);\n        }\n        /**\n         * Opens the file at path p with the given flag. The file must exist.\n         * @param p The path to open.\n         * @param flag The flag to use when opening the file.\n         */\n        openFile(p, flag, cb) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        /**\n         * Create the file at path p with the given mode. Then, open it with the given\n         * flag.\n         */\n        createFile(p, flag, mode, cb) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        open(p, flag, mode, cb) {\n            const mustBeFile = (e, stats) => {\n                if (e) {\n                    // File does not exist.\n                    switch (flag.pathNotExistsAction()) {\n                        case ActionType.CREATE_FILE:\n                            // Ensure parent exists.\n                            return this.stat(path.dirname(p), false, (e, parentStats) => {\n                                if (e) {\n                                    cb(e);\n                                }\n                                else if (parentStats && !parentStats.isDirectory()) {\n                                    cb(ApiError.ENOTDIR(path.dirname(p)));\n                                }\n                                else {\n                                    this.createFile(p, flag, mode, cb);\n                                }\n                            });\n                        case ActionType.THROW_EXCEPTION:\n                            return cb(ApiError.ENOENT(p));\n                        default:\n                            return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.'));\n                    }\n                }\n                else {\n                    // File exists.\n                    if (stats && stats.isDirectory()) {\n                        return cb(ApiError.EISDIR(p));\n                    }\n                    switch (flag.pathExistsAction()) {\n                        case ActionType.THROW_EXCEPTION:\n                            return cb(ApiError.EEXIST(p));\n                        case ActionType.TRUNCATE_FILE:\n                            // NOTE: In a previous implementation, we deleted the file and\n                            // re-created it. However, this created a race condition if another\n                            // asynchronous request was trying to read the file, as the file\n                            // would not exist for a small period of time.\n                            return this.openFile(p, flag, (e, fd) => {\n                                if (e) {\n                                    cb(e);\n                                }\n                                else if (fd) {\n                                    fd.truncate(0, () => {\n                                        fd.sync(() => {\n                                            cb(null, fd);\n                                        });\n                                    });\n                                }\n                                else {\n                                    fail();\n                                }\n                            });\n                        case ActionType.NOP:\n                            return this.openFile(p, flag, cb);\n                        default:\n                            return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.'));\n                    }\n                }\n            };\n            this.stat(p, false, mustBeFile);\n        }\n        rename(oldPath, newPath, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        renameSync(oldPath, newPath) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        stat(p, isLstat, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        statSync(p, isLstat) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        /**\n         * Opens the file at path p with the given flag. The file must exist.\n         * @param p The path to open.\n         * @param flag The flag to use when opening the file.\n         * @return A File object corresponding to the opened file.\n         */\n        openFileSync(p, flag, mode) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        /**\n         * Create the file at path p with the given mode. Then, open it with the given\n         * flag.\n         */\n        createFileSync(p, flag, mode) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        openSync(p, flag, mode) {\n            // Check if the path exists, and is a file.\n            let stats;\n            try {\n                stats = this.statSync(p, false);\n            }\n            catch (e) {\n                // File does not exist.\n                switch (flag.pathNotExistsAction()) {\n                    case ActionType.CREATE_FILE:\n                        // Ensure parent exists.\n                        const parentStats = this.statSync(path.dirname(p), false);\n                        if (!parentStats.isDirectory()) {\n                            throw ApiError.ENOTDIR(path.dirname(p));\n                        }\n                        return this.createFileSync(p, flag, mode);\n                    case ActionType.THROW_EXCEPTION:\n                        throw ApiError.ENOENT(p);\n                    default:\n                        throw new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.');\n                }\n            }\n            // File exists.\n            if (stats.isDirectory()) {\n                throw ApiError.EISDIR(p);\n            }\n            switch (flag.pathExistsAction()) {\n                case ActionType.THROW_EXCEPTION:\n                    throw ApiError.EEXIST(p);\n                case ActionType.TRUNCATE_FILE:\n                    // Delete file.\n                    this.unlinkSync(p);\n                    // Create file. Use the same mode as the old file.\n                    // Node itself modifies the ctime when this occurs, so this action\n                    // will preserve that behavior if the underlying file system\n                    // supports those properties.\n                    return this.createFileSync(p, flag, stats.mode);\n                case ActionType.NOP:\n                    return this.openFileSync(p, flag, mode);\n                default:\n                    throw new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.');\n            }\n        }\n        unlink(p, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        unlinkSync(p) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        rmdir(p, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        rmdirSync(p) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        mkdir(p, mode, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        mkdirSync(p, mode) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        readdir(p, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        readdirSync(p) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        exists(p, cb) {\n            this.stat(p, null, function (err) {\n                cb(!err);\n            });\n        }\n        existsSync(p) {\n            try {\n                this.statSync(p, true);\n                return true;\n            }\n            catch (e) {\n                return false;\n            }\n        }\n        realpath(p, cache, cb) {\n            if (this.supportsLinks()) {\n                // The path could contain symlinks. Split up the path,\n                // resolve any symlinks, return the resolved string.\n                const splitPath = p.split(path.sep);\n                // TODO: Simpler to just pass through file, find sep and such.\n                for (let i = 0; i < splitPath.length; i++) {\n                    const addPaths = splitPath.slice(0, i + 1);\n                    splitPath[i] = path.join.apply(null, addPaths);\n                }\n            }\n            else {\n                // No symlinks. We just need to verify that it exists.\n                this.exists(p, function (doesExist) {\n                    if (doesExist) {\n                        cb(null, p);\n                    }\n                    else {\n                        cb(ApiError.ENOENT(p));\n                    }\n                });\n            }\n        }\n        realpathSync(p, cache) {\n            if (this.supportsLinks()) {\n                // The path could contain symlinks. Split up the path,\n                // resolve any symlinks, return the resolved string.\n                const splitPath = p.split(path.sep);\n                // TODO: Simpler to just pass through file, find sep and such.\n                for (let i = 0; i < splitPath.length; i++) {\n                    const addPaths = splitPath.slice(0, i + 1);\n                    splitPath[i] = path.join.apply(path, addPaths);\n                }\n                return splitPath.join(path.sep);\n            }\n            else {\n                // No symlinks. We just need to verify that it exists.\n                if (this.existsSync(p)) {\n                    return p;\n                }\n                else {\n                    throw ApiError.ENOENT(p);\n                }\n            }\n        }\n        truncate(p, len, cb) {\n            this.open(p, FileFlag.getFileFlag('r+'), 0x1a4, (function (er, fd) {\n                if (er) {\n                    return cb(er);\n                }\n                fd.truncate(len, (function (er) {\n                    fd.close((function (er2) {\n                        cb(er || er2);\n                    }));\n                }));\n            }));\n        }\n        truncateSync(p, len) {\n            const fd = this.openSync(p, FileFlag.getFileFlag('r+'), 0x1a4);\n            // Need to safely close FD, regardless of whether or not truncate succeeds.\n            try {\n                fd.truncateSync(len);\n            }\n            catch (e) {\n                throw e;\n            }\n            finally {\n                fd.closeSync();\n            }\n        }\n        readFile(fname, encoding, flag, cb) {\n            // Wrap cb in file closing code.\n            const oldCb = cb;\n            // Get file.\n            this.open(fname, flag, 0x1a4, (err, fd) => {\n                if (err) {\n                    return cb(err);\n                }\n                cb = function (err, arg) {\n                    fd.close(function (err2) {\n                        if (!err) {\n                            err = err2;\n                        }\n                        return oldCb(err, arg);\n                    });\n                };\n                fd.stat((err, stat) => {\n                    if (err) {\n                        return cb(err);\n                    }\n                    // Allocate buffer.\n                    const buf = Buffer.alloc(stat.size);\n                    fd.read(buf, 0, stat.size, 0, (err) => {\n                        if (err) {\n                            return cb(err);\n                        }\n                        else if (encoding === null) {\n                            return cb(err, buf);\n                        }\n                        try {\n                            cb(null, buf.toString(encoding));\n                        }\n                        catch (e) {\n                            cb(e);\n                        }\n                    });\n                });\n            });\n        }\n        readFileSync(fname, encoding, flag) {\n            // Get file.\n            const fd = this.openSync(fname, flag, 0x1a4);\n            try {\n                const stat = fd.statSync();\n                // Allocate buffer.\n                const buf = Buffer.alloc(stat.size);\n                fd.readSync(buf, 0, stat.size, 0);\n                fd.closeSync();\n                if (encoding === null) {\n                    return buf;\n                }\n                return buf.toString(encoding);\n            }\n            finally {\n                fd.closeSync();\n            }\n        }\n        writeFile(fname, data, encoding, flag, mode, cb) {\n            // Wrap cb in file closing code.\n            const oldCb = cb;\n            // Get file.\n            this.open(fname, flag, 0x1a4, function (err, fd) {\n                if (err) {\n                    return cb(err);\n                }\n                cb = function (err) {\n                    fd.close(function (err2) {\n                        oldCb(err ? err : err2);\n                    });\n                };\n                try {\n                    if (typeof data === 'string') {\n                        data = Buffer.from(data, encoding);\n                    }\n                }\n                catch (e) {\n                    return cb(e);\n                }\n                // Write into file.\n                fd.write(data, 0, data.length, 0, cb);\n            });\n        }\n        writeFileSync(fname, data, encoding, flag, mode) {\n            // Get file.\n            const fd = this.openSync(fname, flag, mode);\n            try {\n                if (typeof data === 'string') {\n                    data = Buffer.from(data, encoding);\n                }\n                // Write into file.\n                fd.writeSync(data, 0, data.length, 0);\n            }\n            finally {\n                fd.closeSync();\n            }\n        }\n        appendFile(fname, data, encoding, flag, mode, cb) {\n            // Wrap cb in file closing code.\n            const oldCb = cb;\n            this.open(fname, flag, mode, function (err, fd) {\n                if (err) {\n                    return cb(err);\n                }\n                cb = function (err) {\n                    fd.close(function (err2) {\n                        oldCb(err ? err : err2);\n                    });\n                };\n                if (typeof data === 'string') {\n                    data = Buffer.from(data, encoding);\n                }\n                fd.write(data, 0, data.length, null, cb);\n            });\n        }\n        appendFileSync(fname, data, encoding, flag, mode) {\n            const fd = this.openSync(fname, flag, mode);\n            try {\n                if (typeof data === 'string') {\n                    data = Buffer.from(data, encoding);\n                }\n                fd.writeSync(data, 0, data.length, null);\n            }\n            finally {\n                fd.closeSync();\n            }\n        }\n        chmod(p, isLchmod, mode, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        chmodSync(p, isLchmod, mode) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        chown(p, isLchown, uid, gid, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        chownSync(p, isLchown, uid, gid) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        utimes(p, atime, mtime, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        utimesSync(p, atime, mtime) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        link(srcpath, dstpath, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        linkSync(srcpath, dstpath) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        symlink(srcpath, dstpath, type, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        symlinkSync(srcpath, dstpath, type) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        readlink(p, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        readlinkSync(p) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n    }\n    /**\n     * Implements the asynchronous API in terms of the synchronous API.\n     * @class SynchronousFileSystem\n     */\n    class SynchronousFileSystem extends BaseFileSystem {\n        supportsSynch() {\n            return true;\n        }\n        rename(oldPath, newPath, cb) {\n            try {\n                this.renameSync(oldPath, newPath);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        stat(p, isLstat, cb) {\n            try {\n                cb(null, this.statSync(p, isLstat));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        open(p, flags, mode, cb) {\n            try {\n                cb(null, this.openSync(p, flags, mode));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        unlink(p, cb) {\n            try {\n                this.unlinkSync(p);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        rmdir(p, cb) {\n            try {\n                this.rmdirSync(p);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        mkdir(p, mode, cb) {\n            try {\n                this.mkdirSync(p, mode);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        readdir(p, cb) {\n            try {\n                cb(null, this.readdirSync(p));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        chmod(p, isLchmod, mode, cb) {\n            try {\n                this.chmodSync(p, isLchmod, mode);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        chown(p, isLchown, uid, gid, cb) {\n            try {\n                this.chownSync(p, isLchown, uid, gid);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        utimes(p, atime, mtime, cb) {\n            try {\n                this.utimesSync(p, atime, mtime);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        link(srcpath, dstpath, cb) {\n            try {\n                this.linkSync(srcpath, dstpath);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        symlink(srcpath, dstpath, type, cb) {\n            try {\n                this.symlinkSync(srcpath, dstpath, type);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        readlink(p, cb) {\n            try {\n                cb(null, this.readlinkSync(p));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n    }\n\n\n    return {\n        BaseFileSystem: BaseFileSystem,\n        SynchronousFileSystem: SynchronousFileSystem\n    };\n});\ndefine('skylark-browserfs/core/file',['./api_error'], function (api_error) {\n    'use strict';\n\n    const { ApiError, ErrorCode } = api_error;\n    /**\n     * Base class that contains shared implementations of functions for the file\n     * object.\n     */\n    class BaseFile {\n        sync(cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        syncSync() {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        datasync(cb) {\n            this.sync(cb);\n        }\n        datasyncSync() {\n            return this.syncSync();\n        }\n        chown(uid, gid, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        chownSync(uid, gid) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        chmod(mode, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        chmodSync(mode) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        utimes(atime, mtime, cb) {\n            cb(new ApiError(ErrorCode.ENOTSUP));\n        }\n        utimesSync(atime, mtime) {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n    }\n    return { BaseFile: BaseFile };\n});\ndefine('skylark-browserfs/generic/preload_file',[\n    '../libs/buffers',\n    '../core/file',\n    '../core/node_fs_stats',\n    '../core/api_error',\n    '../core/node_fs',\n    '../core/util'\n], function (buffers,file, Stats, api_error, fs, util) {\n    'use strict';\n\n    const { BaseFile } = file;\n    const { ApiError, ErrorCode } = api_error;\n    const { emptyBuffer } = util;\n    const { Buffer } = buffers;\n\n    /**\n     * An implementation of the File interface that operates on a file that is\n     * completely in-memory. PreloadFiles are backed by a Buffer.\n     *\n     * This is also an abstract class, as it lacks an implementation of 'sync' and\n     * 'close'. Each filesystem that wishes to use this file representation must\n     * extend this class and implement those two methods.\n     * @todo 'close' lever that disables functionality once closed.\n     */\n    class PreloadFile extends BaseFile {\n        /**\n         * Creates a file with the given path and, optionally, the given contents. Note\n         * that, if contents is specified, it will be mutated by the file!\n         * @param _fs The file system that created the file.\n         * @param _path\n         * @param _mode The mode that the file was opened using.\n         *   Dictates permissions and where the file pointer starts.\n         * @param _stat The stats object for the given file.\n         *   PreloadFile will mutate this object. Note that this object must contain\n         *   the appropriate mode that the file was opened as.\n         * @param contents A buffer containing the entire\n         *   contents of the file. PreloadFile will mutate this buffer. If not\n         *   specified, we assume it is a new file.\n         */\n        constructor(_fs, _path, _flag, _stat, contents) {\n            super();\n            this._pos = 0;\n            this._dirty = false;\n            this._fs = _fs;\n            this._path = _path;\n            this._flag = _flag;\n            this._stat = _stat;\n            this._buffer = contents ? contents : emptyBuffer();\n            // Note: This invariant is *not* maintained once the file starts getting\n            // modified.\n            // Note: Only actually matters if file is readable, as writeable modes may\n            // truncate/append to file.\n            if (this._stat.size !== this._buffer.length && this._flag.isReadable()) {\n                throw new Error(`Invalid buffer: Buffer is ${this._buffer.length} long, yet Stats object specifies that file is ${this._stat.size} long.`);\n            }\n        }\n        /**\n         * NONSTANDARD: Get the underlying buffer for this file. !!DO NOT MUTATE!! Will mess up dirty tracking.\n         */\n        getBuffer() {\n            return this._buffer;\n        }\n        /**\n         * NONSTANDARD: Get underlying stats for this file. !!DO NOT MUTATE!!\n         */\n        getStats() {\n            return this._stat;\n        }\n        getFlag() {\n            return this._flag;\n        }\n        /**\n         * Get the path to this file.\n         * @return [String] The path to the file.\n         */\n        getPath() {\n            return this._path;\n        }\n        /**\n         * Get the current file position.\n         *\n         * We emulate the following bug mentioned in the Node documentation:\n         * > On Linux, positional writes don't work when the file is opened in append\n         *   mode. The kernel ignores the position argument and always appends the data\n         *   to the end of the file.\n         * @return [Number] The current file position.\n         */\n        getPos() {\n            if (this._flag.isAppendable()) {\n                return this._stat.size;\n            }\n            return this._pos;\n        }\n        /**\n         * Advance the current file position by the indicated number of positions.\n         * @param [Number] delta\n         */\n        advancePos(delta) {\n            return this._pos += delta;\n        }\n        /**\n         * Set the file position.\n         * @param [Number] newPos\n         */\n        setPos(newPos) {\n            return this._pos = newPos;\n        }\n        /**\n         * **Core**: Asynchronous sync. Must be implemented by subclasses of this\n         * class.\n         * @param [Function(BrowserFS.ApiError)] cb\n         */\n        sync(cb) {\n            try {\n                this.syncSync();\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        /**\n         * **Core**: Synchronous sync.\n         */\n        syncSync() {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        /**\n         * **Core**: Asynchronous close. Must be implemented by subclasses of this\n         * class.\n         * @param [Function(BrowserFS.ApiError)] cb\n         */\n        close(cb) {\n            try {\n                this.closeSync();\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        /**\n         * **Core**: Synchronous close.\n         */\n        closeSync() {\n            throw new ApiError(ErrorCode.ENOTSUP);\n        }\n        /**\n         * Asynchronous `stat`.\n         * @param [Function(BrowserFS.ApiError, BrowserFS.node.fs.Stats)] cb\n         */\n        stat(cb) {\n            try {\n                cb(null, Stats.clone(this._stat));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        /**\n         * Synchronous `stat`.\n         */\n        statSync() {\n            return Stats.clone(this._stat);\n        }\n        /**\n         * Asynchronous truncate.\n         * @param [Number] len\n         * @param [Function(BrowserFS.ApiError)] cb\n         */\n        truncate(len, cb) {\n            try {\n                this.truncateSync(len);\n                if (this._flag.isSynchronous() && !fs.getRootFS().supportsSynch()) {\n                    this.sync(cb);\n                }\n                cb();\n            }\n            catch (e) {\n                return cb(e);\n            }\n        }\n        /**\n         * Synchronous truncate.\n         * @param [Number] len\n         */\n        truncateSync(len) {\n            this._dirty = true;\n            if (!this._flag.isWriteable()) {\n                throw new ApiError(ErrorCode.EPERM, 'File not opened with a writeable mode.');\n            }\n            this._stat.mtimeMs = Date.now();\n            if (len > this._buffer.length) {\n                const buf = Buffer.alloc(len - this._buffer.length, 0);\n                // Write will set @_stat.size for us.\n                this.writeSync(buf, 0, buf.length, this._buffer.length);\n                if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\n                    this.syncSync();\n                }\n                return;\n            }\n            this._stat.size = len;\n            // Truncate buffer to 'len'.\n            const newBuff = Buffer.alloc(len);\n            this._buffer.copy(newBuff, 0, 0, len);\n            this._buffer = newBuff;\n            if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\n                this.syncSync();\n            }\n        }\n        /**\n         * Write buffer to the file.\n         * Note that it is unsafe to use fs.write multiple times on the same file\n         * without waiting for the callback.\n         * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\n         *  the file.\n         * @param [Number] offset Offset in the buffer to start reading data from.\n         * @param [Number] length The amount of bytes to write to the file.\n         * @param [Number] position Offset from the beginning of the file where this\n         *   data should be written. If position is null, the data will be written at\n         *   the current position.\n         * @param [Function(BrowserFS.ApiError, Number, BrowserFS.node.Buffer)]\n         *   cb The number specifies the number of bytes written into the file.\n         */\n        write(buffer, offset, length, position, cb) {\n            try {\n                cb(null, this.writeSync(buffer, offset, length, position), buffer);\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        /**\n         * Write buffer to the file.\n         * Note that it is unsafe to use fs.writeSync multiple times on the same file\n         * without waiting for the callback.\n         * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\n         *  the file.\n         * @param [Number] offset Offset in the buffer to start reading data from.\n         * @param [Number] length The amount of bytes to write to the file.\n         * @param [Number] position Offset from the beginning of the file where this\n         *   data should be written. If position is null, the data will be written at\n         *   the current position.\n         * @return [Number]\n         */\n        writeSync(buffer, offset, length, position) {\n            this._dirty = true;\n            if (position === undefined || position === null) {\n                position = this.getPos();\n            }\n            if (!this._flag.isWriteable()) {\n                throw new ApiError(ErrorCode.EPERM, 'File not opened with a writeable mode.');\n            }\n            const endFp = position + length;\n            if (endFp > this._stat.size) {\n                this._stat.size = endFp;\n                if (endFp > this._buffer.length) {\n                    // Extend the buffer!\n                    const newBuff = Buffer.alloc(endFp);\n                    this._buffer.copy(newBuff);\n                    this._buffer = newBuff;\n                }\n            }\n            const len = buffer.copy(this._buffer, position, offset, offset + length);\n            this._stat.mtimeMs = Date.now();\n            if (this._flag.isSynchronous()) {\n                this.syncSync();\n                return len;\n            }\n            this.setPos(position + len);\n            return len;\n        }\n        /**\n         * Read data from the file.\n         * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\n         *   written to.\n         * @param [Number] offset The offset within the buffer where writing will\n         *   start.\n         * @param [Number] length An integer specifying the number of bytes to read.\n         * @param [Number] position An integer specifying where to begin reading from\n         *   in the file. If position is null, data will be read from the current file\n         *   position.\n         * @param [Function(BrowserFS.ApiError, Number, BrowserFS.node.Buffer)] cb The\n         *   number is the number of bytes read\n         */\n        read(buffer, offset, length, position, cb) {\n            try {\n                cb(null, this.readSync(buffer, offset, length, position), buffer);\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        /**\n         * Read data from the file.\n         * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\n         *   written to.\n         * @param [Number] offset The offset within the buffer where writing will\n         *   start.\n         * @param [Number] length An integer specifying the number of bytes to read.\n         * @param [Number] position An integer specifying where to begin reading from\n         *   in the file. If position is null, data will be read from the current file\n         *   position.\n         * @return [Number]\n         */\n        readSync(buffer, offset, length, position) {\n            if (!this._flag.isReadable()) {\n                throw new ApiError(ErrorCode.EPERM, 'File not opened with a readable mode.');\n            }\n            if (position === undefined || position === null) {\n                position = this.getPos();\n            }\n            const endRead = position + length;\n            if (endRead > this._stat.size) {\n                length = this._stat.size - position;\n            }\n            const rv = this._buffer.copy(buffer, offset, position, position + length);\n            this._stat.atimeMs = Date.now();\n            this._pos = position + length;\n            return rv;\n        }\n        /**\n         * Asynchronous `fchmod`.\n         * @param [Number|String] mode\n         * @param [Function(BrowserFS.ApiError)] cb\n         */\n        chmod(mode, cb) {\n            try {\n                this.chmodSync(mode);\n                cb();\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        /**\n         * Asynchronous `fchmod`.\n         * @param [Number] mode\n         */\n        chmodSync(mode) {\n            if (!this._fs.supportsProps()) {\n                throw new ApiError(ErrorCode.ENOTSUP);\n            }\n            this._dirty = true;\n            this._stat.chmod(mode);\n            this.syncSync();\n        }\n        isDirty() {\n            return this._dirty;\n        }\n        /**\n         * Resets the dirty bit. Should only be called after a sync has completed successfully.\n         */\n        resetDirty() {\n            this._dirty = false;\n        }\n    }\n    /**\n     * File class for the InMemory and XHR file systems.\n     * Doesn't sync to anything, so it works nicely for memory-only files.\n     */\n    class NoSyncFile extends PreloadFile {\n        constructor(_fs, _path, _flag, _stat, contents) {\n            super(_fs, _path, _flag, _stat, contents);\n        }\n        /**\n         * Asynchronous sync. Doesn't do anything, simply calls the cb.\n         * @param [Function(BrowserFS.ApiError)] cb\n         */\n        sync(cb) {\n            cb();\n        }\n        /**\n         * Synchronous sync. Doesn't do anything.\n         */\n        syncSync() {\n            // NOP.\n        }\n        /**\n         * Asynchronous close. Doesn't do anything, simply calls the cb.\n         * @param [Function(BrowserFS.ApiError)] cb\n         */\n        close(cb) {\n            cb();\n        }\n        /**\n         * Synchronous close. Doesn't do anything.\n         */\n        closeSync() {\n            // NOP.\n        }\n    }\n\n    return {\n        PreloadFile,\n        NoSyncFile\n    }\n});\ndefine('skylark-browserfs/backend/AsyncMirror',[\n    '../core/file_system',\n    '../core/api_error',\n    '../core/file_flag',\n    '../generic/preload_file',\n    '../libs/path'\n], function (file_system, api_error, file_flag, preload_file, path) {\n    'use strict';\n\n\n    const  { SynchronousFileSystem } = file_system;\n    const { ApiError, ErrorCode } = api_error;\n    const { FileFlag } = file_flag;\n    const { PreloadFile} = preload_file;\n\n    /**\n     * We define our own file to interpose on syncSync() for mirroring purposes.\n     */\n    class MirrorFile extends PreloadFile {\n        constructor(fs, path, flag, stat, data) {\n            super(fs, path, flag, stat, data);\n        }\n        syncSync() {\n            if (this.isDirty()) {\n                this._fs._syncSync(this);\n                this.resetDirty();\n            }\n        }\n        closeSync() {\n            this.syncSync();\n        }\n    }\n    /**\n     * AsyncMirrorFS mirrors a synchronous filesystem into an asynchronous filesystem\n     * by:\n     *\n     * * Performing operations over the in-memory copy, while asynchronously pipelining them\n     *   to the backing store.\n     * * During application loading, the contents of the async file system can be reloaded into\n     *   the synchronous store, if desired.\n     *\n     * The two stores will be kept in sync. The most common use-case is to pair a synchronous\n     * in-memory filesystem with an asynchronous backing store.\n     *\n     * Example: Mirroring an IndexedDB file system to an in memory file system. Now, you can use\n     * IndexedDB synchronously.\n     *\n     * ```javascript\n     * BrowserFS.configure({\n     *   fs: \"AsyncMirror\",\n     *   options: {\n     *     sync: { fs: \"InMemory\" },\n     *     async: { fs: \"IndexedDB\" }\n     *   }\n     * }, function(e) {\n     *   // BrowserFS is initialized and ready-to-use!\n     * });\n     * ```\n     *\n     * Or, alternatively:\n     *\n     * ```javascript\n     * BrowserFS.FileSystem.IndexedDB.Create(function(e, idbfs) {\n     *   BrowserFS.FileSystem.InMemory.Create(function(e, inMemory) {\n     *     BrowserFS.FileSystem.AsyncMirror({\n     *       sync: inMemory, async: idbfs\n     *     }, function(e, mirrored) {\n     *       BrowserFS.initialize(mirrored);\n     *     });\n     *   });\n     * });\n     * ```\n     */\n    class AsyncMirror extends SynchronousFileSystem {\n        /**\n         * **Deprecated; use AsyncMirror.Create() method instead.**\n         *\n         * Mirrors the synchronous file system into the asynchronous file system.\n         *\n         * **IMPORTANT**: You must call `initialize` on the file system before it can be used.\n         * @param sync The synchronous file system to mirror the asynchronous file system to.\n         * @param async The asynchronous file system to mirror.\n         */\n        constructor(sync, async) {\n            super();\n            /**\n             * Queue of pending asynchronous operations.\n             */\n            this._queue = [];\n            this._queueRunning = false;\n            this._isInitialized = false;\n            this._initializeCallbacks = [];\n            this._sync = sync;\n            this._async = async;\n        }\n        /**\n         * Constructs and initializes an AsyncMirror file system with the given options.\n         */\n        static Create(opts, cb) {\n            try {\n                const fs = new AsyncMirror(opts.sync, opts.async);\n                fs._initialize((e) => {\n                    if (e) {\n                        cb(e);\n                    }\n                    else {\n                        cb(null, fs);\n                    }\n                });\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        static isAvailable() {\n            return true;\n        }\n        getName() {\n            return AsyncMirror.Name;\n        }\n        _syncSync(fd) {\n            this._sync.writeFileSync(fd.getPath(), fd.getBuffer(), null, FileFlag.getFileFlag('w'), fd.getStats().mode);\n            this.enqueueOp({\n                apiMethod: 'writeFile',\n                arguments: [fd.getPath(), fd.getBuffer(), null, fd.getFlag(), fd.getStats().mode]\n            });\n        }\n        isReadOnly() { return false; }\n        supportsSynch() { return true; }\n        supportsLinks() { return false; }\n        supportsProps() { return this._sync.supportsProps() && this._async.supportsProps(); }\n        renameSync(oldPath, newPath) {\n            this._sync.renameSync(oldPath, newPath);\n            this.enqueueOp({\n                apiMethod: 'rename',\n                arguments: [oldPath, newPath]\n            });\n        }\n        statSync(p, isLstat) {\n            return this._sync.statSync(p, isLstat);\n        }\n        openSync(p, flag, mode) {\n            // Sanity check: Is this open/close permitted?\n            const fd = this._sync.openSync(p, flag, mode);\n            fd.closeSync();\n            return new MirrorFile(this, p, flag, this._sync.statSync(p, false), this._sync.readFileSync(p, null, FileFlag.getFileFlag('r')));\n        }\n        unlinkSync(p) {\n            this._sync.unlinkSync(p);\n            this.enqueueOp({\n                apiMethod: 'unlink',\n                arguments: [p]\n            });\n        }\n        rmdirSync(p) {\n            this._sync.rmdirSync(p);\n            this.enqueueOp({\n                apiMethod: 'rmdir',\n                arguments: [p]\n            });\n        }\n        mkdirSync(p, mode) {\n            this._sync.mkdirSync(p, mode);\n            this.enqueueOp({\n                apiMethod: 'mkdir',\n                arguments: [p, mode]\n            });\n        }\n        readdirSync(p) {\n            return this._sync.readdirSync(p);\n        }\n        existsSync(p) {\n            return this._sync.existsSync(p);\n        }\n        chmodSync(p, isLchmod, mode) {\n            this._sync.chmodSync(p, isLchmod, mode);\n            this.enqueueOp({\n                apiMethod: 'chmod',\n                arguments: [p, isLchmod, mode]\n            });\n        }\n        chownSync(p, isLchown, uid, gid) {\n            this._sync.chownSync(p, isLchown, uid, gid);\n            this.enqueueOp({\n                apiMethod: 'chown',\n                arguments: [p, isLchown, uid, gid]\n            });\n        }\n        utimesSync(p, atime, mtime) {\n            this._sync.utimesSync(p, atime, mtime);\n            this.enqueueOp({\n                apiMethod: 'utimes',\n                arguments: [p, atime, mtime]\n            });\n        }\n        /**\n         * Called once to load up files from async storage into sync storage.\n         */\n        _initialize(userCb) {\n            const callbacks = this._initializeCallbacks;\n            const end = (e) => {\n                this._isInitialized = !e;\n                this._initializeCallbacks = [];\n                callbacks.forEach((cb) => cb(e));\n            };\n            if (!this._isInitialized) {\n                // First call triggers initialization, the rest wait.\n                if (callbacks.push(userCb) === 1) {\n                    const copyDirectory = (p, mode, cb) => {\n                        if (p !== '/') {\n                            this._sync.mkdirSync(p, mode);\n                        }\n                        this._async.readdir(p, (err, files) => {\n                            let i = 0;\n                            // NOTE: This function must not be in a lexically nested statement,\n                            // such as an if or while statement. Safari refuses to run the\n                            // script since it is undefined behavior.\n                            function copyNextFile(err) {\n                                if (err) {\n                                    cb(err);\n                                }\n                                else if (i < files.length) {\n                                    copyItem(path.join(p, files[i]), copyNextFile);\n                                    i++;\n                                }\n                                else {\n                                    cb();\n                                }\n                            }\n                            if (err) {\n                                cb(err);\n                            }\n                            else {\n                                copyNextFile();\n                            }\n                        });\n                    }, copyFile = (p, mode, cb) => {\n                        this._async.readFile(p, null, FileFlag.getFileFlag('r'), (err, data) => {\n                            if (err) {\n                                cb(err);\n                            }\n                            else {\n                                try {\n                                    this._sync.writeFileSync(p, data, null, FileFlag.getFileFlag('w'), mode);\n                                }\n                                catch (e) {\n                                    err = e;\n                                }\n                                finally {\n                                    cb(err);\n                                }\n                            }\n                        });\n                    }, copyItem = (p, cb) => {\n                        this._async.stat(p, false, (err, stats) => {\n                            if (err) {\n                                cb(err);\n                            }\n                            else if (stats.isDirectory()) {\n                                copyDirectory(p, stats.mode, cb);\n                            }\n                            else {\n                                copyFile(p, stats.mode, cb);\n                            }\n                        });\n                    };\n                    copyDirectory('/', 0, end);\n                }\n            }\n            else {\n                userCb();\n            }\n        }\n        enqueueOp(op) {\n            this._queue.push(op);\n            if (!this._queueRunning) {\n                this._queueRunning = true;\n                const doNextOp = (err) => {\n                    if (err) {\n                        throw new Error(`WARNING: File system has desynchronized. Received following error: ${err}\\n$`);\n                    }\n                    if (this._queue.length > 0) {\n                        const op = this._queue.shift(), args = op.arguments;\n                        args.push(doNextOp);\n                        this._async[op.apiMethod].apply(this._async, args);\n                    }\n                    else {\n                        this._queueRunning = false;\n                    }\n                };\n                doNextOp();\n            }\n        }\n    }\n    AsyncMirror.Name = \"AsyncMirror\";\n    AsyncMirror.Options = {\n        sync: {\n            type: \"object\",\n            description: \"The synchronous file system to mirror the asynchronous file system to.\",\n            validator: (v, cb) => {\n                if (v && typeof (v['supportsSynch']) === \"function\" && v.supportsSynch()) {\n                    cb();\n                }\n                else {\n                    cb(new ApiError(ErrorCode.EINVAL, `'sync' option must be a file system that supports synchronous operations`));\n                }\n            }\n        },\n        async: {\n            type: \"object\",\n            description: \"The asynchronous file system to mirror.\"\n        }\n    };\n\n    return AsyncMirror;\n});\ndefine('skylark-browserfs/backend/Dropbox',[\n    '../libs/buffers',\n    '../generic/preload_file',\n    '../core/file_system',\n    '../core/node_fs_stats',\n    '../core/api_error',\n    '../core/util',\n///    'dropbox_bridge',\n    '../generic/setImmediate',\n    '../libs/path'\n], function (buffers,preload_file, file_system, node_fs_stats, api_error, util,  setImmediate, path) {\n    'use strict';\n\n    const { BaseFileSystem } = file_system;\n    const { Stats, FileType } = node_fs_stats;\n    const { ApiError, ErrorCode } = api_error;\n    const { arrayBuffer2Buffer, buffer2ArrayBuffer } =  util;\n///    const { Dropbox } =  dropbox_bridge;\n    const { dirname } =  path;\n\n    const { PreloadFile} = preload_file;\n\n    const {Buffer} = buffers;\n\n\n    /**\n     * Dropbox paths do not begin with a /, they just begin with a folder at the root node.\n     * Here, we strip the `/`.\n     * @param p An absolute path\n     */\n    function FixPath(p) {\n        if (p === '/') {\n            return '';\n        }\n        else {\n            return p;\n        }\n    }\n    /**\n     * HACK: Dropbox errors are FUBAR'd sometimes.\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/146\n     * @param e\n     */\n    function ExtractTheFuckingError(e) {\n        const obj = e.error;\n        if (obj['.tag']) {\n            // Everything is OK.\n            return obj;\n        }\n        else if (obj['error']) {\n            // Terrible nested object bug.\n            const obj2 = obj.error;\n            if (obj2['.tag']) {\n                return obj2;\n            }\n            else if (obj2['reason'] && obj2['reason']['.tag']) {\n                return obj2.reason;\n            }\n            else {\n                return obj2;\n            }\n        }\n        else if (typeof (obj) === 'string') {\n            // Might be a fucking JSON object error.\n            try {\n                const obj2 = JSON.parse(obj);\n                if (obj2['error'] && obj2['error']['reason'] && obj2['error']['reason']['.tag']) {\n                    return obj2.error.reason;\n                }\n            }\n            catch (e) {\n                // Nope. Give up.\n            }\n        }\n        return obj;\n    }\n    /**\n     * Returns a user-facing error message given an error.\n     *\n     * HACK: Dropbox error messages sometimes lack a `user_message` field.\n     * Sometimes, they are even strings. Ugh.\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/146\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/145\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/144\n     * @param err An error.\n     */\n    function GetErrorMessage(err) {\n        if (err['user_message']) {\n            return err.user_message.text;\n        }\n        else if (err['error_summary']) {\n            return err.error_summary;\n        }\n        else if (typeof (err.error) === \"string\") {\n            return err.error;\n        }\n        else if (typeof (err.error) === \"object\") {\n            // DROPBOX BUG: Sometimes, error is a nested error.\n            return GetErrorMessage(err.error);\n        }\n        else {\n            throw new Error(`Dropbox's servers gave us a garbage error message: ${JSON.stringify(err)}`);\n        }\n    }\n    function LookupErrorToError(err, p, msg) {\n        switch (err['.tag']) {\n            case 'malformed_path':\n                return new ApiError(ErrorCode.EBADF, msg, p);\n            case 'not_found':\n                return ApiError.ENOENT(p);\n            case 'not_file':\n                return ApiError.EISDIR(p);\n            case 'not_folder':\n                return ApiError.ENOTDIR(p);\n            case 'restricted_content':\n                return ApiError.EPERM(p);\n            case 'other':\n            default:\n                return new ApiError(ErrorCode.EIO, msg, p);\n        }\n    }\n    function WriteErrorToError(err, p, msg) {\n        switch (err['.tag']) {\n            case 'malformed_path':\n            case 'disallowed_name':\n                return new ApiError(ErrorCode.EBADF, msg, p);\n            case 'conflict':\n            case 'no_write_permission':\n            case 'team_folder':\n                return ApiError.EPERM(p);\n            case 'insufficient_space':\n                return new ApiError(ErrorCode.ENOSPC, msg);\n            case 'other':\n            default:\n                return new ApiError(ErrorCode.EIO, msg, p);\n        }\n    }\n    function FilesDeleteWrapped(client, p, cb) {\n        const arg = {\n            path: FixPath(p)\n        };\n        client.filesDeleteV2(arg)\n            .then(() => {\n            cb();\n        }).catch((e) => {\n            const err = ExtractTheFuckingError(e);\n            switch (err['.tag']) {\n                case 'path_lookup':\n                    cb(LookupErrorToError(err.path_lookup, p, GetErrorMessage(e)));\n                    break;\n                case 'path_write':\n                    cb(WriteErrorToError(err.path_write, p, GetErrorMessage(e)));\n                    break;\n                case 'too_many_write_operations':\n                    setTimeout(() => FilesDeleteWrapped(client, p, cb), 500 + (300 * (Math.random())));\n                    break;\n                case 'other':\n                default:\n                    cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), p));\n                    break;\n            }\n        });\n    }\n    class DropboxFile extends PreloadFile {\n        constructor(_fs, _path, _flag, _stat, contents) {\n            super(_fs, _path, _flag, _stat, contents);\n        }\n        sync(cb) {\n            this._fs._syncFile(this.getPath(), this.getBuffer(), cb);\n        }\n        close(cb) {\n            this.sync(cb);\n        }\n    }\n    /**\n     * A read/write file system backed by Dropbox cloud storage.\n     *\n     * Uses the Dropbox V2 API, and the 2.x JS SDK.\n     */\n    class DropboxFileSystem extends BaseFileSystem {\n        constructor(client) {\n            super();\n            this._client = client;\n        }\n        /**\n         * Creates a new DropboxFileSystem instance with the given options.\n         * Must be given an *authenticated* Dropbox client from 2.x JS SDK.\n         */\n        static Create(opts, cb) {\n            cb(null, new DropboxFileSystem(opts.client));\n        }\n        static isAvailable() {\n            // Checks if the Dropbox library is loaded.\n            return typeof Dropbox !== 'undefined';\n        }\n        getName() {\n            return DropboxFileSystem.Name;\n        }\n        isReadOnly() {\n            return false;\n        }\n        // Dropbox doesn't support symlinks, properties, or synchronous calls\n        // TODO: does it???\n        supportsSymlinks() {\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            return false;\n        }\n        /**\n         * Deletes *everything* in the file system. Mainly intended for unit testing!\n         * @param mainCb Called when operation completes.\n         */\n        empty(mainCb) {\n            this.readdir('/', (e, paths) => {\n                if (paths) {\n                    const next = (e) => {\n                        if (paths.length === 0) {\n                            mainCb();\n                        }\n                        else {\n                            FilesDeleteWrapped(this._client, paths.shift(), next);\n                        }\n                    };\n                    next();\n                }\n                else {\n                    mainCb(e);\n                }\n            });\n        }\n        rename(oldPath, newPath, cb) {\n            // Dropbox doesn't let you rename things over existing things, but POSIX does.\n            // So, we need to see if newPath exists...\n            this.stat(newPath, false, (e, stats) => {\n                const rename = () => {\n                    const relocationArg = {\n                        from_path: FixPath(oldPath),\n                        to_path: FixPath(newPath)\n                    };\n                    this._client.filesMoveV2(relocationArg)\n                        .then(() => cb())\n                        .catch(function (e) {\n                        const err = ExtractTheFuckingError(e);\n                        switch (err['.tag']) {\n                            case 'from_lookup':\n                                cb(LookupErrorToError(err.from_lookup, oldPath, GetErrorMessage(e)));\n                                break;\n                            case 'from_write':\n                                cb(WriteErrorToError(err.from_write, oldPath, GetErrorMessage(e)));\n                                break;\n                            case 'to':\n                                cb(WriteErrorToError(err.to, newPath, GetErrorMessage(e)));\n                                break;\n                            case 'cant_copy_shared_folder':\n                            case 'cant_nest_shared_folder':\n                                cb(new ApiError(ErrorCode.EPERM, GetErrorMessage(e), oldPath));\n                                break;\n                            case 'cant_move_folder_into_itself':\n                            case 'duplicated_or_nested_paths':\n                                cb(new ApiError(ErrorCode.EBADF, GetErrorMessage(e), oldPath));\n                                break;\n                            case 'too_many_files':\n                                cb(new ApiError(ErrorCode.ENOSPC, GetErrorMessage(e), oldPath));\n                                break;\n                            case 'other':\n                            default:\n                                cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), oldPath));\n                                break;\n                        }\n                    });\n                };\n                if (e) {\n                    // Doesn't exist. Proceed!\n                    rename();\n                }\n                else if (oldPath === newPath) {\n                    // NOP if the path exists. Error if it doesn't exist.\n                    if (e) {\n                        cb(ApiError.ENOENT(newPath));\n                    }\n                    else {\n                        cb();\n                    }\n                }\n                else if (stats && stats.isDirectory()) {\n                    // Exists, is a directory. Cannot rename over an existing directory.\n                    cb(ApiError.EISDIR(newPath));\n                }\n                else {\n                    // Exists, is a file, and differs from oldPath. Delete and rename.\n                    this.unlink(newPath, (e) => {\n                        if (e) {\n                            cb(e);\n                        }\n                        else {\n                            rename();\n                        }\n                    });\n                }\n            });\n        }\n        stat(path, isLstat, cb) {\n            if (path === '/') {\n                // Dropbox doesn't support querying the root directory.\n                setImmediate(function () {\n                    cb(null, new Stats(FileType.DIRECTORY, 4096));\n                });\n                return;\n            }\n            const arg = {\n                path: FixPath(path)\n            };\n            this._client.filesGetMetadata(arg).then((ref) => {\n                switch (ref['.tag']) {\n                    case 'file':\n                        const fileMetadata = ref;\n                        // TODO: Parse time fields.\n                        cb(null, new Stats(FileType.FILE, fileMetadata.size));\n                        break;\n                    case 'folder':\n                        cb(null, new Stats(FileType.DIRECTORY, 4096));\n                        break;\n                    case 'deleted':\n                        cb(ApiError.ENOENT(path));\n                        break;\n                    default:\n                        // Unknown.\n                        break;\n                }\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                switch (err['.tag']) {\n                    case 'path':\n                        cb(LookupErrorToError(err.path, path, GetErrorMessage(e)));\n                        break;\n                    default:\n                        cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), path));\n                        break;\n                }\n            });\n        }\n        openFile(path, flags, cb) {\n            const downloadArg = {\n                path: FixPath(path)\n            };\n            this._client.filesDownload(downloadArg).then((res) => {\n                const b = res.fileBlob;\n                const fr = new FileReader();\n                fr.onload = () => {\n                    const ab = fr.result;\n                    cb(null, new DropboxFile(this, path, flags, new Stats(FileType.FILE, ab.byteLength), arrayBuffer2Buffer(ab)));\n                };\n                fr.readAsArrayBuffer(b);\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                switch (err['.tag']) {\n                    case 'path':\n                        const dpError = err;\n                        cb(LookupErrorToError(dpError.path, path, GetErrorMessage(e)));\n                        break;\n                    case 'other':\n                    default:\n                        cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), path));\n                        break;\n                }\n            });\n        }\n        createFile(p, flags, mode, cb) {\n            const fileData = Buffer.alloc(0);\n            const blob = new Blob([buffer2ArrayBuffer(fileData)], { type: \"octet/stream\" });\n            const commitInfo = {\n                contents: blob,\n                path: FixPath(p)\n            };\n            this._client.filesUpload(commitInfo).then((metadata) => {\n                cb(null, new DropboxFile(this, p, flags, new Stats(FileType.FILE, 0), fileData));\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                // HACK: Casting to 'any' since tag can be 'too_many_write_operations'.\n                switch (err['.tag']) {\n                    case 'path':\n                        const upError = err;\n                        cb(WriteErrorToError(upError.path.reason, p, GetErrorMessage(e)));\n                        break;\n                    case 'too_many_write_operations':\n                        // Retry in (500, 800) ms.\n                        setTimeout(() => this.createFile(p, flags, mode, cb), 500 + (300 * (Math.random())));\n                        break;\n                    case 'other':\n                    default:\n                        cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), p));\n                        break;\n                }\n            });\n        }\n        /**\n         * Delete a file\n         */\n        unlink(path, cb) {\n            // Must be a file. Check first.\n            this.stat(path, false, (e, stat) => {\n                if (stat) {\n                    if (stat.isDirectory()) {\n                        cb(ApiError.EISDIR(path));\n                    }\n                    else {\n                        FilesDeleteWrapped(this._client, path, cb);\n                    }\n                }\n                else {\n                    cb(e);\n                }\n            });\n        }\n        /**\n         * Delete a directory\n         */\n        rmdir(path, cb) {\n            this.readdir(path, (e, paths) => {\n                if (paths) {\n                    if (paths.length > 0) {\n                        cb(ApiError.ENOTEMPTY(path));\n                    }\n                    else {\n                        FilesDeleteWrapped(this._client, path, cb);\n                    }\n                }\n                else {\n                    cb(e);\n                }\n            });\n        }\n        /**\n         * Create a directory\n         */\n        mkdir(p, mode, cb) {\n            // Dropbox's create_folder is recursive. Check if parent exists.\n            const parent = dirname(p);\n            this.stat(parent, false, (e, stats) => {\n                if (e) {\n                    cb(e);\n                }\n                else if (stats && !stats.isDirectory()) {\n                    cb(ApiError.ENOTDIR(parent));\n                }\n                else {\n                    const arg = {\n                        path: FixPath(p)\n                    };\n                    this._client.filesCreateFolderV2(arg).then(() => cb()).catch((e) => {\n                        const err = ExtractTheFuckingError(e);\n                        if (err['.tag'] === \"too_many_write_operations\") {\n                            // Retry in a bit.\n                            setTimeout(() => this.mkdir(p, mode, cb), 500 + (300 * (Math.random())));\n                        }\n                        else {\n                            cb(WriteErrorToError(ExtractTheFuckingError(e).path, p, GetErrorMessage(e)));\n                        }\n                    });\n                }\n            });\n        }\n        /**\n         * Get the names of the files in a directory\n         */\n        readdir(path, cb) {\n            const arg = {\n                path: FixPath(path)\n            };\n            this._client.filesListFolder(arg).then((res) => {\n                ContinueReadingDir(this._client, path, res, [], cb);\n            }).catch((e) => {\n                ProcessListFolderError(e, path, cb);\n            });\n        }\n        /**\n         * (Internal) Syncs file to Dropbox.\n         */\n        _syncFile(p, d, cb) {\n            const blob = new Blob([buffer2ArrayBuffer(d)], { type: \"octet/stream\" });\n            const arg = {\n                contents: blob,\n                path: FixPath(p),\n                mode: {\n                    '.tag': 'overwrite'\n                }\n            };\n            this._client.filesUpload(arg).then(() => {\n                cb();\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                switch (err['.tag']) {\n                    case 'path':\n                        const upError = err;\n                        cb(WriteErrorToError(upError.path.reason, p, GetErrorMessage(e)));\n                        break;\n                    case 'too_many_write_operations':\n                        setTimeout(() => this._syncFile(p, d, cb), 500 + (300 * (Math.random())));\n                        break;\n                    case 'other':\n                    default:\n                        cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), p));\n                        break;\n                }\n            });\n        }\n    }\n    DropboxFileSystem.Name = \"DropboxV2\";\n    DropboxFileSystem.Options = {\n        client: {\n            type: \"object\",\n            description: \"An *authenticated* Dropbox client. Must be from the 2.5.x JS SDK.\"\n        }\n    };\n    function ProcessListFolderError(e, path, cb) {\n        const err = ExtractTheFuckingError(e);\n        switch (err['.tag']) {\n            case 'path':\n                const pathError = err;\n                cb(LookupErrorToError(pathError.path, path, GetErrorMessage(e)));\n                break;\n            case 'other':\n            default:\n                cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), path));\n                break;\n        }\n    }\n    function ContinueReadingDir(client, path, res, previousEntries, cb) {\n        const newEntries = res.entries.map((e) => e.path_display).filter((p) => !!p);\n        const entries = previousEntries.concat(newEntries);\n        if (!res.has_more) {\n            cb(null, entries);\n        }\n        else {\n            const arg = {\n                cursor: res.cursor\n            };\n            client.filesListFolderContinue(arg).then((res) => {\n                ContinueReadingDir(client, path, res, entries, cb);\n            }).catch((e) => {\n                ProcessListFolderError(e, path, cb);\n            });\n        }\n    }\n\n    DropboxFileSystem.DropboxFile = DropboxFile;\n\n    return  DropboxFileSystem;\n    \n});\ndefine('skylark-browserfs/backend/Emscripten',[\n    '../libs/buffers',\n    '../core/file_system',\n    '../core/node_fs_stats',\n    '../core/file',\n    '../core/util',\n    '../core/api_error'\n], function (buffers,file_system, node_fs_stats, file, util, api_error) {\n    'use strict';\n\n    const { SynchronousFileSystem } = file_system;\n    const { Stats, FileType } = node_fs_stats;\n    const { BaseFile } = file;\n    const { uint8Array2Buffer, buffer2Uint8array } = util;\n    const { ApiError, ErrorCode, ErrorStrings } = api_error;\n    const { Buffer } = buffers;\n\n    /**\n     * @hidden\n     */\n    function convertError(e, path = '') {\n        const errno = e.errno;\n        let parent = e.node;\n        const paths = [];\n        while (parent) {\n            paths.unshift(parent.name);\n            if (parent === parent.parent) {\n                break;\n            }\n            parent = parent.parent;\n        }\n        return new ApiError(errno, ErrorStrings[errno], paths.length > 0 ? '/' + paths.join('/') : path);\n    }\n    class EmscriptenFile extends BaseFile {\n        constructor(_fs, _FS, _path, _stream) {\n            super();\n            this._fs = _fs;\n            this._FS = _FS;\n            this._path = _path;\n            this._stream = _stream;\n        }\n        getPos() {\n            return undefined;\n        }\n        close(cb) {\n            let err = null;\n            try {\n                this.closeSync();\n            }\n            catch (e) {\n                err = e;\n            }\n            finally {\n                cb(err);\n            }\n        }\n        closeSync() {\n            try {\n                this._FS.close(this._stream);\n            }\n            catch (e) {\n                throw convertError(e, this._path);\n            }\n        }\n        stat(cb) {\n            try {\n                cb(null, this.statSync());\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        statSync() {\n            try {\n                return this._fs.statSync(this._path, false);\n            }\n            catch (e) {\n                throw convertError(e, this._path);\n            }\n        }\n        truncate(len, cb) {\n            let err = null;\n            try {\n                this.truncateSync(len);\n            }\n            catch (e) {\n                err = e;\n            }\n            finally {\n                cb(err);\n            }\n        }\n        truncateSync(len) {\n            try {\n                this._FS.ftruncate(this._stream.fd, len);\n            }\n            catch (e) {\n                throw convertError(e, this._path);\n            }\n        }\n        write(buffer, offset, length, position, cb) {\n            try {\n                cb(null, this.writeSync(buffer, offset, length, position), buffer);\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        writeSync(buffer, offset, length, position) {\n            try {\n                const u8 = buffer2Uint8array(buffer);\n                // Emscripten is particular about what position is set to.\n                const emPosition = position === null ? undefined : position;\n                return this._FS.write(this._stream, u8, offset, length, emPosition);\n            }\n            catch (e) {\n                throw convertError(e, this._path);\n            }\n        }\n        read(buffer, offset, length, position, cb) {\n            try {\n                cb(null, this.readSync(buffer, offset, length, position), buffer);\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        readSync(buffer, offset, length, position) {\n            try {\n                const u8 = buffer2Uint8array(buffer);\n                // Emscripten is particular about what position is set to.\n                const emPosition = position === null ? undefined : position;\n                return this._FS.read(this._stream, u8, offset, length, emPosition);\n            }\n            catch (e) {\n                throw convertError(e, this._path);\n            }\n        }\n        sync(cb) {\n            // NOP.\n            cb();\n        }\n        syncSync() {\n            // NOP.\n        }\n        chown(uid, gid, cb) {\n            let err = null;\n            try {\n                this.chownSync(uid, gid);\n            }\n            catch (e) {\n                err = e;\n            }\n            finally {\n                cb(err);\n            }\n        }\n        chownSync(uid, gid) {\n            try {\n                this._FS.fchown(this._stream.fd, uid, gid);\n            }\n            catch (e) {\n                throw convertError(e, this._path);\n            }\n        }\n        chmod(mode, cb) {\n            let err = null;\n            try {\n                this.chmodSync(mode);\n            }\n            catch (e) {\n                err = e;\n            }\n            finally {\n                cb(err);\n            }\n        }\n        chmodSync(mode) {\n            try {\n                this._FS.fchmod(this._stream.fd, mode);\n            }\n            catch (e) {\n                throw convertError(e, this._path);\n            }\n        }\n        utimes(atime, mtime, cb) {\n            let err = null;\n            try {\n                this.utimesSync(atime, mtime);\n            }\n            catch (e) {\n                err = e;\n            }\n            finally {\n                cb(err);\n            }\n        }\n        utimesSync(atime, mtime) {\n            this._fs.utimesSync(this._path, atime, mtime);\n        }\n    }\n    /**\n     * Mounts an Emscripten file system into the BrowserFS file system.\n     */\n    class EmscriptenFileSystem extends SynchronousFileSystem {\n        constructor(_FS) {\n            super();\n            this._FS = _FS;\n        }\n        /**\n         * Create an EmscriptenFileSystem instance with the given options.\n         */\n        static Create(opts, cb) {\n            cb(null, new EmscriptenFileSystem(opts.FS));\n        }\n        static isAvailable() { return true; }\n        getName() { return this._FS.DB_NAME(); }\n        isReadOnly() { return false; }\n        supportsLinks() { return true; }\n        supportsProps() { return true; }\n        supportsSynch() { return true; }\n        renameSync(oldPath, newPath) {\n            try {\n                this._FS.rename(oldPath, newPath);\n            }\n            catch (e) {\n                if (e.errno === ErrorCode.ENOENT) {\n                    throw convertError(e, this.existsSync(oldPath) ? newPath : oldPath);\n                }\n                else {\n                    throw convertError(e);\n                }\n            }\n        }\n        statSync(p, isLstat) {\n            try {\n                const stats = isLstat ? this._FS.lstat(p) : this._FS.stat(p);\n                const itemType = this.modeToFileType(stats.mode);\n                return new Stats(itemType, stats.size, stats.mode, stats.atime.getTime(), stats.mtime.getTime(), stats.ctime.getTime());\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        openSync(p, flag, mode) {\n            try {\n                const stream = this._FS.open(p, flag.getFlagString(), mode);\n                if (this._FS.isDir(stream.node.mode)) {\n                    this._FS.close(stream);\n                    throw ApiError.EISDIR(p);\n                }\n                return new EmscriptenFile(this, this._FS, p, stream);\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        unlinkSync(p) {\n            try {\n                this._FS.unlink(p);\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        rmdirSync(p) {\n            try {\n                this._FS.rmdir(p);\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        mkdirSync(p, mode) {\n            try {\n                this._FS.mkdir(p, mode);\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        readdirSync(p) {\n            try {\n                // Emscripten returns items for '.' and '..'. Node does not.\n                return this._FS.readdir(p).filter((p) => p !== '.' && p !== '..');\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        truncateSync(p, len) {\n            try {\n                this._FS.truncate(p, len);\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        readFileSync(p, encoding, flag) {\n            try {\n                const data = this._FS.readFile(p, { flags: flag.getFlagString() });\n                const buff = uint8Array2Buffer(data);\n                if (encoding) {\n                    return buff.toString(encoding);\n                }\n                else {\n                    return buff;\n                }\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        writeFileSync(p, data, encoding, flag, mode) {\n            try {\n                if (encoding) {\n                    data = Buffer.from(data, encoding);\n                }\n                const u8 = buffer2Uint8array(data);\n                this._FS.writeFile(p, u8, { flags: flag.getFlagString(), encoding: 'binary' });\n                this._FS.chmod(p, mode);\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        chmodSync(p, isLchmod, mode) {\n            try {\n                isLchmod ? this._FS.lchmod(p, mode) : this._FS.chmod(p, mode);\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        chownSync(p, isLchown, uid, gid) {\n            try {\n                isLchown ? this._FS.lchown(p, uid, gid) : this._FS.chown(p, uid, gid);\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        symlinkSync(srcpath, dstpath, type) {\n            try {\n                this._FS.symlink(srcpath, dstpath);\n            }\n            catch (e) {\n                throw convertError(e);\n            }\n        }\n        readlinkSync(p) {\n            try {\n                return this._FS.readlink(p);\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        utimesSync(p, atime, mtime) {\n            try {\n                this._FS.utime(p, atime.getTime(), mtime.getTime());\n            }\n            catch (e) {\n                throw convertError(e, p);\n            }\n        }\n        modeToFileType(mode) {\n            if (this._FS.isDir(mode)) {\n                return FileType.DIRECTORY;\n            }\n            else if (this._FS.isFile(mode)) {\n                return FileType.FILE;\n            }\n            else if (this._FS.isLink(mode)) {\n                return FileType.SYMLINK;\n            }\n            else {\n                throw ApiError.EPERM(`Invalid mode: ${mode}`);\n            }\n        }\n    }\n    EmscriptenFileSystem.Name = \"EmscriptenFileSystem\";\n    EmscriptenFileSystem.Options = {\n        FS: {\n            type: \"object\",\n            description: \"The Emscripten file system to use (the `FS` variable)\"\n        }\n    };\n\n    EmscriptenFileSystem.EmscriptenFile = EmscriptenFile;\n\n    return EmscriptenFileSystem;\n});\ndefine('skylark-browserfs/backend/FolderAdapter',[\n    '../core/file_system',\n    '../libs/path',\n    '../core/api_error'\n], function (file_system, path, api_error) {\n    'use strict';\n\n    const { BaseFileSystem } = file_system;\n    const { ApiError } = api_error;\n\n    /**\n     * The FolderAdapter file system wraps a file system, and scopes all interactions to a subfolder of that file system.\n     *\n     * Example: Given a file system `foo` with folder `bar` and file `bar/baz`...\n     *\n     * ```javascript\n     * BrowserFS.configure({\n     *   fs: \"FolderAdapter\",\n     *   options: {\n     *     folder: \"bar\",\n     *     wrapped: foo\n     *   }\n     * }, function(e) {\n     *   var fs = BrowserFS.BFSRequire('fs');\n     *   fs.readdirSync('/'); // ['baz']\n     * });\n     * ```\n     */\n    class FolderAdapter extends BaseFileSystem {\n        constructor(folder, wrapped) {\n            super();\n            this._folder = folder;\n            this._wrapped = wrapped;\n        }\n        /**\n         * Creates a FolderAdapter instance with the given options.\n         */\n        static Create(opts, cb) {\n            const fa = new FolderAdapter(opts.folder, opts.wrapped);\n            fa._initialize(function (e) {\n                if (e) {\n                    cb(e);\n                }\n                else {\n                    cb(null, fa);\n                }\n            });\n        }\n        static isAvailable() {\n            return true;\n        }\n        getName() { return this._wrapped.getName(); }\n        isReadOnly() { return this._wrapped.isReadOnly(); }\n        supportsProps() { return this._wrapped.supportsProps(); }\n        supportsSynch() { return this._wrapped.supportsSynch(); }\n        supportsLinks() { return false; }\n        /**\n         * Initialize the file system. Ensures that the wrapped file system\n         * has the given folder.\n         */\n        _initialize(cb) {\n            this._wrapped.exists(this._folder, (exists) => {\n                if (exists) {\n                    cb();\n                }\n                else if (this._wrapped.isReadOnly()) {\n                    cb(ApiError.ENOENT(this._folder));\n                }\n                else {\n                    this._wrapped.mkdir(this._folder, 0x1ff, cb);\n                }\n            });\n        }\n    }\n    FolderAdapter.Name = \"FolderAdapter\";\n    FolderAdapter.Options = {\n        folder: {\n            type: \"string\",\n            description: \"The folder to use as the root directory\"\n        },\n        wrapped: {\n            type: \"object\",\n            description: \"The file system to wrap\"\n        }\n    };\n    /**\n     * @hidden\n     */\n    function translateError(folder, e) {\n        if (e !== null && typeof e === 'object') {\n            const err = e;\n            let p = err.path;\n            if (p) {\n                p = '/' + path.relative(folder, p);\n                err.message = err.message.replace(err.path, p);\n                err.path = p;\n            }\n        }\n        return e;\n    }\n    /**\n     * @hidden\n     */\n    function wrapCallback(folder, cb) {\n        if (typeof cb === 'function') {\n            return function (err) {\n                if (arguments.length > 0) {\n                    arguments[0] = translateError(folder, err);\n                }\n                cb.apply(null, arguments);\n            };\n        }\n        else {\n            return cb;\n        }\n    }\n    /**\n     * @hidden\n     */\n    function wrapFunction(name, wrapFirst, wrapSecond) {\n        if (name.slice(name.length - 4) !== 'Sync') {\n            // Async function. Translate error in callback.\n            return function () {\n                if (arguments.length > 0) {\n                    if (wrapFirst) {\n                        arguments[0] = path.join(this._folder, arguments[0]);\n                    }\n                    if (wrapSecond) {\n                        arguments[1] = path.join(this._folder, arguments[1]);\n                    }\n                    arguments[arguments.length - 1] = wrapCallback(this._folder, arguments[arguments.length - 1]);\n                }\n                return this._wrapped[name].apply(this._wrapped, arguments);\n            };\n        }\n        else {\n            // Sync function. Translate error in catch.\n            return function () {\n                try {\n                    if (wrapFirst) {\n                        arguments[0] = path.join(this._folder, arguments[0]);\n                    }\n                    if (wrapSecond) {\n                        arguments[1] = path.join(this._folder, arguments[1]);\n                    }\n                    return this._wrapped[name].apply(this._wrapped, arguments);\n                }\n                catch (e) {\n                    throw translateError(this._folder, e);\n                }\n            };\n        }\n    }\n    // First argument is a path.\n    ['diskSpace', 'stat', 'statSync', 'open', 'openSync', 'unlink', 'unlinkSync',\n        'rmdir', 'rmdirSync', 'mkdir', 'mkdirSync', 'readdir', 'readdirSync', 'exists',\n        'existsSync', 'realpath', 'realpathSync', 'truncate', 'truncateSync', 'readFile',\n        'readFileSync', 'writeFile', 'writeFileSync', 'appendFile', 'appendFileSync',\n        'chmod', 'chmodSync', 'chown', 'chownSync', 'utimes', 'utimesSync', 'readlink',\n        'readlinkSync'].forEach((name) => {\n        FolderAdapter.prototype[name] = wrapFunction(name, true, false);\n    });\n    // First and second arguments are paths.\n    ['rename', 'renameSync', 'link', 'linkSync', 'symlink', 'symlinkSync'].forEach((name) => {\n        FolderAdapter.prototype[name] = wrapFunction(name, true, true);\n    });\n\n    return FolderAdapter;\n});\ndefine('skylark-browserfs/backend/HTML5FS',[\n    \"skylark-langx-async\",\n    '../generic/preload_file',\n    '../core/file_system',\n    '../core/api_error',\n    '../core/file_flag',\n    '../core/node_fs_stats',\n    '../libs/path',\n    '../core/global',\n    '../core/util'\n], function (async,preload_file, file_system, api_error, file_flag, node_fs_stats, path, global, util) {\n    'use strict';\n    const { BaseFileSystem } = file_system;\n    const { ApiError, ErrorCode } = api_error;\n    const { ActionType } = file_flag;\n    const { Stats, FileType } = node_fs_stats;\n    const asyncEach = async.each;\n    const { buffer2ArrayBuffer, arrayBuffer2Buffer } = util;\n\n    const { PreloadFile} = preload_file;\n\n    /**\n     * @hidden\n     */\n    function isDirectoryEntry(entry) {\n        return entry.isDirectory;\n    }\n    /**\n     * @hidden\n     */\n    const _getFS = global.webkitRequestFileSystem || global.requestFileSystem || null;\n    /**\n     * @hidden\n     */\n    function _requestQuota(type, size, success, errorCallback) {\n        // We cast navigator and window to '<any>' because everything here is\n        // nonstandard functionality, despite the fact that Chrome has the only\n        // implementation of the HTML5FS and is likely driving the standardization\n        // process. Thus, these objects defined off of navigator and window are not\n        // present in the DefinitelyTyped TypeScript typings for FileSystem.\n        if (typeof navigator['webkitPersistentStorage'] !== 'undefined') {\n            switch (type) {\n                case global.PERSISTENT:\n                    navigator.webkitPersistentStorage.requestQuota(size, success, errorCallback);\n                    break;\n                case global.TEMPORARY:\n                    navigator.webkitTemporaryStorage.requestQuota(size, success, errorCallback);\n                    break;\n                default:\n                    errorCallback(new TypeError(`Invalid storage type: ${type}`));\n                    break;\n            }\n        }\n        else {\n            global.webkitStorageInfo.requestQuota(type, size, success, errorCallback);\n        }\n    }\n    /**\n     * @hidden\n     */\n    function _toArray(list) {\n        return Array.prototype.slice.call(list || [], 0);\n    }\n    /**\n     * Converts the given DOMError into an appropriate ApiError.\n     * @url https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n     * @hidden\n     */\n    function convertError(err, p, expectedDir) {\n        switch (err.name) {\n            /* The user agent failed to create a file or directory due to the existence of a file or\n                directory with the same path.  */\n            case \"PathExistsError\":\n                return ApiError.EEXIST(p);\n            /* The operation failed because it would cause the application to exceed its storage quota.  */\n            case 'QuotaExceededError':\n                return ApiError.FileError(ErrorCode.ENOSPC, p);\n            /*  A required file or directory could not be found at the time an operation was processed.   */\n            case 'NotFoundError':\n                return ApiError.ENOENT(p);\n            /* This is a security error code to be used in situations not covered by any other error codes.\n                - A required file was unsafe for access within a Web application\n                - Too many calls are being made on filesystem resources */\n            case 'SecurityError':\n                return ApiError.FileError(ErrorCode.EACCES, p);\n            /* The modification requested was illegal. Examples of invalid modifications include moving a\n                directory into its own child, moving a file into its parent directory without changing its name,\n                or copying a directory to a path occupied by a file.  */\n            case 'InvalidModificationError':\n                return ApiError.FileError(ErrorCode.EPERM, p);\n            /* The user has attempted to look up a file or directory, but the Entry found is of the wrong type\n                [e.g. is a DirectoryEntry when the user requested a FileEntry].  */\n            case 'TypeMismatchError':\n                return ApiError.FileError(expectedDir ? ErrorCode.ENOTDIR : ErrorCode.EISDIR, p);\n            /* A path or URL supplied to the API was malformed.  */\n            case \"EncodingError\":\n            /* An operation depended on state cached in an interface object, but that state that has changed\n                since it was read from disk.  */\n            case \"InvalidStateError\":\n            /* The user attempted to write to a file or directory which could not be modified due to the state\n                of the underlying filesystem.  */\n            case \"NoModificationAllowedError\":\n            default:\n                return ApiError.FileError(ErrorCode.EINVAL, p);\n        }\n    }\n    // A note about getFile and getDirectory options:\n    // These methods are called at numerous places in this file, and are passed\n    // some combination of these two options:\n    //   - create: If true, the entry will be created if it doesn't exist.\n    //             If false, an error will be thrown if it doesn't exist.\n    //   - exclusive: If true, only create the entry if it doesn't already exist,\n    //                and throw an error if it does.\n    class HTML5FSFile extends PreloadFile {\n        constructor(fs, entry, path, flag, stat, contents) {\n            super(fs, path, flag, stat, contents);\n            this._entry = entry;\n        }\n        sync(cb) {\n            if (!this.isDirty()) {\n                return cb();\n            }\n            this._entry.createWriter((writer) => {\n                const buffer = this.getBuffer();\n                const blob = new Blob([buffer2ArrayBuffer(buffer)]);\n                const length = blob.size;\n                writer.onwriteend = (err) => {\n                    writer.onwriteend = null;\n                    writer.onerror = null;\n                    writer.truncate(length);\n                    this.resetDirty();\n                    cb();\n                };\n                writer.onerror = (err) => {\n                    cb(convertError(err, this.getPath(), false));\n                };\n                writer.write(blob);\n            });\n        }\n        close(cb) {\n            this.sync(cb);\n        }\n    }\n    /**\n     * A read-write filesystem backed by the HTML5 FileSystem API.\n     *\n     * As the HTML5 FileSystem is only implemented in Blink, this interface is\n     * only available in Chrome.\n     */\n    class HTML5FS extends BaseFileSystem {\n        /**\n         * @param size storage quota to request, in megabytes. Allocated value may be less.\n         * @param type window.PERSISTENT or window.TEMPORARY. Defaults to PERSISTENT.\n         */\n        constructor(size = 5, type = global.PERSISTENT) {\n            super();\n            // Convert MB to bytes.\n            this.size = 1024 * 1024 * size;\n            this.type = type;\n        }\n        /**\n         * Creates an HTML5FS instance with the given options.\n         */\n        static Create(opts, cb) {\n            const fs = new HTML5FS(opts.size, opts.type);\n            fs._allocate((e) => e ? cb(e) : cb(null, fs));\n        }\n        static isAvailable() {\n            return !!_getFS;\n        }\n        getName() {\n            return HTML5FS.Name;\n        }\n        isReadOnly() {\n            return false;\n        }\n        supportsSymlinks() {\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            return false;\n        }\n        /**\n         * Deletes everything in the FS. Used for testing.\n         * Karma clears the storage after you quit it but not between runs of the test\n         * suite, and the tests expect an empty FS every time.\n         */\n        empty(mainCb) {\n            // Get a list of all entries in the root directory to delete them\n            this._readdir('/', (err, entries) => {\n                if (err) {\n                    mainCb(err);\n                }\n                else {\n                    // Called when every entry has been operated on\n                    const finished = (er) => {\n                        if (err) {\n                            mainCb(err);\n                        }\n                        else {\n                            mainCb();\n                        }\n                    };\n                    // Removes files and recursively removes directories\n                    const deleteEntry = (entry, cb) => {\n                        const succ = () => {\n                            cb();\n                        };\n                        const error = (err) => {\n                            cb(convertError(err, entry.fullPath, !entry.isDirectory));\n                        };\n                        if (isDirectoryEntry(entry)) {\n                            entry.removeRecursively(succ, error);\n                        }\n                        else {\n                            entry.remove(succ, error);\n                        }\n                    };\n                    // Loop through the entries and remove them, then call the callback\n                    // when they're all finished.\n                    asyncEach(entries, deleteEntry, finished);\n                }\n            });\n        }\n        rename(oldPath, newPath, cb) {\n            let semaphore = 2;\n            let successCount = 0;\n            const root = this.fs.root;\n            let currentPath = oldPath;\n            const error = (err) => {\n                if (--semaphore <= 0) {\n                    cb(convertError(err, currentPath, false));\n                }\n            };\n            const success = (file) => {\n                if (++successCount === 2) {\n                    return cb(new ApiError(ErrorCode.EINVAL, \"Something was identified as both a file and a directory. This should never happen.\"));\n                }\n                // SPECIAL CASE: If newPath === oldPath, and the path exists, then\n                // this operation trivially succeeds.\n                if (oldPath === newPath) {\n                    return cb();\n                }\n                // Get the new parent directory.\n                currentPath = path.dirname(newPath);\n                root.getDirectory(currentPath, {}, (parentDir) => {\n                    currentPath = path.basename(newPath);\n                    file.moveTo(parentDir, currentPath, (entry) => { cb(); }, (err) => {\n                        // SPECIAL CASE: If oldPath is a directory, and newPath is a\n                        // file, rename should delete the file and perform the move.\n                        if (file.isDirectory) {\n                            currentPath = newPath;\n                            // Unlink only works on files. Try to delete newPath.\n                            this.unlink(newPath, (e) => {\n                                if (e) {\n                                    // newPath is probably a directory.\n                                    error(err);\n                                }\n                                else {\n                                    // Recur, now that newPath doesn't exist.\n                                    this.rename(oldPath, newPath, cb);\n                                }\n                            });\n                        }\n                        else {\n                            error(err);\n                        }\n                    });\n                }, error);\n            };\n            // We don't know if oldPath is a *file* or a *directory*, and there's no\n            // way to stat items. So launch both requests, see which one succeeds.\n            root.getFile(oldPath, {}, success, error);\n            root.getDirectory(oldPath, {}, success, error);\n        }\n        stat(path, isLstat, cb) {\n            // Throw an error if the entry doesn't exist, because then there's nothing\n            // to stat.\n            const opts = {\n                create: false\n            };\n            // Called when the path has been successfully loaded as a file.\n            const loadAsFile = (entry) => {\n                const fileFromEntry = (file) => {\n                    const stat = new Stats(FileType.FILE, file.size);\n                    cb(null, stat);\n                };\n                entry.file(fileFromEntry, failedToLoad);\n            };\n            // Called when the path has been successfully loaded as a directory.\n            const loadAsDir = (dir) => {\n                // Directory entry size can't be determined from the HTML5 FS API, and is\n                // implementation-dependant anyway, so a dummy value is used.\n                const size = 4096;\n                const stat = new Stats(FileType.DIRECTORY, size);\n                cb(null, stat);\n            };\n            // Called when the path couldn't be opened as a directory or a file.\n            const failedToLoad = (err) => {\n                cb(convertError(err, path, false /* Unknown / irrelevant */));\n            };\n            // Called when the path couldn't be opened as a file, but might still be a\n            // directory.\n            const failedToLoadAsFile = () => {\n                this.fs.root.getDirectory(path, opts, loadAsDir, failedToLoad);\n            };\n            // No method currently exists to determine whether a path refers to a\n            // directory or a file, so this implementation tries both and uses the first\n            // one that succeeds.\n            this.fs.root.getFile(path, opts, loadAsFile, failedToLoadAsFile);\n        }\n        open(p, flags, mode, cb) {\n            // XXX: err is a DOMError\n            const error = (err) => {\n                if (err.name === 'InvalidModificationError' && flags.isExclusive()) {\n                    cb(ApiError.EEXIST(p));\n                }\n                else {\n                    cb(convertError(err, p, false));\n                }\n            };\n            this.fs.root.getFile(p, {\n                create: flags.pathNotExistsAction() === ActionType.CREATE_FILE,\n                exclusive: flags.isExclusive()\n            }, (entry) => {\n                // Try to fetch corresponding file.\n                entry.file((file) => {\n                    const reader = new FileReader();\n                    reader.onloadend = (event) => {\n                        const bfsFile = this._makeFile(p, entry, flags, file, reader.result);\n                        cb(null, bfsFile);\n                    };\n                    reader.onerror = (ev) => {\n                        error(reader.error);\n                    };\n                    reader.readAsArrayBuffer(file);\n                }, error);\n            }, error);\n        }\n        unlink(path, cb) {\n            this._remove(path, cb, true);\n        }\n        rmdir(path, cb) {\n            // Check if directory is non-empty, first.\n            this.readdir(path, (e, files) => {\n                if (e) {\n                    cb(e);\n                }\n                else if (files.length > 0) {\n                    cb(ApiError.ENOTEMPTY(path));\n                }\n                else {\n                    this._remove(path, cb, false);\n                }\n            });\n        }\n        mkdir(path, mode, cb) {\n            // Create the directory, but throw an error if it already exists, as per\n            // mkdir(1)\n            const opts = {\n                create: true,\n                exclusive: true\n            };\n            const success = (dir) => {\n                cb();\n            };\n            const error = (err) => {\n                cb(convertError(err, path, true));\n            };\n            this.fs.root.getDirectory(path, opts, success, error);\n        }\n        /**\n         * Map _readdir's list of `FileEntry`s to their names and return that.\n         */\n        readdir(path, cb) {\n            this._readdir(path, (e, entries) => {\n                if (entries) {\n                    const rv = [];\n                    for (const entry of entries) {\n                        rv.push(entry.name);\n                    }\n                    cb(null, rv);\n                }\n                else {\n                    return cb(e);\n                }\n            });\n        }\n        /**\n         * Returns a BrowserFS object representing a File.\n         */\n        _makeFile(path, entry, flag, stat, data = new ArrayBuffer(0)) {\n            const stats = new Stats(FileType.FILE, stat.size);\n            const buffer = arrayBuffer2Buffer(data);\n            return new HTML5FSFile(this, entry, path, flag, stats, buffer);\n        }\n        /**\n         * Returns an array of `FileEntry`s. Used internally by empty and readdir.\n         */\n        _readdir(path, cb) {\n            const error = (err) => {\n                cb(convertError(err, path, true));\n            };\n            // Grab the requested directory.\n            this.fs.root.getDirectory(path, { create: false }, (dirEntry) => {\n                const reader = dirEntry.createReader();\n                let entries = [];\n                // Call the reader.readEntries() until no more results are returned.\n                const readEntries = () => {\n                    reader.readEntries(((results) => {\n                        if (results.length) {\n                            entries = entries.concat(_toArray(results));\n                            readEntries();\n                        }\n                        else {\n                            cb(null, entries);\n                        }\n                    }), error);\n                };\n                readEntries();\n            }, error);\n        }\n        /**\n         * Requests a storage quota from the browser to back this FS.\n         */\n        _allocate(cb) {\n            const success = (fs) => {\n                this.fs = fs;\n                cb();\n            };\n            const error = (err) => {\n                cb(convertError(err, \"/\", true));\n            };\n            if (this.type === global.PERSISTENT) {\n                _requestQuota(this.type, this.size, (granted) => {\n                    _getFS(this.type, granted, success, error);\n                }, error);\n            }\n            else {\n                _getFS(this.type, this.size, success, error);\n            }\n        }\n        /**\n         * Delete a file or directory from the file system\n         * isFile should reflect which call was made to remove the it (`unlink` or\n         * `rmdir`). If this doesn't match what's actually at `path`, an error will be\n         * returned\n         */\n        _remove(path, cb, isFile) {\n            const success = (entry) => {\n                const succ = () => {\n                    cb();\n                };\n                const err = (err) => {\n                    cb(convertError(err, path, !isFile));\n                };\n                entry.remove(succ, err);\n            };\n            const error = (err) => {\n                cb(convertError(err, path, !isFile));\n            };\n            // Deleting the entry, so don't create it\n            const opts = {\n                create: false\n            };\n            if (isFile) {\n                this.fs.root.getFile(path, opts, success, error);\n            }\n            else {\n                this.fs.root.getDirectory(path, opts, success, error);\n            }\n        }\n    }\n    HTML5FS.Name = \"HTML5FS\";\n    HTML5FS.Options = {\n        size: {\n            type: \"number\",\n            optional: true,\n            description: \"Storage quota to request, in megabytes. Allocated value may be less. Defaults to 5.\"\n        },\n        type: {\n            type: \"number\",\n            optional: true,\n            description: \"window.PERSISTENT or window.TEMPORARY. Defaults to PERSISTENT.\"\n        }\n    };\n\n    HTML5FS.HTML5FSFile = HTML5FSFile;\n\n    return HTML5FS;\n});\ndefine('skylark-browserfs/generic/inode',[\n    '../libs/buffers',\n    '../core/node_fs_stats'\n], function (buffers,node_fs_stats) {\n    'use strict';\n\n    const  { Stats, FileType } = node_fs_stats;\n    const { Buffer } = buffers;\n\n    /**\n     * Generic inode definition that can easily be serialized.\n     */\n    class Inode {\n        constructor(id, size, mode, atime, mtime, ctime) {\n            this.id = id;\n            this.size = size;\n            this.mode = mode;\n            this.atime = atime;\n            this.mtime = mtime;\n            this.ctime = ctime;\n        }\n        /**\n         * Converts the buffer into an Inode.\n         */\n        static fromBuffer(buffer) {\n            if (buffer === undefined) {\n                throw new Error(\"NO\");\n            }\n            return new Inode(buffer.toString('ascii', 30), buffer.readUInt32LE(0), buffer.readUInt16LE(4), buffer.readDoubleLE(6), buffer.readDoubleLE(14), buffer.readDoubleLE(22));\n        }\n        /**\n         * Handy function that converts the Inode to a Node Stats object.\n         */\n        toStats() {\n            return new Stats((this.mode & 0xF000) === FileType.DIRECTORY ? FileType.DIRECTORY : FileType.FILE, this.size, this.mode, this.atime, this.mtime, this.ctime);\n        }\n        /**\n         * Get the size of this Inode, in bytes.\n         */\n        getSize() {\n            // ASSUMPTION: ID is ASCII (1 byte per char).\n            return 30 + this.id.length;\n        }\n        /**\n         * Writes the inode into the start of the buffer.\n         */\n        toBuffer(buff = Buffer.alloc(this.getSize())) {\n            buff.writeUInt32LE(this.size, 0);\n            buff.writeUInt16LE(this.mode, 4);\n            buff.writeDoubleLE(this.atime, 6);\n            buff.writeDoubleLE(this.mtime, 14);\n            buff.writeDoubleLE(this.ctime, 22);\n            buff.write(this.id, 30, this.id.length, 'ascii');\n            return buff;\n        }\n        /**\n         * Updates the Inode using information from the stats object. Used by file\n         * systems at sync time, e.g.:\n         * - Program opens file and gets a File object.\n         * - Program mutates file. File object is responsible for maintaining\n         *   metadata changes locally -- typically in a Stats object.\n         * - Program closes file. File object's metadata changes are synced with the\n         *   file system.\n         * @return True if any changes have occurred.\n         */\n        update(stats) {\n            let hasChanged = false;\n            if (this.size !== stats.size) {\n                this.size = stats.size;\n                hasChanged = true;\n            }\n            if (this.mode !== stats.mode) {\n                this.mode = stats.mode;\n                hasChanged = true;\n            }\n            const atimeMs = stats.atime.getTime();\n            if (this.atime !== atimeMs) {\n                this.atime = atimeMs;\n                hasChanged = true;\n            }\n            const mtimeMs = stats.mtime.getTime();\n            if (this.mtime !== mtimeMs) {\n                this.mtime = mtimeMs;\n                hasChanged = true;\n            }\n            const ctimeMs = stats.ctime.getTime();\n            if (this.ctime !== ctimeMs) {\n                this.ctime = ctimeMs;\n                hasChanged = true;\n            }\n            return hasChanged;\n        }\n        // XXX: Copied from Stats. Should reconcile these two into something more\n        //      compact.\n        /**\n         * @return [Boolean] True if this item is a file.\n         */\n        isFile() {\n            return (this.mode & 0xF000) === FileType.FILE;\n        }\n        /**\n         * @return [Boolean] True if this item is a directory.\n         */\n        isDirectory() {\n            return (this.mode & 0xF000) === FileType.DIRECTORY;\n        }\n    }\n\n\n    return Inode;\n});\ndefine('skylark-browserfs/generic/key_value_filesystem',[\n    '../libs/buffers',\n    '../core/file_system',\n    '../core/api_error',\n    '../core/node_fs_stats',\n    '../libs/path',\n    '../generic/inode',\n    '../generic/preload_file',\n    '../core/util'\n], function (buffers,file_system, api_error, node_fs_stats, path, Inode, preload_file, util) {\n    'use strict';\n\n    const { BaseFileSystem, SynchronousFileSystem } = file_system;\n    const { ApiError, ErrorCode } = api_error;\n    const { FileType } = node_fs_stats;\n    const { emptyBuffer } = util;\n    const { PreloadFile} = preload_file;\n    const { Buffer } = buffers;\n\n\n    /**\n     * @hidden\n     */\n    const ROOT_NODE_ID = \"/\";\n    /**\n     * @hidden\n     */\n    let emptyDirNode = null;\n    /**\n     * Returns an empty directory node.\n     * @hidden\n     */\n    function getEmptyDirNode() {\n        if (emptyDirNode) {\n            return emptyDirNode;\n        }\n        return emptyDirNode = Buffer.from(\"{}\");\n    }\n    /**\n     * Generates a random ID.\n     * @hidden\n     */\n    function GenerateRandomID() {\n        // From http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n            const r = Math.random() * 16 | 0;\n            const v = c === 'x' ? r : (r & 0x3 | 0x8);\n            return v.toString(16);\n        });\n    }\n    /**\n     * Helper function. Checks if 'e' is defined. If so, it triggers the callback\n     * with 'e' and returns false. Otherwise, returns true.\n     * @hidden\n     */\n    function noError(e, cb) {\n        if (e) {\n            cb(e);\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Helper function. Checks if 'e' is defined. If so, it aborts the transaction,\n     * triggers the callback with 'e', and returns false. Otherwise, returns true.\n     * @hidden\n     */\n    function noErrorTx(e, tx, cb) {\n        if (e) {\n            tx.abort(() => {\n                cb(e);\n            });\n            return false;\n        }\n        return true;\n    }\n    class LRUNode {\n        constructor(key, value) {\n            this.key = key;\n            this.value = value;\n            this.prev = null;\n            this.next = null;\n        }\n    }\n    // Adapted from https://chrisrng.svbtle.com/lru-cache-in-javascript\n    class LRUCache {\n        constructor(limit) {\n            this.limit = limit;\n            this.size = 0;\n            this.map = {};\n            this.head = null;\n            this.tail = null;\n        }\n        /**\n         * Change or add a new value in the cache\n         * We overwrite the entry if it already exists\n         */\n        set(key, value) {\n            const node = new LRUNode(key, value);\n            if (this.map[key]) {\n                this.map[key].value = node.value;\n                this.remove(node.key);\n            }\n            else {\n                if (this.size >= this.limit) {\n                    delete this.map[this.tail.key];\n                    this.size--;\n                    this.tail = this.tail.prev;\n                    this.tail.next = null;\n                }\n            }\n            this.setHead(node);\n        }\n        /* Retrieve a single entry from the cache */\n        get(key) {\n            if (this.map[key]) {\n                const value = this.map[key].value;\n                const node = new LRUNode(key, value);\n                this.remove(key);\n                this.setHead(node);\n                return value;\n            }\n            else {\n                return null;\n            }\n        }\n        /* Remove a single entry from the cache */\n        remove(key) {\n            const node = this.map[key];\n            if (!node) {\n                return;\n            }\n            if (node.prev !== null) {\n                node.prev.next = node.next;\n            }\n            else {\n                this.head = node.next;\n            }\n            if (node.next !== null) {\n                node.next.prev = node.prev;\n            }\n            else {\n                this.tail = node.prev;\n            }\n            delete this.map[key];\n            this.size--;\n        }\n        /* Resets the entire cache - Argument limit is optional to be reset */\n        removeAll() {\n            this.size = 0;\n            this.map = {};\n            this.head = null;\n            this.tail = null;\n        }\n        setHead(node) {\n            node.next = this.head;\n            node.prev = null;\n            if (this.head !== null) {\n                this.head.prev = node;\n            }\n            this.head = node;\n            if (this.tail === null) {\n                this.tail = node;\n            }\n            this.size++;\n            this.map[node.key] = node;\n        }\n    }\n    /**\n     * A simple RW transaction for simple synchronous key-value stores.\n     */\n    class SimpleSyncRWTransaction {\n        constructor(store) {\n            this.store = store;\n            /**\n             * Stores data in the keys we modify prior to modifying them.\n             * Allows us to roll back commits.\n             */\n            this.originalData = {};\n            /**\n             * List of keys modified in this transaction, if any.\n             */\n            this.modifiedKeys = [];\n        }\n        get(key) {\n            const val = this.store.get(key);\n            this.stashOldValue(key, val);\n            return val;\n        }\n        put(key, data, overwrite) {\n            this.markModified(key);\n            return this.store.put(key, data, overwrite);\n        }\n        del(key) {\n            this.markModified(key);\n            this.store.del(key);\n        }\n        commit() { }\n        abort() {\n            // Rollback old values.\n            for (const key of this.modifiedKeys) {\n                const value = this.originalData[key];\n                if (!value) {\n                    // Key didn't exist.\n                    this.store.del(key);\n                }\n                else {\n                    // Key existed. Store old value.\n                    this.store.put(key, value, true);\n                }\n            }\n        }\n        /**\n         * Stashes given key value pair into `originalData` if it doesn't already\n         * exist. Allows us to stash values the program is requesting anyway to\n         * prevent needless `get` requests if the program modifies the data later\n         * on during the transaction.\n         */\n        stashOldValue(key, value) {\n            // Keep only the earliest value in the transaction.\n            if (!this.originalData.hasOwnProperty(key)) {\n                this.originalData[key] = value;\n            }\n        }\n        /**\n         * Marks the given key as modified, and stashes its value if it has not been\n         * stashed already.\n         */\n        markModified(key) {\n            if (this.modifiedKeys.indexOf(key) === -1) {\n                this.modifiedKeys.push(key);\n                if (!this.originalData.hasOwnProperty(key)) {\n                    this.originalData[key] = this.store.get(key);\n                }\n            }\n        }\n    }\n    class SyncKeyValueFile extends PreloadFile {\n        constructor(_fs, _path, _flag, _stat, contents) {\n            super(_fs, _path, _flag, _stat, contents);\n        }\n        syncSync() {\n            if (this.isDirty()) {\n                this._fs._syncSync(this.getPath(), this.getBuffer(), this.getStats());\n                this.resetDirty();\n            }\n        }\n        closeSync() {\n            this.syncSync();\n        }\n    }\n    /**\n     * A \"Synchronous key-value file system\". Stores data to/retrieves data from an\n     * underlying key-value store.\n     *\n     * We use a unique ID for each node in the file system. The root node has a\n     * fixed ID.\n     * @todo Introduce Node ID caching.\n     * @todo Check modes.\n     */\n    class SyncKeyValueFileSystem extends SynchronousFileSystem {\n        static isAvailable() { return true; }\n        constructor(options) {\n            super();\n            this.store = options.store;\n            // INVARIANT: Ensure that the root exists.\n            this.makeRootDirectory();\n        }\n        getName() { return this.store.name(); }\n        isReadOnly() { return false; }\n        supportsSymlinks() { return false; }\n        supportsProps() { return false; }\n        supportsSynch() { return true; }\n        /**\n         * Delete all contents stored in the file system.\n         */\n        empty() {\n            this.store.clear();\n            // INVARIANT: Root always exists.\n            this.makeRootDirectory();\n        }\n        renameSync(oldPath, newPath) {\n            const tx = this.store.beginTransaction('readwrite'), oldParent = path.dirname(oldPath), oldName = path.basename(oldPath), newParent = path.dirname(newPath), newName = path.basename(newPath), \n            // Remove oldPath from parent's directory listing.\n            oldDirNode = this.findINode(tx, oldParent), oldDirList = this.getDirListing(tx, oldParent, oldDirNode);\n            if (!oldDirList[oldName]) {\n                throw ApiError.ENOENT(oldPath);\n            }\n            const nodeId = oldDirList[oldName];\n            delete oldDirList[oldName];\n            // Invariant: Can't move a folder inside itself.\n            // This funny little hack ensures that the check passes only if oldPath\n            // is a subpath of newParent. We append '/' to avoid matching folders that\n            // are a substring of the bottom-most folder in the path.\n            if ((newParent + '/').indexOf(oldPath + '/') === 0) {\n                throw new ApiError(ErrorCode.EBUSY, oldParent);\n            }\n            // Add newPath to parent's directory listing.\n            let newDirNode, newDirList;\n            if (newParent === oldParent) {\n                // Prevent us from re-grabbing the same directory listing, which still\n                // contains oldName.\n                newDirNode = oldDirNode;\n                newDirList = oldDirList;\n            }\n            else {\n                newDirNode = this.findINode(tx, newParent);\n                newDirList = this.getDirListing(tx, newParent, newDirNode);\n            }\n            if (newDirList[newName]) {\n                // If it's a file, delete it.\n                const newNameNode = this.getINode(tx, newPath, newDirList[newName]);\n                if (newNameNode.isFile()) {\n                    try {\n                        tx.del(newNameNode.id);\n                        tx.del(newDirList[newName]);\n                    }\n                    catch (e) {\n                        tx.abort();\n                        throw e;\n                    }\n                }\n                else {\n                    // If it's a directory, throw a permissions error.\n                    throw ApiError.EPERM(newPath);\n                }\n            }\n            newDirList[newName] = nodeId;\n            // Commit the two changed directory listings.\n            try {\n                tx.put(oldDirNode.id, Buffer.from(JSON.stringify(oldDirList)), true);\n                tx.put(newDirNode.id, Buffer.from(JSON.stringify(newDirList)), true);\n            }\n            catch (e) {\n                tx.abort();\n                throw e;\n            }\n            tx.commit();\n        }\n        statSync(p, isLstat) {\n            // Get the inode to the item, convert it into a Stats object.\n            return this.findINode(this.store.beginTransaction('readonly'), p).toStats();\n        }\n        createFileSync(p, flag, mode) {\n            const tx = this.store.beginTransaction('readwrite'), data = emptyBuffer(), newFile = this.commitNewFile(tx, p, FileType.FILE, mode, data);\n            // Open the file.\n            return new SyncKeyValueFile(this, p, flag, newFile.toStats(), data);\n        }\n        openFileSync(p, flag) {\n            const tx = this.store.beginTransaction('readonly'), node = this.findINode(tx, p), data = tx.get(node.id);\n            if (data === undefined) {\n                throw ApiError.ENOENT(p);\n            }\n            return new SyncKeyValueFile(this, p, flag, node.toStats(), data);\n        }\n        unlinkSync(p) {\n            this.removeEntry(p, false);\n        }\n        rmdirSync(p) {\n            // Check first if directory is empty.\n            if (this.readdirSync(p).length > 0) {\n                throw ApiError.ENOTEMPTY(p);\n            }\n            else {\n                this.removeEntry(p, true);\n            }\n        }\n        mkdirSync(p, mode) {\n            const tx = this.store.beginTransaction('readwrite'), data = Buffer.from('{}');\n            this.commitNewFile(tx, p, FileType.DIRECTORY, mode, data);\n        }\n        readdirSync(p) {\n            const tx = this.store.beginTransaction('readonly');\n            return Object.keys(this.getDirListing(tx, p, this.findINode(tx, p)));\n        }\n        _syncSync(p, data, stats) {\n            // @todo Ensure mtime updates properly, and use that to determine if a data\n            //       update is required.\n            const tx = this.store.beginTransaction('readwrite'), \n            // We use the _findInode helper because we actually need the INode id.\n            fileInodeId = this._findINode(tx, path.dirname(p), path.basename(p)), fileInode = this.getINode(tx, p, fileInodeId), inodeChanged = fileInode.update(stats);\n            try {\n                // Sync data.\n                tx.put(fileInode.id, data, true);\n                // Sync metadata.\n                if (inodeChanged) {\n                    tx.put(fileInodeId, fileInode.toBuffer(), true);\n                }\n            }\n            catch (e) {\n                tx.abort();\n                throw e;\n            }\n            tx.commit();\n        }\n        /**\n         * Checks if the root directory exists. Creates it if it doesn't.\n         */\n        makeRootDirectory() {\n            const tx = this.store.beginTransaction('readwrite');\n            if (tx.get(ROOT_NODE_ID) === undefined) {\n                // Create new inode.\n                const currTime = (new Date()).getTime(), \n                // Mode 0666\n                dirInode = new Inode(GenerateRandomID(), 4096, 511 | FileType.DIRECTORY, currTime, currTime, currTime);\n                // If the root doesn't exist, the first random ID shouldn't exist,\n                // either.\n                tx.put(dirInode.id, getEmptyDirNode(), false);\n                tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false);\n                tx.commit();\n            }\n        }\n        /**\n         * Helper function for findINode.\n         * @param parent The parent directory of the file we are attempting to find.\n         * @param filename The filename of the inode we are attempting to find, minus\n         *   the parent.\n         * @return string The ID of the file's inode in the file system.\n         */\n        _findINode(tx, parent, filename) {\n            const readDirectory = (inode) => {\n                // Get the root's directory listing.\n                const dirList = this.getDirListing(tx, parent, inode);\n                // Get the file's ID.\n                if (dirList[filename]) {\n                    return dirList[filename];\n                }\n                else {\n                    throw ApiError.ENOENT(path.resolve(parent, filename));\n                }\n            };\n            if (parent === '/') {\n                if (filename === '') {\n                    // BASE CASE #1: Return the root's ID.\n                    return ROOT_NODE_ID;\n                }\n                else {\n                    // BASE CASE #2: Find the item in the root ndoe.\n                    return readDirectory(this.getINode(tx, parent, ROOT_NODE_ID));\n                }\n            }\n            else {\n                return readDirectory(this.getINode(tx, parent + path.sep + filename, this._findINode(tx, path.dirname(parent), path.basename(parent))));\n            }\n        }\n        /**\n         * Finds the Inode of the given path.\n         * @param p The path to look up.\n         * @return The Inode of the path p.\n         * @todo memoize/cache\n         */\n        findINode(tx, p) {\n            return this.getINode(tx, p, this._findINode(tx, path.dirname(p), path.basename(p)));\n        }\n        /**\n         * Given the ID of a node, retrieves the corresponding Inode.\n         * @param tx The transaction to use.\n         * @param p The corresponding path to the file (used for error messages).\n         * @param id The ID to look up.\n         */\n        getINode(tx, p, id) {\n            const inode = tx.get(id);\n            if (inode === undefined) {\n                throw ApiError.ENOENT(p);\n            }\n            return Inode.fromBuffer(inode);\n        }\n        /**\n         * Given the Inode of a directory, retrieves the corresponding directory\n         * listing.\n         */\n        getDirListing(tx, p, inode) {\n            if (!inode.isDirectory()) {\n                throw ApiError.ENOTDIR(p);\n            }\n            const data = tx.get(inode.id);\n            if (data === undefined) {\n                throw ApiError.ENOENT(p);\n            }\n            return JSON.parse(data.toString());\n        }\n        /**\n         * Creates a new node under a random ID. Retries 5 times before giving up in\n         * the exceedingly unlikely chance that we try to reuse a random GUID.\n         * @return The GUID that the data was stored under.\n         */\n        addNewNode(tx, data) {\n            const retries = 0;\n            let currId;\n            while (retries < 5) {\n                try {\n                    currId = GenerateRandomID();\n                    tx.put(currId, data, false);\n                    return currId;\n                }\n                catch (e) {\n                    // Ignore and reroll.\n                }\n            }\n            throw new ApiError(ErrorCode.EIO, 'Unable to commit data to key-value store.');\n        }\n        /**\n         * Commits a new file (well, a FILE or a DIRECTORY) to the file system with\n         * the given mode.\n         * Note: This will commit the transaction.\n         * @param p The path to the new file.\n         * @param type The type of the new file.\n         * @param mode The mode to create the new file with.\n         * @param data The data to store at the file's data node.\n         * @return The Inode for the new file.\n         */\n        commitNewFile(tx, p, type, mode, data) {\n            const parentDir = path.dirname(p), fname = path.basename(p), parentNode = this.findINode(tx, parentDir), dirListing = this.getDirListing(tx, parentDir, parentNode), currTime = (new Date()).getTime();\n            // Invariant: The root always exists.\n            // If we don't check this prior to taking steps below, we will create a\n            // file with name '' in root should p == '/'.\n            if (p === '/') {\n                throw ApiError.EEXIST(p);\n            }\n            // Check if file already exists.\n            if (dirListing[fname]) {\n                throw ApiError.EEXIST(p);\n            }\n            let fileNode;\n            try {\n                // Commit data.\n                const dataId = this.addNewNode(tx, data);\n                fileNode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);\n                // Commit file node.\n                const fileNodeId = this.addNewNode(tx, fileNode.toBuffer());\n                // Update and commit parent directory listing.\n                dirListing[fname] = fileNodeId;\n                tx.put(parentNode.id, Buffer.from(JSON.stringify(dirListing)), true);\n            }\n            catch (e) {\n                tx.abort();\n                throw e;\n            }\n            tx.commit();\n            return fileNode;\n        }\n        /**\n         * Remove all traces of the given path from the file system.\n         * @param p The path to remove from the file system.\n         * @param isDir Does the path belong to a directory, or a file?\n         * @todo Update mtime.\n         */\n        removeEntry(p, isDir) {\n            const tx = this.store.beginTransaction('readwrite'), parent = path.dirname(p), parentNode = this.findINode(tx, parent), parentListing = this.getDirListing(tx, parent, parentNode), fileName = path.basename(p);\n            if (!parentListing[fileName]) {\n                throw ApiError.ENOENT(p);\n            }\n            // Remove from directory listing of parent.\n            const fileNodeId = parentListing[fileName];\n            delete parentListing[fileName];\n            // Get file inode.\n            const fileNode = this.getINode(tx, p, fileNodeId);\n            if (!isDir && fileNode.isDirectory()) {\n                throw ApiError.EISDIR(p);\n            }\n            else if (isDir && !fileNode.isDirectory()) {\n                throw ApiError.ENOTDIR(p);\n            }\n            try {\n                // Delete data.\n                tx.del(fileNode.id);\n                // Delete node.\n                tx.del(fileNodeId);\n                // Update directory listing.\n                tx.put(parentNode.id, Buffer.from(JSON.stringify(parentListing)), true);\n            }\n            catch (e) {\n                tx.abort();\n                throw e;\n            }\n            // Success.\n            tx.commit();\n        }\n    }\n    class AsyncKeyValueFile extends PreloadFile {\n        constructor(_fs, _path, _flag, _stat, contents) {\n            super(_fs, _path, _flag, _stat, contents);\n        }\n        sync(cb) {\n            if (this.isDirty()) {\n                this._fs._sync(this.getPath(), this.getBuffer(), this.getStats(), (e) => {\n                    if (!e) {\n                        this.resetDirty();\n                    }\n                    cb(e);\n                });\n            }\n            else {\n                cb();\n            }\n        }\n        close(cb) {\n            this.sync(cb);\n        }\n    }\n    /**\n     * An \"Asynchronous key-value file system\". Stores data to/retrieves data from\n     * an underlying asynchronous key-value store.\n     */\n    class AsyncKeyValueFileSystem extends BaseFileSystem {\n        constructor(cacheSize) {\n            super();\n            this._cache = null;\n            if (cacheSize > 0) {\n                this._cache = new LRUCache(cacheSize);\n            }\n        }\n        static isAvailable() { return true; }\n        /**\n         * Initializes the file system. Typically called by subclasses' async\n         * constructors.\n         */\n        init(store, cb) {\n            this.store = store;\n            // INVARIANT: Ensure that the root exists.\n            this.makeRootDirectory(cb);\n        }\n        getName() { return this.store.name(); }\n        isReadOnly() { return false; }\n        supportsSymlinks() { return false; }\n        supportsProps() { return false; }\n        supportsSynch() { return false; }\n        /**\n         * Delete all contents stored in the file system.\n         */\n        empty(cb) {\n            if (this._cache) {\n                this._cache.removeAll();\n            }\n            this.store.clear((e) => {\n                if (noError(e, cb)) {\n                    // INVARIANT: Root always exists.\n                    this.makeRootDirectory(cb);\n                }\n            });\n        }\n        rename(oldPath, newPath, cb) {\n            // TODO: Make rename compatible with the cache.\n            if (this._cache) {\n                // Clear and disable cache during renaming process.\n                const c = this._cache;\n                this._cache = null;\n                c.removeAll();\n                const oldCb = cb;\n                cb = (e) => {\n                    // Restore empty cache.\n                    this._cache = c;\n                    oldCb(e);\n                };\n            }\n            const tx = this.store.beginTransaction('readwrite');\n            const oldParent = path.dirname(oldPath), oldName = path.basename(oldPath);\n            const newParent = path.dirname(newPath), newName = path.basename(newPath);\n            const inodes = {};\n            const lists = {};\n            let errorOccurred = false;\n            // Invariant: Can't move a folder inside itself.\n            // This funny little hack ensures that the check passes only if oldPath\n            // is a subpath of newParent. We append '/' to avoid matching folders that\n            // are a substring of the bottom-most folder in the path.\n            if ((newParent + '/').indexOf(oldPath + '/') === 0) {\n                return cb(new ApiError(ErrorCode.EBUSY, oldParent));\n            }\n            /**\n             * Responsible for Phase 2 of the rename operation: Modifying and\n             * committing the directory listings. Called once we have successfully\n             * retrieved both the old and new parent's inodes and listings.\n             */\n            const theOleSwitcharoo = () => {\n                // Sanity check: Ensure both paths are present, and no error has occurred.\n                if (errorOccurred || !lists.hasOwnProperty(oldParent) || !lists.hasOwnProperty(newParent)) {\n                    return;\n                }\n                const oldParentList = lists[oldParent], oldParentINode = inodes[oldParent], newParentList = lists[newParent], newParentINode = inodes[newParent];\n                // Delete file from old parent.\n                if (!oldParentList[oldName]) {\n                    cb(ApiError.ENOENT(oldPath));\n                }\n                else {\n                    const fileId = oldParentList[oldName];\n                    delete oldParentList[oldName];\n                    // Finishes off the renaming process by adding the file to the new\n                    // parent.\n                    const completeRename = () => {\n                        newParentList[newName] = fileId;\n                        // Commit old parent's list.\n                        tx.put(oldParentINode.id, Buffer.from(JSON.stringify(oldParentList)), true, (e) => {\n                            if (noErrorTx(e, tx, cb)) {\n                                if (oldParent === newParent) {\n                                    // DONE!\n                                    tx.commit(cb);\n                                }\n                                else {\n                                    // Commit new parent's list.\n                                    tx.put(newParentINode.id, Buffer.from(JSON.stringify(newParentList)), true, (e) => {\n                                        if (noErrorTx(e, tx, cb)) {\n                                            tx.commit(cb);\n                                        }\n                                    });\n                                }\n                            }\n                        });\n                    };\n                    if (newParentList[newName]) {\n                        // 'newPath' already exists. Check if it's a file or a directory, and\n                        // act accordingly.\n                        this.getINode(tx, newPath, newParentList[newName], (e, inode) => {\n                            if (noErrorTx(e, tx, cb)) {\n                                if (inode.isFile()) {\n                                    // Delete the file and continue.\n                                    tx.del(inode.id, (e) => {\n                                        if (noErrorTx(e, tx, cb)) {\n                                            tx.del(newParentList[newName], (e) => {\n                                                if (noErrorTx(e, tx, cb)) {\n                                                    completeRename();\n                                                }\n                                            });\n                                        }\n                                    });\n                                }\n                                else {\n                                    // Can't overwrite a directory using rename.\n                                    tx.abort((e) => {\n                                        cb(ApiError.EPERM(newPath));\n                                    });\n                                }\n                            }\n                        });\n                    }\n                    else {\n                        completeRename();\n                    }\n                }\n            };\n            /**\n             * Grabs a path's inode and directory listing, and shoves it into the\n             * inodes and lists hashes.\n             */\n            const processInodeAndListings = (p) => {\n                this.findINodeAndDirListing(tx, p, (e, node, dirList) => {\n                    if (e) {\n                        if (!errorOccurred) {\n                            errorOccurred = true;\n                            tx.abort(() => {\n                                cb(e);\n                            });\n                        }\n                        // If error has occurred already, just stop here.\n                    }\n                    else {\n                        inodes[p] = node;\n                        lists[p] = dirList;\n                        theOleSwitcharoo();\n                    }\n                });\n            };\n            processInodeAndListings(oldParent);\n            if (oldParent !== newParent) {\n                processInodeAndListings(newParent);\n            }\n        }\n        stat(p, isLstat, cb) {\n            const tx = this.store.beginTransaction('readonly');\n            this.findINode(tx, p, (e, inode) => {\n                if (noError(e, cb)) {\n                    cb(null, inode.toStats());\n                }\n            });\n        }\n        createFile(p, flag, mode, cb) {\n            const tx = this.store.beginTransaction('readwrite'), data = emptyBuffer();\n            this.commitNewFile(tx, p, FileType.FILE, mode, data, (e, newFile) => {\n                if (noError(e, cb)) {\n                    cb(null, new AsyncKeyValueFile(this, p, flag, newFile.toStats(), data));\n                }\n            });\n        }\n        openFile(p, flag, cb) {\n            const tx = this.store.beginTransaction('readonly');\n            // Step 1: Grab the file's inode.\n            this.findINode(tx, p, (e, inode) => {\n                if (noError(e, cb)) {\n                    // Step 2: Grab the file's data.\n                    tx.get(inode.id, (e, data) => {\n                        if (noError(e, cb)) {\n                            if (data === undefined) {\n                                cb(ApiError.ENOENT(p));\n                            }\n                            else {\n                                cb(null, new AsyncKeyValueFile(this, p, flag, inode.toStats(), data));\n                            }\n                        }\n                    });\n                }\n            });\n        }\n        unlink(p, cb) {\n            this.removeEntry(p, false, cb);\n        }\n        rmdir(p, cb) {\n            // Check first if directory is empty.\n            this.readdir(p, (err, files) => {\n                if (err) {\n                    cb(err);\n                }\n                else if (files.length > 0) {\n                    cb(ApiError.ENOTEMPTY(p));\n                }\n                else {\n                    this.removeEntry(p, true, cb);\n                }\n            });\n        }\n        mkdir(p, mode, cb) {\n            const tx = this.store.beginTransaction('readwrite'), data = Buffer.from('{}');\n            this.commitNewFile(tx, p, FileType.DIRECTORY, mode, data, cb);\n        }\n        readdir(p, cb) {\n            const tx = this.store.beginTransaction('readonly');\n            this.findINode(tx, p, (e, inode) => {\n                if (noError(e, cb)) {\n                    this.getDirListing(tx, p, inode, (e, dirListing) => {\n                        if (noError(e, cb)) {\n                            cb(null, Object.keys(dirListing));\n                        }\n                    });\n                }\n            });\n        }\n        _sync(p, data, stats, cb) {\n            // @todo Ensure mtime updates properly, and use that to determine if a data\n            //       update is required.\n            const tx = this.store.beginTransaction('readwrite');\n            // Step 1: Get the file node's ID.\n            this._findINode(tx, path.dirname(p), path.basename(p), (e, fileInodeId) => {\n                if (noErrorTx(e, tx, cb)) {\n                    // Step 2: Get the file inode.\n                    this.getINode(tx, p, fileInodeId, (e, fileInode) => {\n                        if (noErrorTx(e, tx, cb)) {\n                            const inodeChanged = fileInode.update(stats);\n                            // Step 3: Sync the data.\n                            tx.put(fileInode.id, data, true, (e) => {\n                                if (noErrorTx(e, tx, cb)) {\n                                    // Step 4: Sync the metadata (if it changed)!\n                                    if (inodeChanged) {\n                                        tx.put(fileInodeId, fileInode.toBuffer(), true, (e) => {\n                                            if (noErrorTx(e, tx, cb)) {\n                                                tx.commit(cb);\n                                            }\n                                        });\n                                    }\n                                    else {\n                                        // No need to sync metadata; return.\n                                        tx.commit(cb);\n                                    }\n                                }\n                            });\n                        }\n                    });\n                }\n            });\n        }\n        /**\n         * Checks if the root directory exists. Creates it if it doesn't.\n         */\n        makeRootDirectory(cb) {\n            const tx = this.store.beginTransaction('readwrite');\n            tx.get(ROOT_NODE_ID, (e, data) => {\n                if (e || data === undefined) {\n                    // Create new inode.\n                    const currTime = (new Date()).getTime(), \n                    // Mode 0666\n                    dirInode = new Inode(GenerateRandomID(), 4096, 511 | FileType.DIRECTORY, currTime, currTime, currTime);\n                    // If the root doesn't exist, the first random ID shouldn't exist,\n                    // either.\n                    tx.put(dirInode.id, getEmptyDirNode(), false, (e) => {\n                        if (noErrorTx(e, tx, cb)) {\n                            tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false, (e) => {\n                                if (e) {\n                                    tx.abort(() => { cb(e); });\n                                }\n                                else {\n                                    tx.commit(cb);\n                                }\n                            });\n                        }\n                    });\n                }\n                else {\n                    // We're good.\n                    tx.commit(cb);\n                }\n            });\n        }\n        /**\n         * Helper function for findINode.\n         * @param parent The parent directory of the file we are attempting to find.\n         * @param filename The filename of the inode we are attempting to find, minus\n         *   the parent.\n         * @param cb Passed an error or the ID of the file's inode in the file system.\n         */\n        _findINode(tx, parent, filename, cb) {\n            if (this._cache) {\n                const id = this._cache.get(path.join(parent, filename));\n                if (id) {\n                    return cb(null, id);\n                }\n            }\n            const handleDirectoryListings = (e, inode, dirList) => {\n                if (e) {\n                    cb(e);\n                }\n                else if (dirList[filename]) {\n                    const id = dirList[filename];\n                    if (this._cache) {\n                        this._cache.set(path.join(parent, filename), id);\n                    }\n                    cb(null, id);\n                }\n                else {\n                    cb(ApiError.ENOENT(path.resolve(parent, filename)));\n                }\n            };\n            if (parent === '/') {\n                if (filename === '') {\n                    // BASE CASE #1: Return the root's ID.\n                    if (this._cache) {\n                        this._cache.set(path.join(parent, filename), ROOT_NODE_ID);\n                    }\n                    cb(null, ROOT_NODE_ID);\n                }\n                else {\n                    // BASE CASE #2: Find the item in the root node.\n                    this.getINode(tx, parent, ROOT_NODE_ID, (e, inode) => {\n                        if (noError(e, cb)) {\n                            this.getDirListing(tx, parent, inode, (e, dirList) => {\n                                // handle_directory_listings will handle e for us.\n                                handleDirectoryListings(e, inode, dirList);\n                            });\n                        }\n                    });\n                }\n            }\n            else {\n                // Get the parent directory's INode, and find the file in its directory\n                // listing.\n                this.findINodeAndDirListing(tx, parent, handleDirectoryListings);\n            }\n        }\n        /**\n         * Finds the Inode of the given path.\n         * @param p The path to look up.\n         * @param cb Passed an error or the Inode of the path p.\n         * @todo memoize/cache\n         */\n        findINode(tx, p, cb) {\n            this._findINode(tx, path.dirname(p), path.basename(p), (e, id) => {\n                if (noError(e, cb)) {\n                    this.getINode(tx, p, id, cb);\n                }\n            });\n        }\n        /**\n         * Given the ID of a node, retrieves the corresponding Inode.\n         * @param tx The transaction to use.\n         * @param p The corresponding path to the file (used for error messages).\n         * @param id The ID to look up.\n         * @param cb Passed an error or the inode under the given id.\n         */\n        getINode(tx, p, id, cb) {\n            tx.get(id, (e, data) => {\n                if (noError(e, cb)) {\n                    if (data === undefined) {\n                        cb(ApiError.ENOENT(p));\n                    }\n                    else {\n                        cb(null, Inode.fromBuffer(data));\n                    }\n                }\n            });\n        }\n        /**\n         * Given the Inode of a directory, retrieves the corresponding directory\n         * listing.\n         */\n        getDirListing(tx, p, inode, cb) {\n            if (!inode.isDirectory()) {\n                cb(ApiError.ENOTDIR(p));\n            }\n            else {\n                tx.get(inode.id, (e, data) => {\n                    if (noError(e, cb)) {\n                        try {\n                            cb(null, JSON.parse(data.toString()));\n                        }\n                        catch (e) {\n                            // Occurs when data is undefined, or corresponds to something other\n                            // than a directory listing. The latter should never occur unless\n                            // the file system is corrupted.\n                            cb(ApiError.ENOENT(p));\n                        }\n                    }\n                });\n            }\n        }\n        /**\n         * Given a path to a directory, retrieves the corresponding INode and\n         * directory listing.\n         */\n        findINodeAndDirListing(tx, p, cb) {\n            this.findINode(tx, p, (e, inode) => {\n                if (noError(e, cb)) {\n                    this.getDirListing(tx, p, inode, (e, listing) => {\n                        if (noError(e, cb)) {\n                            cb(null, inode, listing);\n                        }\n                    });\n                }\n            });\n        }\n        /**\n         * Adds a new node under a random ID. Retries 5 times before giving up in\n         * the exceedingly unlikely chance that we try to reuse a random GUID.\n         * @param cb Passed an error or the GUID that the data was stored under.\n         */\n        addNewNode(tx, data, cb) {\n            let retries = 0, currId;\n            const reroll = () => {\n                if (++retries === 5) {\n                    // Max retries hit. Return with an error.\n                    cb(new ApiError(ErrorCode.EIO, 'Unable to commit data to key-value store.'));\n                }\n                else {\n                    // Try again.\n                    currId = GenerateRandomID();\n                    tx.put(currId, data, false, (e, committed) => {\n                        if (e || !committed) {\n                            reroll();\n                        }\n                        else {\n                            // Successfully stored under 'currId'.\n                            cb(null, currId);\n                        }\n                    });\n                }\n            };\n            reroll();\n        }\n        /**\n         * Commits a new file (well, a FILE or a DIRECTORY) to the file system with\n         * the given mode.\n         * Note: This will commit the transaction.\n         * @param p The path to the new file.\n         * @param type The type of the new file.\n         * @param mode The mode to create the new file with.\n         * @param data The data to store at the file's data node.\n         * @param cb Passed an error or the Inode for the new file.\n         */\n        commitNewFile(tx, p, type, mode, data, cb) {\n            const parentDir = path.dirname(p), fname = path.basename(p), currTime = (new Date()).getTime();\n            // Invariant: The root always exists.\n            // If we don't check this prior to taking steps below, we will create a\n            // file with name '' in root should p == '/'.\n            if (p === '/') {\n                return cb(ApiError.EEXIST(p));\n            }\n            // Let's build a pyramid of code!\n            // Step 1: Get the parent directory's inode and directory listing\n            this.findINodeAndDirListing(tx, parentDir, (e, parentNode, dirListing) => {\n                if (noErrorTx(e, tx, cb)) {\n                    if (dirListing[fname]) {\n                        // File already exists.\n                        tx.abort(() => {\n                            cb(ApiError.EEXIST(p));\n                        });\n                    }\n                    else {\n                        // Step 2: Commit data to store.\n                        this.addNewNode(tx, data, (e, dataId) => {\n                            if (noErrorTx(e, tx, cb)) {\n                                // Step 3: Commit the file's inode to the store.\n                                const fileInode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);\n                                this.addNewNode(tx, fileInode.toBuffer(), (e, fileInodeId) => {\n                                    if (noErrorTx(e, tx, cb)) {\n                                        // Step 4: Update parent directory's listing.\n                                        dirListing[fname] = fileInodeId;\n                                        tx.put(parentNode.id, Buffer.from(JSON.stringify(dirListing)), true, (e) => {\n                                            if (noErrorTx(e, tx, cb)) {\n                                                // Step 5: Commit and return the new inode.\n                                                tx.commit((e) => {\n                                                    if (noErrorTx(e, tx, cb)) {\n                                                        cb(null, fileInode);\n                                                    }\n                                                });\n                                            }\n                                        });\n                                    }\n                                });\n                            }\n                        });\n                    }\n                }\n            });\n        }\n        /**\n         * Remove all traces of the given path from the file system.\n         * @param p The path to remove from the file system.\n         * @param isDir Does the path belong to a directory, or a file?\n         * @todo Update mtime.\n         */\n        removeEntry(p, isDir, cb) {\n            // Eagerly delete from cache (harmless even if removal fails)\n            if (this._cache) {\n                this._cache.remove(p);\n            }\n            const tx = this.store.beginTransaction('readwrite'), parent = path.dirname(p), fileName = path.basename(p);\n            // Step 1: Get parent directory's node and directory listing.\n            this.findINodeAndDirListing(tx, parent, (e, parentNode, parentListing) => {\n                if (noErrorTx(e, tx, cb)) {\n                    if (!parentListing[fileName]) {\n                        tx.abort(() => {\n                            cb(ApiError.ENOENT(p));\n                        });\n                    }\n                    else {\n                        // Remove from directory listing of parent.\n                        const fileNodeId = parentListing[fileName];\n                        delete parentListing[fileName];\n                        // Step 2: Get file inode.\n                        this.getINode(tx, p, fileNodeId, (e, fileNode) => {\n                            if (noErrorTx(e, tx, cb)) {\n                                if (!isDir && fileNode.isDirectory()) {\n                                    tx.abort(() => {\n                                        cb(ApiError.EISDIR(p));\n                                    });\n                                }\n                                else if (isDir && !fileNode.isDirectory()) {\n                                    tx.abort(() => {\n                                        cb(ApiError.ENOTDIR(p));\n                                    });\n                                }\n                                else {\n                                    // Step 3: Delete data.\n                                    tx.del(fileNode.id, (e) => {\n                                        if (noErrorTx(e, tx, cb)) {\n                                            // Step 4: Delete node.\n                                            tx.del(fileNodeId, (e) => {\n                                                if (noErrorTx(e, tx, cb)) {\n                                                    // Step 5: Update directory listing.\n                                                    tx.put(parentNode.id, Buffer.from(JSON.stringify(parentListing)), true, (e) => {\n                                                        if (noErrorTx(e, tx, cb)) {\n                                                            tx.commit(cb);\n                                                        }\n                                                    });\n                                                }\n                                            });\n                                        }\n                                    });\n                                }\n                            }\n                        });\n                    }\n                }\n            });\n        }\n    }\n\n\n    return {\n        SimpleSyncRWTransaction: SimpleSyncRWTransaction,\n        SyncKeyValueFile: SyncKeyValueFile,\n        SyncKeyValueFileSystem: SyncKeyValueFileSystem,\n        AsyncKeyValueFile: AsyncKeyValueFile,\n        AsyncKeyValueFileSystem: AsyncKeyValueFileSystem\n    };\n});\ndefine('skylark-browserfs/backend/InMemory',['../generic/key_value_filesystem'], function (key_value_filesystem) {\n    'use strict';\n\n    const { SimpleSyncRWTransaction, SyncKeyValueFileSystem } = key_value_filesystem;\n    /**\n     * A simple in-memory key-value store backed by a JavaScript object.\n     */\n    class InMemoryStore {\n        constructor() {\n            this.store = {};\n        }\n        name() { return InMemoryFileSystem.Name; }\n        clear() { this.store = {}; }\n        beginTransaction(type) {\n            return new SimpleSyncRWTransaction(this);\n        }\n        get(key) {\n            return this.store[key];\n        }\n        put(key, data, overwrite) {\n            if (!overwrite && this.store.hasOwnProperty(key)) {\n                return false;\n            }\n            this.store[key] = data;\n            return true;\n        }\n        del(key) {\n            delete this.store[key];\n        }\n    }\n    /**\n     * A simple in-memory file system backed by an InMemoryStore.\n     * Files are not persisted across page loads.\n     */\n    class InMemoryFileSystem extends SyncKeyValueFileSystem {\n        constructor() {\n            super({ store: new InMemoryStore() });\n        }\n        /**\n         * Creates an InMemoryFileSystem instance.\n         */\n        static Create(options, cb) {\n            cb(null, new InMemoryFileSystem());\n        }\n    }\n    InMemoryFileSystem.Name = \"InMemory\";\n    InMemoryFileSystem.Options = {};\n\n    InMemoryFileSystem.InMemoryStore = InMemoryStore;\n\n    return InMemoryFileSystem;\n});\ndefine('skylark-browserfs/backend/IndexedDB',[\n    '../generic/key_value_filesystem',\n    '../core/api_error',\n    '../core/global',\n    '../core/util'\n], function (key_value_filesystem, api_error, global, util) {\n    'use strict';\n    const { AsyncKeyValueFileSystem } =  key_value_filesystem;\n    const { ApiError, ErrorCode }  = api_error;\n    const { arrayBuffer2Buffer, buffer2ArrayBuffer }  = util;\n\n    /**\n     * Get the indexedDB constructor for the current browser.\n     * @hidden\n     */\n    const indexedDB = global.indexedDB ||\n        global.mozIndexedDB ||\n        global.webkitIndexedDB ||\n        global.msIndexedDB;\n    /**\n     * Converts a DOMException or a DOMError from an IndexedDB event into a\n     * standardized BrowserFS API error.\n     * @hidden\n     */\n    function convertError(e, message = e.toString()) {\n        switch (e.name) {\n            case \"NotFoundError\":\n                return new ApiError(ErrorCode.ENOENT, message);\n            case \"QuotaExceededError\":\n                return new ApiError(ErrorCode.ENOSPC, message);\n            default:\n                // The rest do not seem to map cleanly to standard error codes.\n                return new ApiError(ErrorCode.EIO, message);\n        }\n    }\n    /**\n     * Produces a new onerror handler for IDB. Our errors are always fatal, so we\n     * handle them generically: Call the user-supplied callback with a translated\n     * version of the error, and let the error bubble up.\n     * @hidden\n     */\n    function onErrorHandler(cb, code = ErrorCode.EIO, message = null) {\n        return function (e) {\n            // Prevent the error from canceling the transaction.\n            e.preventDefault();\n            cb(new ApiError(code, message !== null ? message : undefined));\n        };\n    }\n    /**\n     * @hidden\n     */\n    class IndexedDBROTransaction {\n        constructor(tx, store) {\n            this.tx = tx;\n            this.store = store;\n        }\n        get(key, cb) {\n            try {\n                const r = this.store.get(key);\n                r.onerror = onErrorHandler(cb);\n                r.onsuccess = (event) => {\n                    // IDB returns the value 'undefined' when you try to get keys that\n                    // don't exist. The caller expects this behavior.\n                    const result = event.target.result;\n                    if (result === undefined) {\n                        cb(null, result);\n                    }\n                    else {\n                        // IDB data is stored as an ArrayBuffer\n                        cb(null, arrayBuffer2Buffer(result));\n                    }\n                };\n            }\n            catch (e) {\n                cb(convertError(e));\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    class IndexedDBRWTransaction extends IndexedDBROTransaction {\n        constructor(tx, store) {\n            super(tx, store);\n        }\n        put(key, data, overwrite, cb) {\n            try {\n                const arraybuffer = buffer2ArrayBuffer(data);\n                let r;\n                // Note: 'add' will never overwrite an existing key.\n                r = overwrite ? this.store.put(arraybuffer, key) : this.store.add(arraybuffer, key);\n                // XXX: NEED TO RETURN FALSE WHEN ADD HAS A KEY CONFLICT. NO ERROR.\n                r.onerror = onErrorHandler(cb);\n                r.onsuccess = (event) => {\n                    cb(null, true);\n                };\n            }\n            catch (e) {\n                cb(convertError(e));\n            }\n        }\n        del(key, cb) {\n            try {\n                // NOTE: IE8 has a bug with identifiers named 'delete' unless used as a string\n                // like this.\n                // http://stackoverflow.com/a/26479152\n                const r = this.store['delete'](key);\n                r.onerror = onErrorHandler(cb);\n                r.onsuccess = (event) => {\n                    cb();\n                };\n            }\n            catch (e) {\n                cb(convertError(e));\n            }\n        }\n        commit(cb) {\n            // Return to the event loop to commit the transaction.\n            setTimeout(cb, 0);\n        }\n        abort(cb) {\n            let _e = null;\n            try {\n                this.tx.abort();\n            }\n            catch (e) {\n                _e = convertError(e);\n            }\n            finally {\n                cb(_e);\n            }\n        }\n    }\n    class IndexedDBStore {\n        constructor(db, storeName) {\n            this.db = db;\n            this.storeName = storeName;\n        }\n        static Create(storeName, cb) {\n            const openReq = indexedDB.open(storeName, 1);\n            openReq.onupgradeneeded = (event) => {\n                const db = event.target.result;\n                // Huh. This should never happen; we're at version 1. Why does another\n                // database exist?\n                if (db.objectStoreNames.contains(storeName)) {\n                    db.deleteObjectStore(storeName);\n                }\n                db.createObjectStore(storeName);\n            };\n            openReq.onsuccess = (event) => {\n                cb(null, new IndexedDBStore(event.target.result, storeName));\n            };\n            openReq.onerror = onErrorHandler(cb, ErrorCode.EACCES);\n        }\n        name() {\n            return IndexedDBFileSystem.Name + \" - \" + this.storeName;\n        }\n        clear(cb) {\n            try {\n                const tx = this.db.transaction(this.storeName, 'readwrite'), objectStore = tx.objectStore(this.storeName), r = objectStore.clear();\n                r.onsuccess = (event) => {\n                    // Use setTimeout to commit transaction.\n                    setTimeout(cb, 0);\n                };\n                r.onerror = onErrorHandler(cb);\n            }\n            catch (e) {\n                cb(convertError(e));\n            }\n        }\n        beginTransaction(type = 'readonly') {\n            const tx = this.db.transaction(this.storeName, type), objectStore = tx.objectStore(this.storeName);\n            if (type === 'readwrite') {\n                return new IndexedDBRWTransaction(tx, objectStore);\n            }\n            else if (type === 'readonly') {\n                return new IndexedDBROTransaction(tx, objectStore);\n            }\n            else {\n                throw new ApiError(ErrorCode.EINVAL, 'Invalid transaction type.');\n            }\n        }\n    }\n    /**\n     * A file system that uses the IndexedDB key value file system.\n     */\n    class IndexedDBFileSystem extends AsyncKeyValueFileSystem {\n        constructor(cacheSize) {\n            super(cacheSize);\n        }\n        /**\n         * Constructs an IndexedDB file system with the given options.\n         */\n        static Create(opts = {}, cb) {\n            IndexedDBStore.Create(opts.storeName ? opts.storeName : 'browserfs', (e, store) => {\n                if (store) {\n                    const idbfs = new IndexedDBFileSystem(typeof (opts.cacheSize) === 'number' ? opts.cacheSize : 100);\n                    idbfs.init(store, (e) => {\n                        if (e) {\n                            cb(e);\n                        }\n                        else {\n                            cb(null, idbfs);\n                        }\n                    });\n                }\n                else {\n                    cb(e);\n                }\n            });\n        }\n        static isAvailable() {\n            // In Safari's private browsing mode, indexedDB.open returns NULL.\n            // In Firefox, it throws an exception.\n            // In Chrome, it \"just works\", and clears the database when you leave the page.\n            // Untested: Opera, IE.\n            try {\n                return typeof indexedDB !== 'undefined' && null !== indexedDB.open(\"__browserfs_test__\");\n            }\n            catch (e) {\n                return false;\n            }\n        }\n    }\n    IndexedDBFileSystem.Name = \"IndexedDB\";\n    IndexedDBFileSystem.Options = {\n        storeName: {\n            type: \"string\",\n            optional: true,\n            description: \"The name of this file system. You can have multiple IndexedDB file systems operating at once, but each must have a different name.\"\n        },\n        cacheSize: {\n            type: \"number\",\n            optional: true,\n            description: \"The size of the inode cache. Defaults to 100. A size of 0 or below disables caching.\"\n        }\n    };\n\n\n    IndexedDBFileSystem.IndexedDBROTransaction = IndexedDBROTransaction;\n    IndexedDBFileSystem.IndexedDBRWTransaction = IndexedDBRWTransaction;\n    IndexedDBFileSystem.IndexedDBStore = IndexedDBStore;\n\n    return IndexedDBFileSystem;\n});\ndefine('skylark-browserfs/backend/LocalStorage',[\n    '../libs/buffers',\n    '../generic/key_value_filesystem',\n    '../core/api_error',\n    '../core/global'\n], function (buffers,key_value_filesystem, api_error, global) {\n    'use strict';\n\n    const { SyncKeyValueFileSystem, SimpleSyncRWTransaction } = key_value_filesystem;\n    const { ApiError, ErrorCode } = api_error;\n\n    const { Buffer} = buffers;\n\n    /**\n     * Some versions of FF and all versions of IE do not support the full range of\n     * 16-bit numbers encoded as characters, as they enforce UTF-16 restrictions.\n     * @url http://stackoverflow.com/questions/11170716/are-there-any-characters-that-are-not-allowed-in-localstorage/11173673#11173673\n     * @hidden\n     */\n    let supportsBinaryString = false, binaryEncoding;\n    try {\n        global.localStorage.setItem(\"__test__\", String.fromCharCode(0xD800));\n        supportsBinaryString = global.localStorage.getItem(\"__test__\") === String.fromCharCode(0xD800);\n    }\n    catch (e) {\n        // IE throws an exception.\n        supportsBinaryString = false;\n    }\n    binaryEncoding = supportsBinaryString ? 'binary_string' : 'binary_string_ie';\n    if (!Buffer.isEncoding(binaryEncoding)) {\n        // Fallback for non BrowserFS implementations of buffer that lack a\n        // binary_string format.\n        binaryEncoding = \"base64\";\n    }\n    /**\n     * A synchronous key-value store backed by localStorage.\n     */\n    class LocalStorageStore {\n        name() {\n            return LocalStorageFileSystem.Name;\n        }\n        clear() {\n            global.localStorage.clear();\n        }\n        beginTransaction(type) {\n            // No need to differentiate.\n            return new SimpleSyncRWTransaction(this);\n        }\n        get(key) {\n            try {\n                const data = global.localStorage.getItem(key);\n                if (data !== null) {\n                    return Buffer.from(data, binaryEncoding);\n                }\n            }\n            catch (e) {\n                // Do nothing.\n            }\n            // Key doesn't exist, or a failure occurred.\n            return undefined;\n        }\n        put(key, data, overwrite) {\n            try {\n                if (!overwrite && global.localStorage.getItem(key) !== null) {\n                    // Don't want to overwrite the key!\n                    return false;\n                }\n                global.localStorage.setItem(key, data.toString(binaryEncoding));\n                return true;\n            }\n            catch (e) {\n                throw new ApiError(ErrorCode.ENOSPC, \"LocalStorage is full.\");\n            }\n        }\n        del(key) {\n            try {\n                global.localStorage.removeItem(key);\n            }\n            catch (e) {\n                throw new ApiError(ErrorCode.EIO, \"Unable to delete key \" + key + \": \" + e);\n            }\n        }\n    }\n    /**\n     * A synchronous file system backed by localStorage. Connects our\n     * LocalStorageStore to our SyncKeyValueFileSystem.\n     */\n    class LocalStorageFileSystem extends SyncKeyValueFileSystem {\n        /**\n         * Creates a new LocalStorage file system using the contents of `localStorage`.\n         */\n        constructor() { super({ store: new LocalStorageStore() }); }\n        /**\n         * Creates a LocalStorageFileSystem instance.\n         */\n        static Create(options, cb) {\n            cb(null, new LocalStorageFileSystem());\n        }\n        static isAvailable() {\n            return typeof global.localStorage !== 'undefined';\n        }\n    }\n    LocalStorageFileSystem.Name = \"LocalStorage\";\n    LocalStorageFileSystem.Options = {};\n    \n    LocalStorageFileSystem.LocalStorageStore = LocalStorageStore;\n\n    return LocalStorageFileSystem;\n});\ndefine('skylark-browserfs/backend/MountableFileSystem',[\n    '../core/file_system',\n    './InMemory',\n    '../core/api_error',\n    '../core/node_fs',\n    '../libs/path',\n    '../core/util'\n], function (file_system, InMemory, api_error, fs, path, util) {\n    'use strict';\n    const { BaseFileSystem } = file_system;\n    const {InMemoryFileSystem}  = InMemory;\n    const { ApiError, ErrorCode }  = api_error;\n    const { mkdirpSync }  = util;\n\n    /**\n     * The MountableFileSystem allows you to mount multiple backend types or\n     * multiple instantiations of the same backend into a single file system tree.\n     * The file systems do not need to know about each other; all interactions are\n     * automatically facilitated through this interface.\n     *\n     * For example, if a file system is mounted at /mnt/blah, and a request came in\n     * for /mnt/blah/foo.txt, the file system would see a request for /foo.txt.\n     *\n     * You can mount file systems when you configure the file system:\n     * ```javascript\n     * BrowserFS.configure({\n     *   fs: \"MountableFileSystem\",\n     *   options: {\n     *     '/data': { fs: 'HTTPRequest', options: { index: \"http://mysite.com/files/index.json\" } },\n     *     '/home': { fs: 'LocalStorage' }\n     *   }\n     * }, function(e) {\n     *\n     * });\n     * ```\n     *\n     * For advanced users, you can also mount file systems *after* MFS is constructed:\n     * ```javascript\n     * BrowserFS.FileSystem.HTTPRequest.Create({\n     *   index: \"http://mysite.com/files/index.json\"\n     * }, function(e, xhrfs) {\n     *   BrowserFS.FileSystem.MountableFileSystem.Create({\n     *     '/data': xhrfs\n     *   }, function(e, mfs) {\n     *     BrowserFS.initialize(mfs);\n     *\n     *     // Added after-the-fact...\n     *     BrowserFS.FileSystem.LocalStorage.Create(function(e, lsfs) {\n     *       mfs.mount('/home', lsfs);\n     *     });\n     *   });\n     * });\n     * ```\n     *\n     * Since MountableFileSystem simply proxies requests to mounted file systems, it supports all of the operations that the mounted file systems support.\n     *\n     * With no mounted file systems, `MountableFileSystem` acts as a simple `InMemory` filesystem.\n     */\n    class MountableFileSystem extends BaseFileSystem {\n        /**\n         * Creates a new, empty MountableFileSystem.\n         */\n        constructor(rootFs) {\n            super();\n            // Contains the list of mount points in mntMap, sorted by string length in decreasing order.\n            // Ensures that we scan the most specific mount points for a match first, which lets us\n            // nest mount points.\n            this.mountList = [];\n            this.mntMap = {};\n            this.rootFs = rootFs;\n        }\n        /**\n         * Creates a MountableFileSystem instance with the given options.\n         */\n        static Create(opts, cb) {\n            InMemoryFileSystem.Create({}, (e, imfs) => {\n                if (imfs) {\n                    const fs = new MountableFileSystem(imfs);\n                    try {\n                        Object.keys(opts).forEach((mountPoint) => {\n                            fs.mount(mountPoint, opts[mountPoint]);\n                        });\n                    }\n                    catch (e) {\n                        return cb(e);\n                    }\n                    cb(null, fs);\n                }\n                else {\n                    cb(e);\n                }\n            });\n        }\n        static isAvailable() {\n            return true;\n        }\n        /**\n         * Mounts the file system at the given mount point.\n         */\n        mount(mountPoint, fs) {\n            if (mountPoint[0] !== '/') {\n                mountPoint = `/${mountPoint}`;\n            }\n            mountPoint = path.resolve(mountPoint);\n            if (this.mntMap[mountPoint]) {\n                throw new ApiError(ErrorCode.EINVAL, \"Mount point \" + mountPoint + \" is already taken.\");\n            }\n            mkdirpSync(mountPoint, 0x1ff, this.rootFs);\n            this.mntMap[mountPoint] = fs;\n            this.mountList.push(mountPoint);\n            this.mountList = this.mountList.sort((a, b) => b.length - a.length);\n        }\n        umount(mountPoint) {\n            if (mountPoint[0] !== '/') {\n                mountPoint = `/${mountPoint}`;\n            }\n            mountPoint = path.resolve(mountPoint);\n            if (!this.mntMap[mountPoint]) {\n                throw new ApiError(ErrorCode.EINVAL, \"Mount point \" + mountPoint + \" is already unmounted.\");\n            }\n            delete this.mntMap[mountPoint];\n            this.mountList.splice(this.mountList.indexOf(mountPoint), 1);\n            while (mountPoint !== '/') {\n                if (this.rootFs.readdirSync(mountPoint).length === 0) {\n                    this.rootFs.rmdirSync(mountPoint);\n                    mountPoint = path.dirname(mountPoint);\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        /**\n         * Returns the file system that the path points to.\n         */\n        _getFs(path) {\n            const mountList = this.mountList, len = mountList.length;\n            for (let i = 0; i < len; i++) {\n                const mountPoint = mountList[i];\n                // We know path is normalized, so it is a substring of the mount point.\n                if (mountPoint.length <= path.length && path.indexOf(mountPoint) === 0) {\n                    path = path.substr(mountPoint.length > 1 ? mountPoint.length : 0);\n                    if (path === '') {\n                        path = '/';\n                    }\n                    return { fs: this.mntMap[mountPoint], path: path, mountPoint: mountPoint };\n                }\n            }\n            // Query our root file system.\n            return { fs: this.rootFs, path: path, mountPoint: '/' };\n        }\n        // Global information methods\n        getName() {\n            return MountableFileSystem.Name;\n        }\n        diskSpace(path, cb) {\n            cb(0, 0);\n        }\n        isReadOnly() {\n            return false;\n        }\n        supportsLinks() {\n            // I'm not ready for cross-FS links yet.\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            return true;\n        }\n        /**\n         * Fixes up error messages so they mention the mounted file location relative\n         * to the MFS root, not to the particular FS's root.\n         * Mutates the input error, and returns it.\n         */\n        standardizeError(err, path, realPath) {\n            const index = err.message.indexOf(path);\n            if (index !== -1) {\n                err.message = err.message.substr(0, index) + realPath + err.message.substr(index + path.length);\n                err.path = realPath;\n            }\n            return err;\n        }\n        // The following methods involve multiple file systems, and thus have custom\n        // logic.\n        // Note that we go through the Node API to use its robust default argument\n        // processing.\n        rename(oldPath, newPath, cb) {\n            // Scenario 1: old and new are on same FS.\n            const fs1rv = this._getFs(oldPath);\n            const fs2rv = this._getFs(newPath);\n            if (fs1rv.fs === fs2rv.fs) {\n                return fs1rv.fs.rename(fs1rv.path, fs2rv.path, (e) => {\n                    if (e) {\n                        this.standardizeError(this.standardizeError(e, fs1rv.path, oldPath), fs2rv.path, newPath);\n                    }\n                    cb(e);\n                });\n            }\n            // Scenario 2: Different file systems.\n            // Read old file, write new file, delete old file.\n            return fs.readFile(oldPath, function (err, data) {\n                if (err) {\n                    return cb(err);\n                }\n                fs.writeFile(newPath, data, function (err) {\n                    if (err) {\n                        return cb(err);\n                    }\n                    fs.unlink(oldPath, cb);\n                });\n            });\n        }\n        renameSync(oldPath, newPath) {\n            // Scenario 1: old and new are on same FS.\n            const fs1rv = this._getFs(oldPath);\n            const fs2rv = this._getFs(newPath);\n            if (fs1rv.fs === fs2rv.fs) {\n                try {\n                    return fs1rv.fs.renameSync(fs1rv.path, fs2rv.path);\n                }\n                catch (e) {\n                    this.standardizeError(this.standardizeError(e, fs1rv.path, oldPath), fs2rv.path, newPath);\n                    throw e;\n                }\n            }\n            // Scenario 2: Different file systems.\n            const data = fs.readFileSync(oldPath);\n            fs.writeFileSync(newPath, data);\n            return fs.unlinkSync(oldPath);\n        }\n        readdirSync(p) {\n            const fsInfo = this._getFs(p);\n            // If null, rootfs did not have the directory\n            // (or the target FS is the root fs).\n            let rv = null;\n            // Mount points are all defined in the root FS.\n            // Ensure that we list those, too.\n            if (fsInfo.fs !== this.rootFs) {\n                try {\n                    rv = this.rootFs.readdirSync(p);\n                }\n                catch (e) {\n                    // Ignore.\n                }\n            }\n            try {\n                const rv2 = fsInfo.fs.readdirSync(fsInfo.path);\n                if (rv === null) {\n                    return rv2;\n                }\n                else {\n                    // Filter out duplicates.\n                    return rv2.concat(rv.filter((val) => rv2.indexOf(val) === -1));\n                }\n            }\n            catch (e) {\n                if (rv === null) {\n                    throw this.standardizeError(e, fsInfo.path, p);\n                }\n                else {\n                    // The root FS had something.\n                    return rv;\n                }\n            }\n        }\n        readdir(p, cb) {\n            const fsInfo = this._getFs(p);\n            fsInfo.fs.readdir(fsInfo.path, (err, files) => {\n                if (fsInfo.fs !== this.rootFs) {\n                    try {\n                        const rv = this.rootFs.readdirSync(p);\n                        if (files) {\n                            // Filter out duplicates.\n                            files = files.concat(rv.filter((val) => files.indexOf(val) === -1));\n                        }\n                        else {\n                            files = rv;\n                        }\n                    }\n                    catch (e) {\n                        // Root FS and target FS did not have directory.\n                        if (err) {\n                            return cb(this.standardizeError(err, fsInfo.path, p));\n                        }\n                    }\n                }\n                else if (err) {\n                    // Root FS and target FS are the same, and did not have directory.\n                    return cb(this.standardizeError(err, fsInfo.path, p));\n                }\n                cb(null, files);\n            });\n        }\n        realpathSync(p, cache) {\n            const fsInfo = this._getFs(p);\n            try {\n                const mountedPath = fsInfo.fs.realpathSync(fsInfo.path, {});\n                // resolve is there to remove any trailing slash that may be present\n                return path.resolve(path.join(fsInfo.mountPoint, mountedPath));\n            }\n            catch (e) {\n                throw this.standardizeError(e, fsInfo.path, p);\n            }\n        }\n        realpath(p, cache, cb) {\n            const fsInfo = this._getFs(p);\n            fsInfo.fs.realpath(fsInfo.path, {}, (err, rv) => {\n                if (err) {\n                    cb(this.standardizeError(err, fsInfo.path, p));\n                }\n                else {\n                    // resolve is there to remove any trailing slash that may be present\n                    cb(null, path.resolve(path.join(fsInfo.mountPoint, rv)));\n                }\n            });\n        }\n        rmdirSync(p) {\n            const fsInfo = this._getFs(p);\n            if (this._containsMountPt(p)) {\n                throw ApiError.ENOTEMPTY(p);\n            }\n            else {\n                try {\n                    fsInfo.fs.rmdirSync(fsInfo.path);\n                }\n                catch (e) {\n                    throw this.standardizeError(e, fsInfo.path, p);\n                }\n            }\n        }\n        rmdir(p, cb) {\n            const fsInfo = this._getFs(p);\n            if (this._containsMountPt(p)) {\n                cb(ApiError.ENOTEMPTY(p));\n            }\n            else {\n                fsInfo.fs.rmdir(fsInfo.path, (err) => {\n                    cb(err ? this.standardizeError(err, fsInfo.path, p) : null);\n                });\n            }\n        }\n        /**\n         * Returns true if the given path contains a mount point.\n         */\n        _containsMountPt(p) {\n            const mountPoints = this.mountList, len = mountPoints.length;\n            for (let i = 0; i < len; i++) {\n                const pt = mountPoints[i];\n                if (pt.length >= p.length && pt.slice(0, p.length) === p) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n    MountableFileSystem.Name = \"MountableFileSystem\";\n    MountableFileSystem.Options = {};\n    /**\n     * Tricky: Define all of the functions that merely forward arguments to the\n     * relevant file system, or return/throw an error.\n     * Take advantage of the fact that the *first* argument is always the path, and\n     * the *last* is the callback function (if async).\n     * @todo Can use numArgs to make proxying more efficient.\n     * @hidden\n     */\n    function defineFcn(name, isSync, numArgs) {\n        if (isSync) {\n            return function (...args) {\n                const path = args[0];\n                const rv = this._getFs(path);\n                args[0] = rv.path;\n                try {\n                    return rv.fs[name].apply(rv.fs, args);\n                }\n                catch (e) {\n                    this.standardizeError(e, rv.path, path);\n                    throw e;\n                }\n            };\n        }\n        else {\n            return function (...args) {\n                const path = args[0];\n                const rv = this._getFs(path);\n                args[0] = rv.path;\n                if (typeof args[args.length - 1] === 'function') {\n                    const cb = args[args.length - 1];\n                    args[args.length - 1] = (...args) => {\n                        if (args.length > 0 && args[0] instanceof ApiError) {\n                            this.standardizeError(args[0], rv.path, path);\n                        }\n                        cb.apply(null, args);\n                    };\n                }\n                return rv.fs[name].apply(rv.fs, args);\n            };\n        }\n    }\n    /**\n     * @hidden\n     */\n    const fsCmdMap = [\n        // 1 arg functions\n        ['exists', 'unlink', 'readlink'],\n        // 2 arg functions\n        ['stat', 'mkdir', 'truncate'],\n        // 3 arg functions\n        ['open', 'readFile', 'chmod', 'utimes'],\n        // 4 arg functions\n        ['chown'],\n        // 5 arg functions\n        ['writeFile', 'appendFile']\n    ];\n    for (let i = 0; i < fsCmdMap.length; i++) {\n        const cmds = fsCmdMap[i];\n        for (const fnName of cmds) {\n            MountableFileSystem.prototype[fnName] = defineFcn(fnName, false, i + 1);\n            MountableFileSystem.prototype[fnName + 'Sync'] = defineFcn(fnName + 'Sync', true, i + 1);\n        }\n    }\n\n\n    return MountableFileSystem;\n});\ndefine('skylark-browserfs/generic/mutex',['../generic/setImmediate'], function (setImmediate) {\n    'use strict';\n    /**\n     * Non-recursive mutex\n     * @hidden\n     */\n    class Mutex {\n        constructor() {\n            this._locked = false;\n            this._waiters = [];\n        }\n        lock(cb) {\n            if (this._locked) {\n                this._waiters.push(cb);\n                return;\n            }\n            this._locked = true;\n            cb();\n        }\n        unlock() {\n            if (!this._locked) {\n                throw new Error('unlock of a non-locked mutex');\n            }\n            const next = this._waiters.shift();\n            // don't unlock - we want to queue up next for the\n            // _end_ of the current task execution, but we don't\n            // want it to be called inline with whatever the\n            // current stack is.  This way we still get the nice\n            // behavior that an unlock immediately followed by a\n            // lock won't cause starvation.\n            if (next) {\n                setImmediate(next);\n                return;\n            }\n            this._locked = false;\n        }\n        tryLock() {\n            if (this._locked) {\n                return false;\n            }\n            this._locked = true;\n            return true;\n        }\n        isLocked() {\n            return this._locked;\n        }\n    }\n\n    return Mutex;\n});\ndefine('skylark-browserfs/generic/locked_fs',['./mutex'], function (Mutex) {\n    'use strict';\n    /**\n     * This class serializes access to an underlying async filesystem.\n     * For example, on an OverlayFS instance with an async lower\n     * directory operations like rename and rmdir may involve multiple\n     * requests involving both the upper and lower filesystems -- they\n     * are not executed in a single atomic step.  OverlayFS uses this\n     * LockedFS to avoid having to reason about the correctness of\n     * multiple requests interleaving.\n     */\n    class LockedFS {\n        constructor(fs) {\n            this._fs = fs;\n            this._mu = new Mutex();\n        }\n        getName() {\n            return 'LockedFS<' + this._fs.getName() + '>';\n        }\n        getFSUnlocked() {\n            return this._fs;\n        }\n        diskSpace(p, cb) {\n            // FIXME: should this lock?\n            this._fs.diskSpace(p, cb);\n        }\n        isReadOnly() {\n            return this._fs.isReadOnly();\n        }\n        supportsLinks() {\n            return this._fs.supportsLinks();\n        }\n        supportsProps() {\n            return this._fs.supportsProps();\n        }\n        supportsSynch() {\n            return this._fs.supportsSynch();\n        }\n        rename(oldPath, newPath, cb) {\n            this._mu.lock(() => {\n                this._fs.rename(oldPath, newPath, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        renameSync(oldPath, newPath) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.renameSync(oldPath, newPath);\n        }\n        stat(p, isLstat, cb) {\n            this._mu.lock(() => {\n                this._fs.stat(p, isLstat, (err, stat) => {\n                    this._mu.unlock();\n                    cb(err, stat);\n                });\n            });\n        }\n        statSync(p, isLstat) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.statSync(p, isLstat);\n        }\n        open(p, flag, mode, cb) {\n            this._mu.lock(() => {\n                this._fs.open(p, flag, mode, (err, fd) => {\n                    this._mu.unlock();\n                    cb(err, fd);\n                });\n            });\n        }\n        openSync(p, flag, mode) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.openSync(p, flag, mode);\n        }\n        unlink(p, cb) {\n            this._mu.lock(() => {\n                this._fs.unlink(p, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        unlinkSync(p) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.unlinkSync(p);\n        }\n        rmdir(p, cb) {\n            this._mu.lock(() => {\n                this._fs.rmdir(p, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        rmdirSync(p) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.rmdirSync(p);\n        }\n        mkdir(p, mode, cb) {\n            this._mu.lock(() => {\n                this._fs.mkdir(p, mode, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        mkdirSync(p, mode) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.mkdirSync(p, mode);\n        }\n        readdir(p, cb) {\n            this._mu.lock(() => {\n                this._fs.readdir(p, (err, files) => {\n                    this._mu.unlock();\n                    cb(err, files);\n                });\n            });\n        }\n        readdirSync(p) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.readdirSync(p);\n        }\n        exists(p, cb) {\n            this._mu.lock(() => {\n                this._fs.exists(p, (exists) => {\n                    this._mu.unlock();\n                    cb(exists);\n                });\n            });\n        }\n        existsSync(p) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.existsSync(p);\n        }\n        realpath(p, cache, cb) {\n            this._mu.lock(() => {\n                this._fs.realpath(p, cache, (err, resolvedPath) => {\n                    this._mu.unlock();\n                    cb(err, resolvedPath);\n                });\n            });\n        }\n        realpathSync(p, cache) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.realpathSync(p, cache);\n        }\n        truncate(p, len, cb) {\n            this._mu.lock(() => {\n                this._fs.truncate(p, len, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        truncateSync(p, len) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.truncateSync(p, len);\n        }\n        readFile(fname, encoding, flag, cb) {\n            this._mu.lock(() => {\n                this._fs.readFile(fname, encoding, flag, (err, data) => {\n                    this._mu.unlock();\n                    cb(err, data);\n                });\n            });\n        }\n        readFileSync(fname, encoding, flag) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.readFileSync(fname, encoding, flag);\n        }\n        writeFile(fname, data, encoding, flag, mode, cb) {\n            this._mu.lock(() => {\n                this._fs.writeFile(fname, data, encoding, flag, mode, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        writeFileSync(fname, data, encoding, flag, mode) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.writeFileSync(fname, data, encoding, flag, mode);\n        }\n        appendFile(fname, data, encoding, flag, mode, cb) {\n            this._mu.lock(() => {\n                this._fs.appendFile(fname, data, encoding, flag, mode, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        appendFileSync(fname, data, encoding, flag, mode) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.appendFileSync(fname, data, encoding, flag, mode);\n        }\n        chmod(p, isLchmod, mode, cb) {\n            this._mu.lock(() => {\n                this._fs.chmod(p, isLchmod, mode, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        chmodSync(p, isLchmod, mode) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.chmodSync(p, isLchmod, mode);\n        }\n        chown(p, isLchown, uid, gid, cb) {\n            this._mu.lock(() => {\n                this._fs.chown(p, isLchown, uid, gid, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        chownSync(p, isLchown, uid, gid) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.chownSync(p, isLchown, uid, gid);\n        }\n        utimes(p, atime, mtime, cb) {\n            this._mu.lock(() => {\n                this._fs.utimes(p, atime, mtime, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        utimesSync(p, atime, mtime) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.utimesSync(p, atime, mtime);\n        }\n        link(srcpath, dstpath, cb) {\n            this._mu.lock(() => {\n                this._fs.link(srcpath, dstpath, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        linkSync(srcpath, dstpath) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.linkSync(srcpath, dstpath);\n        }\n        symlink(srcpath, dstpath, type, cb) {\n            this._mu.lock(() => {\n                this._fs.symlink(srcpath, dstpath, type, (err) => {\n                    this._mu.unlock();\n                    cb(err);\n                });\n            });\n        }\n        symlinkSync(srcpath, dstpath, type) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.symlinkSync(srcpath, dstpath, type);\n        }\n        readlink(p, cb) {\n            this._mu.lock(() => {\n                this._fs.readlink(p, (err, linkString) => {\n                    this._mu.unlock();\n                    cb(err, linkString);\n                });\n            });\n        }\n        readlinkSync(p) {\n            if (this._mu.isLocked()) {\n                throw new Error('invalid sync call');\n            }\n            return this._fs.readlinkSync(p);\n        }\n    }\n\n    return LockedFS;\n});\ndefine('skylark-browserfs/backend/OverlayFS',[\n    '../core/file_system',\n    '../core/api_error',\n    '../core/file_flag',\n    '../core/node_fs_stats',\n    '../generic/preload_file',\n    '../generic/locked_fs',\n    '../libs/path'\n], function (file_system, api_error, file_flag, node_fs_stats, preload_file, LockedFS, path) {\n\n    'use strict';\n\n\n    const { BaseFileSystem } = file_system;\n    const { ApiError, ErrorCode }  = api_error;\n    const { FileFlag, ActionType }  = file_flag;\n    const { Stats }  = node_fs_stats;\n    const {PreloadFile}  = preload_file;\n\n    /**\n     * @hidden\n     */\n    const deletionLogPath = '/.deletedFiles.log';\n    /**\n     * Given a read-only mode, makes it writable.\n     * @hidden\n     */\n    function makeModeWritable(mode) {\n        return 0o222 | mode;\n    }\n    /**\n     * @hidden\n     */\n    function getFlag(f) {\n        return FileFlag.getFileFlag(f);\n    }\n    /**\n     * Overlays a RO file to make it writable.\n     */\n    class OverlayFile extends PreloadFile {\n        constructor(fs, path, flag, stats, data) {\n            super(fs, path, flag, stats, data);\n        }\n        sync(cb) {\n            if (!this.isDirty()) {\n                cb(null);\n                return;\n            }\n            this._fs._syncAsync(this, (err) => {\n                this.resetDirty();\n                cb(err);\n            });\n        }\n        syncSync() {\n            if (this.isDirty()) {\n                this._fs._syncSync(this);\n                this.resetDirty();\n            }\n        }\n        close(cb) {\n            this.sync(cb);\n        }\n        closeSync() {\n            this.syncSync();\n        }\n    }\n    /**\n     * *INTERNAL, DO NOT USE DIRECTLY!*\n     *\n     * Core OverlayFS class that contains no locking whatsoever. We wrap these objects\n     * in a LockedFS to prevent races.\n     */\n    class UnlockedOverlayFS extends BaseFileSystem {\n        constructor(writable, readable) {\n            super();\n            this._isInitialized = false;\n            this._initializeCallbacks = [];\n            this._deletedFiles = {};\n            this._deleteLog = '';\n            // If 'true', we have scheduled a delete log update.\n            this._deleteLogUpdatePending = false;\n            // If 'true', a delete log update is needed after the scheduled delete log\n            // update finishes.\n            this._deleteLogUpdateNeeded = false;\n            // If there was an error updating the delete log...\n            this._deleteLogError = null;\n            this._writable = writable;\n            this._readable = readable;\n            if (this._writable.isReadOnly()) {\n                throw new ApiError(ErrorCode.EINVAL, \"Writable file system must be writable.\");\n            }\n        }\n        static isAvailable() {\n            return true;\n        }\n        getOverlayedFileSystems() {\n            return {\n                readable: this._readable,\n                writable: this._writable\n            };\n        }\n        _syncAsync(file, cb) {\n            this.createParentDirectoriesAsync(file.getPath(), (err) => {\n                if (err) {\n                    return cb(err);\n                }\n                this._writable.writeFile(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode, cb);\n            });\n        }\n        _syncSync(file) {\n            this.createParentDirectories(file.getPath());\n            this._writable.writeFileSync(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode);\n        }\n        getName() {\n            return OverlayFS.Name;\n        }\n        /**\n         * **INTERNAL METHOD**\n         *\n         * Called once to load up metadata stored on the writable file system.\n         */\n        _initialize(cb) {\n            const callbackArray = this._initializeCallbacks;\n            const end = (e) => {\n                this._isInitialized = !e;\n                this._initializeCallbacks = [];\n                callbackArray.forEach(((cb) => cb(e)));\n            };\n            // if we're already initialized, immediately invoke the callback\n            if (this._isInitialized) {\n                return cb();\n            }\n            callbackArray.push(cb);\n            // The first call to initialize initializes, the rest wait for it to complete.\n            if (callbackArray.length !== 1) {\n                return;\n            }\n            // Read deletion log, process into metadata.\n            this._writable.readFile(deletionLogPath, 'utf8', getFlag('r'), (err, data) => {\n                if (err) {\n                    // ENOENT === Newly-instantiated file system, and thus empty log.\n                    if (err.errno !== ErrorCode.ENOENT) {\n                        return end(err);\n                    }\n                }\n                else {\n                    this._deleteLog = data;\n                }\n                this._reparseDeletionLog();\n                end();\n            });\n        }\n        isReadOnly() { return false; }\n        supportsSynch() { return this._readable.supportsSynch() && this._writable.supportsSynch(); }\n        supportsLinks() { return false; }\n        supportsProps() { return this._readable.supportsProps() && this._writable.supportsProps(); }\n        getDeletionLog() {\n            return this._deleteLog;\n        }\n        restoreDeletionLog(log) {\n            this._deleteLog = log;\n            this._reparseDeletionLog();\n            this.updateLog('');\n        }\n        rename(oldPath, newPath, cb) {\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(oldPath, cb) || this.checkPathAsync(newPath, cb)) {\n                return;\n            }\n            if (oldPath === deletionLogPath || newPath === deletionLogPath) {\n                return cb(ApiError.EPERM('Cannot rename deletion log.'));\n            }\n            // nothing to do if paths match\n            if (oldPath === newPath) {\n                return cb();\n            }\n            this.stat(oldPath, false, (oldErr, oldStats) => {\n                if (oldErr) {\n                    return cb(oldErr);\n                }\n                return this.stat(newPath, false, (newErr, newStats) => {\n                    const self = this;\n                    // precondition: both oldPath and newPath exist and are dirs.\n                    // decreases: |files|\n                    // Need to move *every file/folder* currently stored on\n                    // readable to its new location on writable.\n                    function copyDirContents(files) {\n                        const file = files.shift();\n                        if (!file) {\n                            return cb();\n                        }\n                        const oldFile = path.resolve(oldPath, file);\n                        const newFile = path.resolve(newPath, file);\n                        // Recursion! Should work for any nested files / folders.\n                        self.rename(oldFile, newFile, (err) => {\n                            if (err) {\n                                return cb(err);\n                            }\n                            copyDirContents(files);\n                        });\n                    }\n                    let mode = 0o777;\n                    // from linux's rename(2) manpage: oldpath can specify a\n                    // directory.  In this case, newpath must either not exist, or\n                    // it must specify an empty directory.\n                    if (oldStats.isDirectory()) {\n                        if (newErr) {\n                            if (newErr.errno !== ErrorCode.ENOENT) {\n                                return cb(newErr);\n                            }\n                            return this._writable.exists(oldPath, (exists) => {\n                                // simple case - both old and new are on the writable layer\n                                if (exists) {\n                                    return this._writable.rename(oldPath, newPath, cb);\n                                }\n                                this._writable.mkdir(newPath, mode, (mkdirErr) => {\n                                    if (mkdirErr) {\n                                        return cb(mkdirErr);\n                                    }\n                                    this._readable.readdir(oldPath, (err, files) => {\n                                        if (err) {\n                                            return cb();\n                                        }\n                                        copyDirContents(files);\n                                    });\n                                });\n                            });\n                        }\n                        mode = newStats.mode;\n                        if (!newStats.isDirectory()) {\n                            return cb(ApiError.ENOTDIR(newPath));\n                        }\n                        this.readdir(newPath, (readdirErr, files) => {\n                            if (files && files.length) {\n                                return cb(ApiError.ENOTEMPTY(newPath));\n                            }\n                            this._readable.readdir(oldPath, (err, files) => {\n                                if (err) {\n                                    return cb();\n                                }\n                                copyDirContents(files);\n                            });\n                        });\n                    }\n                    if (newStats && newStats.isDirectory()) {\n                        return cb(ApiError.EISDIR(newPath));\n                    }\n                    this.readFile(oldPath, null, getFlag('r'), (err, data) => {\n                        if (err) {\n                            return cb(err);\n                        }\n                        return this.writeFile(newPath, data, null, getFlag('w'), oldStats.mode, (err) => {\n                            if (err) {\n                                return cb(err);\n                            }\n                            return this.unlink(oldPath, cb);\n                        });\n                    });\n                });\n            });\n        }\n        renameSync(oldPath, newPath) {\n            this.checkInitialized();\n            this.checkPath(oldPath);\n            this.checkPath(newPath);\n            if (oldPath === deletionLogPath || newPath === deletionLogPath) {\n                throw ApiError.EPERM('Cannot rename deletion log.');\n            }\n            // Write newPath using oldPath's contents, delete oldPath.\n            const oldStats = this.statSync(oldPath, false);\n            if (oldStats.isDirectory()) {\n                // Optimization: Don't bother moving if old === new.\n                if (oldPath === newPath) {\n                    return;\n                }\n                let mode = 0o777;\n                if (this.existsSync(newPath)) {\n                    const stats = this.statSync(newPath, false);\n                    mode = stats.mode;\n                    if (stats.isDirectory()) {\n                        if (this.readdirSync(newPath).length > 0) {\n                            throw ApiError.ENOTEMPTY(newPath);\n                        }\n                    }\n                    else {\n                        throw ApiError.ENOTDIR(newPath);\n                    }\n                }\n                // Take care of writable first. Move any files there, or create an empty directory\n                // if it doesn't exist.\n                if (this._writable.existsSync(oldPath)) {\n                    this._writable.renameSync(oldPath, newPath);\n                }\n                else if (!this._writable.existsSync(newPath)) {\n                    this._writable.mkdirSync(newPath, mode);\n                }\n                // Need to move *every file/folder* currently stored on readable to its new location\n                // on writable.\n                if (this._readable.existsSync(oldPath)) {\n                    this._readable.readdirSync(oldPath).forEach((name) => {\n                        // Recursion! Should work for any nested files / folders.\n                        this.renameSync(path.resolve(oldPath, name), path.resolve(newPath, name));\n                    });\n                }\n            }\n            else {\n                if (this.existsSync(newPath) && this.statSync(newPath, false).isDirectory()) {\n                    throw ApiError.EISDIR(newPath);\n                }\n                this.writeFileSync(newPath, this.readFileSync(oldPath, null, getFlag('r')), null, getFlag('w'), oldStats.mode);\n            }\n            if (oldPath !== newPath && this.existsSync(oldPath)) {\n                this.unlinkSync(oldPath);\n            }\n        }\n        stat(p, isLstat, cb) {\n            if (!this.checkInitAsync(cb)) {\n                return;\n            }\n            this._writable.stat(p, isLstat, (err, stat) => {\n                if (err && err.errno === ErrorCode.ENOENT) {\n                    if (this._deletedFiles[p]) {\n                        cb(ApiError.ENOENT(p));\n                    }\n                    this._readable.stat(p, isLstat, (err, stat) => {\n                        if (stat) {\n                            // Make the oldStat's mode writable. Preserve the topmost\n                            // part of the mode, which specifies if it is a file or a\n                            // directory.\n                            stat = Stats.clone(stat);\n                            stat.mode = makeModeWritable(stat.mode);\n                        }\n                        cb(err, stat);\n                    });\n                }\n                else {\n                    cb(err, stat);\n                }\n            });\n        }\n        statSync(p, isLstat) {\n            this.checkInitialized();\n            try {\n                return this._writable.statSync(p, isLstat);\n            }\n            catch (e) {\n                if (this._deletedFiles[p]) {\n                    throw ApiError.ENOENT(p);\n                }\n                const oldStat = Stats.clone(this._readable.statSync(p, isLstat));\n                // Make the oldStat's mode writable. Preserve the topmost part of the\n                // mode, which specifies if it is a file or a directory.\n                oldStat.mode = makeModeWritable(oldStat.mode);\n                return oldStat;\n            }\n        }\n        open(p, flag, mode, cb) {\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {\n                return;\n            }\n            this.stat(p, false, (err, stats) => {\n                if (stats) {\n                    switch (flag.pathExistsAction()) {\n                        case ActionType.TRUNCATE_FILE:\n                            return this.createParentDirectoriesAsync(p, (err) => {\n                                if (err) {\n                                    return cb(err);\n                                }\n                                this._writable.open(p, flag, mode, cb);\n                            });\n                        case ActionType.NOP:\n                            return this._writable.exists(p, (exists) => {\n                                if (exists) {\n                                    this._writable.open(p, flag, mode, cb);\n                                }\n                                else {\n                                    // at this point we know the stats object we got is from\n                                    // the readable FS.\n                                    stats = Stats.clone(stats);\n                                    stats.mode = mode;\n                                    this._readable.readFile(p, null, getFlag('r'), (readFileErr, data) => {\n                                        if (readFileErr) {\n                                            return cb(readFileErr);\n                                        }\n                                        if (stats.size === -1) {\n                                            stats.size = data.length;\n                                        }\n                                        const f = new OverlayFile(this, p, flag, stats, data);\n                                        cb(null, f);\n                                    });\n                                }\n                            });\n                        default:\n                            return cb(ApiError.EEXIST(p));\n                    }\n                }\n                else {\n                    switch (flag.pathNotExistsAction()) {\n                        case ActionType.CREATE_FILE:\n                            return this.createParentDirectoriesAsync(p, (err) => {\n                                if (err) {\n                                    return cb(err);\n                                }\n                                return this._writable.open(p, flag, mode, cb);\n                            });\n                        default:\n                            return cb(ApiError.ENOENT(p));\n                    }\n                }\n            });\n        }\n        openSync(p, flag, mode) {\n            this.checkInitialized();\n            this.checkPath(p);\n            if (p === deletionLogPath) {\n                throw ApiError.EPERM('Cannot open deletion log.');\n            }\n            if (this.existsSync(p)) {\n                switch (flag.pathExistsAction()) {\n                    case ActionType.TRUNCATE_FILE:\n                        this.createParentDirectories(p);\n                        return this._writable.openSync(p, flag, mode);\n                    case ActionType.NOP:\n                        if (this._writable.existsSync(p)) {\n                            return this._writable.openSync(p, flag, mode);\n                        }\n                        else {\n                            // Create an OverlayFile.\n                            const buf = this._readable.readFileSync(p, null, getFlag('r'));\n                            const stats = Stats.clone(this._readable.statSync(p, false));\n                            stats.mode = mode;\n                            return new OverlayFile(this, p, flag, stats, buf);\n                        }\n                    default:\n                        throw ApiError.EEXIST(p);\n                }\n            }\n            else {\n                switch (flag.pathNotExistsAction()) {\n                    case ActionType.CREATE_FILE:\n                        this.createParentDirectories(p);\n                        return this._writable.openSync(p, flag, mode);\n                    default:\n                        throw ApiError.ENOENT(p);\n                }\n            }\n        }\n        unlink(p, cb) {\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {\n                return;\n            }\n            this.exists(p, (exists) => {\n                if (!exists) {\n                    return cb(ApiError.ENOENT(p));\n                }\n                this._writable.exists(p, (writableExists) => {\n                    if (writableExists) {\n                        return this._writable.unlink(p, (err) => {\n                            if (err) {\n                                return cb(err);\n                            }\n                            this.exists(p, (readableExists) => {\n                                if (readableExists) {\n                                    this.deletePath(p);\n                                }\n                                cb(null);\n                            });\n                        });\n                    }\n                    else {\n                        // if this only exists on the readable FS, add it to the\n                        // delete map.\n                        this.deletePath(p);\n                        cb(null);\n                    }\n                });\n            });\n        }\n        unlinkSync(p) {\n            this.checkInitialized();\n            this.checkPath(p);\n            if (this.existsSync(p)) {\n                if (this._writable.existsSync(p)) {\n                    this._writable.unlinkSync(p);\n                }\n                // if it still exists add to the delete log\n                if (this.existsSync(p)) {\n                    this.deletePath(p);\n                }\n            }\n            else {\n                throw ApiError.ENOENT(p);\n            }\n        }\n        rmdir(p, cb) {\n            if (!this.checkInitAsync(cb)) {\n                return;\n            }\n            const rmdirLower = () => {\n                this.readdir(p, (err, files) => {\n                    if (err) {\n                        return cb(err);\n                    }\n                    if (files.length) {\n                        return cb(ApiError.ENOTEMPTY(p));\n                    }\n                    this.deletePath(p);\n                    cb(null);\n                });\n            };\n            this.exists(p, (exists) => {\n                if (!exists) {\n                    return cb(ApiError.ENOENT(p));\n                }\n                this._writable.exists(p, (writableExists) => {\n                    if (writableExists) {\n                        this._writable.rmdir(p, (err) => {\n                            if (err) {\n                                return cb(err);\n                            }\n                            this._readable.exists(p, (readableExists) => {\n                                if (readableExists) {\n                                    rmdirLower();\n                                }\n                                else {\n                                    cb();\n                                }\n                            });\n                        });\n                    }\n                    else {\n                        rmdirLower();\n                    }\n                });\n            });\n        }\n        rmdirSync(p) {\n            this.checkInitialized();\n            if (this.existsSync(p)) {\n                if (this._writable.existsSync(p)) {\n                    this._writable.rmdirSync(p);\n                }\n                if (this.existsSync(p)) {\n                    // Check if directory is empty.\n                    if (this.readdirSync(p).length > 0) {\n                        throw ApiError.ENOTEMPTY(p);\n                    }\n                    else {\n                        this.deletePath(p);\n                    }\n                }\n            }\n            else {\n                throw ApiError.ENOENT(p);\n            }\n        }\n        mkdir(p, mode, cb) {\n            if (!this.checkInitAsync(cb)) {\n                return;\n            }\n            this.exists(p, (exists) => {\n                if (exists) {\n                    return cb(ApiError.EEXIST(p));\n                }\n                // The below will throw should any of the parent directories\n                // fail to exist on _writable.\n                this.createParentDirectoriesAsync(p, (err) => {\n                    if (err) {\n                        return cb(err);\n                    }\n                    this._writable.mkdir(p, mode, cb);\n                });\n            });\n        }\n        mkdirSync(p, mode) {\n            this.checkInitialized();\n            if (this.existsSync(p)) {\n                throw ApiError.EEXIST(p);\n            }\n            else {\n                // The below will throw should any of the parent directories fail to exist\n                // on _writable.\n                this.createParentDirectories(p);\n                this._writable.mkdirSync(p, mode);\n            }\n        }\n        readdir(p, cb) {\n            if (!this.checkInitAsync(cb)) {\n                return;\n            }\n            this.stat(p, false, (err, dirStats) => {\n                if (err) {\n                    return cb(err);\n                }\n                if (!dirStats.isDirectory()) {\n                    return cb(ApiError.ENOTDIR(p));\n                }\n                this._writable.readdir(p, (err, wFiles) => {\n                    if (err && err.code !== 'ENOENT') {\n                        return cb(err);\n                    }\n                    else if (err || !wFiles) {\n                        wFiles = [];\n                    }\n                    this._readable.readdir(p, (err, rFiles) => {\n                        // if the directory doesn't exist on the lower FS set rFiles\n                        // here to simplify the following code.\n                        if (err || !rFiles) {\n                            rFiles = [];\n                        }\n                        // Readdir in both, check delete log on read-only file system's files, merge, return.\n                        const seenMap = {};\n                        const filtered = wFiles.concat(rFiles.filter((fPath) => !this._deletedFiles[`${p}/${fPath}`])).filter((fPath) => {\n                            // Remove duplicates.\n                            const result = !seenMap[fPath];\n                            seenMap[fPath] = true;\n                            return result;\n                        });\n                        cb(null, filtered);\n                    });\n                });\n            });\n        }\n        readdirSync(p) {\n            this.checkInitialized();\n            const dirStats = this.statSync(p, false);\n            if (!dirStats.isDirectory()) {\n                throw ApiError.ENOTDIR(p);\n            }\n            // Readdir in both, check delete log on RO file system's listing, merge, return.\n            let contents = [];\n            try {\n                contents = contents.concat(this._writable.readdirSync(p));\n            }\n            catch (e) {\n                // NOP.\n            }\n            try {\n                contents = contents.concat(this._readable.readdirSync(p).filter((fPath) => !this._deletedFiles[`${p}/${fPath}`]));\n            }\n            catch (e) {\n                // NOP.\n            }\n            const seenMap = {};\n            return contents.filter((fileP) => {\n                const result = !seenMap[fileP];\n                seenMap[fileP] = true;\n                return result;\n            });\n        }\n        exists(p, cb) {\n            // Cannot pass an error back to callback, so throw an exception instead\n            // if not initialized.\n            this.checkInitialized();\n            this._writable.exists(p, (existsWritable) => {\n                if (existsWritable) {\n                    return cb(true);\n                }\n                this._readable.exists(p, (existsReadable) => {\n                    cb(existsReadable && this._deletedFiles[p] !== true);\n                });\n            });\n        }\n        existsSync(p) {\n            this.checkInitialized();\n            return this._writable.existsSync(p) || (this._readable.existsSync(p) && this._deletedFiles[p] !== true);\n        }\n        chmod(p, isLchmod, mode, cb) {\n            if (!this.checkInitAsync(cb)) {\n                return;\n            }\n            this.operateOnWritableAsync(p, (err) => {\n                if (err) {\n                    return cb(err);\n                }\n                else {\n                    this._writable.chmod(p, isLchmod, mode, cb);\n                }\n            });\n        }\n        chmodSync(p, isLchmod, mode) {\n            this.checkInitialized();\n            this.operateOnWritable(p, () => {\n                this._writable.chmodSync(p, isLchmod, mode);\n            });\n        }\n        chown(p, isLchmod, uid, gid, cb) {\n            if (!this.checkInitAsync(cb)) {\n                return;\n            }\n            this.operateOnWritableAsync(p, (err) => {\n                if (err) {\n                    return cb(err);\n                }\n                else {\n                    this._writable.chown(p, isLchmod, uid, gid, cb);\n                }\n            });\n        }\n        chownSync(p, isLchown, uid, gid) {\n            this.checkInitialized();\n            this.operateOnWritable(p, () => {\n                this._writable.chownSync(p, isLchown, uid, gid);\n            });\n        }\n        utimes(p, atime, mtime, cb) {\n            if (!this.checkInitAsync(cb)) {\n                return;\n            }\n            this.operateOnWritableAsync(p, (err) => {\n                if (err) {\n                    return cb(err);\n                }\n                else {\n                    this._writable.utimes(p, atime, mtime, cb);\n                }\n            });\n        }\n        utimesSync(p, atime, mtime) {\n            this.checkInitialized();\n            this.operateOnWritable(p, () => {\n                this._writable.utimesSync(p, atime, mtime);\n            });\n        }\n        deletePath(p) {\n            this._deletedFiles[p] = true;\n            this.updateLog(`d${p}\\n`);\n        }\n        updateLog(addition) {\n            this._deleteLog += addition;\n            if (this._deleteLogUpdatePending) {\n                this._deleteLogUpdateNeeded = true;\n            }\n            else {\n                this._deleteLogUpdatePending = true;\n                this._writable.writeFile(deletionLogPath, this._deleteLog, 'utf8', FileFlag.getFileFlag('w'), 0o644, (e) => {\n                    this._deleteLogUpdatePending = false;\n                    if (e) {\n                        this._deleteLogError = e;\n                    }\n                    else if (this._deleteLogUpdateNeeded) {\n                        this._deleteLogUpdateNeeded = false;\n                        this.updateLog('');\n                    }\n                });\n            }\n        }\n        _reparseDeletionLog() {\n            this._deletedFiles = {};\n            this._deleteLog.split('\\n').forEach((path) => {\n                // If the log entry begins w/ 'd', it's a deletion.\n                this._deletedFiles[path.slice(1)] = path.slice(0, 1) === 'd';\n            });\n        }\n        checkInitialized() {\n            if (!this._isInitialized) {\n                throw new ApiError(ErrorCode.EPERM, \"OverlayFS is not initialized. Please initialize OverlayFS using its initialize() method before using it.\");\n            }\n            else if (this._deleteLogError !== null) {\n                const e = this._deleteLogError;\n                this._deleteLogError = null;\n                throw e;\n            }\n        }\n        checkInitAsync(cb) {\n            if (!this._isInitialized) {\n                cb(new ApiError(ErrorCode.EPERM, \"OverlayFS is not initialized. Please initialize OverlayFS using its initialize() method before using it.\"));\n                return false;\n            }\n            else if (this._deleteLogError !== null) {\n                const e = this._deleteLogError;\n                this._deleteLogError = null;\n                cb(e);\n                return false;\n            }\n            return true;\n        }\n        checkPath(p) {\n            if (p === deletionLogPath) {\n                throw ApiError.EPERM(p);\n            }\n        }\n        checkPathAsync(p, cb) {\n            if (p === deletionLogPath) {\n                cb(ApiError.EPERM(p));\n                return true;\n            }\n            return false;\n        }\n        createParentDirectoriesAsync(p, cb) {\n            let parent = path.dirname(p);\n            const toCreate = [];\n            const self = this;\n            this._writable.stat(parent, false, statDone);\n            function statDone(err, stat) {\n                if (err) {\n                    if (parent === \"/\") {\n                        cb(new ApiError(ErrorCode.EBUSY, \"Invariant failed: root does not exist!\"));\n                    }\n                    else {\n                        toCreate.push(parent);\n                        parent = path.dirname(parent);\n                        self._writable.stat(parent, false, statDone);\n                    }\n                }\n                else {\n                    createParents();\n                }\n            }\n            function createParents() {\n                if (!toCreate.length) {\n                    return cb();\n                }\n                const dir = toCreate.pop();\n                self._readable.stat(dir, false, (err, stats) => {\n                    // stop if we couldn't read the dir\n                    if (!stats) {\n                        return cb();\n                    }\n                    self._writable.mkdir(dir, stats.mode, (err) => {\n                        if (err) {\n                            return cb(err);\n                        }\n                        createParents();\n                    });\n                });\n            }\n        }\n        /**\n         * With the given path, create the needed parent directories on the writable storage\n         * should they not exist. Use modes from the read-only storage.\n         */\n        createParentDirectories(p) {\n            let parent = path.dirname(p), toCreate = [];\n            while (!this._writable.existsSync(parent)) {\n                toCreate.push(parent);\n                parent = path.dirname(parent);\n            }\n            toCreate = toCreate.reverse();\n            toCreate.forEach((p) => {\n                this._writable.mkdirSync(p, this.statSync(p, false).mode);\n            });\n        }\n        /**\n         * Helper function:\n         * - Ensures p is on writable before proceeding. Throws an error if it doesn't exist.\n         * - Calls f to perform operation on writable.\n         */\n        operateOnWritable(p, f) {\n            if (this.existsSync(p)) {\n                if (!this._writable.existsSync(p)) {\n                    // File is on readable storage. Copy to writable storage before\n                    // changing its mode.\n                    this.copyToWritable(p);\n                }\n                f();\n            }\n            else {\n                throw ApiError.ENOENT(p);\n            }\n        }\n        operateOnWritableAsync(p, cb) {\n            this.exists(p, (exists) => {\n                if (!exists) {\n                    return cb(ApiError.ENOENT(p));\n                }\n                this._writable.exists(p, (existsWritable) => {\n                    if (existsWritable) {\n                        cb();\n                    }\n                    else {\n                        return this.copyToWritableAsync(p, cb);\n                    }\n                });\n            });\n        }\n        /**\n         * Copy from readable to writable storage.\n         * PRECONDITION: File does not exist on writable storage.\n         */\n        copyToWritable(p) {\n            const pStats = this.statSync(p, false);\n            if (pStats.isDirectory()) {\n                this._writable.mkdirSync(p, pStats.mode);\n            }\n            else {\n                this.writeFileSync(p, this._readable.readFileSync(p, null, getFlag('r')), null, getFlag('w'), this.statSync(p, false).mode);\n            }\n        }\n        copyToWritableAsync(p, cb) {\n            this.stat(p, false, (err, pStats) => {\n                if (err) {\n                    return cb(err);\n                }\n                if (pStats.isDirectory()) {\n                    return this._writable.mkdir(p, pStats.mode, cb);\n                }\n                // need to copy file.\n                this._readable.readFile(p, null, getFlag('r'), (err, data) => {\n                    if (err) {\n                        return cb(err);\n                    }\n                    this.writeFile(p, data, null, getFlag('w'), pStats.mode, cb);\n                });\n            });\n        }\n    }\n    /**\n     * OverlayFS makes a read-only filesystem writable by storing writes on a second,\n     * writable file system. Deletes are persisted via metadata stored on the writable\n     * file system.\n     */\n    class OverlayFS extends LockedFS {\n        /**\n         * @param writable The file system to write modified files to.\n         * @param readable The file system that initially populates this file system.\n         */\n        constructor(writable, readable) {\n            super(new UnlockedOverlayFS(writable, readable));\n        }\n        /**\n         * Constructs and initializes an OverlayFS instance with the given options.\n         */\n        static Create(opts, cb) {\n            try {\n                const fs = new OverlayFS(opts.writable, opts.readable);\n                fs._initialize((e) => {\n                    cb(e, fs);\n                });\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        static isAvailable() {\n            return UnlockedOverlayFS.isAvailable();\n        }\n        getOverlayedFileSystems() {\n            return super.getFSUnlocked().getOverlayedFileSystems();\n        }\n        unwrap() {\n            return super.getFSUnlocked();\n        }\n        _initialize(cb) {\n            super.getFSUnlocked()._initialize(cb);\n        }\n    }\n    OverlayFS.Name = \"OverlayFS\";\n    OverlayFS.Options = {\n        writable: {\n            type: \"object\",\n            description: \"The file system to write modified files to.\"\n        },\n        readable: {\n            type: \"object\",\n            description: \"The file system that initially populates this file system.\"\n        }\n    };\n\n    return OverlayFS;\n});\ndefine('skylark-browserfs/backend/WorkerFS',[\n    '../libs/buffers',\n    '../core/file_system',\n    '../core/api_error',\n    '../core/file_flag',\n    '../core/util',\n    '../core/file',\n    '../core/node_fs_stats',\n    '../generic/preload_file',\n    '../core/global',\n    '../core/node_fs'\n], function (buffers,file_system, api_error, file_flag, util, file, node_fs_stats, preload_file, global, fs) {\n    'use strict';\n\n    const { BaseFileSystem } = file_system;\n    const { ApiError, ErrorCode }  = api_error;\n    const { FileFlag }  = file_flag;\n    const { buffer2ArrayBuffer, arrayBuffer2Buffer, emptyBuffer }  = util;\n    const { BaseFile }  = file;\n    const { Stats }  = node_fs_stats;\n    const {PreloadFile}  = preload_file;\n    const { Buffer } = buffers;\n\n    /**\n     * @hidden\n     */\n    var SpecialArgType;\n    (function (SpecialArgType) {\n        // Callback\n        SpecialArgType[SpecialArgType[\"CB\"] = 0] = \"CB\";\n        // File descriptor\n        SpecialArgType[SpecialArgType[\"FD\"] = 1] = \"FD\";\n        // API error\n        SpecialArgType[SpecialArgType[\"API_ERROR\"] = 2] = \"API_ERROR\";\n        // Stats object\n        SpecialArgType[SpecialArgType[\"STATS\"] = 3] = \"STATS\";\n        // Initial probe for file system information.\n        SpecialArgType[SpecialArgType[\"PROBE\"] = 4] = \"PROBE\";\n        // FileFlag object.\n        SpecialArgType[SpecialArgType[\"FILEFLAG\"] = 5] = \"FILEFLAG\";\n        // Buffer object.\n        SpecialArgType[SpecialArgType[\"BUFFER\"] = 6] = \"BUFFER\";\n        // Generic Error object.\n        SpecialArgType[SpecialArgType[\"ERROR\"] = 7] = \"ERROR\";\n    })(SpecialArgType || (SpecialArgType = {}));\n    /**\n     * Converts callback arguments into ICallbackArgument objects, and back\n     * again.\n     * @hidden\n     */\n    class CallbackArgumentConverter {\n        constructor() {\n            this._callbacks = {};\n            this._nextId = 0;\n        }\n        toRemoteArg(cb) {\n            const id = this._nextId++;\n            this._callbacks[id] = cb;\n            return {\n                type: SpecialArgType.CB,\n                id: id\n            };\n        }\n        toLocalArg(id) {\n            const cb = this._callbacks[id];\n            delete this._callbacks[id];\n            return cb;\n        }\n    }\n    /**\n     * @hidden\n     */\n    class FileDescriptorArgumentConverter {\n        constructor() {\n            this._fileDescriptors = {};\n            this._nextId = 0;\n        }\n        toRemoteArg(fd, p, flag, cb) {\n            const id = this._nextId++;\n            let data;\n            let stat;\n            this._fileDescriptors[id] = fd;\n            // Extract needed information asynchronously.\n            fd.stat((err, stats) => {\n                if (err) {\n                    cb(err);\n                }\n                else {\n                    stat = bufferToTransferrableObject(stats.toBuffer());\n                    // If it's a readable flag, we need to grab contents.\n                    if (flag.isReadable()) {\n                        fd.read(Buffer.alloc(stats.size), 0, stats.size, 0, (err, bytesRead, buff) => {\n                            if (err) {\n                                cb(err);\n                            }\n                            else {\n                                data = bufferToTransferrableObject(buff);\n                                cb(null, {\n                                    type: SpecialArgType.FD,\n                                    id: id,\n                                    data: data,\n                                    stat: stat,\n                                    path: p,\n                                    flag: flag.getFlagString()\n                                });\n                            }\n                        });\n                    }\n                    else {\n                        // File is not readable, which means writing to it will append or\n                        // truncate/replace existing contents. Return an empty arraybuffer.\n                        cb(null, {\n                            type: SpecialArgType.FD,\n                            id: id,\n                            data: new ArrayBuffer(0),\n                            stat: stat,\n                            path: p,\n                            flag: flag.getFlagString()\n                        });\n                    }\n                }\n            });\n        }\n        applyFdAPIRequest(request, cb) {\n            const fdArg = request.args[0];\n            this._applyFdChanges(fdArg, (err, fd) => {\n                if (err) {\n                    cb(err);\n                }\n                else {\n                    // Apply method on now-changed file descriptor.\n                    fd[request.method]((e) => {\n                        if (request.method === 'close') {\n                            delete this._fileDescriptors[fdArg.id];\n                        }\n                        cb(e);\n                    });\n                }\n            });\n        }\n        _applyFdChanges(remoteFd, cb) {\n            const fd = this._fileDescriptors[remoteFd.id], data = transferrableObjectToBuffer(remoteFd.data), remoteStats = Stats.fromBuffer(transferrableObjectToBuffer(remoteFd.stat));\n            // Write data if the file is writable.\n            const flag = FileFlag.getFileFlag(remoteFd.flag);\n            if (flag.isWriteable()) {\n                // Appendable: Write to end of file.\n                // Writeable: Replace entire contents of file.\n                fd.write(data, 0, data.length, flag.isAppendable() ? fd.getPos() : 0, (e) => {\n                    function applyStatChanges() {\n                        // Check if mode changed.\n                        fd.stat((e, stats) => {\n                            if (e) {\n                                cb(e);\n                            }\n                            else {\n                                if (stats.mode !== remoteStats.mode) {\n                                    fd.chmod(remoteStats.mode, (e) => {\n                                        cb(e, fd);\n                                    });\n                                }\n                                else {\n                                    cb(e, fd);\n                                }\n                            }\n                        });\n                    }\n                    if (e) {\n                        cb(e);\n                    }\n                    else {\n                        // If writeable & not appendable, we need to ensure file contents are\n                        // identical to those from the remote FD. Thus, we truncate to the\n                        // length of the remote file.\n                        if (!flag.isAppendable()) {\n                            fd.truncate(data.length, () => {\n                                applyStatChanges();\n                            });\n                        }\n                        else {\n                            applyStatChanges();\n                        }\n                    }\n                });\n            }\n            else {\n                cb(null, fd);\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    function apiErrorLocal2Remote(e) {\n        return {\n            type: SpecialArgType.API_ERROR,\n            errorData: bufferToTransferrableObject(e.writeToBuffer())\n        };\n    }\n    /**\n     * @hidden\n     */\n    function apiErrorRemote2Local(e) {\n        return ApiError.fromBuffer(transferrableObjectToBuffer(e.errorData));\n    }\n    /**\n     * @hidden\n     */\n    function errorLocal2Remote(e) {\n        return {\n            type: SpecialArgType.ERROR,\n            name: e.name,\n            message: e.message,\n            stack: e.stack\n        };\n    }\n    /**\n     * @hidden\n     */\n    function errorRemote2Local(e) {\n        let cnstr = global[e.name];\n        if (typeof (cnstr) !== 'function') {\n            cnstr = Error;\n        }\n        const err = new cnstr(e.message);\n        err.stack = e.stack;\n        return err;\n    }\n    /**\n     * @hidden\n     */\n    function statsLocal2Remote(stats) {\n        return {\n            type: SpecialArgType.STATS,\n            statsData: bufferToTransferrableObject(stats.toBuffer())\n        };\n    }\n    /**\n     * @hidden\n     */\n    function statsRemote2Local(stats) {\n        return Stats.fromBuffer(transferrableObjectToBuffer(stats.statsData));\n    }\n    /**\n     * @hidden\n     */\n    function fileFlagLocal2Remote(flag) {\n        return {\n            type: SpecialArgType.FILEFLAG,\n            flagStr: flag.getFlagString()\n        };\n    }\n    /**\n     * @hidden\n     */\n    function fileFlagRemote2Local(remoteFlag) {\n        return FileFlag.getFileFlag(remoteFlag.flagStr);\n    }\n    /**\n     * @hidden\n     */\n    function bufferToTransferrableObject(buff) {\n        return buffer2ArrayBuffer(buff);\n    }\n    /**\n     * @hidden\n     */\n    function transferrableObjectToBuffer(buff) {\n        return arrayBuffer2Buffer(buff);\n    }\n    /**\n     * @hidden\n     */\n    function bufferLocal2Remote(buff) {\n        return {\n            type: SpecialArgType.BUFFER,\n            data: bufferToTransferrableObject(buff)\n        };\n    }\n    /**\n     * @hidden\n     */\n    function bufferRemote2Local(buffArg) {\n        return transferrableObjectToBuffer(buffArg.data);\n    }\n    /**\n     * @hidden\n     */\n    function isAPIRequest(data) {\n        return data && typeof data === 'object' && data.hasOwnProperty('browserfsMessage') && data['browserfsMessage'];\n    }\n    /**\n     * @hidden\n     */\n    function isAPIResponse(data) {\n        return data && typeof data === 'object' && data.hasOwnProperty('browserfsMessage') && data['browserfsMessage'];\n    }\n    /**\n     * Represents a remote file in a different worker/thread.\n     */\n    class WorkerFile extends PreloadFile {\n        constructor(_fs, _path, _flag, _stat, remoteFdId, contents) {\n            super(_fs, _path, _flag, _stat, contents);\n            this._remoteFdId = remoteFdId;\n        }\n        getRemoteFdId() {\n            return this._remoteFdId;\n        }\n        /**\n         * @hidden\n         */\n        toRemoteArg() {\n            return {\n                type: SpecialArgType.FD,\n                id: this._remoteFdId,\n                data: bufferToTransferrableObject(this.getBuffer()),\n                stat: bufferToTransferrableObject(this.getStats().toBuffer()),\n                path: this.getPath(),\n                flag: this.getFlag().getFlagString()\n            };\n        }\n        sync(cb) {\n            this._syncClose('sync', cb);\n        }\n        close(cb) {\n            this._syncClose('close', cb);\n        }\n        _syncClose(type, cb) {\n            if (this.isDirty()) {\n                this._fs.syncClose(type, this, (e) => {\n                    if (!e) {\n                        this.resetDirty();\n                    }\n                    cb(e);\n                });\n            }\n            else {\n                cb();\n            }\n        }\n    }\n    /**\n     * WorkerFS lets you access a BrowserFS instance that is running in a different\n     * JavaScript context (e.g. access BrowserFS in one of your WebWorkers, or\n     * access BrowserFS running on the main page from a WebWorker).\n     *\n     * For example, to have a WebWorker access files in the main browser thread,\n     * do the following:\n     *\n     * MAIN BROWSER THREAD:\n     *\n     * ```javascript\n     *   // Listen for remote file system requests.\n     *   BrowserFS.FileSystem.WorkerFS.attachRemoteListener(webWorkerObject);\n     * ```\n     *\n     * WEBWORKER THREAD:\n     *\n     * ```javascript\n     *   // Set the remote file system as the root file system.\n     *   BrowserFS.configure({ fs: \"WorkerFS\", options: { worker: self }}, function(e) {\n     *     // Ready!\n     *   });\n     * ```\n     *\n     * Note that synchronous operations are not permitted on the WorkerFS, regardless\n     * of the configuration option of the remote FS.\n     */\n    class WorkerFS extends BaseFileSystem {\n        /**\n         * Constructs a new WorkerFS instance that connects with BrowserFS running on\n         * the specified worker.\n         */\n        constructor(worker) {\n            super();\n            this._callbackConverter = new CallbackArgumentConverter();\n            this._isInitialized = false;\n            this._isReadOnly = false;\n            this._supportLinks = false;\n            this._supportProps = false;\n            this._worker = worker;\n            this._worker.addEventListener('message', (e) => {\n                const resp = e.data;\n                if (isAPIResponse(resp)) {\n                    let i;\n                    const args = resp.args;\n                    const fixedArgs = new Array(args.length);\n                    // Dispatch event to correct id.\n                    for (i = 0; i < fixedArgs.length; i++) {\n                        fixedArgs[i] = this._argRemote2Local(args[i]);\n                    }\n                    this._callbackConverter.toLocalArg(resp.cbId).apply(null, fixedArgs);\n                }\n            });\n        }\n        static Create(opts, cb) {\n            const fs = new WorkerFS(opts.worker);\n            fs._initialize(() => {\n                cb(null, fs);\n            });\n        }\n        static isAvailable() {\n            return typeof (importScripts) !== 'undefined' || typeof (Worker) !== 'undefined';\n        }\n        /**\n         * Attaches a listener to the remote worker for file system requests.\n         */\n        static attachRemoteListener(worker) {\n            const fdConverter = new FileDescriptorArgumentConverter();\n            function argLocal2Remote(arg, requestArgs, cb) {\n                switch (typeof arg) {\n                    case 'object':\n                        if (arg instanceof Stats) {\n                            cb(null, statsLocal2Remote(arg));\n                        }\n                        else if (arg instanceof ApiError) {\n                            cb(null, apiErrorLocal2Remote(arg));\n                        }\n                        else if (arg instanceof BaseFile) {\n                            // Pass in p and flags from original request.\n                            cb(null, fdConverter.toRemoteArg(arg, requestArgs[0], requestArgs[1], cb));\n                        }\n                        else if (arg instanceof FileFlag) {\n                            cb(null, fileFlagLocal2Remote(arg));\n                        }\n                        else if (arg instanceof Buffer) {\n                            cb(null, bufferLocal2Remote(arg));\n                        }\n                        else if (arg instanceof Error) {\n                            cb(null, errorLocal2Remote(arg));\n                        }\n                        else {\n                            cb(null, arg);\n                        }\n                        break;\n                    default:\n                        cb(null, arg);\n                        break;\n                }\n            }\n            function argRemote2Local(arg, fixedRequestArgs) {\n                if (!arg) {\n                    return arg;\n                }\n                switch (typeof arg) {\n                    case 'object':\n                        if (typeof arg['type'] === 'number') {\n                            const specialArg = arg;\n                            switch (specialArg.type) {\n                                case SpecialArgType.CB:\n                                    const cbId = arg.id;\n                                    return function () {\n                                        let i;\n                                        const fixedArgs = new Array(arguments.length);\n                                        let message, countdown = arguments.length;\n                                        function abortAndSendError(err) {\n                                            if (countdown > 0) {\n                                                countdown = -1;\n                                                message = {\n                                                    browserfsMessage: true,\n                                                    cbId: cbId,\n                                                    args: [apiErrorLocal2Remote(err)]\n                                                };\n                                                worker.postMessage(message);\n                                            }\n                                        }\n                                        for (i = 0; i < arguments.length; i++) {\n                                            // Capture i and argument.\n                                            ((i, arg) => {\n                                                argLocal2Remote(arg, fixedRequestArgs, (err, fixedArg) => {\n                                                    fixedArgs[i] = fixedArg;\n                                                    if (err) {\n                                                        abortAndSendError(err);\n                                                    }\n                                                    else if (--countdown === 0) {\n                                                        message = {\n                                                            browserfsMessage: true,\n                                                            cbId: cbId,\n                                                            args: fixedArgs\n                                                        };\n                                                        worker.postMessage(message);\n                                                    }\n                                                });\n                                            })(i, arguments[i]);\n                                        }\n                                        if (arguments.length === 0) {\n                                            message = {\n                                                browserfsMessage: true,\n                                                cbId: cbId,\n                                                args: fixedArgs\n                                            };\n                                            worker.postMessage(message);\n                                        }\n                                    };\n                                case SpecialArgType.API_ERROR:\n                                    return apiErrorRemote2Local(specialArg);\n                                case SpecialArgType.STATS:\n                                    return statsRemote2Local(specialArg);\n                                case SpecialArgType.FILEFLAG:\n                                    return fileFlagRemote2Local(specialArg);\n                                case SpecialArgType.BUFFER:\n                                    return bufferRemote2Local(specialArg);\n                                case SpecialArgType.ERROR:\n                                    return errorRemote2Local(specialArg);\n                                default:\n                                    // No idea what this is.\n                                    return arg;\n                            }\n                        }\n                        else {\n                            return arg;\n                        }\n                    default:\n                        return arg;\n                }\n            }\n            worker.addEventListener('message', (e) => {\n                const request = e.data;\n                if (isAPIRequest(request)) {\n                    const args = request.args, fixedArgs = new Array(args.length);\n                    switch (request.method) {\n                        case 'close':\n                        case 'sync':\n                            (() => {\n                                // File descriptor-relative methods.\n                                const remoteCb = args[1];\n                                fdConverter.applyFdAPIRequest(request, (err) => {\n                                    // Send response.\n                                    const response = {\n                                        browserfsMessage: true,\n                                        cbId: remoteCb.id,\n                                        args: err ? [apiErrorLocal2Remote(err)] : []\n                                    };\n                                    worker.postMessage(response);\n                                });\n                            })();\n                            break;\n                        case 'probe':\n                            (() => {\n                                const rootFs = fs.getRootFS(), remoteCb = args[1], probeResponse = {\n                                    type: SpecialArgType.PROBE,\n                                    isReadOnly: rootFs.isReadOnly(),\n                                    supportsLinks: rootFs.supportsLinks(),\n                                    supportsProps: rootFs.supportsProps()\n                                }, response = {\n                                    browserfsMessage: true,\n                                    cbId: remoteCb.id,\n                                    args: [probeResponse]\n                                };\n                                worker.postMessage(response);\n                            })();\n                            break;\n                        default:\n                            // File system methods.\n                            for (let i = 0; i < args.length; i++) {\n                                fixedArgs[i] = argRemote2Local(args[i], fixedArgs);\n                            }\n                            const rootFS = fs.getRootFS();\n                            rootFS[request.method].apply(rootFS, fixedArgs);\n                            break;\n                    }\n                }\n            });\n        }\n        getName() {\n            return WorkerFS.Name;\n        }\n        isReadOnly() { return this._isReadOnly; }\n        supportsSynch() { return false; }\n        supportsLinks() { return this._supportLinks; }\n        supportsProps() { return this._supportProps; }\n        rename(oldPath, newPath, cb) {\n            this._rpc('rename', arguments);\n        }\n        stat(p, isLstat, cb) {\n            this._rpc('stat', arguments);\n        }\n        open(p, flag, mode, cb) {\n            this._rpc('open', arguments);\n        }\n        unlink(p, cb) {\n            this._rpc('unlink', arguments);\n        }\n        rmdir(p, cb) {\n            this._rpc('rmdir', arguments);\n        }\n        mkdir(p, mode, cb) {\n            this._rpc('mkdir', arguments);\n        }\n        readdir(p, cb) {\n            this._rpc('readdir', arguments);\n        }\n        exists(p, cb) {\n            this._rpc('exists', arguments);\n        }\n        realpath(p, cache, cb) {\n            this._rpc('realpath', arguments);\n        }\n        truncate(p, len, cb) {\n            this._rpc('truncate', arguments);\n        }\n        readFile(fname, encoding, flag, cb) {\n            this._rpc('readFile', arguments);\n        }\n        writeFile(fname, data, encoding, flag, mode, cb) {\n            this._rpc('writeFile', arguments);\n        }\n        appendFile(fname, data, encoding, flag, mode, cb) {\n            this._rpc('appendFile', arguments);\n        }\n        chmod(p, isLchmod, mode, cb) {\n            this._rpc('chmod', arguments);\n        }\n        chown(p, isLchown, uid, gid, cb) {\n            this._rpc('chown', arguments);\n        }\n        utimes(p, atime, mtime, cb) {\n            this._rpc('utimes', arguments);\n        }\n        link(srcpath, dstpath, cb) {\n            this._rpc('link', arguments);\n        }\n        symlink(srcpath, dstpath, type, cb) {\n            this._rpc('symlink', arguments);\n        }\n        readlink(p, cb) {\n            this._rpc('readlink', arguments);\n        }\n        syncClose(method, fd, cb) {\n            this._worker.postMessage({\n                browserfsMessage: true,\n                method: method,\n                args: [fd.toRemoteArg(), this._callbackConverter.toRemoteArg(cb)]\n            });\n        }\n        /**\n         * Called once both local and remote sides are set up.\n         */\n        _initialize(cb) {\n            if (!this._isInitialized) {\n                const message = {\n                    browserfsMessage: true,\n                    method: 'probe',\n                    args: [this._argLocal2Remote(emptyBuffer()), this._callbackConverter.toRemoteArg((probeResponse) => {\n                            this._isInitialized = true;\n                            this._isReadOnly = probeResponse.isReadOnly;\n                            this._supportLinks = probeResponse.supportsLinks;\n                            this._supportProps = probeResponse.supportsProps;\n                            cb();\n                        })]\n                };\n                this._worker.postMessage(message);\n            }\n            else {\n                cb();\n            }\n        }\n        _argRemote2Local(arg) {\n            if (!arg) {\n                return arg;\n            }\n            switch (typeof arg) {\n                case 'object':\n                    if (typeof arg['type'] === 'number') {\n                        const specialArg = arg;\n                        switch (specialArg.type) {\n                            case SpecialArgType.API_ERROR:\n                                return apiErrorRemote2Local(specialArg);\n                            case SpecialArgType.FD:\n                                const fdArg = specialArg;\n                                return new WorkerFile(this, fdArg.path, FileFlag.getFileFlag(fdArg.flag), Stats.fromBuffer(transferrableObjectToBuffer(fdArg.stat)), fdArg.id, transferrableObjectToBuffer(fdArg.data));\n                            case SpecialArgType.STATS:\n                                return statsRemote2Local(specialArg);\n                            case SpecialArgType.FILEFLAG:\n                                return fileFlagRemote2Local(specialArg);\n                            case SpecialArgType.BUFFER:\n                                return bufferRemote2Local(specialArg);\n                            case SpecialArgType.ERROR:\n                                return errorRemote2Local(specialArg);\n                            default:\n                                return arg;\n                        }\n                    }\n                    else {\n                        return arg;\n                    }\n                default:\n                    return arg;\n            }\n        }\n        _rpc(methodName, args) {\n            const fixedArgs = new Array(args.length);\n            for (let i = 0; i < args.length; i++) {\n                fixedArgs[i] = this._argLocal2Remote(args[i]);\n            }\n            const message = {\n                browserfsMessage: true,\n                method: methodName,\n                args: fixedArgs\n            };\n            this._worker.postMessage(message);\n        }\n        /**\n         * Converts a local argument into a remote argument. Public so WorkerFile objects can call it.\n         */\n        _argLocal2Remote(arg) {\n            if (!arg) {\n                return arg;\n            }\n            switch (typeof arg) {\n                case \"object\":\n                    if (arg instanceof Stats) {\n                        return statsLocal2Remote(arg);\n                    }\n                    else if (arg instanceof ApiError) {\n                        return apiErrorLocal2Remote(arg);\n                    }\n                    else if (arg instanceof WorkerFile) {\n                        return arg.toRemoteArg();\n                    }\n                    else if (arg instanceof FileFlag) {\n                        return fileFlagLocal2Remote(arg);\n                    }\n                    else if (arg instanceof Buffer) {\n                        return bufferLocal2Remote(arg);\n                    }\n                    else if (arg instanceof Error) {\n                        return errorLocal2Remote(arg);\n                    }\n                    else {\n                        return \"Unknown argument\";\n                    }\n                case \"function\":\n                    return this._callbackConverter.toRemoteArg(arg);\n                default:\n                    return arg;\n            }\n        }\n    }\n    WorkerFS.Name = \"WorkerFS\";\n    WorkerFS.Options = {\n        worker: {\n            type: \"object\",\n            description: \"The target worker that you want to connect to, or the current worker if in a worker context.\",\n            validator: function (v, cb) {\n                // Check for a `postMessage` function.\n                if (v['postMessage']) {\n                    cb();\n                }\n                else {\n                    cb(new ApiError(ErrorCode.EINVAL, `option must be a Web Worker instance.`));\n                }\n            }\n        }\n    };\n\n    return WorkerFS;\n});\ndefine('skylark-browserfs/generic/xhr',[\n    '../libs/buffers',\n    '../core/util',\n    '../core/api_error'\n], function (buffers,util, api_error) {\n    'use strict';\n    /**\n     * Contains utility methods for performing a variety of tasks with\n     * XmlHttpRequest across browsers.\n     */\n    const { isIE, emptyBuffer } = util;\n    const { ApiError, ErrorCode } = api_error;\n    const { Buffer } = buffers;\n\n    const xhrIsAvailable = (typeof (XMLHttpRequest) !== \"undefined\" && XMLHttpRequest !== null);\n    function asyncDownloadFileModern(p, type, cb) {\n        const req = new XMLHttpRequest();\n        req.open('GET', p, true);\n        let jsonSupported = true;\n        switch (type) {\n            case 'buffer':\n                req.responseType = 'arraybuffer';\n                break;\n            case 'json':\n                // Some browsers don't support the JSON response type.\n                // They either reset responseType, or throw an exception.\n                // @see https://github.com/Modernizr/Modernizr/blob/master/src/testXhrType.js\n                try {\n                    req.responseType = 'json';\n                    jsonSupported = req.responseType === 'json';\n                }\n                catch (e) {\n                    jsonSupported = false;\n                }\n                break;\n            default:\n                return cb(new ApiError(ErrorCode.EINVAL, \"Invalid download type: \" + type));\n        }\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    switch (type) {\n                        case 'buffer':\n                            // XXX: WebKit-based browsers return *null* when XHRing an empty file.\n                            return cb(null, req.response ? Buffer.from(req.response) : emptyBuffer());\n                        case 'json':\n                            if (jsonSupported) {\n                                return cb(null, req.response);\n                            }\n                            else {\n                                return cb(null, JSON.parse(req.responseText));\n                            }\n                    }\n                }\n                else {\n                    return cb(new ApiError(ErrorCode.EIO, `XHR error: response returned code ${req.status}`));\n                }\n            }\n        };\n        req.send();\n    }\n    function syncDownloadFileModern(p, type) {\n        const req = new XMLHttpRequest();\n        req.open('GET', p, false);\n        // On most platforms, we cannot set the responseType of synchronous downloads.\n        // @todo Test for this; IE10 allows this, as do older versions of Chrome/FF.\n        let data = null;\n        let err = null;\n        // Classic hack to download binary data as a string.\n        req.overrideMimeType('text/plain; charset=x-user-defined');\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    switch (type) {\n                        case 'buffer':\n                            // Convert the text into a buffer.\n                            const text = req.responseText;\n                            data = Buffer.alloc(text.length);\n                            // Throw away the upper bits of each character.\n                            for (let i = 0; i < text.length; i++) {\n                                // This will automatically throw away the upper bit of each\n                                // character for us.\n                                data[i] = text.charCodeAt(i);\n                            }\n                            return;\n                        case 'json':\n                            data = JSON.parse(req.responseText);\n                            return;\n                    }\n                }\n                else {\n                    err = new ApiError(ErrorCode.EIO, `XHR error: response returned code ${req.status}`);\n                    return;\n                }\n            }\n        };\n        req.send();\n        if (err) {\n            throw err;\n        }\n        return data;\n    }\n    function syncDownloadFileIE10(p, type) {\n        const req = new XMLHttpRequest();\n        req.open('GET', p, false);\n        switch (type) {\n            case 'buffer':\n                req.responseType = 'arraybuffer';\n                break;\n            case 'json':\n                // IE10 does not support the JSON type.\n                break;\n            default:\n                throw new ApiError(ErrorCode.EINVAL, \"Invalid download type: \" + type);\n        }\n        let data;\n        let err;\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    switch (type) {\n                        case 'buffer':\n                            data = Buffer.from(req.response);\n                            break;\n                        case 'json':\n                            data = JSON.parse(req.response);\n                            break;\n                    }\n                }\n                else {\n                    err = new ApiError(ErrorCode.EIO, `XHR error: response returned code ${req.status}`);\n                }\n            }\n        };\n        req.send();\n        if (err) {\n            throw err;\n        }\n        return data;\n    }\n    /**\n     * @hidden\n     */\n    function getFileSize(async, p, cb) {\n        const req = new XMLHttpRequest();\n        req.open('HEAD', p, async);\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    try {\n                        return cb(null, parseInt(req.getResponseHeader('Content-Length') || '-1', 10));\n                    }\n                    catch (e) {\n                        // In the event that the header isn't present or there is an error...\n                        return cb(new ApiError(ErrorCode.EIO, \"XHR HEAD error: Could not read content-length.\"));\n                    }\n                }\n                else {\n                    return cb(new ApiError(ErrorCode.EIO, `XHR HEAD error: response returned code ${req.status}`));\n                }\n            }\n        };\n        req.send();\n    }\n    /**\n     * Asynchronously download a file as a buffer or a JSON object.\n     * Note that the third function signature with a non-specialized type is\n     * invalid, but TypeScript requires it when you specialize string arguments to\n     * constants.\n     * @hidden\n     */\n    let asyncDownloadFile = asyncDownloadFileModern;\n    /**\n     * Synchronously download a file as a buffer or a JSON object.\n     * Note that the third function signature with a non-specialized type is\n     * invalid, but TypeScript requires it when you specialize string arguments to\n     * constants.\n     * @hidden\n     */\n    let syncDownloadFile = (isIE && typeof Blob !== 'undefined') ? syncDownloadFileIE10 : syncDownloadFileModern;\n    /**\n     * Synchronously retrieves the size of the given file in bytes.\n     * @hidden\n     */\n    function getFileSizeSync(p) {\n        let rv = -1;\n        getFileSize(false, p, function (err, size) {\n            if (err) {\n                throw err;\n            }\n            rv = size;\n        });\n        return rv;\n    }\n    /**\n     * Asynchronously retrieves the size of the given file in bytes.\n     * @hidden\n     */\n    function getFileSizeAsync(p, cb) {\n        getFileSize(true, p, cb);\n    }\n\n\n\n    return {\n        xhrIsAvailable: xhrIsAvailable,\n        asyncDownloadFile: asyncDownloadFile,\n        syncDownloadFile: syncDownloadFile,\n        getFileSizeSync: getFileSizeSync,\n        getFileSizeAsync: getFileSizeAsync\n    };\n});\ndefine('skylark-browserfs/generic/fetch',[\n    '../libs/buffers',\n    '../core/api_error'\n], function (buffers,api_error) {\n    'use strict';\n\n    /**\n     * Contains utility methods using 'fetch'.\n     */\n    const { ApiError, ErrorCode }= api_error;\n\n    const fetchIsAvailable = (typeof (fetch) !== \"undefined\" && fetch !== null);\n    const { Buffer } = buffers;\n\n    function fetchFileAsync(p, type, cb) {\n        let request;\n        try {\n            request = fetch(p);\n        }\n        catch (e) {\n            // XXX: fetch will throw a TypeError if the URL has credentials in it\n            return cb(new ApiError(ErrorCode.EINVAL, e.message));\n        }\n        request\n            .then((res) => {\n            if (!res.ok) {\n                return cb(new ApiError(ErrorCode.EIO, `fetch error: response returned code ${res.status}`));\n            }\n            else {\n                switch (type) {\n                    case 'buffer':\n                        res.arrayBuffer()\n                            .then((buf) => cb(null, Buffer.from(buf)))\n                            .catch((err) => cb(new ApiError(ErrorCode.EIO, err.message)));\n                        break;\n                    case 'json':\n                        res.json()\n                            .then((json) => cb(null, json))\n                            .catch((err) => cb(new ApiError(ErrorCode.EIO, err.message)));\n                        break;\n                    default:\n                        cb(new ApiError(ErrorCode.EINVAL, \"Invalid download type: \" + type));\n                }\n            }\n        })\n            .catch((err) => cb(new ApiError(ErrorCode.EIO, err.message)));\n    }\n\n    /**\n     * Asynchronously retrieves the size of the given file in bytes.\n     * @hidden\n     */\n\n    function fetchFileSizeAsync(p, cb) {\n        fetch(p, { method: 'HEAD' })\n            .then((res) => {\n            if (!res.ok) {\n                return cb(new ApiError(ErrorCode.EIO, `fetch HEAD error: response returned code ${res.status}`));\n            }\n            else {\n                return cb(null, parseInt(res.headers.get('Content-Length') || '-1', 10));\n            }\n        })\n            .catch((err) => cb(new ApiError(ErrorCode.EIO, err.message)));\n    }\n\n    return {\n        fetchIsAvailable: fetchIsAvailable,\n        fetchFileAsync: fetchFileAsync,\n        fetchFileSizeAsync: fetchFileSizeAsync\n    };\n});\ndefine('skylark-browserfs/generic/file_index',[\n    '../core/node_fs_stats',\n    '../libs/path'\n], function (node_fs_stats, path) {\n    'use strict';\n\n    const {Stats, FileType }  = node_fs_stats;\n\n    /**\n     * A simple class for storing a filesystem index. Assumes that all paths passed\n     * to it are *absolute* paths.\n     *\n     * Can be used as a partial or a full index, although care must be taken if used\n     * for the former purpose, especially when directories are concerned.\n     */\n    class FileIndex {\n        /**\n         * Constructs a new FileIndex.\n         */\n        constructor() {\n            // _index is a single-level key,value store that maps *directory* paths to\n            // DirInodes. File information is only contained in DirInodes themselves.\n            this._index = {};\n            // Create the root directory.\n            this.addPath('/', new DirInode());\n        }\n        /**\n         * Static method for constructing indices from a JSON listing.\n         * @param listing Directory listing generated by tools/XHRIndexer.coffee\n         * @return A new FileIndex object.\n         */\n        static fromListing(listing) {\n            const idx = new FileIndex();\n            // Add a root DirNode.\n            const rootInode = new DirInode();\n            idx._index['/'] = rootInode;\n            const queue = [['', listing, rootInode]];\n            while (queue.length > 0) {\n                let inode;\n                const next = queue.pop();\n                const pwd = next[0];\n                const tree = next[1];\n                const parent = next[2];\n                for (const node in tree) {\n                    if (tree.hasOwnProperty(node)) {\n                        const children = tree[node];\n                        const name = `${pwd}/${node}`;\n                        if (children) {\n                            idx._index[name] = inode = new DirInode();\n                            queue.push([name, children, inode]);\n                        }\n                        else {\n                            // This inode doesn't have correct size information, noted with -1.\n                            inode = new FileInode(new Stats(FileType.FILE, -1, 0x16D));\n                        }\n                        if (parent) {\n                            parent._ls[node] = inode;\n                        }\n                    }\n                }\n            }\n            return idx;\n        }\n        /**\n         * Runs the given function over all files in the index.\n         */\n        fileIterator(cb) {\n            for (const path in this._index) {\n                if (this._index.hasOwnProperty(path)) {\n                    const dir = this._index[path];\n                    const files = dir.getListing();\n                    for (const file of files) {\n                        const item = dir.getItem(file);\n                        if (isFileInode(item)) {\n                            cb(item.getData());\n                        }\n                    }\n                }\n            }\n        }\n        /**\n         * Adds the given absolute path to the index if it is not already in the index.\n         * Creates any needed parent directories.\n         * @param path The path to add to the index.\n         * @param inode The inode for the\n         *   path to add.\n         * @return 'True' if it was added or already exists, 'false' if there\n         *   was an issue adding it (e.g. item in path is a file, item exists but is\n         *   different).\n         * @todo If adding fails and implicitly creates directories, we do not clean up\n         *   the new empty directories.\n         */\n        addPath(path, inode) {\n            if (!inode) {\n                throw new Error('Inode must be specified');\n            }\n            if (path[0] !== '/') {\n                throw new Error('Path must be absolute, got: ' + path);\n            }\n            // Check if it already exists.\n            if (this._index.hasOwnProperty(path)) {\n                return this._index[path] === inode;\n            }\n            const splitPath = this._split_path(path);\n            const dirpath = splitPath[0];\n            const itemname = splitPath[1];\n            // Try to add to its parent directory first.\n            let parent = this._index[dirpath];\n            if (parent === undefined && path !== '/') {\n                // Create parent.\n                parent = new DirInode();\n                if (!this.addPath(dirpath, parent)) {\n                    return false;\n                }\n            }\n            // Add myself to my parent.\n            if (path !== '/') {\n                if (!parent.addItem(itemname, inode)) {\n                    return false;\n                }\n            }\n            // If I'm a directory, add myself to the index.\n            if (isDirInode(inode)) {\n                this._index[path] = inode;\n            }\n            return true;\n        }\n        /**\n         * Adds the given absolute path to the index if it is not already in the index.\n         * The path is added without special treatment (no joining of adjacent separators, etc).\n         * Creates any needed parent directories.\n         * @param path The path to add to the index.\n         * @param inode The inode for the\n         *   path to add.\n         * @return 'True' if it was added or already exists, 'false' if there\n         *   was an issue adding it (e.g. item in path is a file, item exists but is\n         *   different).\n         * @todo If adding fails and implicitly creates directories, we do not clean up\n         *   the new empty directories.\n         */\n        addPathFast(path, inode) {\n            const itemNameMark = path.lastIndexOf('/');\n            const parentPath = itemNameMark === 0 ? \"/\" : path.substring(0, itemNameMark);\n            const itemName = path.substring(itemNameMark + 1);\n            // Try to add to its parent directory first.\n            let parent = this._index[parentPath];\n            if (parent === undefined) {\n                // Create parent.\n                parent = new DirInode();\n                this.addPathFast(parentPath, parent);\n            }\n            if (!parent.addItem(itemName, inode)) {\n                return false;\n            }\n            // If adding a directory, add to the index as well.\n            if (inode.isDir()) {\n                this._index[path] = inode;\n            }\n            return true;\n        }\n        /**\n         * Removes the given path. Can be a file or a directory.\n         * @return The removed item,\n         *   or null if it did not exist.\n         */\n        removePath(path) {\n            const splitPath = this._split_path(path);\n            const dirpath = splitPath[0];\n            const itemname = splitPath[1];\n            // Try to remove it from its parent directory first.\n            const parent = this._index[dirpath];\n            if (parent === undefined) {\n                return null;\n            }\n            // Remove myself from my parent.\n            const inode = parent.remItem(itemname);\n            if (inode === null) {\n                return null;\n            }\n            // If I'm a directory, remove myself from the index, and remove my children.\n            if (isDirInode(inode)) {\n                const children = inode.getListing();\n                for (const child of children) {\n                    this.removePath(path + '/' + child);\n                }\n                // Remove the directory from the index, unless it's the root.\n                if (path !== '/') {\n                    delete this._index[path];\n                }\n            }\n            return inode;\n        }\n        /**\n         * Retrieves the directory listing of the given path.\n         * @return An array of files in the given path, or 'null' if it does not exist.\n         */\n        ls(path) {\n            const item = this._index[path];\n            if (item === undefined) {\n                return null;\n            }\n            return item.getListing();\n        }\n        /**\n         * Returns the inode of the given item.\n         * @return Returns null if the item does not exist.\n         */\n        getInode(path) {\n            const splitPath = this._split_path(path);\n            const dirpath = splitPath[0];\n            const itemname = splitPath[1];\n            // Retrieve from its parent directory.\n            const parent = this._index[dirpath];\n            if (parent === undefined) {\n                return null;\n            }\n            // Root case\n            if (dirpath === path) {\n                return parent;\n            }\n            return parent.getItem(itemname);\n        }\n        /**\n         * Split into a (directory path, item name) pair\n         */\n        _split_path(p) {\n            const dirpath = path.dirname(p);\n            const itemname = p.substr(dirpath.length + (dirpath === \"/\" ? 0 : 1));\n            return [dirpath, itemname];\n        }\n    }\n    \n    /**\n     * Inode for a file. Stores an arbitrary (filesystem-specific) data payload.\n     */\n    class FileInode {\n        constructor(data) {\n            this.data = data;\n        }\n        isFile() { return true; }\n        isDir() { return false; }\n        getData() { return this.data; }\n        setData(data) { this.data = data; }\n    }\n    /**\n     * Inode for a directory. Currently only contains the directory listing.\n     */\n    class DirInode {\n        /**\n         * Constructs an inode for a directory.\n         */\n        constructor(data = null) {\n            this.data = data;\n            this._ls = {};\n        }\n        isFile() {\n            return false;\n        }\n        isDir() {\n            return true;\n        }\n        getData() { return this.data; }\n        /**\n         * Return a Stats object for this inode.\n         * @todo Should probably remove this at some point. This isn't the\n         *       responsibility of the FileIndex.\n         */\n        getStats() {\n            return new Stats(FileType.DIRECTORY, 4096, 0x16D);\n        }\n        /**\n         * Returns the directory listing for this directory. Paths in the directory are\n         * relative to the directory's path.\n         * @return The directory listing for this directory.\n         */\n        getListing() {\n            return Object.keys(this._ls);\n        }\n        /**\n         * Returns the inode for the indicated item, or null if it does not exist.\n         * @param p Name of item in this directory.\n         */\n        getItem(p) {\n            const item = this._ls[p];\n            return item ? item : null;\n        }\n        /**\n         * Add the given item to the directory listing. Note that the given inode is\n         * not copied, and will be mutated by the DirInode if it is a DirInode.\n         * @param p Item name to add to the directory listing.\n         * @param inode The inode for the\n         *   item to add to the directory inode.\n         * @return True if it was added, false if it already existed.\n         */\n        addItem(p, inode) {\n            if (p in this._ls) {\n                return false;\n            }\n            this._ls[p] = inode;\n            return true;\n        }\n        /**\n         * Removes the given item from the directory listing.\n         * @param p Name of item to remove from the directory listing.\n         * @return Returns the item\n         *   removed, or null if the item did not exist.\n         */\n        remItem(p) {\n            const item = this._ls[p];\n            if (item === undefined) {\n                return null;\n            }\n            delete this._ls[p];\n            return item;\n        }\n    }\n    /**\n     * @hidden\n     */\n    function isFileInode(inode) {\n        return !!inode && inode.isFile();\n    }\n    /**\n     * @hidden\n     */\n    function isDirInode(inode) {\n        return !!inode && inode.isDir();\n    }\n\n\n    return {\n        FileIndex: FileIndex,\n        FileInode: FileInode,\n        DirInode: DirInode,\n        isFileInode: isFileInode,\n        isDirInode: isDirInode\n    };\n});\ndefine('skylark-browserfs/backend/HTTPRequest',[\n    '../core/file_system',\n    '../core/api_error',\n    '../core/file_flag',\n    '../core/util',\n    '../core/node_fs_stats',\n    '../generic/preload_file',\n    '../generic/xhr',\n    '../generic/fetch',\n    '../generic/file_index'\n], function (file_system, api_error, file_flag, util, node_fs_stats, preload_file, xhr, fetch, file_index) {\n    'use strict';\n\n    const { BaseFileSystem } = file_system;\n    const { ApiError, ErrorCode }  = api_error;\n    const { ActionType }  = file_flag;\n    const { copyingSlice }  = util;\n    const  {Stats} = node_fs_stats;\n    const { NoSyncFile }  = preload_file;\n    const { xhrIsAvailable, asyncDownloadFile, syncDownloadFile, getFileSizeAsync, getFileSizeSync }  = xhr;\n    const { fetchIsAvailable, fetchFileAsync, fetchFileSizeAsync }  = fetch;\n    const { FileIndex, isFileInode, isDirInode }  = file_index;\n    /**\n     * Try to convert the given buffer into a string, and pass it to the callback.\n     * Optimization that removes the needed try/catch into a helper function, as\n     * this is an uncommon case.\n     * @hidden\n     */\n    function tryToString(buff, encoding, cb) {\n        try {\n            cb(null, buff.toString(encoding));\n        }\n        catch (e) {\n            cb(e);\n        }\n    }\n    function syncNotAvailableError() {\n        throw new ApiError(ErrorCode.ENOTSUP, `Synchronous HTTP download methods are not available in this environment.`);\n    }\n    /**\n     * A simple filesystem backed by HTTP downloads. You must create a directory listing using the\n     * `make_http_index` tool provided by BrowserFS.\n     *\n     * If you install BrowserFS globally with `npm i -g browserfs`, you can generate a listing by\n     * running `make_http_index` in your terminal in the directory you would like to index:\n     *\n     * ```\n     * make_http_index > index.json\n     * ```\n     *\n     * Listings objects look like the following:\n     *\n     * ```json\n     * {\n     *   \"home\": {\n     *     \"jvilk\": {\n     *       \"someFile.txt\": null,\n     *       \"someDir\": {\n     *         // Empty directory\n     *       }\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * *This example has the folder `/home/jvilk` with subfile `someFile.txt` and subfolder `someDir`.*\n     */\n    class HTTPRequest extends BaseFileSystem {\n        constructor(index, prefixUrl = '', preferXHR = false) {\n            super();\n            // prefix_url must end in a directory separator.\n            if (prefixUrl.length > 0 && prefixUrl.charAt(prefixUrl.length - 1) !== '/') {\n                prefixUrl = prefixUrl + '/';\n            }\n            this.prefixUrl = prefixUrl;\n            this._index = FileIndex.fromListing(index);\n            if (fetchIsAvailable && (!preferXHR || !xhrIsAvailable)) {\n                this._requestFileAsyncInternal = fetchFileAsync;\n                this._requestFileSizeAsyncInternal = fetchFileSizeAsync;\n            }\n            else {\n                this._requestFileAsyncInternal = asyncDownloadFile;\n                this._requestFileSizeAsyncInternal = getFileSizeAsync;\n            }\n            if (xhrIsAvailable) {\n                this._requestFileSyncInternal = syncDownloadFile;\n                this._requestFileSizeSyncInternal = getFileSizeSync;\n            }\n            else {\n                this._requestFileSyncInternal = syncNotAvailableError;\n                this._requestFileSizeSyncInternal = syncNotAvailableError;\n            }\n        }\n        /**\n         * Construct an HTTPRequest file system backend with the given options.\n         */\n        static Create(opts, cb) {\n            if (opts.index === undefined) {\n                opts.index = `index.json`;\n            }\n            if (typeof (opts.index) === \"string\") {\n                asyncDownloadFile(opts.index, \"json\", (e, data) => {\n                    if (e) {\n                        cb(e);\n                    }\n                    else {\n                        cb(null, new HTTPRequest(data, opts.baseUrl));\n                    }\n                });\n            }\n            else {\n                cb(null, new HTTPRequest(opts.index, opts.baseUrl));\n            }\n        }\n        static isAvailable() {\n            return xhrIsAvailable || fetchIsAvailable;\n        }\n        empty() {\n            this._index.fileIterator(function (file) {\n                file.fileData = null;\n            });\n        }\n        getName() {\n            return HTTPRequest.Name;\n        }\n        diskSpace(path, cb) {\n            // Read-only file system. We could calculate the total space, but that's not\n            // important right now.\n            cb(0, 0);\n        }\n        isReadOnly() {\n            return true;\n        }\n        supportsLinks() {\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            // Synchronous operations are only available via the XHR interface for now.\n            return xhrIsAvailable;\n        }\n        /**\n         * Special HTTPFS function: Preload the given file into the index.\n         * @param [String] path\n         * @param [BrowserFS.Buffer] buffer\n         */\n        preloadFile(path, buffer) {\n            const inode = this._index.getInode(path);\n            if (isFileInode(inode)) {\n                if (inode === null) {\n                    throw ApiError.ENOENT(path);\n                }\n                const stats = inode.getData();\n                stats.size = buffer.length;\n                stats.fileData = buffer;\n            }\n            else {\n                throw ApiError.EISDIR(path);\n            }\n        }\n        stat(path, isLstat, cb) {\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                return cb(ApiError.ENOENT(path));\n            }\n            let stats;\n            if (isFileInode(inode)) {\n                stats = inode.getData();\n                // At this point, a non-opened file will still have default stats from the listing.\n                if (stats.size < 0) {\n                    this._requestFileSizeAsync(path, function (e, size) {\n                        if (e) {\n                            return cb(e);\n                        }\n                        stats.size = size;\n                        cb(null, Stats.clone(stats));\n                    });\n                }\n                else {\n                    cb(null, Stats.clone(stats));\n                }\n            }\n            else if (isDirInode(inode)) {\n                stats = inode.getStats();\n                cb(null, stats);\n            }\n            else {\n                cb(ApiError.FileError(ErrorCode.EINVAL, path));\n            }\n        }\n        statSync(path, isLstat) {\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                throw ApiError.ENOENT(path);\n            }\n            let stats;\n            if (isFileInode(inode)) {\n                stats = inode.getData();\n                // At this point, a non-opened file will still have default stats from the listing.\n                if (stats.size < 0) {\n                    stats.size = this._requestFileSizeSync(path);\n                }\n            }\n            else if (isDirInode(inode)) {\n                stats = inode.getStats();\n            }\n            else {\n                throw ApiError.FileError(ErrorCode.EINVAL, path);\n            }\n            return stats;\n        }\n        open(path, flags, mode, cb) {\n            // INVARIANT: You can't write to files on this file system.\n            if (flags.isWriteable()) {\n                return cb(new ApiError(ErrorCode.EPERM, path));\n            }\n            const self = this;\n            // Check if the path exists, and is a file.\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                return cb(ApiError.ENOENT(path));\n            }\n            if (isFileInode(inode)) {\n                const stats = inode.getData();\n                switch (flags.pathExistsAction()) {\n                    case ActionType.THROW_EXCEPTION:\n                    case ActionType.TRUNCATE_FILE:\n                        return cb(ApiError.EEXIST(path));\n                    case ActionType.NOP:\n                        // Use existing file contents.\n                        // XXX: Uh, this maintains the previously-used flag.\n                        if (stats.fileData) {\n                            return cb(null, new NoSyncFile(self, path, flags, Stats.clone(stats), stats.fileData));\n                        }\n                        // @todo be lazier about actually requesting the file\n                        this._requestFileAsync(path, 'buffer', function (err, buffer) {\n                            if (err) {\n                                return cb(err);\n                            }\n                            // we don't initially have file sizes\n                            stats.size = buffer.length;\n                            stats.fileData = buffer;\n                            return cb(null, new NoSyncFile(self, path, flags, Stats.clone(stats), buffer));\n                        });\n                        break;\n                    default:\n                        return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.'));\n                }\n            }\n            else {\n                return cb(ApiError.EISDIR(path));\n            }\n        }\n        openSync(path, flags, mode) {\n            // INVARIANT: You can't write to files on this file system.\n            if (flags.isWriteable()) {\n                throw new ApiError(ErrorCode.EPERM, path);\n            }\n            // Check if the path exists, and is a file.\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                throw ApiError.ENOENT(path);\n            }\n            if (isFileInode(inode)) {\n                const stats = inode.getData();\n                switch (flags.pathExistsAction()) {\n                    case ActionType.THROW_EXCEPTION:\n                    case ActionType.TRUNCATE_FILE:\n                        throw ApiError.EEXIST(path);\n                    case ActionType.NOP:\n                        // Use existing file contents.\n                        // XXX: Uh, this maintains the previously-used flag.\n                        if (stats.fileData) {\n                            return new NoSyncFile(this, path, flags, Stats.clone(stats), stats.fileData);\n                        }\n                        // @todo be lazier about actually requesting the file\n                        const buffer = this._requestFileSync(path, 'buffer');\n                        // we don't initially have file sizes\n                        stats.size = buffer.length;\n                        stats.fileData = buffer;\n                        return new NoSyncFile(this, path, flags, Stats.clone(stats), buffer);\n                    default:\n                        throw new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.');\n                }\n            }\n            else {\n                throw ApiError.EISDIR(path);\n            }\n        }\n        readdir(path, cb) {\n            try {\n                cb(null, this.readdirSync(path));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        readdirSync(path) {\n            // Check if it exists.\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                throw ApiError.ENOENT(path);\n            }\n            else if (isDirInode(inode)) {\n                return inode.getListing();\n            }\n            else {\n                throw ApiError.ENOTDIR(path);\n            }\n        }\n        /**\n         * We have the entire file as a buffer; optimize readFile.\n         */\n        readFile(fname, encoding, flag, cb) {\n            // Wrap cb in file closing code.\n            const oldCb = cb;\n            // Get file.\n            this.open(fname, flag, 0x1a4, function (err, fd) {\n                if (err) {\n                    return cb(err);\n                }\n                cb = function (err, arg) {\n                    fd.close(function (err2) {\n                        if (!err) {\n                            err = err2;\n                        }\n                        return oldCb(err, arg);\n                    });\n                };\n                const fdCast = fd;\n                const fdBuff = fdCast.getBuffer();\n                if (encoding === null) {\n                    cb(err, copyingSlice(fdBuff));\n                }\n                else {\n                    tryToString(fdBuff, encoding, cb);\n                }\n            });\n        }\n        /**\n         * Specially-optimized readfile.\n         */\n        readFileSync(fname, encoding, flag) {\n            // Get file.\n            const fd = this.openSync(fname, flag, 0x1a4);\n            try {\n                const fdCast = fd;\n                const fdBuff = fdCast.getBuffer();\n                if (encoding === null) {\n                    return copyingSlice(fdBuff);\n                }\n                return fdBuff.toString(encoding);\n            }\n            finally {\n                fd.closeSync();\n            }\n        }\n        _getHTTPPath(filePath) {\n            if (filePath.charAt(0) === '/') {\n                filePath = filePath.slice(1);\n            }\n            return this.prefixUrl + filePath;\n        }\n        _requestFileAsync(p, type, cb) {\n            this._requestFileAsyncInternal(this._getHTTPPath(p), type, cb);\n        }\n        _requestFileSync(p, type) {\n            return this._requestFileSyncInternal(this._getHTTPPath(p), type);\n        }\n        /**\n         * Only requests the HEAD content, for the file size.\n         */\n        _requestFileSizeAsync(path, cb) {\n            this._requestFileSizeAsyncInternal(this._getHTTPPath(path), cb);\n        }\n        _requestFileSizeSync(path) {\n            return this._requestFileSizeSyncInternal(this._getHTTPPath(path));\n        }\n    }\n    HTTPRequest.Name = \"HTTPRequest\";\n    HTTPRequest.Options = {\n        index: {\n            type: [\"string\", \"object\"],\n            optional: true,\n            description: \"URL to a file index as a JSON file or the file index object itself, generated with the make_http_index script. Defaults to `index.json`.\"\n        },\n        baseUrl: {\n            type: \"string\",\n            optional: true,\n            description: \"Used as the URL prefix for fetched files. Default: Fetch files relative to the index.\"\n        },\n        preferXHR: {\n            type: \"boolean\",\n            optional: true,\n            description: \"Whether to prefer XmlHttpRequest or fetch for async operations if both are available. Default: false\"\n        }\n    };\n\n    return HTTPRequest;\n});\ndefine('skylark-browserfs/generic/extended_ascii',[],function () {\n    'use strict';\n    /**\n     * (Nonstandard) String utility function for 8-bit ASCII with the extended\n     * character set. Unlike the ASCII above, we do not mask the high bits.\n     *\n     * Placed into a separate file so it can be used with other Buffer implementations.\n     * @see http://en.wikipedia.org/wiki/Extended_ASCII\n     */\n    class ExtendedASCII {\n        static str2byte(str, buf) {\n            const length = str.length > buf.length ? buf.length : str.length;\n            for (let i = 0; i < length; i++) {\n                let charCode = str.charCodeAt(i);\n                if (charCode > 0x7F) {\n                    // Check if extended ASCII.\n                    const charIdx = ExtendedASCII.extendedChars.indexOf(str.charAt(i));\n                    if (charIdx > -1) {\n                        charCode = charIdx + 0x80;\n                    }\n                    // Otherwise, keep it as-is.\n                }\n                buf[charCode] = i;\n            }\n            return length;\n        }\n        static byte2str(buff) {\n            const chars = new Array(buff.length);\n            for (let i = 0; i < buff.length; i++) {\n                const charCode = buff[i];\n                if (charCode > 0x7F) {\n                    chars[i] = ExtendedASCII.extendedChars[charCode - 128];\n                }\n                else {\n                    chars[i] = String.fromCharCode(charCode);\n                }\n            }\n            return chars.join('');\n        }\n        static byteLength(str) { return str.length; }\n    }\n    \n    ExtendedASCII.extendedChars = ['\\u00C7', '\\u00FC', '\\u00E9', '\\u00E2', '\\u00E4',\n        '\\u00E0', '\\u00E5', '\\u00E7', '\\u00EA', '\\u00EB', '\\u00E8', '\\u00EF',\n        '\\u00EE', '\\u00EC', '\\u00C4', '\\u00C5', '\\u00C9', '\\u00E6', '\\u00C6',\n        '\\u00F4', '\\u00F6', '\\u00F2', '\\u00FB', '\\u00F9', '\\u00FF', '\\u00D6',\n        '\\u00DC', '\\u00F8', '\\u00A3', '\\u00D8', '\\u00D7', '\\u0192', '\\u00E1',\n        '\\u00ED', '\\u00F3', '\\u00FA', '\\u00F1', '\\u00D1', '\\u00AA', '\\u00BA',\n        '\\u00BF', '\\u00AE', '\\u00AC', '\\u00BD', '\\u00BC', '\\u00A1', '\\u00AB',\n        '\\u00BB', '_', '_', '_', '\\u00A6', '\\u00A6', '\\u00C1', '\\u00C2', '\\u00C0',\n        '\\u00A9', '\\u00A6', '\\u00A6', '+', '+', '\\u00A2', '\\u00A5', '+', '+', '-',\n        '-', '+', '-', '+', '\\u00E3', '\\u00C3', '+', '+', '-', '-', '\\u00A6', '-',\n        '+', '\\u00A4', '\\u00F0', '\\u00D0', '\\u00CA', '\\u00CB', '\\u00C8', 'i',\n        '\\u00CD', '\\u00CE', '\\u00CF', '+', '+', '_', '_', '\\u00A6', '\\u00CC', '_',\n        '\\u00D3', '\\u00DF', '\\u00D4', '\\u00D2', '\\u00F5', '\\u00D5', '\\u00B5',\n        '\\u00FE', '\\u00DE', '\\u00DA', '\\u00DB', '\\u00D9', '\\u00FD', '\\u00DD',\n        '\\u00AF', '\\u00B4', '\\u00AD', '\\u00B1', '_', '\\u00BE', '\\u00B6', '\\u00A7',\n        '\\u00F7', '\\u00B8', '\\u00B0', '\\u00A8', '\\u00B7', '\\u00B9', '\\u00B3',\n        '\\u00B2', '_', ' '];\n\n    return ExtendedASCII;\n});\ndefine('skylark-browserfs/backend/ZipFS',[\n    '../core/api_error',\n    '../core/node_fs_stats',\n    '../core/file_system',\n    '../core/file_flag',\n    '../generic/preload_file',\n    '../core/util',\n    '../generic/extended_ascii',\n    '../generic/setImmediate',\n    '../generic/file_index'\n], function (api_error,  node_fs_stats, file_system, file_flag, preload_file, util, ExtendedASCII, setImmediate, file_index) {\n    'use strict';\n\n    const { ApiError, ErrorCode }  = api_error;\n    const { Stats, FileType }  = node_fs_stats;\n    const { SynchronousFileSystem }  = file_system;\n    const { ActionType }  = file_flag;\n    const { NoSyncFile }  = preload_file;\n    const { arrayish2Buffer, copyingSlice, bufferValidator }  = util;\n    /**\n     * @hidden\n     */\n    let inflateRaw;\n    try {\n        inflateRaw = require('pako/lib/inflate').inflateRaw;\n    } catch (e) {\n        console.warn(e);\n    }\n    const { FileIndex, DirInode, FileInode, isDirInode, isFileInode } = '../generic/file_index';\n    /**\n     * Maps CompressionMethod => function that decompresses.\n     * @hidden\n     */\n    const decompressionMethods = {};\n    /**\n     * 4.4.2.2: Indicates the compatibiltiy of a file's external attributes.\n     */\n    var ExternalFileAttributeType;\n    (function (ExternalFileAttributeType) {\n        ExternalFileAttributeType[ExternalFileAttributeType[\"MSDOS\"] = 0] = \"MSDOS\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"AMIGA\"] = 1] = \"AMIGA\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"OPENVMS\"] = 2] = \"OPENVMS\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"UNIX\"] = 3] = \"UNIX\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"VM_CMS\"] = 4] = \"VM_CMS\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"ATARI_ST\"] = 5] = \"ATARI_ST\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"OS2_HPFS\"] = 6] = \"OS2_HPFS\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"MAC\"] = 7] = \"MAC\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"Z_SYSTEM\"] = 8] = \"Z_SYSTEM\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"CP_M\"] = 9] = \"CP_M\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"NTFS\"] = 10] = \"NTFS\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"MVS\"] = 11] = \"MVS\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"VSE\"] = 12] = \"VSE\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"ACORN_RISC\"] = 13] = \"ACORN_RISC\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"VFAT\"] = 14] = \"VFAT\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"ALT_MVS\"] = 15] = \"ALT_MVS\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"BEOS\"] = 16] = \"BEOS\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"TANDEM\"] = 17] = \"TANDEM\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"OS_400\"] = 18] = \"OS_400\";\n        ExternalFileAttributeType[ExternalFileAttributeType[\"OSX\"] = 19] = \"OSX\";\n    })(ExternalFileAttributeType || (ExternalFileAttributeType = {}));\n    /**\n     * 4.4.5\n     */\n    var CompressionMethod;\n    (function (CompressionMethod) {\n        CompressionMethod[CompressionMethod[\"STORED\"] = 0] = \"STORED\";\n        CompressionMethod[CompressionMethod[\"SHRUNK\"] = 1] = \"SHRUNK\";\n        CompressionMethod[CompressionMethod[\"REDUCED_1\"] = 2] = \"REDUCED_1\";\n        CompressionMethod[CompressionMethod[\"REDUCED_2\"] = 3] = \"REDUCED_2\";\n        CompressionMethod[CompressionMethod[\"REDUCED_3\"] = 4] = \"REDUCED_3\";\n        CompressionMethod[CompressionMethod[\"REDUCED_4\"] = 5] = \"REDUCED_4\";\n        CompressionMethod[CompressionMethod[\"IMPLODE\"] = 6] = \"IMPLODE\";\n        CompressionMethod[CompressionMethod[\"DEFLATE\"] = 8] = \"DEFLATE\";\n        CompressionMethod[CompressionMethod[\"DEFLATE64\"] = 9] = \"DEFLATE64\";\n        CompressionMethod[CompressionMethod[\"TERSE_OLD\"] = 10] = \"TERSE_OLD\";\n        CompressionMethod[CompressionMethod[\"BZIP2\"] = 12] = \"BZIP2\";\n        CompressionMethod[CompressionMethod[\"LZMA\"] = 14] = \"LZMA\";\n        CompressionMethod[CompressionMethod[\"TERSE_NEW\"] = 18] = \"TERSE_NEW\";\n        CompressionMethod[CompressionMethod[\"LZ77\"] = 19] = \"LZ77\";\n        CompressionMethod[CompressionMethod[\"WAVPACK\"] = 97] = \"WAVPACK\";\n        CompressionMethod[CompressionMethod[\"PPMD\"] = 98] = \"PPMD\"; // PPMd version I, Rev 1\n    })(CompressionMethod || (CompressionMethod = {}));\n    /**\n     * Converts the input time and date in MS-DOS format into a JavaScript Date\n     * object.\n     * @hidden\n     */\n    function msdos2date(time, date) {\n        // MS-DOS Date\n        // |0 0 0 0  0|0 0 0  0|0 0 0  0 0 0 0\n        //   D (1-31)  M (1-23)  Y (from 1980)\n        const day = date & 0x1F;\n        // JS date is 0-indexed, DOS is 1-indexed.\n        const month = ((date >> 5) & 0xF) - 1;\n        const year = (date >> 9) + 1980;\n        // MS DOS Time\n        // |0 0 0 0  0|0 0 0  0 0 0|0  0 0 0 0\n        //    Second      Minute       Hour\n        const second = time & 0x1F;\n        const minute = (time >> 5) & 0x3F;\n        const hour = time >> 11;\n        return new Date(year, month, day, hour, minute, second);\n    }\n    /**\n     * Safely returns the string from the buffer, even if it is 0 bytes long.\n     * (Normally, calling toString() on a buffer with start === end causes an\n     * exception).\n     * @hidden\n     */\n    function safeToString(buff, useUTF8, start, length) {\n        if (length === 0) {\n            return \"\";\n        }\n        else if (useUTF8) {\n            return buff.toString('utf8', start, start + length);\n        }\n        else {\n            return ExtendedASCII.byte2str(buff.slice(start, start + length));\n        }\n    }\n    /*\n       4.3.6 Overall .ZIP file format:\n\n          [local file header 1]\n          [encryption header 1]\n          [file data 1]\n          [data descriptor 1]\n          .\n          .\n          .\n          [local file header n]\n          [encryption header n]\n          [file data n]\n          [data descriptor n]\n          [archive decryption header]\n          [archive extra data record]\n          [central directory header 1]\n          .\n          .\n          .\n          [central directory header n]\n          [zip64 end of central directory record]\n          [zip64 end of central directory locator]\n          [end of central directory record]\n    */\n    /**\n     * 4.3.7  Local file header:\n     *\n     *     local file header signature     4 bytes  (0x04034b50)\n     *     version needed to extract       2 bytes\n     *     general purpose bit flag        2 bytes\n     *     compression method              2 bytes\n     *    last mod file time              2 bytes\n     *    last mod file date              2 bytes\n     *    crc-32                          4 bytes\n     *    compressed size                 4 bytes\n     *    uncompressed size               4 bytes\n     *    file name length                2 bytes\n     *    extra field length              2 bytes\n     *\n     *    file name (variable size)\n     *    extra field (variable size)\n     */\n    class FileHeader {\n        constructor(data) {\n            this.data = data;\n            if (data.readUInt32LE(0) !== 0x04034b50) {\n                throw new ApiError(ErrorCode.EINVAL, \"Invalid Zip file: Local file header has invalid signature: \" + this.data.readUInt32LE(0));\n            }\n        }\n        versionNeeded() { return this.data.readUInt16LE(4); }\n        flags() { return this.data.readUInt16LE(6); }\n        compressionMethod() { return this.data.readUInt16LE(8); }\n        lastModFileTime() {\n            // Time and date is in MS-DOS format.\n            return msdos2date(this.data.readUInt16LE(10), this.data.readUInt16LE(12));\n        }\n        rawLastModFileTime() {\n            return this.data.readUInt32LE(10);\n        }\n        crc32() { return this.data.readUInt32LE(14); }\n        /**\n         * These two values are COMPLETELY USELESS.\n         *\n         * Section 4.4.9:\n         *   If bit 3 of the general purpose bit flag is set,\n         *   these fields are set to zero in the local header and the\n         *   correct values are put in the data descriptor and\n         *   in the central directory.\n         *\n         * So we'll just use the central directory's values.\n         */\n        // public compressedSize(): number { return this.data.readUInt32LE(18); }\n        // public uncompressedSize(): number { return this.data.readUInt32LE(22); }\n        fileNameLength() { return this.data.readUInt16LE(26); }\n        extraFieldLength() { return this.data.readUInt16LE(28); }\n        fileName() {\n            return safeToString(this.data, this.useUTF8(), 30, this.fileNameLength());\n        }\n        extraField() {\n            const start = 30 + this.fileNameLength();\n            return this.data.slice(start, start + this.extraFieldLength());\n        }\n        totalSize() { return 30 + this.fileNameLength() + this.extraFieldLength(); }\n        useUTF8() { return (this.flags() & 0x800) === 0x800; }\n    }\n    /**\n     * 4.3.8  File data\n     *\n     *   Immediately following the local header for a file\n     *   SHOULD be placed the compressed or stored data for the file.\n     *   If the file is encrypted, the encryption header for the file\n     *   SHOULD be placed after the local header and before the file\n     *   data. The series of [local file header][encryption header]\n     *   [file data][data descriptor] repeats for each file in the\n     *   .ZIP archive.\n     *\n     *   Zero-byte files, directories, and other file types that\n     *   contain no content MUST not include file data.\n     */\n    class FileData {\n        constructor(header, record, data) {\n            this.header = header;\n            this.record = record;\n            this.data = data;\n        }\n        decompress() {\n            // Check the compression\n            const compressionMethod = this.header.compressionMethod();\n            const fcn = decompressionMethods[compressionMethod];\n            if (fcn) {\n                return fcn(this.data, this.record.compressedSize(), this.record.uncompressedSize(), this.record.flag());\n            }\n            else {\n                let name = CompressionMethod[compressionMethod];\n                if (!name) {\n                    name = `Unknown: ${compressionMethod}`;\n                }\n                throw new ApiError(ErrorCode.EINVAL, `Invalid compression method on file '${this.header.fileName()}': ${name}`);\n            }\n        }\n        getHeader() {\n            return this.header;\n        }\n        getRecord() {\n            return this.record;\n        }\n        getRawData() {\n            return this.data;\n        }\n    }\n    /**\n     * 4.3.9  Data descriptor:\n     *\n     *    crc-32                          4 bytes\n     *    compressed size                 4 bytes\n     *    uncompressed size               4 bytes\n     */\n    class DataDescriptor {\n        constructor(data) {\n            this.data = data;\n        }\n        crc32() { return this.data.readUInt32LE(0); }\n        compressedSize() { return this.data.readUInt32LE(4); }\n        uncompressedSize() { return this.data.readUInt32LE(8); }\n    }\n    /*\n    ` 4.3.10  Archive decryption header:\n\n          4.3.10.1 The Archive Decryption Header is introduced in version 6.2\n          of the ZIP format specification.  This record exists in support\n          of the Central Directory Encryption Feature implemented as part of\n          the Strong Encryption Specification as described in this document.\n          When the Central Directory Structure is encrypted, this decryption\n          header MUST precede the encrypted data segment.\n     */\n    /**\n     * 4.3.11  Archive extra data record:\n     *\n     *      archive extra data signature    4 bytes  (0x08064b50)\n     *      extra field length              4 bytes\n     *      extra field data                (variable size)\n     *\n     *    4.3.11.1 The Archive Extra Data Record is introduced in version 6.2\n     *    of the ZIP format specification.  This record MAY be used in support\n     *    of the Central Directory Encryption Feature implemented as part of\n     *    the Strong Encryption Specification as described in this document.\n     *    When present, this record MUST immediately precede the central\n     *    directory data structure.\n     */\n    class ArchiveExtraDataRecord {\n        constructor(data) {\n            this.data = data;\n            if (this.data.readUInt32LE(0) !== 0x08064b50) {\n                throw new ApiError(ErrorCode.EINVAL, \"Invalid archive extra data record signature: \" + this.data.readUInt32LE(0));\n            }\n        }\n        length() { return this.data.readUInt32LE(4); }\n        extraFieldData() { return this.data.slice(8, 8 + this.length()); }\n    }\n    /**\n     * 4.3.13 Digital signature:\n     *\n     *      header signature                4 bytes  (0x05054b50)\n     *      size of data                    2 bytes\n     *      signature data (variable size)\n     *\n     *    With the introduction of the Central Directory Encryption\n     *    feature in version 6.2 of this specification, the Central\n     *    Directory Structure MAY be stored both compressed and encrypted.\n     *    Although not required, it is assumed when encrypting the\n     *    Central Directory Structure, that it will be compressed\n     *    for greater storage efficiency.  Information on the\n     *    Central Directory Encryption feature can be found in the section\n     *    describing the Strong Encryption Specification. The Digital\n     *    Signature record will be neither compressed nor encrypted.\n     */\n    class DigitalSignature {\n        constructor(data) {\n            this.data = data;\n            if (this.data.readUInt32LE(0) !== 0x05054b50) {\n                throw new ApiError(ErrorCode.EINVAL, \"Invalid digital signature signature: \" + this.data.readUInt32LE(0));\n            }\n        }\n        size() { return this.data.readUInt16LE(4); }\n        signatureData() { return this.data.slice(6, 6 + this.size()); }\n    }\n    /**\n     * 4.3.12  Central directory structure:\n     *\n     *  central file header signature   4 bytes  (0x02014b50)\n     *  version made by                 2 bytes\n     *  version needed to extract       2 bytes\n     *  general purpose bit flag        2 bytes\n     *  compression method              2 bytes\n     *  last mod file time              2 bytes\n     *  last mod file date              2 bytes\n     *  crc-32                          4 bytes\n     *  compressed size                 4 bytes\n     *  uncompressed size               4 bytes\n     *  file name length                2 bytes\n     *  extra field length              2 bytes\n     *  file comment length             2 bytes\n     *  disk number start               2 bytes\n     *  internal file attributes        2 bytes\n     *  external file attributes        4 bytes\n     *  relative offset of local header 4 bytes\n     *\n     *  file name (variable size)\n     *  extra field (variable size)\n     *  file comment (variable size)\n     */\n    class CentralDirectory {\n        constructor(zipData, data) {\n            this.zipData = zipData;\n            this.data = data;\n            // Sanity check.\n            if (this.data.readUInt32LE(0) !== 0x02014b50) {\n                throw new ApiError(ErrorCode.EINVAL, `Invalid Zip file: Central directory record has invalid signature: ${this.data.readUInt32LE(0)}`);\n            }\n            this._filename = this.produceFilename();\n        }\n        versionMadeBy() { return this.data.readUInt16LE(4); }\n        versionNeeded() { return this.data.readUInt16LE(6); }\n        flag() { return this.data.readUInt16LE(8); }\n        compressionMethod() { return this.data.readUInt16LE(10); }\n        lastModFileTime() {\n            // Time and date is in MS-DOS format.\n            return msdos2date(this.data.readUInt16LE(12), this.data.readUInt16LE(14));\n        }\n        rawLastModFileTime() {\n            return this.data.readUInt32LE(12);\n        }\n        crc32() { return this.data.readUInt32LE(16); }\n        compressedSize() { return this.data.readUInt32LE(20); }\n        uncompressedSize() { return this.data.readUInt32LE(24); }\n        fileNameLength() { return this.data.readUInt16LE(28); }\n        extraFieldLength() { return this.data.readUInt16LE(30); }\n        fileCommentLength() { return this.data.readUInt16LE(32); }\n        diskNumberStart() { return this.data.readUInt16LE(34); }\n        internalAttributes() { return this.data.readUInt16LE(36); }\n        externalAttributes() { return this.data.readUInt32LE(38); }\n        headerRelativeOffset() { return this.data.readUInt32LE(42); }\n        produceFilename() {\n            /*\n              4.4.17.1 claims:\n              * All slashes are forward ('/') slashes.\n              * Filename doesn't begin with a slash.\n              * No drive letters or any nonsense like that.\n              * If filename is missing, the input came from standard input.\n        \n              Unfortunately, this isn't true in practice. Some Windows zip utilities use\n              a backslash here, but the correct Unix-style path in file headers.\n        \n              To avoid seeking all over the file to recover the known-good filenames\n              from file headers, we simply convert '/' to '\\' here.\n            */\n            const fileName = safeToString(this.data, this.useUTF8(), 46, this.fileNameLength());\n            return fileName.replace(/\\\\/g, \"/\");\n        }\n        fileName() {\n            return this._filename;\n        }\n        rawFileName() {\n            return this.data.slice(46, 46 + this.fileNameLength());\n        }\n        extraField() {\n            const start = 44 + this.fileNameLength();\n            return this.data.slice(start, start + this.extraFieldLength());\n        }\n        fileComment() {\n            const start = 46 + this.fileNameLength() + this.extraFieldLength();\n            return safeToString(this.data, this.useUTF8(), start, this.fileCommentLength());\n        }\n        rawFileComment() {\n            const start = 46 + this.fileNameLength() + this.extraFieldLength();\n            return this.data.slice(start, start + this.fileCommentLength());\n        }\n        totalSize() {\n            return 46 + this.fileNameLength() + this.extraFieldLength() + this.fileCommentLength();\n        }\n        isDirectory() {\n            // NOTE: This assumes that the zip file implementation uses the lower byte\n            //       of external attributes for DOS attributes for\n            //       backwards-compatibility. This is not mandated, but appears to be\n            //       commonplace.\n            //       According to the spec, the layout of external attributes is\n            //       platform-dependent.\n            //       If that fails, we also check if the name of the file ends in '/',\n            //       which is what Java's ZipFile implementation does.\n            const fileName = this.fileName();\n            return (this.externalAttributes() & 0x10 ? true : false) || (fileName.charAt(fileName.length - 1) === '/');\n        }\n        isFile() { return !this.isDirectory(); }\n        useUTF8() { return (this.flag() & 0x800) === 0x800; }\n        isEncrypted() { return (this.flag() & 0x1) === 0x1; }\n        getFileData() {\n            // Need to grab the header before we can figure out where the actual\n            // compressed data starts.\n            const start = this.headerRelativeOffset();\n            const header = new FileHeader(this.zipData.slice(start));\n            return new FileData(header, this, this.zipData.slice(start + header.totalSize()));\n        }\n        getData() {\n            return this.getFileData().decompress();\n        }\n        getRawData() {\n            return this.getFileData().getRawData();\n        }\n        getStats() {\n            return new Stats(FileType.FILE, this.uncompressedSize(), 0x16D, Date.now(), this.lastModFileTime().getTime());\n        }\n    }\n    /**\n     * 4.3.16: end of central directory record\n     *  end of central dir signature    4 bytes  (0x06054b50)\n     *  number of this disk             2 bytes\n     *  number of the disk with the\n     *  start of the central directory  2 bytes\n     *  total number of entries in the\n     *  central directory on this disk  2 bytes\n     *  total number of entries in\n     *  the central directory           2 bytes\n     *  size of the central directory   4 bytes\n     *  offset of start of central\n     *  directory with respect to\n     *  the starting disk number        4 bytes\n     *  .ZIP file comment length        2 bytes\n     *  .ZIP file comment       (variable size)\n     */\n    class EndOfCentralDirectory {\n        constructor(data) {\n            this.data = data;\n            if (this.data.readUInt32LE(0) !== 0x06054b50) {\n                throw new ApiError(ErrorCode.EINVAL, `Invalid Zip file: End of central directory record has invalid signature: ${this.data.readUInt32LE(0)}`);\n            }\n        }\n        diskNumber() { return this.data.readUInt16LE(4); }\n        cdDiskNumber() { return this.data.readUInt16LE(6); }\n        cdDiskEntryCount() { return this.data.readUInt16LE(8); }\n        cdTotalEntryCount() { return this.data.readUInt16LE(10); }\n        cdSize() { return this.data.readUInt32LE(12); }\n        cdOffset() { return this.data.readUInt32LE(16); }\n        cdZipCommentLength() { return this.data.readUInt16LE(20); }\n        cdZipComment() {\n            // Assuming UTF-8. The specification doesn't specify.\n            return safeToString(this.data, true, 22, this.cdZipCommentLength());\n        }\n        rawCdZipComment() {\n            return this.data.slice(22, 22 + this.cdZipCommentLength());\n        }\n    }\n    /**\n     * Contains the table of contents of a Zip file.\n     */\n    class ZipTOC {\n        constructor(index, directoryEntries, eocd, data) {\n            this.index = index;\n            this.directoryEntries = directoryEntries;\n            this.eocd = eocd;\n            this.data = data;\n        }\n    }\n    /**\n     * Zip file-backed filesystem\n     * Implemented according to the standard:\n     * http://www.pkware.com/documents/casestudies/APPNOTE.TXT\n     *\n     * While there are a few zip libraries for JavaScript (e.g. JSZip and zip.js),\n     * they are not a good match for BrowserFS. In particular, these libraries\n     * perform a lot of unneeded data copying, and eagerly decompress every file\n     * in the zip file upon loading to check the CRC32. They also eagerly decode\n     * strings. Furthermore, these libraries duplicate functionality already present\n     * in BrowserFS (e.g. UTF-8 decoding and binary data manipulation).\n     *\n     * This filesystem takes advantage of BrowserFS's Buffer implementation, which\n     * efficiently represents the zip file in memory (in both ArrayBuffer-enabled\n     * browsers *and* non-ArrayBuffer browsers), and which can neatly be 'sliced'\n     * without copying data. Each struct defined in the standard is represented with\n     * a buffer slice pointing to an offset in the zip file, and has getters for\n     * each field. As we anticipate that this data will not be read often, we choose\n     * not to store each struct field in the JavaScript object; instead, to reduce\n     * memory consumption, we retrieve it directly from the binary data each time it\n     * is requested.\n     *\n     * When the filesystem is instantiated, we determine the directory structure\n     * of the zip file as quickly as possible. We lazily decompress and check the\n     * CRC32 of files. We do not cache decompressed files; if this is a desired\n     * feature, it is best implemented as a generic file system wrapper that can\n     * cache data from arbitrary file systems.\n     *\n     * For inflation, we use `pako`'s implementation:\n     * https://github.com/nodeca/pako\n     *\n     * Current limitations:\n     * * No encryption.\n     * * No ZIP64 support.\n     * * Read-only.\n     *   Write support would require that we:\n     *   - Keep track of changed/new files.\n     *   - Compress changed files, and generate appropriate metadata for each.\n     *   - Update file offsets for other files in the zip file.\n     *   - Stream it out to a location.\n     *   This isn't that bad, so we might do this at a later date.\n     */\n    class ZipFS extends SynchronousFileSystem {\n        constructor(input, name = '') {\n            super();\n            this.name = name;\n            this._index = new FileIndex();\n            this._directoryEntries = [];\n            this._eocd = null;\n            this._index = input.index;\n            this._directoryEntries = input.directoryEntries;\n            this._eocd = input.eocd;\n            this.data = input.data;\n        }\n        /**\n         * Constructs a ZipFS instance with the given options.\n         */\n        static Create(opts, cb) {\n            try {\n                ZipFS._computeIndex(opts.zipData, (e, zipTOC) => {\n                    if (zipTOC) {\n                        const fs = new ZipFS(zipTOC, opts.name);\n                        cb(null, fs);\n                    }\n                    else {\n                        cb(e);\n                    }\n                });\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        static isAvailable() { return true; }\n        static RegisterDecompressionMethod(m, fcn) {\n            decompressionMethods[m] = fcn;\n        }\n        /**\n         * Locates the end of central directory record at the end of the file.\n         * Throws an exception if it cannot be found.\n         */\n        static _getEOCD(data) {\n            // Unfortunately, the comment is variable size and up to 64K in size.\n            // We assume that the magic signature does not appear in the comment, and\n            // in the bytes between the comment and the signature. Other ZIP\n            // implementations make this same assumption, since the alternative is to\n            // read thread every entry in the file to get to it. :(\n            // These are *negative* offsets from the end of the file.\n            const startOffset = 22;\n            const endOffset = Math.min(startOffset + 0xFFFF, data.length - 1);\n            // There's not even a byte alignment guarantee on the comment so we need to\n            // search byte by byte. *grumble grumble*\n            for (let i = startOffset; i < endOffset; i++) {\n                // Magic number: EOCD Signature\n                if (data.readUInt32LE(data.length - i) === 0x06054b50) {\n                    return new EndOfCentralDirectory(data.slice(data.length - i));\n                }\n            }\n            throw new ApiError(ErrorCode.EINVAL, \"Invalid ZIP file: Could not locate End of Central Directory signature.\");\n        }\n        static _addToIndex(cd, index) {\n            // Paths must be absolute, yet zip file paths are always relative to the\n            // zip root. So we append '/' and call it a day.\n            let filename = cd.fileName();\n            if (filename.charAt(0) === '/') {\n                throw new ApiError(ErrorCode.EPERM, `Unexpectedly encountered an absolute path in a zip file. Please file a bug.`);\n            }\n            // XXX: For the file index, strip the trailing '/'.\n            if (filename.charAt(filename.length - 1) === '/') {\n                filename = filename.substr(0, filename.length - 1);\n            }\n            if (cd.isDirectory()) {\n                index.addPathFast('/' + filename, new DirInode(cd));\n            }\n            else {\n                index.addPathFast('/' + filename, new FileInode(cd));\n            }\n        }\n        static _computeIndex(data, cb) {\n            try {\n                const index = new FileIndex();\n                const eocd = ZipFS._getEOCD(data);\n                if (eocd.diskNumber() !== eocd.cdDiskNumber()) {\n                    return cb(new ApiError(ErrorCode.EINVAL, \"ZipFS does not support spanned zip files.\"));\n                }\n                const cdPtr = eocd.cdOffset();\n                if (cdPtr === 0xFFFFFFFF) {\n                    return cb(new ApiError(ErrorCode.EINVAL, \"ZipFS does not support Zip64.\"));\n                }\n                const cdEnd = cdPtr + eocd.cdSize();\n                ZipFS._computeIndexResponsive(data, index, cdPtr, cdEnd, cb, [], eocd);\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        static _computeIndexResponsiveTrampoline(data, index, cdPtr, cdEnd, cb, cdEntries, eocd) {\n            try {\n                ZipFS._computeIndexResponsive(data, index, cdPtr, cdEnd, cb, cdEntries, eocd);\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        static _computeIndexResponsive(data, index, cdPtr, cdEnd, cb, cdEntries, eocd) {\n            if (cdPtr < cdEnd) {\n                let count = 0;\n                while (count++ < 200 && cdPtr < cdEnd) {\n                    const cd = new CentralDirectory(data, data.slice(cdPtr));\n                    ZipFS._addToIndex(cd, index);\n                    cdPtr += cd.totalSize();\n                    cdEntries.push(cd);\n                }\n                setImmediate(() => {\n                    ZipFS._computeIndexResponsiveTrampoline(data, index, cdPtr, cdEnd, cb, cdEntries, eocd);\n                });\n            }\n            else {\n                cb(null, new ZipTOC(index, cdEntries, eocd, data));\n            }\n        }\n        getName() {\n            return ZipFS.Name + (this.name !== '' ? ` ${this.name}` : '');\n        }\n        /**\n         * Get the CentralDirectory object for the given path.\n         */\n        getCentralDirectoryEntry(path) {\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                throw ApiError.ENOENT(path);\n            }\n            if (isFileInode(inode)) {\n                return inode.getData();\n            }\n            else if (isDirInode(inode)) {\n                return inode.getData();\n            }\n            else {\n                // Should never occur.\n                throw ApiError.EPERM(`Invalid inode: ${inode}`);\n            }\n        }\n        getCentralDirectoryEntryAt(index) {\n            const dirEntry = this._directoryEntries[index];\n            if (!dirEntry) {\n                throw new RangeError(`Invalid directory index: ${index}.`);\n            }\n            return dirEntry;\n        }\n        getNumberOfCentralDirectoryEntries() {\n            return this._directoryEntries.length;\n        }\n        getEndOfCentralDirectory() {\n            return this._eocd;\n        }\n        diskSpace(path, cb) {\n            // Read-only file system.\n            cb(this.data.length, 0);\n        }\n        isReadOnly() {\n            return true;\n        }\n        supportsLinks() {\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            return true;\n        }\n        statSync(path, isLstat) {\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                throw ApiError.ENOENT(path);\n            }\n            let stats;\n            if (isFileInode(inode)) {\n                stats = inode.getData().getStats();\n            }\n            else if (isDirInode(inode)) {\n                stats = inode.getStats();\n            }\n            else {\n                throw new ApiError(ErrorCode.EINVAL, \"Invalid inode.\");\n            }\n            return stats;\n        }\n        openSync(path, flags, mode) {\n            // INVARIANT: Cannot write to RO file systems.\n            if (flags.isWriteable()) {\n                throw new ApiError(ErrorCode.EPERM, path);\n            }\n            // Check if the path exists, and is a file.\n            const inode = this._index.getInode(path);\n            if (!inode) {\n                throw ApiError.ENOENT(path);\n            }\n            else if (isFileInode(inode)) {\n                const cdRecord = inode.getData();\n                const stats = cdRecord.getStats();\n                switch (flags.pathExistsAction()) {\n                    case ActionType.THROW_EXCEPTION:\n                    case ActionType.TRUNCATE_FILE:\n                        throw ApiError.EEXIST(path);\n                    case ActionType.NOP:\n                        return new NoSyncFile(this, path, flags, stats, cdRecord.getData());\n                    default:\n                        throw new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.');\n                }\n            }\n            else {\n                throw ApiError.EISDIR(path);\n            }\n        }\n        readdirSync(path) {\n            // Check if it exists.\n            const inode = this._index.getInode(path);\n            if (!inode) {\n                throw ApiError.ENOENT(path);\n            }\n            else if (isDirInode(inode)) {\n                return inode.getListing();\n            }\n            else {\n                throw ApiError.ENOTDIR(path);\n            }\n        }\n        /**\n         * Specially-optimized readfile.\n         */\n        readFileSync(fname, encoding, flag) {\n            // Get file.\n            const fd = this.openSync(fname, flag, 0x1a4);\n            try {\n                const fdCast = fd;\n                const fdBuff = fdCast.getBuffer();\n                if (encoding === null) {\n                    return copyingSlice(fdBuff);\n                }\n                return fdBuff.toString(encoding);\n            }\n            finally {\n                fd.closeSync();\n            }\n        }\n    }\n    ZipFS.Name = \"ZipFS\";\n    ZipFS.Options = {\n        zipData: {\n            type: \"object\",\n            description: \"The zip file as a Buffer object.\",\n            validator: bufferValidator\n        },\n        name: {\n            type: \"string\",\n            optional: true,\n            description: \"The name of the zip file (optional).\"\n        }\n    };\n    ZipFS.CompressionMethod = CompressionMethod;\n    ZipFS.RegisterDecompressionMethod(CompressionMethod.DEFLATE, (data, compressedSize, uncompressedSize) => {\n        return arrayish2Buffer(inflateRaw(data.slice(0, compressedSize), { chunkSize: uncompressedSize }));\n    });\n    ZipFS.RegisterDecompressionMethod(CompressionMethod.STORED, (data, compressedSize, uncompressedSize) => {\n        return copyingSlice(data, 0, uncompressedSize);\n    });\n\n    return ZipFS;\n\n});\ndefine('skylark-browserfs/backend/IsoFS',[\n    '../core/api_error',\n    '../core/node_fs_stats',\n    '../core/file_system',\n    '../core/file_flag',\n    '../generic/preload_file',\n    '../core/util',\n    '../libs/path'\n], function (api_error,  node_fs_stats,file_system, file_flag, preload_file, util, path) {\n    'use strict';\n\n    const { ApiError, ErrorCode } = api_error;\n    const { Stats, FileType }  = node_fs_stats;\n    const { SynchronousFileSystem }  = file_system;\n    const { ActionType }  = file_flag;\n    const { NoSyncFile }  = preload_file;\n    const { copyingSlice, bufferValidator }  = util;\n\n    /**\n     * @hidden\n     */\n    const rockRidgeIdentifier = \"IEEE_P1282\";\n    /**\n     * @hidden\n     */\n    function getASCIIString(data, startIndex, length) {\n        return data.toString('ascii', startIndex, startIndex + length).trim();\n    }\n    /**\n     * @hidden\n     */\n    function getJolietString(data, startIndex, length) {\n        if (length === 1) {\n            // Special: Root, parent, current directory are still a single byte.\n            return String.fromCharCode(data[startIndex]);\n        }\n        // UTF16-BE, which isn't natively supported by NodeJS Buffers.\n        // Length should be even, but pessimistically floor just in case.\n        const pairs = Math.floor(length / 2);\n        const chars = new Array(pairs);\n        for (let i = 0; i < pairs; i++) {\n            const pos = startIndex + (i << 1);\n            chars[i] = String.fromCharCode(data[pos + 1] | (data[pos] << 8));\n        }\n        return chars.join('');\n    }\n    /**\n     * @hidden\n     */\n    function getDate(data, startIndex) {\n        const year = parseInt(getASCIIString(data, startIndex, 4), 10);\n        const mon = parseInt(getASCIIString(data, startIndex + 4, 2), 10);\n        const day = parseInt(getASCIIString(data, startIndex + 6, 2), 10);\n        const hour = parseInt(getASCIIString(data, startIndex + 8, 2), 10);\n        const min = parseInt(getASCIIString(data, startIndex + 10, 2), 10);\n        const sec = parseInt(getASCIIString(data, startIndex + 12, 2), 10);\n        const hundrethsSec = parseInt(getASCIIString(data, startIndex + 14, 2), 10);\n        // Last is a time-zone offset, but JavaScript dates don't support time zones well.\n        return new Date(year, mon, day, hour, min, sec, hundrethsSec * 100);\n    }\n    /**\n     * @hidden\n     */\n    function getShortFormDate(data, startIndex) {\n        const yearsSince1900 = data[startIndex];\n        const month = data[startIndex + 1];\n        const day = data[startIndex + 2];\n        const hour = data[startIndex + 3];\n        const minute = data[startIndex + 4];\n        const second = data[startIndex + 5];\n        // JavaScript's Date support isn't so great; ignore timezone.\n        // const offsetFromGMT = this._data[24];\n        return new Date(yearsSince1900, month - 1, day, hour, minute, second);\n    }\n    /**\n     * @hidden\n     */\n    function constructSystemUseEntry(bigData, i) {\n        const data = bigData.slice(i);\n        const sue = new SystemUseEntry(data);\n        switch (sue.signatureWord()) {\n            case 17221 /* CE */:\n                return new CEEntry(data);\n            case 20548 /* PD */:\n                return new PDEntry(data);\n            case 21328 /* SP */:\n                return new SPEntry(data);\n            case 21332 /* ST */:\n                return new STEntry(data);\n            case 17746 /* ER */:\n                return new EREntry(data);\n            case 17747 /* ES */:\n                return new ESEntry(data);\n            case 20568 /* PX */:\n                return new PXEntry(data);\n            case 20558 /* PN */:\n                return new PNEntry(data);\n            case 21324 /* SL */:\n                return new SLEntry(data);\n            case 20045 /* NM */:\n                return new NMEntry(data);\n            case 17228 /* CL */:\n                return new CLEntry(data);\n            case 20556 /* PL */:\n                return new PLEntry(data);\n            case 21061 /* RE */:\n                return new REEntry(data);\n            case 21574 /* TF */:\n                return new TFEntry(data);\n            case 21318 /* SF */:\n                return new SFEntry(data);\n            case 21074 /* RR */:\n                return new RREntry(data);\n            default:\n                return sue;\n        }\n    }\n    /**\n     * @hidden\n     */\n    function constructSystemUseEntries(data, i, len, isoData) {\n        // If the remaining allocated space following the last recorded System Use Entry in a System\n        // Use field or Continuation Area is less than four bytes long, it cannot contain a System\n        // Use Entry and shall be ignored\n        len = len - 4;\n        let entries = new Array();\n        while (i < len) {\n            const entry = constructSystemUseEntry(data, i);\n            const length = entry.length();\n            if (length === 0) {\n                // Invalid SU section; prevent infinite loop.\n                return entries;\n            }\n            i += length;\n            if (entry instanceof STEntry) {\n                // ST indicates the end of entries.\n                break;\n            }\n            if (entry instanceof CEEntry) {\n                entries = entries.concat(entry.getEntries(isoData));\n            }\n            else {\n                entries.push(entry);\n            }\n        }\n        return entries;\n    }\n    /**\n     * @hidden\n     */\n    class VolumeDescriptor {\n        constructor(data) {\n            this._data = data;\n        }\n        type() {\n            return this._data[0];\n        }\n        standardIdentifier() {\n            return getASCIIString(this._data, 1, 5);\n        }\n        version() {\n            return this._data[6];\n        }\n        data() {\n            return this._data.slice(7, 2048);\n        }\n    }\n    /**\n     * @hidden\n     */\n    class PrimaryOrSupplementaryVolumeDescriptor extends VolumeDescriptor {\n        constructor(data) {\n            super(data);\n            this._root = null;\n        }\n        systemIdentifier() {\n            return this._getString32(8);\n        }\n        volumeIdentifier() {\n            return this._getString32(40);\n        }\n        volumeSpaceSize() {\n            return this._data.readUInt32LE(80);\n        }\n        volumeSetSize() {\n            return this._data.readUInt16LE(120);\n        }\n        volumeSequenceNumber() {\n            return this._data.readUInt16LE(124);\n        }\n        logicalBlockSize() {\n            return this._data.readUInt16LE(128);\n        }\n        pathTableSize() {\n            return this._data.readUInt32LE(132);\n        }\n        locationOfTypeLPathTable() {\n            return this._data.readUInt32LE(140);\n        }\n        locationOfOptionalTypeLPathTable() {\n            return this._data.readUInt32LE(144);\n        }\n        locationOfTypeMPathTable() {\n            return this._data.readUInt32BE(148);\n        }\n        locationOfOptionalTypeMPathTable() {\n            return this._data.readUInt32BE(152);\n        }\n        rootDirectoryEntry(isoData) {\n            if (this._root === null) {\n                this._root = this._constructRootDirectoryRecord(this._data.slice(156));\n                this._root.rootCheckForRockRidge(isoData);\n            }\n            return this._root;\n        }\n        volumeSetIdentifier() {\n            return this._getString(190, 128);\n        }\n        publisherIdentifier() {\n            return this._getString(318, 128);\n        }\n        dataPreparerIdentifier() {\n            return this._getString(446, 128);\n        }\n        applicationIdentifier() {\n            return this._getString(574, 128);\n        }\n        copyrightFileIdentifier() {\n            return this._getString(702, 38);\n        }\n        abstractFileIdentifier() {\n            return this._getString(740, 36);\n        }\n        bibliographicFileIdentifier() {\n            return this._getString(776, 37);\n        }\n        volumeCreationDate() {\n            return getDate(this._data, 813);\n        }\n        volumeModificationDate() {\n            return getDate(this._data, 830);\n        }\n        volumeExpirationDate() {\n            return getDate(this._data, 847);\n        }\n        volumeEffectiveDate() {\n            return getDate(this._data, 864);\n        }\n        fileStructureVersion() {\n            return this._data[881];\n        }\n        applicationUsed() {\n            return this._data.slice(883, 883 + 512);\n        }\n        reserved() {\n            return this._data.slice(1395, 1395 + 653);\n        }\n        _getString32(idx) {\n            return this._getString(idx, 32);\n        }\n    }\n    /**\n     * @hidden\n     */\n    class PrimaryVolumeDescriptor extends PrimaryOrSupplementaryVolumeDescriptor {\n        constructor(data) {\n            super(data);\n            if (this.type() !== 1 /* PrimaryVolumeDescriptor */) {\n                throw new ApiError(ErrorCode.EIO, `Invalid primary volume descriptor.`);\n            }\n        }\n        name() {\n            return \"ISO9660\";\n        }\n        _constructRootDirectoryRecord(data) {\n            return new ISODirectoryRecord(data, -1);\n        }\n        _getString(idx, len) {\n            return this._getString(idx, len);\n        }\n    }\n    /**\n     * @hidden\n     */\n    class SupplementaryVolumeDescriptor extends PrimaryOrSupplementaryVolumeDescriptor {\n        constructor(data) {\n            super(data);\n            if (this.type() !== 2 /* SupplementaryVolumeDescriptor */) {\n                throw new ApiError(ErrorCode.EIO, `Invalid supplementary volume descriptor.`);\n            }\n            const escapeSequence = this.escapeSequence();\n            const third = escapeSequence[2];\n            // Third character identifies what 'level' of the UCS specification to follow.\n            // We ignore it.\n            if (escapeSequence[0] !== 0x25 || escapeSequence[1] !== 0x2F ||\n                (third !== 0x40 && third !== 0x43 && third !== 0x45)) {\n                throw new ApiError(ErrorCode.EIO, `Unrecognized escape sequence for SupplementaryVolumeDescriptor: ${escapeSequence.toString()}`);\n            }\n        }\n        name() {\n            return \"Joliet\";\n        }\n        escapeSequence() {\n            return this._data.slice(88, 120);\n        }\n        _constructRootDirectoryRecord(data) {\n            return new JolietDirectoryRecord(data, -1);\n        }\n        _getString(idx, len) {\n            return getJolietString(this._data, idx, len);\n        }\n    }\n    /**\n     * @hidden\n     */\n    class DirectoryRecord {\n        constructor(data, rockRidgeOffset) {\n            this._suEntries = null;\n            this._fileOrDir = null;\n            this._data = data;\n            this._rockRidgeOffset = rockRidgeOffset;\n        }\n        hasRockRidge() {\n            return this._rockRidgeOffset > -1;\n        }\n        getRockRidgeOffset() {\n            return this._rockRidgeOffset;\n        }\n        /**\n         * !!ONLY VALID ON ROOT NODE!!\n         * Checks if Rock Ridge is enabled, and sets the offset.\n         */\n        rootCheckForRockRidge(isoData) {\n            const dir = this.getDirectory(isoData);\n            this._rockRidgeOffset = dir.getDotEntry(isoData)._getRockRidgeOffset(isoData);\n            if (this._rockRidgeOffset > -1) {\n                // Wipe out directory. Start over with RR knowledge.\n                this._fileOrDir = null;\n            }\n        }\n        length() {\n            return this._data[0];\n        }\n        extendedAttributeRecordLength() {\n            return this._data[1];\n        }\n        lba() {\n            return this._data.readUInt32LE(2) * 2048;\n        }\n        dataLength() {\n            return this._data.readUInt32LE(10);\n        }\n        recordingDate() {\n            return getShortFormDate(this._data, 18);\n        }\n        fileFlags() {\n            return this._data[25];\n        }\n        fileUnitSize() {\n            return this._data[26];\n        }\n        interleaveGapSize() {\n            return this._data[27];\n        }\n        volumeSequenceNumber() {\n            return this._data.readUInt16LE(28);\n        }\n        identifier() {\n            return this._getString(33, this._data[32]);\n        }\n        fileName(isoData) {\n            if (this.hasRockRidge()) {\n                const fn = this._rockRidgeFilename(isoData);\n                if (fn !== null) {\n                    return fn;\n                }\n            }\n            const ident = this.identifier();\n            if (this.isDirectory(isoData)) {\n                return ident;\n            }\n            // Files:\n            // - MUST have 0x2E (.) separating the name from the extension\n            // - MUST have 0x3B (;) separating the file name and extension from the version\n            // Gets expanded to two-byte char in Unicode directory records.\n            const versionSeparator = ident.indexOf(';');\n            if (versionSeparator === -1) {\n                // Some Joliet filenames lack the version separator, despite the standard\n                // specifying that it should be there.\n                return ident;\n            }\n            else if (ident[versionSeparator - 1] === '.') {\n                // Empty extension. Do not include '.' in the filename.\n                return ident.slice(0, versionSeparator - 1);\n            }\n            else {\n                // Include up to version separator.\n                return ident.slice(0, versionSeparator);\n            }\n        }\n        isDirectory(isoData) {\n            let rv = !!(this.fileFlags() & 2 /* Directory */);\n            // If it lacks the Directory flag, it may still be a directory if we've exceeded the directory\n            // depth limit. Rock Ridge marks these as files and adds a special attribute.\n            if (!rv && this.hasRockRidge()) {\n                rv = this.getSUEntries(isoData).filter((e) => e instanceof CLEntry).length > 0;\n            }\n            return rv;\n        }\n        isSymlink(isoData) {\n            return this.hasRockRidge() && this.getSUEntries(isoData).filter((e) => e instanceof SLEntry).length > 0;\n        }\n        getSymlinkPath(isoData) {\n            let p = \"\";\n            const entries = this.getSUEntries(isoData);\n            const getStr = this._getGetString();\n            for (const entry of entries) {\n                if (entry instanceof SLEntry) {\n                    const components = entry.componentRecords();\n                    for (const component of components) {\n                        const flags = component.flags();\n                        if (flags & 2 /* CURRENT */) {\n                            p += \"./\";\n                        }\n                        else if (flags & 4 /* PARENT */) {\n                            p += \"../\";\n                        }\n                        else if (flags & 8 /* ROOT */) {\n                            p += \"/\";\n                        }\n                        else {\n                            p += component.content(getStr);\n                            if (!(flags & 1 /* CONTINUE */)) {\n                                p += '/';\n                            }\n                        }\n                    }\n                    if (!entry.continueFlag()) {\n                        // We are done with this link.\n                        break;\n                    }\n                }\n            }\n            if (p.length > 1 && p[p.length - 1] === '/') {\n                // Trim trailing '/'.\n                return p.slice(0, p.length - 1);\n            }\n            else {\n                return p;\n            }\n        }\n        getFile(isoData) {\n            if (this.isDirectory(isoData)) {\n                throw new Error(`Tried to get a File from a directory.`);\n            }\n            if (this._fileOrDir === null) {\n                this._fileOrDir = isoData.slice(this.lba(), this.lba() + this.dataLength());\n            }\n            return this._fileOrDir;\n        }\n        getDirectory(isoData) {\n            if (!this.isDirectory(isoData)) {\n                throw new Error(`Tried to get a Directory from a file.`);\n            }\n            if (this._fileOrDir === null) {\n                this._fileOrDir = this._constructDirectory(isoData);\n            }\n            return this._fileOrDir;\n        }\n        getSUEntries(isoData) {\n            if (!this._suEntries) {\n                this._constructSUEntries(isoData);\n            }\n            return this._suEntries;\n        }\n        _rockRidgeFilename(isoData) {\n            const nmEntries = this.getSUEntries(isoData).filter((e) => e instanceof NMEntry);\n            if (nmEntries.length === 0 || nmEntries[0].flags() & (2 /* CURRENT */ | 4 /* PARENT */)) {\n                return null;\n            }\n            let str = '';\n            const getString = this._getGetString();\n            for (const e of nmEntries) {\n                str += e.name(getString);\n                if (!(e.flags() & 1 /* CONTINUE */)) {\n                    break;\n                }\n            }\n            return str;\n        }\n        _constructSUEntries(isoData) {\n            let i = 33 + this._data[32];\n            if (i % 2 === 1) {\n                // Skip padding field.\n                i++;\n            }\n            i += this._rockRidgeOffset;\n            this._suEntries = constructSystemUseEntries(this._data, i, this.length(), isoData);\n        }\n        /**\n         * !!ONLY VALID ON FIRST ENTRY OF ROOT DIRECTORY!!\n         * Returns -1 if rock ridge is not enabled. Otherwise, returns the offset\n         * at which system use fields begin.\n         */\n        _getRockRidgeOffset(isoData) {\n            // In the worst case, we get some garbage SU entries.\n            // Fudge offset to 0 before proceeding.\n            this._rockRidgeOffset = 0;\n            const suEntries = this.getSUEntries(isoData);\n            if (suEntries.length > 0) {\n                const spEntry = suEntries[0];\n                if (spEntry instanceof SPEntry && spEntry.checkBytesPass()) {\n                    // SUSP is in use.\n                    for (let i = 1; i < suEntries.length; i++) {\n                        const entry = suEntries[i];\n                        if (entry instanceof RREntry || (entry instanceof EREntry && entry.extensionIdentifier() === rockRidgeIdentifier)) {\n                            // Rock Ridge is in use!\n                            return spEntry.bytesSkipped();\n                        }\n                    }\n                }\n            }\n            // Failed.\n            this._rockRidgeOffset = -1;\n            return -1;\n        }\n    }\n    /**\n     * @hidden\n     */\n    class ISODirectoryRecord extends DirectoryRecord {\n        constructor(data, rockRidgeOffset) {\n            super(data, rockRidgeOffset);\n        }\n        _getString(i, len) {\n            return getASCIIString(this._data, i, len);\n        }\n        _constructDirectory(isoData) {\n            return new ISODirectory(this, isoData);\n        }\n        _getGetString() {\n            return getASCIIString;\n        }\n    }\n    /**\n     * @hidden\n     */\n    class JolietDirectoryRecord extends DirectoryRecord {\n        constructor(data, rockRidgeOffset) {\n            super(data, rockRidgeOffset);\n        }\n        _getString(i, len) {\n            return getJolietString(this._data, i, len);\n        }\n        _constructDirectory(isoData) {\n            return new JolietDirectory(this, isoData);\n        }\n        _getGetString() {\n            return getJolietString;\n        }\n    }\n    /**\n     * @hidden\n     */\n    class SystemUseEntry {\n        constructor(data) {\n            this._data = data;\n        }\n        signatureWord() {\n            return this._data.readUInt16BE(0);\n        }\n        signatureWordString() {\n            return getASCIIString(this._data, 0, 2);\n        }\n        length() {\n            return this._data[2];\n        }\n        suVersion() {\n            return this._data[3];\n        }\n    }\n    /**\n     * Continuation entry.\n     * @hidden\n     */\n    class CEEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n            this._entries = null;\n        }\n        /**\n         * Logical block address of the continuation area.\n         */\n        continuationLba() {\n            return this._data.readUInt32LE(4);\n        }\n        /**\n         * Offset into the logical block.\n         */\n        continuationLbaOffset() {\n            return this._data.readUInt32LE(12);\n        }\n        /**\n         * Length of the continuation area.\n         */\n        continuationLength() {\n            return this._data.readUInt32LE(20);\n        }\n        getEntries(isoData) {\n            if (!this._entries) {\n                const start = this.continuationLba() * 2048 + this.continuationLbaOffset();\n                this._entries = constructSystemUseEntries(isoData, start, this.continuationLength(), isoData);\n            }\n            return this._entries;\n        }\n    }\n    /**\n     * Padding entry.\n     * @hidden\n     */\n    class PDEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n    }\n    /**\n     * Identifies that SUSP is in-use.\n     * @hidden\n     */\n    class SPEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n        checkBytesPass() {\n            return this._data[4] === 0xBE && this._data[5] === 0xEF;\n        }\n        bytesSkipped() {\n            return this._data[6];\n        }\n    }\n    /**\n     * Identifies the end of the SUSP entries.\n     * @hidden\n     */\n    class STEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n    }\n    /**\n     * Specifies system-specific extensions to SUSP.\n     * @hidden\n     */\n    class EREntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n        identifierLength() {\n            return this._data[4];\n        }\n        descriptorLength() {\n            return this._data[5];\n        }\n        sourceLength() {\n            return this._data[6];\n        }\n        extensionVersion() {\n            return this._data[7];\n        }\n        extensionIdentifier() {\n            return getASCIIString(this._data, 8, this.identifierLength());\n        }\n        extensionDescriptor() {\n            return getASCIIString(this._data, 8 + this.identifierLength(), this.descriptorLength());\n        }\n        extensionSource() {\n            return getASCIIString(this._data, 8 + this.identifierLength() + this.descriptorLength(), this.sourceLength());\n        }\n    }\n    /**\n     * @hidden\n     */\n    class ESEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n        extensionSequence() {\n            return this._data[4];\n        }\n    }\n    /**\n     * RockRidge: Marks that RockRidge is in use [deprecated]\n     * @hidden\n     */\n    class RREntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n    }\n    /**\n     * RockRidge: Records POSIX file attributes.\n     * @hidden\n     */\n    class PXEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n        mode() {\n            return this._data.readUInt32LE(4);\n        }\n        fileLinks() {\n            return this._data.readUInt32LE(12);\n        }\n        uid() {\n            return this._data.readUInt32LE(20);\n        }\n        gid() {\n            return this._data.readUInt32LE(28);\n        }\n        inode() {\n            return this._data.readUInt32LE(36);\n        }\n    }\n    /**\n     * RockRidge: Records POSIX device number.\n     * @hidden\n     */\n    class PNEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n        devTHigh() {\n            return this._data.readUInt32LE(4);\n        }\n        devTLow() {\n            return this._data.readUInt32LE(12);\n        }\n    }\n    /**\n     * RockRidge: Records symbolic link\n     * @hidden\n     */\n    class SLEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n        flags() {\n            return this._data[4];\n        }\n        continueFlag() {\n            return this.flags() & 0x1;\n        }\n        componentRecords() {\n            const records = new Array();\n            let i = 5;\n            while (i < this.length()) {\n                const record = new SLComponentRecord(this._data.slice(i));\n                records.push(record);\n                i += record.length();\n            }\n            return records;\n        }\n    }\n    /**\n     * @hidden\n     */\n    class SLComponentRecord {\n        constructor(data) {\n            this._data = data;\n        }\n        flags() {\n            return this._data[0];\n        }\n        length() {\n            return 2 + this.componentLength();\n        }\n        componentLength() {\n            return this._data[1];\n        }\n        content(getString) {\n            return getString(this._data, 2, this.componentLength());\n        }\n    }\n    /**\n     * RockRidge: Records alternate file name\n     * @hidden\n     */\n    class NMEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n        flags() {\n            return this._data[4];\n        }\n        name(getString) {\n            return getString(this._data, 5, this.length() - 5);\n        }\n    }\n    /**\n     * RockRidge: Records child link\n     * @hidden\n     */\n    class CLEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n        childDirectoryLba() {\n            return this._data.readUInt32LE(4);\n        }\n    }\n    /**\n     * RockRidge: Records parent link.\n     * @hidden\n     */\n    class PLEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n        parentDirectoryLba() {\n            return this._data.readUInt32LE(4);\n        }\n    }\n    /**\n     * RockRidge: Records relocated directory.\n     * @hidden\n     */\n    class REEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n    }\n    /**\n     * RockRidge: Records file timestamps\n     * @hidden\n     */\n    class TFEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n        flags() {\n            return this._data[4];\n        }\n        creation() {\n            if (this.flags() & 1 /* CREATION */) {\n                if (this._longFormDates()) {\n                    return getDate(this._data, 5);\n                }\n                else {\n                    return getShortFormDate(this._data, 5);\n                }\n            }\n            else {\n                return null;\n            }\n        }\n        modify() {\n            if (this.flags() & 2 /* MODIFY */) {\n                const previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;\n                if (this._longFormDates) {\n                    return getDate(this._data, 5 + (previousDates * 17));\n                }\n                else {\n                    return getShortFormDate(this._data, 5 + (previousDates * 7));\n                }\n            }\n            else {\n                return null;\n            }\n        }\n        access() {\n            if (this.flags() & 4 /* ACCESS */) {\n                let previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;\n                previousDates += (this.flags() & 2 /* MODIFY */) ? 1 : 0;\n                if (this._longFormDates) {\n                    return getDate(this._data, 5 + (previousDates * 17));\n                }\n                else {\n                    return getShortFormDate(this._data, 5 + (previousDates * 7));\n                }\n            }\n            else {\n                return null;\n            }\n        }\n        backup() {\n            if (this.flags() & 16 /* BACKUP */) {\n                let previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;\n                previousDates += (this.flags() & 2 /* MODIFY */) ? 1 : 0;\n                previousDates += (this.flags() & 4 /* ACCESS */) ? 1 : 0;\n                if (this._longFormDates) {\n                    return getDate(this._data, 5 + (previousDates * 17));\n                }\n                else {\n                    return getShortFormDate(this._data, 5 + (previousDates * 7));\n                }\n            }\n            else {\n                return null;\n            }\n        }\n        expiration() {\n            if (this.flags() & 32 /* EXPIRATION */) {\n                let previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;\n                previousDates += (this.flags() & 2 /* MODIFY */) ? 1 : 0;\n                previousDates += (this.flags() & 4 /* ACCESS */) ? 1 : 0;\n                previousDates += (this.flags() & 16 /* BACKUP */) ? 1 : 0;\n                if (this._longFormDates) {\n                    return getDate(this._data, 5 + (previousDates * 17));\n                }\n                else {\n                    return getShortFormDate(this._data, 5 + (previousDates * 7));\n                }\n            }\n            else {\n                return null;\n            }\n        }\n        effective() {\n            if (this.flags() & 64 /* EFFECTIVE */) {\n                let previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;\n                previousDates += (this.flags() & 2 /* MODIFY */) ? 1 : 0;\n                previousDates += (this.flags() & 4 /* ACCESS */) ? 1 : 0;\n                previousDates += (this.flags() & 16 /* BACKUP */) ? 1 : 0;\n                previousDates += (this.flags() & 32 /* EXPIRATION */) ? 1 : 0;\n                if (this._longFormDates) {\n                    return getDate(this._data, 5 + (previousDates * 17));\n                }\n                else {\n                    return getShortFormDate(this._data, 5 + (previousDates * 7));\n                }\n            }\n            else {\n                return null;\n            }\n        }\n        _longFormDates() {\n            return !!(this.flags() && 128 /* LONG_FORM */);\n        }\n    }\n    /**\n     * RockRidge: File data in sparse format.\n     * @hidden\n     */\n    class SFEntry extends SystemUseEntry {\n        constructor(data) {\n            super(data);\n        }\n        virtualSizeHigh() {\n            return this._data.readUInt32LE(4);\n        }\n        virtualSizeLow() {\n            return this._data.readUInt32LE(12);\n        }\n        tableDepth() {\n            return this._data[20];\n        }\n    }\n    /**\n     * @hidden\n     */\n    class Directory {\n        constructor(record, isoData) {\n            this._fileList = [];\n            this._fileMap = {};\n            this._record = record;\n            let i = record.lba();\n            let iLimit = i + record.dataLength();\n            if (!(record.fileFlags() & 2 /* Directory */)) {\n                // Must have a CL entry.\n                const cl = record.getSUEntries(isoData).filter((e) => e instanceof CLEntry)[0];\n                i = cl.childDirectoryLba() * 2048;\n                iLimit = Infinity;\n            }\n            while (i < iLimit) {\n                const len = isoData[i];\n                // Zero-padding between sectors.\n                // TODO: Could optimize this to seek to nearest-sector upon\n                // seeing a 0.\n                if (len === 0) {\n                    i++;\n                    continue;\n                }\n                const r = this._constructDirectoryRecord(isoData.slice(i));\n                const fname = r.fileName(isoData);\n                // Skip '.' and '..' entries.\n                if (fname !== '\\u0000' && fname !== '\\u0001') {\n                    // Skip relocated entries.\n                    if (!r.hasRockRidge() || r.getSUEntries(isoData).filter((e) => e instanceof REEntry).length === 0) {\n                        this._fileMap[fname] = r;\n                        this._fileList.push(fname);\n                    }\n                }\n                else if (iLimit === Infinity) {\n                    // First entry contains needed data.\n                    iLimit = i + r.dataLength();\n                }\n                i += r.length();\n            }\n        }\n        /**\n         * Get the record with the given name.\n         * Returns undefined if not present.\n         */\n        getRecord(name) {\n            return this._fileMap[name];\n        }\n        getFileList() {\n            return this._fileList;\n        }\n        getDotEntry(isoData) {\n            return this._constructDirectoryRecord(isoData.slice(this._record.lba()));\n        }\n    }\n    /**\n     * @hidden\n     */\n    class ISODirectory extends Directory {\n        constructor(record, isoData) {\n            super(record, isoData);\n        }\n        _constructDirectoryRecord(data) {\n            return new ISODirectoryRecord(data, this._record.getRockRidgeOffset());\n        }\n    }\n    /**\n     * @hidden\n     */\n    class JolietDirectory extends Directory {\n        constructor(record, isoData) {\n            super(record, isoData);\n        }\n        _constructDirectoryRecord(data) {\n            return new JolietDirectoryRecord(data, this._record.getRockRidgeOffset());\n        }\n    }\n    /**\n     * Mounts an ISO file as a read-only file system.\n     *\n     * Supports:\n     * * Vanilla ISO9660 ISOs\n     * * Microsoft Joliet and Rock Ridge extensions to the ISO9660 standard\n     */\n    class IsoFS extends SynchronousFileSystem {\n        /**\n         * **Deprecated. Please use IsoFS.Create() method instead.**\n         *\n         * Constructs a read-only file system from the given ISO.\n         * @param data The ISO file in a buffer.\n         * @param name The name of the ISO (optional; used for debug messages / identification via getName()).\n         */\n        constructor(data, name = \"\") {\n            super();\n            this._data = data;\n            // Skip first 16 sectors.\n            let vdTerminatorFound = false;\n            let i = 16 * 2048;\n            const candidateVDs = new Array();\n            while (!vdTerminatorFound) {\n                const slice = data.slice(i);\n                const vd = new VolumeDescriptor(slice);\n                switch (vd.type()) {\n                    case 1 /* PrimaryVolumeDescriptor */:\n                        candidateVDs.push(new PrimaryVolumeDescriptor(slice));\n                        break;\n                    case 2 /* SupplementaryVolumeDescriptor */:\n                        candidateVDs.push(new SupplementaryVolumeDescriptor(slice));\n                        break;\n                    case 255 /* VolumeDescriptorSetTerminator */:\n                        vdTerminatorFound = true;\n                        break;\n                }\n                i += 2048;\n            }\n            if (candidateVDs.length === 0) {\n                throw new ApiError(ErrorCode.EIO, `Unable to find a suitable volume descriptor.`);\n            }\n            candidateVDs.forEach((v) => {\n                // Take an SVD over a PVD.\n                if (!this._pvd || this._pvd.type() !== 2 /* SupplementaryVolumeDescriptor */) {\n                    this._pvd = v;\n                }\n            });\n            this._root = this._pvd.rootDirectoryEntry(data);\n            this._name = name;\n        }\n        /**\n         * Creates an IsoFS instance with the given options.\n         */\n        static Create(opts, cb) {\n            try {\n                cb(null, new IsoFS(opts.data, opts.name));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        static isAvailable() {\n            return true;\n        }\n        getName() {\n            let name = `IsoFS${this._name}${this._pvd ? `-${this._pvd.name()}` : ''}`;\n            if (this._root && this._root.hasRockRidge()) {\n                name += `-RockRidge`;\n            }\n            return name;\n        }\n        diskSpace(path, cb) {\n            // Read-only file system.\n            cb(this._data.length, 0);\n        }\n        isReadOnly() {\n            return true;\n        }\n        supportsLinks() {\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            return true;\n        }\n        statSync(p, isLstat) {\n            const record = this._getDirectoryRecord(p);\n            if (record === null) {\n                throw ApiError.ENOENT(p);\n            }\n            return this._getStats(p, record);\n        }\n        openSync(p, flags, mode) {\n            // INVARIANT: Cannot write to RO file systems.\n            if (flags.isWriteable()) {\n                throw new ApiError(ErrorCode.EPERM, p);\n            }\n            // Check if the path exists, and is a file.\n            const record = this._getDirectoryRecord(p);\n            if (!record) {\n                throw ApiError.ENOENT(p);\n            }\n            else if (record.isSymlink(this._data)) {\n                return this.openSync(path.resolve(p, record.getSymlinkPath(this._data)), flags, mode);\n            }\n            else if (!record.isDirectory(this._data)) {\n                const data = record.getFile(this._data);\n                const stats = this._getStats(p, record);\n                switch (flags.pathExistsAction()) {\n                    case ActionType.THROW_EXCEPTION:\n                    case ActionType.TRUNCATE_FILE:\n                        throw ApiError.EEXIST(p);\n                    case ActionType.NOP:\n                        return new NoSyncFile(this, p, flags, stats, data);\n                    default:\n                        throw new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.');\n                }\n            }\n            else {\n                throw ApiError.EISDIR(p);\n            }\n        }\n        readdirSync(path) {\n            // Check if it exists.\n            const record = this._getDirectoryRecord(path);\n            if (!record) {\n                throw ApiError.ENOENT(path);\n            }\n            else if (record.isDirectory(this._data)) {\n                return record.getDirectory(this._data).getFileList().slice(0);\n            }\n            else {\n                throw ApiError.ENOTDIR(path);\n            }\n        }\n        /**\n         * Specially-optimized readfile.\n         */\n        readFileSync(fname, encoding, flag) {\n            // Get file.\n            const fd = this.openSync(fname, flag, 0x1a4);\n            try {\n                const fdCast = fd;\n                const fdBuff = fdCast.getBuffer();\n                if (encoding === null) {\n                    return copyingSlice(fdBuff);\n                }\n                return fdBuff.toString(encoding);\n            }\n            finally {\n                fd.closeSync();\n            }\n        }\n        _getDirectoryRecord(path) {\n            // Special case.\n            if (path === '/') {\n                return this._root;\n            }\n            const components = path.split('/').slice(1);\n            let dir = this._root;\n            for (const component of components) {\n                if (dir.isDirectory(this._data)) {\n                    dir = dir.getDirectory(this._data).getRecord(component);\n                    if (!dir) {\n                        return null;\n                    }\n                }\n                else {\n                    return null;\n                }\n            }\n            return dir;\n        }\n        _getStats(p, record) {\n            if (record.isSymlink(this._data)) {\n                const newP = path.resolve(p, record.getSymlinkPath(this._data));\n                const dirRec = this._getDirectoryRecord(newP);\n                if (!dirRec) {\n                    return null;\n                }\n                return this._getStats(newP, dirRec);\n            }\n            else {\n                const len = record.dataLength();\n                let mode = 0x16D;\n                const date = record.recordingDate().getTime();\n                let atime = date;\n                let mtime = date;\n                let ctime = date;\n                if (record.hasRockRidge()) {\n                    const entries = record.getSUEntries(this._data);\n                    for (const entry of entries) {\n                        if (entry instanceof PXEntry) {\n                            mode = entry.mode();\n                        }\n                        else if (entry instanceof TFEntry) {\n                            const flags = entry.flags();\n                            if (flags & 4 /* ACCESS */) {\n                                atime = entry.access().getTime();\n                            }\n                            if (flags & 2 /* MODIFY */) {\n                                mtime = entry.modify().getTime();\n                            }\n                            if (flags & 1 /* CREATION */) {\n                                ctime = entry.creation().getTime();\n                            }\n                        }\n                    }\n                }\n                // Mask out writeable flags. This is a RO file system.\n                mode = mode & 0x16D;\n                return new Stats(record.isDirectory(this._data) ? FileType.DIRECTORY : FileType.FILE, len, mode, atime, mtime, ctime);\n            }\n        }\n    }\n    IsoFS.Name = \"IsoFS\";\n    IsoFS.Options = {\n        data: {\n            type: \"object\",\n            description: \"The ISO file in a buffer\",\n            validator: bufferValidator\n        }\n    };\n\n\n    return IsoFS;\n});\ndefine('skylark-browserfs/core/backends',[\n    './util',\n    '../backend/AsyncMirror',\n    '../backend/Dropbox',\n    '../backend/Emscripten',\n    '../backend/FolderAdapter',\n    '../backend/HTML5FS',\n    '../backend/InMemory',\n    '../backend/IndexedDB',\n    '../backend/LocalStorage',\n    '../backend/MountableFileSystem',\n    '../backend/OverlayFS',\n    '../backend/WorkerFS',\n    '../backend/HTTPRequest',\n    '../backend/ZipFS',\n    '../backend/IsoFS'\n], function (util, AsyncMirror, Dropbox, Emscripten, FolderAdapter, HTML5FS, InMemory, IndexedDB, LocalStorage, MountableFileSystem, OverlayFS, WorkerFS, HTTPRequest, ZipFS, IsoFS) {\n    'use strict';\n    const { checkOptions } = util;\n\n    \n\n    // Monkey-patch `Create` functions to check options before file system initialization.\n    [AsyncMirror, Dropbox, Emscripten, FolderAdapter, HTML5FS, InMemory, IndexedDB, IsoFS, LocalStorage, MountableFileSystem, OverlayFS, WorkerFS, HTTPRequest, ZipFS].forEach((fsType) => {\n        const create = fsType.Create;\n        fsType.Create = function (opts, cb) {\n            const oneArg = typeof (opts) === \"function\";\n            const normalizedCb = oneArg ? opts : cb;\n            const normalizedOpts = oneArg ? {} : opts;\n            function wrappedCb(e) {\n                if (e) {\n                    normalizedCb(e);\n                }\n                else {\n                    create.call(fsType, normalizedOpts, normalizedCb);\n                }\n            }\n            checkOptions(fsType, normalizedOpts, wrappedCb);\n        };\n    });\n    /**\n     * @hidden\n     */\n    const Backends = { AsyncMirror, Dropbox, Emscripten, FolderAdapter, HTML5FS, InMemory, IndexedDB, IsoFS, LocalStorage, MountableFileSystem, OverlayFS, WorkerFS, HTTPRequest, XmlHttpRequest: HTTPRequest, ZipFS };\n    // Make sure all backends cast to FileSystemConstructor (for type checking)\n    const _ = Backends;\n    // tslint:disable-next-line:no-unused-expression\n    _;\n    // tslint:enable-next-line:no-unused-expression\n    return Backends;\n});\ndefine('skylark-browserfs/core/browserfs',[\n    '../libs/process',\n    '../libs/buffers',\n    './node_fs',\n    '../libs/path',\n    '../generic/emscripten_fs',\n    './backends',\n    './util',\n    './api_error',\n    '../generic/setImmediate'\n], function (process,buffers, fs, path, EmscriptenFS, Backends, BFSUtils, Errors, setImmediate) {\n    'use strict';\n\n    const {Buffer} = buffers;\n    \n    /**\n     * BrowserFS's main module. This is exposed in the browser via the BrowserFS global.\n     * Due to limitations in typedoc, we document these functions in ./typedoc.ts.\n     */\n    if (process['initializeTTYs']) {\n        process['initializeTTYs']();\n    }\n    /**\n     * Installs BFSRequire as global `require`, a Node Buffer polyfill as the global `Buffer` variable,\n     * and a Node process polyfill as the global `process` variable.\n     */\n    function install(obj) {\n        obj.Buffer = Buffer;\n        obj.process = process;\n        const oldRequire = obj.require ? obj.require : null;\n        // Monkey-patch require for Node-style code.\n        obj.require = function (arg) {\n            const rv = BFSRequire(arg);\n            if (!rv) {\n                return oldRequire.apply(null, Array.prototype.slice.call(arguments, 0));\n            }\n            else {\n                return rv;\n            }\n        };\n    }\n    /**\n     * @hidden\n     */\n    function registerFileSystem(name, fs) {\n        Backends[name] = fs;\n    }\n    function BFSRequire(module) {\n        switch (module) {\n            case 'fs':\n                return fs;\n            case 'path':\n                return path;\n            case 'buffer':\n                // The 'buffer' module has 'Buffer' as a property.\n                return buffer;\n            case 'process':\n                return process;\n            case 'bfs_utils':\n                return BFSUtils;\n            default:\n                return Backends[module];\n        }\n    }\n    /**\n     * Initializes BrowserFS with the given root file system.\n     */\n    function initialize(rootfs) {\n        return fs.initialize(rootfs);\n    }\n    /**\n     * Creates a file system with the given configuration, and initializes BrowserFS with it.\n     * See the FileSystemConfiguration type for more info on the configuration object.\n     */\n    function configure(config, cb) {\n        getFileSystem(config, (e, fs) => {\n            if (fs) {\n                initialize(fs);\n                cb();\n            }\n            else {\n                cb(e);\n            }\n        });\n    }\n    /**\n     * Retrieve a file system with the given configuration.\n     * @param config A FileSystemConfiguration object. See FileSystemConfiguration for details.\n     * @param cb Called when the file system is constructed, or when an error occurs.\n     */\n    function getFileSystem(config, cb) {\n        const fsName = config['fs'];\n        if (!fsName) {\n            return cb(new Errors.ApiError(Errors.ErrorCode.EPERM, 'Missing \"fs\" property on configuration object.'));\n        }\n        const options = config['options'];\n        let waitCount = 0;\n        let called = false;\n        function finish() {\n            if (!called) {\n                called = true;\n                const fsc = Backends[fsName];\n                if (!fsc) {\n                    cb(new Errors.ApiError(Errors.ErrorCode.EPERM, `File system ${fsName} is not available in BrowserFS.`));\n                }\n                else {\n                    fsc.Create(options, cb);\n                }\n            }\n        }\n        if (options !== null && typeof (options) === \"object\") {\n            let finishedIterating = false;\n            const props = Object.keys(options).filter((k) => k !== 'fs');\n            // Check recursively if other fields have 'fs' properties.\n            props.forEach((p) => {\n                const d = options[p];\n                if (d !== null && typeof (d) === \"object\" && d['fs']) {\n                    waitCount++;\n                    getFileSystem(d, function (e, fs) {\n                        waitCount--;\n                        if (e) {\n                            if (called) {\n                                return;\n                            }\n                            called = true;\n                            cb(e);\n                        }\n                        else {\n                            options[p] = fs;\n                            if (waitCount === 0 && finishedIterating) {\n                                finish();\n                            }\n                        }\n                    });\n                }\n            });\n            finishedIterating = true;\n        }\n        if (waitCount === 0) {\n            finish();\n        }\n    }\n\n    return {\n        install: install,\n        registerFileSystem: registerFileSystem,\n        BFSRequire: BFSRequire,\n        initialize: initialize,\n        configure: configure,\n        getFileSystem: getFileSystem,\n        EmscriptenFS,\n        \"FileSystem\" : Backends,\n        Errors,\n        setImmediate\n    };\n});\ndefine('skylark-browserfs/main',[\n    \"./core/browserfs\"\n],function(browserfs){\n    return browserfs;\n});\ndefine('skylark-browserfs', ['skylark-browserfs/main'], function (main) { return main; });\n\ndefine('skylark-98js/helpers',[\n\t\"skylark-jquery\",\n\t\"./win98\"\n],function($,win98js){\n\tvar TAU =     //////|//////\n\t          /////     |     /////\n\t       ///         tau         ///\n\t     ///     ...--> | <--...     ///\n\t   ///     -'   one | turn  '-     ///\n\t  //     .'         |         '.     //\n\t //     /           |           \\     //\n\t//     |            | <-..       |     //\n\t//    |          .->|     \\       |    //\n\t//    |         /   |      |      |    //\n\t- - - - - - Math.PI + Math.PI - - - - - 0\n\t//    |         \\   |      |      |    //\n\t//    |          '->|     /       |    //\n\t//     |            | <-''       |     //\n\t //     \\           |           /     //\n\t  //     '.         |         .'     //\n\t   ///     -.       |       .-     ///\n\t     ///     '''----|----'''     ///\n\t       ///          |          ///\n\t         //////     |     /////\n\t              //////|//////          C/r;\n\n\tvar $G = $(window);\n\n\tfunction Cursor(cursor_def) {\n\t\treturn \"url(images/cursors/\" + cursor_def[0] + \".png) \" +\n\t\t\tcursor_def[1].join(\" \") +\n\t\t\t\", \" + cursor_def[2]\n\t}\n\n\tfunction E(t) {\n\t\treturn document.createElement(t);\n\t}\n\n\tvar DESKTOP_ICON_SIZE = 32;\n\tvar TASKBAR_ICON_SIZE = 16;\n\tvar TITLEBAR_ICON_SIZE = 16;\n\n\t// For Wayback Machine, match URLs like https://web.archive.org/web/20191213113214/https://98.js.org/\n\t// (also match URLs like https://98.js.org/ because why not)\n\tconst web_server_root_for_icons =\n\t\tlocation.href.match(/98.js.org/) ?\n\t\t\tlocation.href.match(/.*98.js.org/)[0] + \"/\" :\n\t\t\t\"/\";\n\n\tfunction getIconPath(iconID, size) {\n\t\treturn web_server_root_for_icons + \"images/icons/\" + iconID + \"-\" + size + \"x\" + size + \".png\";\n\t}\n\n\tfunction Canvas(width, height) {\n\t\tvar new_canvas = E(\"canvas\");\n\t\tvar new_ctx = new_canvas.getContext(\"2d\");\n\t\tnew_ctx.imageSmoothingEnabled = false;\n\t\tnew_ctx.mozImageSmoothingEnabled = false;\n\t\tnew_ctx.webkitImageSmoothingEnabled = false;\n\t\tif (width && height) {\n\t\t\t// new Canvas(width, height)\n\t\t\tnew_canvas.width = width;\n\t\t\tnew_canvas.height = height;\n\t\t} else {\n\t\t\t// new Canvas(image)\n\t\t\tvar copy_of = width;\n\t\t\tif (copy_of) {\n\t\t\t\tnew_canvas.width = copy_of.width;\n\t\t\t\tnew_canvas.height = copy_of.height;\n\t\t\t\tnew_ctx.drawImage(copy_of, 0, 0);\n\t\t\t}\n\t\t}\n\t\tnew_canvas.ctx = new_ctx;\n\t\treturn new_canvas;\n\t}\n\n\tfunction mustHaveMethods(obj, methodNames) {\n\t\tfor (const methodName of methodNames) {\n\t\t\tif (typeof obj[methodName] != 'function') {\n\t\t\t\tconsole.error(\"Missing method\", methodName, \"on object\", obj);\n\t\t\t\tthrow new TypeError(\"missing method \" + methodName);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tconst windowInterfaceMethods = [\n\t\t\"close\",\n\t\t\"minimize\",\n\t\t\"unminimize\",\n\t\t// \"maximize\",\n\t\t// \"unmaximize\",\n\t\t\"bringToFront\", // TODO: maybe setZIndex instead\n\t\t\"getTitle\",\n\t\t// \"getIconName\",\n\t\t\"getIconAtSize\",\n\t\t\"focus\",\n\t\t\"blur\",\n\t\t\"onFocus\",\n\t\t\"onBlur\",\n\t\t\"onClosed\",\n\t];\n\n\n\tfunction file_name_from_path(file_path) {\n\t\treturn file_path.split(\"\\\\\").pop().split(\"/\").pop();\n\t}\n\n\tfunction file_extension_from_path(file_path) {\n\t\treturn (file_path.match(/\\.(\\w+)$/) || [, \"\"])[1];\n\t}\n\treturn {\n\t\tCursor,\n\t\tDESKTOP_ICON_SIZE,\n\t\tTASKBAR_ICON_SIZE,\n\t\tTITLEBAR_ICON_SIZE,\n\t\tgetIconPath,\n\t\tCanvas,\n\t\tmustHaveMethods,\n\t\twindowInterfaceMethods,\n\t\tfile_name_from_path,\n\n\t\tfile_extension_from_path\n\t}\n});\ndefine('skylark-98js/FolderViewItem',[\n\t\"skylark-jquery\",\n\t\"./win98\",\n\t\"./helpers\"\n],function($,win98js,helpers){\n    \"use strict\";\n\n\tfunction FolderViewItem(options) {\n\t\t// TODO: rename options to be consistent,\n\t\t// like is_folder, is_shortcut, etc.\n\t\t// TODO: rename CSS class to folder-view-item, or find a better name\n\t\tvar $container = $(\"<div class='desktop-icon' draggable='true' tabindex=-1/>\");\n\t\tvar $icon_wrapper = $(\"<div class='icon-wrapper'/>\").appendTo($container);\n\t\tvar $selection_effect = $(\"<div class='selection-effect'/>\").appendTo($icon_wrapper);\n\t\tvar $title = $(\"<div class='title'/>\").text(options.title);\n\t\tvar $icon;\n\t\t$container.append($icon_wrapper, $title);\n\n\t\t// TODO: handle the loading state display in some intentional way\n\n\t\t// TODO: or if set to \"web\" mode, single click\n\t\t// also Enter is currently implemented by triggering dblclick which is awkward\n\t\tlet single_click_timeout;\n\t\t$container.on(\"dblclick\", (event) => {\n\t\t\tif (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {\n\t\t\t\treturn; // Not true to Windows 98. But in Windows 98 it doesn't do two things, it just does the double click action.\n\t\t\t\t// At any rate, it feels nice to make Ctrl+click do only one thing (toggling the selection state).\n\t\t\t}\n\t\t\toptions.open();\n\t\t\tclearTimeout(single_click_timeout);\n\t\t});\n\t\t// TODO: allow dragging files out from this folder view to the system file browser, with dataTransfer.setData(\"DownloadURL\", ...)\n\t\t// sadly will only work for a single file (unless it secretly supports text/uri-list (either as a separate type or for DownloadURL))\n\t\t// also it won't work if I want to do custom drag-and-drop (e.g. repositioning icons)\n\t\t// so I have to choose one feature or the other (right?), probably custom drag-and-drop\n\n\t\t$title.on(\"click\", () => {\n\t\t\tif (!$container[0]._was_selected_at_pointerdown) {\n\t\t\t\treturn; // this click is for selecting the item\n\t\t\t}\n\t\t\t// @TODO: if the folder view wasn't focused at pointerdown,\n\t\t\t// don't start rename\n\t\t\tsingle_click_timeout = setTimeout(() => {\n\t\t\t\tif ($container.hasClass(\"selected\")) {\n\t\t\t\t\tthis.start_rename();\n\t\t\t\t}\n\t\t\t}, 500);\n\t\t});\n\n\t\tif (options.shortcut) {\n\t\t\t$container.addClass(\"shortcut\");\n\t\t}\n\t\t$container[0].dataset.filePath = options.file_path;\n\n\t\tthis.element = $container[0];\n\n\t\tthis.icons = options.icons;\n\t\tthis.iconSize = options.iconSize || helpers.DESKTOP_ICON_SIZE;\n\n\t\tthis.file_path = options.file_path;\n\t\tthis.is_system_folder = options.is_system_folder;\n\n\t\tthis._update_icon = () => {\n\t\t\tif (this.icons) {\n\t\t\t\tconst $old_icon = $icon;\n\t\t\t\tconst src = this.icons[this.iconSize];\n\t\t\t\t$icon = $(\"<img class='icon'/>\");\n\t\t\t\t$icon.attr({\n\t\t\t\t\tdraggable: false,\n\t\t\t\t\tsrc,\n\t\t\t\t\twidth: this.iconSize,\n\t\t\t\t\theight: this.iconSize,\n\t\t\t\t});\n\t\t\t\t$selection_effect[0].style.setProperty(\"--icon-image\", `url(\"${src}\")`);\n\t\t\t\tif ($old_icon) {\n\t\t\t\t\t$old_icon.replaceWith($icon);\n\t\t\t\t} else {\n\t\t\t\t\t$icon_wrapper.prepend($icon);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$icon && $icon.remove();\n\t\t\t\t$icon = null;\n\t\t\t\t$selection_effect[0].style.setProperty(\"--icon-image\", \"none\");\n\t\t\t}\n\t\t\t$icon_wrapper[0].style.setProperty(\"--icon-size\", this.iconSize + \"px\");\n\t\t\t$icon_wrapper[0].style.setProperty(\"--shortcut-icon\", `url(\"${helpers.getIconPath(\"shortcut\", this.iconSize)}\")`);\n\t\t};\n\t\tthis.setIcons = (new_icons) => {\n\t\t\tthis.icons = new_icons;\n\t\t\tthis._update_icon();\n\t\t};\n\t\tthis.setIconSize = (new_size) => {\n\t\t\tif (this.iconSize === new_size) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.iconSize = new_size;\n\t\t\tthis._update_icon();\n\t\t};\n\t\tthis._update_icon();\n\n\t\tthis.start_rename = () => {\n\t\t\tif (!options.rename) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ($container.hasClass(\"renaming\")) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t$container.addClass(\"renaming\");\n\t\t\t$container.attr(\"draggable\", false);\n\t\t\tconst old_title = $title.text();\n\t\t\t// @TODO: auto-size the input box,\n\t\t\t// and wrap to multiple lines\n\t\t\tconst $input = $(\"<input type='text'/>\");\n\t\t\t$input.val(old_title);\n\t\t\t$input.on(\"keydown\", (e) => {\n\t\t\t\t// relying on blur event to trigger the rename,\n\t\t\t\t// or to reset the input to the old title\n\t\t\t\tif (e.key === \"Enter\") {\n\t\t\t\t\t$container.focus();\n\t\t\t\t\te.preventDefault();\n\t\t\t\t} else if (e.key === \"Escape\") {\n\t\t\t\t\t$input.val(old_title);\n\t\t\t\t\t$container.focus();\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t});\n\t\t\t$input.on(\"blur\", () => {\n\t\t\t\tconst new_title = $input.val();\n\t\t\t\tif (new_title.trim() === \"\") {\n\t\t\t\t\tshowMessageBox({\n\t\t\t\t\t\ttitle: \"Rename\",\n\t\t\t\t\t\tmessage: \"You must type a filename.\",\n\t\t\t\t\t\ticonID: \"error\",\n\t\t\t\t\t}).then(() => {\n\t\t\t\t\t\t$input.focus(); // @TODO: why is this needed? it's supposed to refocus the last focused element\n\t\t\t\t\t\t// well I guess it doesn't work for the desktop, just windows\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t$input.remove(); // technically not necessary\n\t\t\t\t$title.text(new_title);\n\t\t\t\t$container.removeClass(\"renaming\");\n\t\t\t\t$container.attr(\"draggable\", true);\n\t\t\t\tif (new_title !== old_title) {\n\t\t\t\t\t// console.log(\"renaming\", this.file_path, \"to\", new_title);\n\t\t\t\t\toptions.rename(new_title)\n\t\t\t\t\t\t.catch((error) => {\n\t\t\t\t\t\t\t$title.text(old_title);\n\t\t\t\t\t\t\talert(\"Failed to rename:\\n\\n\" + error);\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\t$title.empty().append($input);\n\t\t\t$input[0].focus();\n\t\t\t$input[0].select();\n\t\t};\n\t}\n\n\treturn FolderViewItem;\n});\ndefine('skylark-98js/filesystem-setup',[\n\t\"skylark-jquery\",\n\t\"skylark-browserfs\",\n\t\"./win98\"\n],function($,BrowserFS, win98js){\n\n\tvar __fs_initialized;\n\tvar __fs_errored;\n\tvar __fs_timed_out;\n\tvar __fs_waiting_callbacks = [];\n\n\n\t// For Wayback Machine, match URLs like https://web.archive.org/web/20191213113214/https://98.js.org/\n\t// (also match URLs like https://98.js.org/ because why not)\n\tconst web_server_root_for_browserfs =\n\t\tlocation.href.match(/98.js.org/) ?\n\t\t\tlocation.href.match(/.*98.js.org/)[0] + \"/\" :\n\t\t\t\"/\";\n\n\tBrowserFS.configure({\n\t\tfs: \"OverlayFS\",\n\t\toptions: {\n\t\t\twritable: {\n\t\t\t\tfs: \"IndexedDB\",\n\t\t\t\toptions: {\n\t\t\t\t\tstoreName: \"C:\"\n\t\t\t\t}\n\t\t\t},\n\t\t\treadable: {\n\t\t\t\tfs: \"XmlHttpRequest\",\n\t\t\t\toptions: {\n\t\t\t\t\tindex: web_server_root_for_browserfs + \"filesystem-index.json\",\n\t\t\t\t\tbaseUrl: web_server_root_for_browserfs\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// TODO: mount the repo contents at something like C:\\98\\\n\t\t// but other OS stuff from a subfolder of the repo as root (C? HD? hard-drive? disk? OS?)\n\t\t// the desktop at something like.. well I guess C:\\98\\desktop\n\t\t// and I could have the default desktop setup in source control there\n\t}, function (error) {\n\t\tif (error) {\n\t\t\t__fs_errored = true;\n\t\t\tif (__fs_waiting_callbacks.length) {\n\t\t\t\t// TODO: DRY (can probably simplify this logic significantly)\n\t\t\t\talert(\"The filesystem is not available. It failed to initialize.\");\n\t\t\t}\n\t\t\t__fs_waiting_callbacks = [];\n\t\t\t// TODO: message box; offer to reset the filesystem\n\t\t\tthrow error;\n\t\t}\n\t\t__fs_initialized = true;\n\t\tfor (var i = 0; i < __fs_waiting_callbacks.length; i++) {\n\t\t\t__fs_waiting_callbacks[i]();\n\t\t}\n\t\t__fs_waiting_callbacks = [];\n\t});\n\n\tsetTimeout(function () {\n\t\t__fs_timed_out = true;\n\t\tif (__fs_waiting_callbacks.length) {\n\t\t\t// TODO: DRY (can probably simplify this logic significantly)\n\t\t\talert(\"The filesystem is not working.\");\n\t\t}\n\t\t__fs_waiting_callbacks = [];\n\t}, 5000);\n\n\tfunction withFilesystem(callback) {\n\t\tif (__fs_initialized) {\n\t\t\tcallback();\n\t\t} else if (__fs_errored) {\n\t\t\talert(\"The filesystem is not available. It failed to initialize.\");\n\t\t} else if (__fs_timed_out) {\n\t\t\talert(\"The filesystem is not working.\");\n\t\t} else {\n\t\t\t// wait within a global period of time while it should be configuring (and not show a message box)\n\t\t\t// TODO: hm, maybe a global timeout isn't what we want\n\t\t\t// The desktop should load, regardless of how long it takes.\n\t\t\t// Other operations could fail in a second or more. Depending on the operation.\n\t\t\t__fs_waiting_callbacks.push(callback);\n\t\t}\n\t}\n\t// TODO: never use alert(); use thematic, non-blocking dialog windows, preferably with warning and error icons\n\t// I have a show_error_message in jspaint, but with no warning or error icons - as of writing; see https://github.com/1j01/jspaint/issues/84\n\n\n\treturn {\n\t\twithFilesystem\n\t}\n\n});\ndefine('skylark-98js/FolderView',[\n\t\"skylark-jquery\",\n\t\"skylark-browserfs\",\n\t\"./win98\",\n\t\"./FolderViewItem\",\n\t\"./filesystem-setup\",\n\t\"./helpers\"\n],function($,BrowserFS, win98js,FolderViewItem,FilesystemSetup,helpers){\n\tconst grid_size_x_for_large_icons = 75;\n\tconst grid_size_y_for_large_icons = 75;\n\t// @TODO: this is supposed to be dynamic based on length of names\n\tconst grid_size_x_for_small_icons = 150;\n\tconst grid_size_y_for_small_icons = 17;\n\n\twindow.resetAllFolderCustomizations = () => {\n\t\tfor (let i = 0; i < localStorage.length; i++) {\n\t\t\tif (localStorage.key(i).startsWith(\"folder-config:\")) {\n\t\t\t\tlocalStorage.removeItem(localStorage.key(i));\n\t\t\t}\n\t\t}\n\t};\n\n\tconst icon_size_by_view_mode = {\n\t\tLARGE_ICONS: 32,\n\t\tSMALL_ICONS: 16,\n\t\tDETAILS: 16,\n\t\tLIST: 16,\n\t\tDESKTOP: 32,\n\t};\n\n\tFolderView.VIEW_MODES = {\n\t\tTHUMBNAILS: \"THUMBNAILS\", // hidden until you right click in a folder, go to Properties, and enable thumbnails\n\t\tLARGE_ICONS: \"LARGE_ICONS\", // left to right, then top to bottom\n\t\tSMALL_ICONS: \"SMALL_ICONS\", // left to right, then top to bottom\n\t\tDETAILS: \"DETAILS\", // table view\n\t\tLIST: \"LIST\", // top to bottom, then left to right\n\t\tDESKTOP: \"DESKTOP\", // like Large Icons, but arranged top to bottom before left to right; does not apply to the Desktop folder, only the Desktop itself\n\t};\n\n\tFolderView.SORT_MODES = {\n\t\tNAME: \"NAME\",\n\t\tTYPE: \"TYPE\",\n\t\tSIZE: \"SIZE\",\n\t\tDATE: \"DATE\",\n\t\t// there are many other attributes, some for specific types of files/objects\n\t};\n\n\t// TODO: what's the \"right\" way to do file type / program associations for icons?\n\n\t// TODO: get more icons; can extract from shell32.dll, moricons.dll, and other files from a VM\n\t// also get more file extensions; can find a mime types listing data dump\n\t// https://github.com/1j01/retrores\n\t// Note: extensions must be lowercase here. This is used to implement case-insensitive matching.\n\tvar file_extension_icons = {\n\t\ttxt: \"notepad-file\",\n\t\tmd: \"notepad-file\",\n\t\tjson: \"notepad-file\",\n\t\tjs: \"notepad-file\",\n\t\tcss: \"notepad-file\",\n\t\thtml: \"notepad-file\",\n\t\tgitattributes: \"notepad-file\",\n\t\tgitignore: \"notepad-file\",\n\t\tpng: \"image-gif\", // \"image-png\"? nope... (but should it be image-gif or image-wmf?)\n\t\tjpg: \"image-jpeg\",\n\t\tjpeg: \"image-jpeg\",\n\t\tgif: \"image-gif\",\n\t\twebp: \"image-other\",\n\t\tbmp: \"paint-file\",\n\t\ttif: \"kodak-imaging-file\",\n\t\ttiff: \"kodak-imaging-file\",\n\t\t// wmf: \"image-wmf\"? nope (https://en.wikipedia.org/wiki/Windows_Metafile)\n\t\t// emf: \"image-wmf\"? nope\n\t\t// wmz: \"image-wmf\"? nope\n\t\t// emz: \"image-wmf\"? nope\n\t\twav: \"sound\",\n\t\tmp3: \"sound\", // TODO: show blue video icon, as it's a container format that can contain video\n\t\togg: \"sound\", // TODO: probably ditto\n\t\twma: \"sound\",\n\t\t// \"doc\": \"doc\"?\n\t\t\"exe\": \"task\",\n\t\thtm: \"html\",\n\t\thtml: \"html\",\n\t\turl: \"html\",\n\t\ttheme: \"themes\",\n\t\tthemepack: \"themes\",\n\t};\n\n\t// @TODO: maintain less fake naming abstraction\n\t// base it more on the actual filesystem\n\t// @TODO: bring system folders, icons, and file associations into one place\n\tconst system_folder_path_to_name = {\n\t\t\"/\": \"(C:)\", //\"My Computer\",\n\t\t\"/my-pictures/\": \"My Pictures\",\n\t\t\"/my-documents/\": \"My Documents\",\n\t\t\"/network-neighborhood/\": \"Network Neighborhood\",\n\t\t\"/desktop/\": \"Desktop\",\n\t\t\"/programs/\": \"Program Files\",\n\t\t\"/recycle-bin/\": \"Recycle Bin\",\n\t};\n\tconst system_folder_name_to_path = Object.fromEntries(\n\t\tObject.entries(system_folder_path_to_name).map(([key, value]) => [value, key])\n\t);\n\tconst system_folder_lowercase_name_to_path = Object.fromEntries(\n\t\tObject.entries(system_folder_name_to_path).map(([key, value]) => [key.toLowerCase(), value])\n\t);\n\n\n\tconst set_dragging_file_paths = (dragging_file_paths) => {\n\t\twindow.dragging_file_paths = dragging_file_paths;\n\t\tlet frame = window;\n\t\twhile (frame !== frame.parent) {\n\t\t\tframe = frame.parent;\n\t\t\tframe.dragging_file_paths = dragging_file_paths;\n\t\t}\n\t};\n\n\tfunction FolderView(folder_path, { asDesktop = false, onStatus, openFolder, openFileOrFolder, onConfigure } = {}) {\n\t\tconst self = this;\n\t\t// TODO: ensure a trailing slash / use path.join where appropriate\n\n\t\tvar $folder_view = $(`<div class=\"folder-view\" tabindex=\"0\">`);\n\n\t\tthis.element = $folder_view[0];\n\n\t\tthis.items = [];\n\n\t\tthis.add_item = (folder_view_item) => {\n\t\t\t$folder_view.append(folder_view_item.element);\n\t\t\tthis.items.push(folder_view_item);\n\t\t\t// if (this.items.length === 1) {\n\t\t\t// \t// this.items[0].element.focus();\n\t\t\t// \tthis.items[0].element.classList.add(\"focused\");\n\t\t\t// }\n\t\t};\n\n\t\t// config:\n\t\t// - [x] view_mode\n\t\t// - [x] sort_mode\n\t\t// - [ ] auto_arrange\n\t\t// - [ ] icon_positions\n\t\t// - [x] view_as_web_page\n\n\t\tthis.config = {};\n\t\tvar storage_key = `folder-config:${asDesktop ? \"desktop\" : folder_path}`;\n\t\ttry {\n\t\t\tconst config_json = localStorage.getItem(storage_key);\n\t\t\tconst config = JSON.parse(config_json);\n\t\t\tif (config) {\n\t\t\t\tObject.assign(this.config, config);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to read folder config:\", e);\n\t\t}\n\t\t// Handling defaults and invalid values at the same time\n\t\tif (!FolderView.VIEW_MODES[this.config.view_mode]) {\n\t\t\tthis.config.view_mode = asDesktop ?\n\t\t\t\tFolderView.VIEW_MODES.DESKTOP :\n\t\t\t\tFolderView.VIEW_MODES.LARGE_ICONS;\n\t\t}\n\t\tif (!FolderView.SORT_MODES[this.config.sort_mode]) {\n\t\t\tthis.config.sort_mode = FolderView.SORT_MODES.NAME;\n\t\t}\n\t\t///this.config.view_as_web_page ??= folder_path !== \"/desktop/\";\n\t\tif (!this.config.view_as_web_page) {\n\t\t\tthis.config.view_as_web_page = folder_path !== \"/desktop/\";\n\t\t}\n\n\t\tthis.element.dataset.viewMode = this.config.view_mode;\n\t\tthis.configure = (config_props) => {\n\t\t\tObject.assign(this.config, config_props);\n\t\t\tif (config_props.view_mode) {\n\t\t\t\tthis.element.dataset.viewMode = config_props.view_mode;\n\t\t\t}\n\t\t\tthis.arrange_icons();\n\t\t\ttry {\n\t\t\t\tlocalStorage.setItem(storage_key, JSON.stringify(this.config));\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Can't write to localStorage:\", e);\n\t\t\t}\n\t\t\t///onConfigure?.(config_props);\n\t\t\tif (onConfigure) {\n\t\t\t\tonConfigure(config_props);\n\t\t\t}\n\t\t};\n\n\t\tthis.cycle_view_mode = () => {\n\t\t\t// const view_modes = Object.values(FolderView.VIEW_MODES);\n\t\t\tconst view_modes = [\n\t\t\t\t// FolderView.VIEW_MODES.THUMBNAILS, conditionally?\n\t\t\t\tFolderView.VIEW_MODES.LARGE_ICONS,\n\t\t\t\tFolderView.VIEW_MODES.SMALL_ICONS,\n\t\t\t\tFolderView.VIEW_MODES.LIST,\n\t\t\t\t// FolderView.VIEW_MODES.DETAILS, // same as list for now\n\t\t\t];\n\t\t\tconst current_view_mode_index = view_modes.indexOf(this.config.view_mode);\n\t\t\tconst next_view_mode_index = (current_view_mode_index + 1) % view_modes.length;\n\t\t\tthis.configure({ view_mode: view_modes[next_view_mode_index] });\n\t\t};\n\n\t\tlet waiting_on_stats = false;\n\t\tthis.arrange_icons = () => {\n\t\t\tif (waiting_on_stats) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!self.element.isConnected) { // checking parentElement doesn't work if under a shadowRoot\n\t\t\t\t// console.trace(\"not in DOM\");\n\t\t\t\treturn; // prevent errors computing layout if folder view removed before stats resolve\n\t\t\t}\n\t\t\tconst pending_promises = this.items.map((item) => item.pendingStatPromise).filter(Boolean);\n\t\t\tconst any_pending = pending_promises.length > 0;\n\t\t\tif (any_pending) {\n\t\t\t\tif (!waiting_on_stats) {\n\t\t\t\t\t// should I choose a batch size? or is waiting on all stats fine?\n\t\t\t\t\t// batches mean that it would update multiple times, which could be jarring.\n\t\t\t\t\tPromise.allSettled(pending_promises).then(() => {\n\t\t\t\t\t\twaiting_on_stats = false;\n\t\t\t\t\t\tself.arrange_icons();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\twaiting_on_stats = true;\n\t\t\t}\n\t\t\tconst horizontal_first =\n\t\t\t\tthis.config.view_mode === FolderView.VIEW_MODES.LARGE_ICONS ||\n\t\t\t\tthis.config.view_mode === FolderView.VIEW_MODES.SMALL_ICONS;\n\t\t\tconst large_icons =\n\t\t\t\tthis.config.view_mode === FolderView.VIEW_MODES.LARGE_ICONS ||\n\t\t\t\tthis.config.view_mode === FolderView.VIEW_MODES.DESKTOP;\n\t\t\tconst icon_size = icon_size_by_view_mode[this.config.view_mode] || 32;\n\n\t\t\tconst grid_size_x = large_icons ? grid_size_x_for_large_icons : grid_size_x_for_small_icons;\n\t\t\tconst grid_size_y = large_icons ? grid_size_y_for_large_icons : grid_size_y_for_small_icons;\n\t\t\tvar x = 0;\n\t\t\tvar y = 0;\n\t\t\tconst dir_ness = (item) =>\n\t\t\t\t// system folders always go first\n\t\t\t\t// not all system folder shortcuts on the desktop have real paths (currently)\n\t\t\t\t// so we can't check system_folder_path_to_name, need a separate attribute.\n\t\t\t\t// system_folder_path_to_name[item.file_path] ? 2 :\n\t\t\t\titem.is_system_folder ? 2 :\n\t\t\t\t\t// then folders, then everything else\n\t\t\t\t\t///item.resolvedStats?.isDirectory() ? 1 : 0;\n\t\t\t\t\titem.resolvedStats && item.resolvedStats.isDirectory() ? 1 : 0;\n\t\t\tconst get_ext = (item) => (item.file_path ||/*??*/ \"\").split(\".\").pop();\n\t\t\tif (this.config.sort_mode === FolderView.SORT_MODES.NAME) {\n\t\t\t\tthis.items.sort((a, b) =>\n\t\t\t\t\tdir_ness(b) - dir_ness(a) ||\n\t\t\t\t\t(a.title ||/*??*/ \"\").localeCompare(b.title ||/*??*/ \"\")\n\t\t\t\t);\n\t\t\t} else if (this.config.sort_mode === FolderView.SORT_MODES.TYPE) {\n\t\t\t\tthis.items.sort((a, b) =>\n\t\t\t\t\tdir_ness(b) - dir_ness(a) ||\n\t\t\t\t\t(get_ext(a) ||/*??*/ \"\").localeCompare(get_ext(b) ||/*??*/ \"\")\n\t\t\t\t);\n\t\t\t} else if (this.config.sort_mode === FolderView.SORT_MODES.SIZE) {\n\t\t\t\tthis.items.sort((a, b) =>\n\t\t\t\t\tdir_ness(b) - dir_ness(a) ||\n\t\t\t\t\t(a.resolvedStats.size ||/*??*/ 0) - (b.resolvedStats && b.resolvedStats.size ||/*??*/ 0)\n\t\t\t\t);\n\t\t\t} else if (this.config.sort_mode === FolderView.SORT_MODES.DATE) {\n\t\t\t\tthis.items.sort((a, b) =>\n\t\t\t\t\tdir_ness(b) - dir_ness(a) ||\n\t\t\t\t\t(a.resolvedStats && a.resolvedStats.mtime ||/*??*/ 0) - (b.resolvedStats && b.resolvedStats.mtime ||/*??*/ 0)\n\t\t\t\t);\n\t\t\t}\n\t\t\tfor (const item of this.items) {\n\t\t\t\t$(item.element).css({\n\t\t\t\t\tleft: x,\n\t\t\t\t\ttop: y,\n\t\t\t\t});\n\t\t\t\tif (horizontal_first) {\n\t\t\t\t\tx += grid_size_x;\n\t\t\t\t\tif (x + grid_size_x > $folder_view[0].clientWidth) {\n\t\t\t\t\t\ty += grid_size_y;\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ty += grid_size_y;\n\t\t\t\t\tif (y + grid_size_y > $folder_view[0].clientHeight) {\n\t\t\t\t\t\tx += grid_size_x;\n\t\t\t\t\t\ty = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\titem.setIconSize(icon_size);\n\n\t\t\t\t// apply sort - well, I'm positioning things absolutely, so I don't need to do this (AS LONG AS I DON'T ASSUME THE DOM ORDER, and use self.items instead)\n\t\t\t\t// and this is very slow for large folders.\n\t\t\t\t// this.element.appendChild(item.element);\n\t\t\t}\n\n\t\t\tif (!any_pending) {\n\t\t\t\t// this.items[0].element.classList.add(\"focused\");\n\t\t\t\tthis.items.forEach((item, index) => {\n\t\t\t\t\titem.element.classList.toggle(\"focused\", index === 0);\n\t\t\t\t});\n\t\t\t\t// console.log(\"this.element.ownerDocument.activeElement\", this.element.ownerDocument.activeElement);\n\t\t\t\t// if (this.element.ownerDocument.activeElement === this.element) {\n\t\t\t\tthis.items[0] && this.items[0].element.focus();\n\t\t\t\t// }\n\t\t\t\tupdateStatus();\n\t\t\t}\n\t\t};\n\n\t\tfunction updateStatus() {\n\t\t\tonStatus && onStatus({\n\t\t\t\titems: self.items,\n\t\t\t\tselectedItems: self.items.filter((item) => item.element.classList.contains(\"selected\")),\n\t\t\t});\n\t\t}\n\n\t\tfunction deleteRecursiveSync(fs, itemPath) {\n\t\t\tif (fs.statSync(itemPath).isDirectory()) {\n\t\t\t\tfor (const childItemName of fs.readdirSync(itemPath)) {\n\t\t\t\t\tdeleteRecursiveSync(itemPath + \"/\" + childItemName);\n\t\t\t\t}\n\t\t\t\tfs.rmdirSync(itemPath);\n\t\t\t} else {\n\t\t\t\tfs.unlinkSync(itemPath);\n\t\t\t}\n\t\t}\n\n\t\tself.focus = function () {\n\t\t\tif ($folder_view.is(\":focus-within\")) {\n\t\t\t\treturn; // don't mess with renaming inputs, for instance, if you click on the input\n\t\t\t}\n\t\t\t$folder_view.focus();\n\t\t\t// This doesn't do much if it's yet to be populated:\n\t\t\tif ($folder_view.find(\".desktop-icon.focused\").length === 0) {\n\t\t\t\tthis.items[0] && this.items[0].element.focus();\n\t\t\t}\n\t\t\t// Initial focus is handled in arrange_icons currently.\n\t\t};\n\n\t\tself.select_all = function () {\n\t\t\t$folder_view.find(\".desktop-icon\").addClass(\"selected\");\n\t\t\tupdateStatus();\n\t\t};\n\n\t\tself.select_inverse = function () {\n\t\t\t$folder_view.find(\".desktop-icon\").each(function () {\n\t\t\t\t$(this).toggleClass(\"selected\");\n\t\t\t});\n\t\t\tupdateStatus();\n\t\t};\n\n\t\tself.delete_selected = function () {\n\t\t\tconst selected_file_paths = $folder_view.find(\".desktop-icon.selected\")\n\t\t\t\t.toArray().map((icon_el) => icon_el.dataset.filePath)\n\t\t\t\t.filter((file_path) => system_folder_path_to_name[file_path] === undefined);\n\n\t\t\tif (selected_file_paths.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// @NOTE: if system setting for displaying file extensions was implemented, this should be changed...\n\t\t\tconst name_of_first = $folder_view.find(\".desktop-icon.selected .title\").text().replace(/\\.([^.]+)$/, \"\");\n\t\t\tshowMessageBox({\n\t\t\t\ttitle: selected_file_paths.length === 1 ? \"Confirm File Delete\" : \"Confirm Multiple File Delete\",\n\t\t\t\tmessage: selected_file_paths.length === 1 ?\n\t\t\t\t\t`Are you sure you want to delete '${name_of_first}'?` :\n\t\t\t\t\t`Are you sure you want to delete these ${selected_file_paths.length} items?`,\n\t\t\t\tbuttons: [\n\t\t\t\t\t{\n\t\t\t\t\t\tlabel: \"Yes\",\n\t\t\t\t\t\tvalue: \"yes\",\n\t\t\t\t\t\tdefault: true,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tlabel: \"No\",\n\t\t\t\t\t\tvalue: \"no\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\ticonID: \"nuke\",\n\t\t\t}).then((result) => {\n\t\t\t\tif (result !== \"yes\") {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tFilesystemSetup.withFilesystem(function () {\n\t\t\t\t\tconst fs = BrowserFS.BFSRequire('fs');\n\t\t\t\t\tlet num_deleted = 0;\n\t\t\t\t\tfor (const file_path of selected_file_paths) {\n\t\t\t\t\t\tlet single_delete_success = false;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdeleteRecursiveSync(fs, file_path);\n\t\t\t\t\t\t\tsingle_delete_success = true;\n\t\t\t\t\t\t\tnum_deleted += 1;\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tconsole.log(\"failed to delete\", file_path, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (single_delete_success) {\n\t\t\t\t\t\t\tself.items.forEach((item) => {\n\t\t\t\t\t\t\t\tif (item.element.dataset.filePath === file_path) {\n\t\t\t\t\t\t\t\t\titem.element.remove();\n\t\t\t\t\t\t\t\t\tupdateStatus();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// TODO: pluralization, and be more specific about folders vs files vs selected items, and total\n\t\t\t\t\tif (num_deleted < selected_file_paths.length) {\n\t\t\t\t\t\talert(`Failed to delete ${selected_file_paths.length - num_deleted} items.`);\n\t\t\t\t\t}\n\t\t\t\t\t// self.refresh();\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\tself.start_rename = () => {\n\t\t\tfor (const item of self.items) {\n\t\t\t\tif (item.element.classList.contains(\"focused\")) {\n\t\t\t\t\titem.start_rename();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Read the folder and create icon items\n\t\tFilesystemSetup.withFilesystem(function () {\n\t\t\tvar fs = BrowserFS.BFSRequire('fs');\n\t\t\tfs.readdir(folder_path, function (error, contents) {\n\t\t\t\tif (error) {\n\t\t\t\t\talert(\"Failed to read contents of the directory \" + folder_path);\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < contents.length; i++) {\n\t\t\t\t\tvar fname = contents[i];\n\t\t\t\t\tadd_fs_item(fname, -1000, -1000);\n\t\t\t\t}\n\t\t\t\tself.arrange_icons();\n\t\t\t});\n\t\t});\n\n\t\t// NOTE: in Windows, icons by default only get moved if they go offscreen (by maybe half the grid size)\n\t\t// we're handling it as if Auto Arrange is on (@TODO: support Auto Arrange off)\n\t\tconst resizeObserver = new ResizeObserver(entries => {\n\t\t\tself.arrange_icons();\n\t\t});\n\t\tresizeObserver.observe(self.element);\n\n\t\t// Handle selecting icons\n\t\t(function () {\n\t\t\tvar $marquee = $(\"<div class='marquee'/>\").appendTo($folder_view).hide();\n\t\t\tvar start = { x: 0, y: 0 };\n\t\t\tvar current = { x: 0, y: 0 };\n\t\t\tvar dragging = false;\n\t\t\tvar drag_update = function () {\n\t\t\t\tvar min_x = Math.min(start.x, current.x);\n\t\t\t\tvar min_y = Math.min(start.y, current.y);\n\t\t\t\tvar max_x = Math.max(start.x, current.x);\n\t\t\t\tvar max_y = Math.max(start.y, current.y);\n\t\t\t\t$marquee.show().css({\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\tleft: min_x,\n\t\t\t\t\ttop: min_y,\n\t\t\t\t\twidth: max_x - min_x,\n\t\t\t\t\theight: max_y - min_y,\n\t\t\t\t});\n\t\t\t\t$folder_view.find(\".desktop-icon\").each(function (i, folder_view_icon) {\n\t\t\t\t\t// Note: this is apparently considerably more complex in Windows 98\n\t\t\t\t\t// like things are not considered the same heights and/or positions based on the size of their names\n\t\t\t\t\tvar icon_offset = $(folder_view_icon).offset();\n\t\t\t\t\tvar icon_left = parseFloat($(folder_view_icon).css(\"left\"));\n\t\t\t\t\tvar icon_top = parseFloat($(folder_view_icon).css(\"top\"));\n\t\t\t\t\tvar icon_width = $(folder_view_icon).width();\n\t\t\t\t\tvar icon_height = $(folder_view_icon).height();\n\t\t\t\t\tfolder_view_icon.classList.toggle(\"selected\",\n\t\t\t\t\t\ticon_left < max_x &&\n\t\t\t\t\t\ticon_top < max_y &&\n\t\t\t\t\t\ticon_left + icon_width > min_x &&\n\t\t\t\t\t\ticon_top + icon_height > min_y\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t\tupdateStatus();\n\t\t\t};\n\t\t\t$folder_view.on(\"pointerdown\", \".desktop-icon\", function (e) {\n\t\t\t\tconst item_el = e.currentTarget;\n\t\t\t\titem_el._was_selected_at_pointerdown = item_el.classList.contains(\"selected\");\n\t\t\t\tselect_item(item_el, e, true);\n\t\t\t});\n\t\t\t$folder_view.on(\"pointerdown\", function (e) {\n\t\t\t\t// TODO: allow a margin of mouse movement before starting selecting\n\t\t\t\tvar view_was_focused = $folder_view.is(\":focus-within\");\n\t\t\t\tself.focus();\n\t\t\t\tvar $icon = $(e.target).closest(\".desktop-icon\");\n\t\t\t\t$marquee.hide();\n\t\t\t\t// var folder_view_offset = $folder_view.offset();\n\t\t\t\tvar folder_view_offset = self.element.getBoundingClientRect();\n\t\t\t\tstart = { x: e.pageX - folder_view_offset.left + $folder_view[0].scrollLeft, y: e.pageY - folder_view_offset.top + $folder_view[0].scrollTop };\n\t\t\t\tcurrent = { x: e.pageX - folder_view_offset.left + $folder_view[0].scrollLeft, y: e.pageY - folder_view_offset.top + $folder_view[0].scrollTop };\n\t\t\t\tif ($icon.length > 0) {\n\t\t\t\t\t$marquee.hide();\n\t\t\t\t\tset_dragging_file_paths($(\".desktop-icon.selected\").get().map((icon) =>\n\t\t\t\t\t\ticon.dataset.filePath\n\t\t\t\t\t).filter((file_path) => file_path));\n\t\t\t\t} else {\n\t\t\t\t\tset_dragging_file_paths([]);\n\t\t\t\t\t// start dragging marquee unless over scrollbar\n\t\t\t\t\tlet scrollbar_width = $folder_view[0].offsetWidth - $folder_view[0].clientWidth;\n\t\t\t\t\tlet scrollbar_height = $folder_view[0].offsetHeight - $folder_view[0].clientHeight;\n\t\t\t\t\tscrollbar_width += 2; // for marquee border (@TODO: make marquee unable to cause scrollbar, by putting it in an overflow: hidden container)\n\t\t\t\t\tscrollbar_height += 2; // for marquee border\n\t\t\t\t\tconst rect = $folder_view[0].getBoundingClientRect();\n\t\t\t\t\tconst over_scrollbar = e.clientX > rect.right - scrollbar_width || e.clientY > rect.bottom - scrollbar_height;\n\t\t\t\t\t// console.log(`over_scrollbar: ${over_scrollbar}, e.clientX: ${e.clientX}, rect.right - scrollbar_width: ${rect.right - scrollbar_width}`);\n\t\t\t\t\tdragging = !over_scrollbar;\n\t\t\t\t\t// don't deselect right away unless the \n\t\t\t\t\t// TODO: deselect on pointerUP, if the desktop was focused\n\t\t\t\t\t// or when starting selecting (re: TODO: allow a margin of movement before starting selecting)\n\t\t\t\t\tif (dragging && view_was_focused) {\n\t\t\t\t\t\tdrag_update();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$($folder_view[0].ownerDocument).on(\"pointermove\", handle_pointermove);\n\t\t\t\t$($folder_view[0].ownerDocument).on(\"pointerup blur\", handle_pointerup_blur);\n\t\t\t});\n\t\t\tfunction handle_pointermove (e) {\n\t\t\t\t// var folder_view_offset = $folder_view.offset();\n\t\t\t\tvar folder_view_offset = self.element.getBoundingClientRect();\n\t\t\t\tcurrent = { x: e.pageX - folder_view_offset.left + $folder_view[0].scrollLeft, y: e.pageY - folder_view_offset.top + $folder_view[0].scrollTop };\n\t\t\t\t// clamp coordinates to within folder view\n\t\t\t\t// This accomplishes three things:\n\t\t\t\t// 1. it improves the visual coherence of the marquee as an object\n\t\t\t\t// 2. it makes the marquee not cause a scrollbar\n\t\t\t\t// 3. it prevents selecting things you can't see\n\t\t\t\tconst scrollbar_width = $folder_view.width() - $folder_view[0].clientWidth;\n\t\t\t\tconst scrollbar_height = $folder_view.height() - $folder_view[0].clientHeight;\n\t\t\t\tconst clamp_left = $folder_view[0].scrollLeft;\n\t\t\t\tconst clamp_top = $folder_view[0].scrollTop;\n\t\t\t\tconst clamp_right = $folder_view.width() + $folder_view[0].scrollLeft - scrollbar_width;\n\t\t\t\tconst clamp_bottom = $folder_view.height() + $folder_view[0].scrollTop - scrollbar_height;\n\t\t\t\tcurrent.x = Math.max(clamp_left, Math.min(clamp_right, current.x));\n\t\t\t\tcurrent.y = Math.max(clamp_top, Math.min(clamp_bottom, current.y));\n\t\t\t\tif (dragging) {\n\t\t\t\t\tdrag_update();\n\t\t\t\t\t// scroll the view by dragging the mouse at/past the edge\n\t\t\t\t\tconst scroll_speed = 10;\n\t\t\t\t\tif (current.x === clamp_left) {\n\t\t\t\t\t\t$folder_view[0].scrollLeft -= scroll_speed;\n\t\t\t\t\t} else if (current.x === clamp_right) {\n\t\t\t\t\t\t$folder_view[0].scrollLeft += scroll_speed;\n\t\t\t\t\t}\n\t\t\t\t\tif (current.y === clamp_top) {\n\t\t\t\t\t\t$folder_view[0].scrollTop -= scroll_speed;\n\t\t\t\t\t} else if (current.y === clamp_bottom) {\n\t\t\t\t\t\t$folder_view[0].scrollTop += scroll_speed;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tfunction handle_pointerup_blur() {\n\t\t\t\t$marquee.hide();\n\t\t\t\tdragging = false;\n\t\t\t\tset_dragging_file_paths([]);\n\t\t\t\t$($folder_view[0].ownerDocument).off(\"pointermove\", handle_pointermove);\n\t\t\t\t$($folder_view[0].ownerDocument).off(\"pointerup blur\", handle_pointerup_blur);\n\t\t\t};\n\t\t})();\n\n\t\tlet search_string = \"\";\n\t\tlet search_timeout;\n\n\t\t$folder_view.on(\"keydown\", function (e) {\n\t\t\t// console.log(\"keydown\", e.isDefaultPrevented());\n\n\t\t\tif (e.target.tagName === \"INPUT\" || e.target.tagName === \"TEXTAREA\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (e.key == \"Enter\") {\n\t\t\t\t$folder_view.find(\".desktop-icon.selected\").trigger(\"dblclick\");\n\t\t\t} else if (e.ctrlKey && e.key == \"a\") {\n\t\t\t\tfolder_view.select_all();\n\t\t\t\te.preventDefault();\n\t\t\t} else if (e.key == \"Delete\") {\n\t\t\t\tself.delete_selected();\n\t\t\t\te.preventDefault();\n\t\t\t} else if (\n\t\t\t\te.key == \"ArrowLeft\" ||\n\t\t\t\te.key == \"ArrowRight\" ||\n\t\t\t\te.key == \"ArrowUp\" ||\n\t\t\t\te.key == \"ArrowDown\"\n\t\t\t) {\n\t\t\t\te.preventDefault();\n\t\t\t\tconst move_x = e.key == \"ArrowLeft\" ? -1 : e.key == \"ArrowRight\" ? 1 : 0;\n\t\t\t\tconst move_y = e.key == \"ArrowUp\" ? -1 : e.key == \"ArrowDown\" ? 1 : 0;\n\t\t\t\tnavigate_grid(move_x, move_y, e);\n\t\t\t\t// @TODO: wrap around columns in list view\n\t\t\t} else if (\n\t\t\t\te.key == \"PageUp\" ||\n\t\t\t\te.key == \"PageDown\"\n\t\t\t) {\n\t\t\t\te.preventDefault();\n\t\t\t\tif (self.config.view_mode === FolderView.VIEW_MODES.LIST) {\n\t\t\t\t\tconst x_dir = e.key == \"PageUp\" ? -1 : 1;\n\t\t\t\t\tconst full_page_size = $folder_view.width();\n\t\t\t\t\tconst item_width = $folder_view.find(\".desktop-icon\").outerWidth();\n\t\t\t\t\tconst page_increment = full_page_size - item_width;\n\t\t\t\t\tfor (let increment = page_increment; increment > 0; increment -= item_width) {\n\t\t\t\t\t\tif (navigate_grid(x_dir * increment / item_width, 0, e)) { // grid units\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst y_dir = e.key == \"PageUp\" ? -1 : 1;\n\t\t\t\t\tconst full_page_size = $folder_view.height();\n\t\t\t\t\tconst item_height = $folder_view.find(\".desktop-icon\").outerHeight();\n\t\t\t\t\tconst page_increment = full_page_size - item_height;\n\t\t\t\t\tfor (let increment = page_increment; increment > 0; increment -= item_height) {\n\t\t\t\t\t\tif (navigate_grid(0, y_dir * increment / item_height, e)) { // grid units\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (e.key == \"Home\") {\n\t\t\t\te.preventDefault();\n\t\t\t\tselect_item(self.items[0], e);\n\t\t\t} else if (e.key == \"End\") {\n\t\t\t\te.preventDefault();\n\t\t\t\tselect_item(self.items[self.items.length - 1], e);\n\t\t\t} else if (e.key == \" \" && search_string.length === 0) {\n\t\t\t\t// Usually there's something focused,\n\t\t\t\t// so this is pretty \"niche\", but space bar selects the focused item.\n\t\t\t\t// Ctrl+Space toggles selection of the focused item.\n\t\t\t\te.preventDefault();\n\t\t\t\tif ((e.ctrlKey || e.metaKey) && $folder_view.find(\".desktop-icon.selected\").length > 0) {\n\t\t\t\t\t$folder_view.find(\".desktop-icon.focused\").toggleClass(\"selected\");\n\t\t\t\t} else {\n\t\t\t\t\t$folder_view.find(\".desktop-icon.focused\").addClass(\"selected\"); // don't use select_item() as it shouldn't unselect anything\n\t\t\t\t}\n\t\t\t\tupdateStatus();\n\t\t\t} else if (e.key === \"F2\") {\n\t\t\t\te.preventDefault();\n\t\t\t\tself.start_rename();\n\t\t\t} else {\n\t\t\t\tif (e.isDefaultPrevented() || e.ctrlKey || e.altKey || e.metaKey) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (search_timeout) {\n\t\t\t\t\tclearTimeout(search_timeout);\n\t\t\t\t}\n\t\t\t\tif (search_string === e.key) {\n\t\t\t\t\t// cycle through items starting with the same letter\n\t\t\t\t\t// Note: not adding to search_string here, so it stays as e.key\n\t\t\t\t\t// @TODO: what if you have an item like \"Llama Photos\", can you not search for \"Llama\" to go to it, in the presence of other 'L' items?\n\t\t\t\t\tconst candidates = self.items.filter((item) => {\n\t\t\t\t\t\tconst title = item.element.querySelector(\".title\").textContent; // @TODO: proper access\n\t\t\t\t\t\treturn title.toLocaleLowerCase().startsWith(search_string.toLocaleLowerCase());\n\t\t\t\t\t});\n\t\t\t\t\tif (candidates.length > 0) {\n\t\t\t\t\t\tconst index = candidates.findIndex((item) => item.element.classList.contains(\"focused\"));\n\t\t\t\t\t\tif (index === -1) {\n\t\t\t\t\t\t\tselect_item(candidates[0], e);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tselect_item(candidates[(index + 1) % candidates.length], e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// focus item matching search string\n\t\t\t\t\tif (e.key !== \"Shift\" && e.key !== \"Compose\") { // Note: composition doesn't actually work; I'd need an input element to do this properly\n\t\t\t\t\t\tsearch_string += e.key;\n\t\t\t\t\t}\n\t\t\t\t\t// console.log(\"search_string: \" + search_string);\n\t\t\t\t\tsearch_timeout = setTimeout(function () {\n\t\t\t\t\t\tsearch_string = \"\";\n\t\t\t\t\t\t// console.log(\"reset search_string\");\n\t\t\t\t\t}, 1000);\n\n\t\t\t\t\tif (search_string.length > 0) {\n\t\t\t\t\t\tfor (const item of self.items) {\n\t\t\t\t\t\t\tconst title = item.element.querySelector(\".title\").textContent; // @TODO: proper access\n\t\t\t\t\t\t\tif (title.toLocaleLowerCase().startsWith(search_string.toLocaleLowerCase())) {\n\t\t\t\t\t\t\t\tselect_item(item, {}); // passing fake event so it doesn't use shiftKey to determine multi-select\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tvar selection_anchor_item_el;\n\n\t\tfunction select_item(item_or_item_el, event, delay_scroll) {\n\t\t\tconst item_el_to_select = item_or_item_el instanceof Element ? item_or_item_el : item_or_item_el.element;\n\t\t\tconst extend_selection = event.shiftKey;\n\t\t\tif (selection_anchor_item_el && !self.items.some(item => item.element === selection_anchor_item_el)) {\n\t\t\t\tselection_anchor_item_el = null; // item was removed somehow\n\t\t\t}\n\t\t\tif (extend_selection && !selection_anchor_item_el) {\n\t\t\t\t// select_item() hasn't been called yet (e.g. hitting Shift+Down without first hitting an arrow key without Shift, in a newly loaded folder view)\n\t\t\t\t// use the focused item as the anchor\n\t\t\t\tselection_anchor_item_el = self.items.find((item) => item.element.classList.contains(\"focused\"))/*?*/.element ||/*??*/ item_el_to_select;\n\t\t\t}\n\t\t\t// console.log(\"select_item\", item_or_item_el, event, \"extend_selection\", extend_selection);\n\t\t\t$folder_view.find(\".desktop-icon\").each(function (i, item_el) {\n\t\t\t\tif (extend_selection) {\n\t\t\t\t\t// select items in a rectangle between the anchor and the new item\n\t\t\t\t\tconst anchor_rect = selection_anchor_item_el.getBoundingClientRect();\n\t\t\t\t\tconst item_el_to_select_rect = item_el_to_select.getBoundingClientRect();\n\t\t\t\t\tconst item_el_rect = item_el.getBoundingClientRect();\n\t\t\t\t\tconst rectangle = {\n\t\t\t\t\t\ttop: Math.min(anchor_rect.top, item_el_to_select_rect.top),\n\t\t\t\t\t\tleft: Math.min(anchor_rect.left, item_el_to_select_rect.left),\n\t\t\t\t\t\tbottom: Math.max(anchor_rect.bottom, item_el_to_select_rect.bottom),\n\t\t\t\t\t\tright: Math.max(anchor_rect.right, item_el_to_select_rect.right)\n\t\t\t\t\t};\n\t\t\t\t\t$(item_el).toggleClass(\"selected\", (\n\t\t\t\t\t\titem_el_rect.top >= rectangle.top &&\n\t\t\t\t\t\titem_el_rect.left >= rectangle.left &&\n\t\t\t\t\t\titem_el_rect.bottom <= rectangle.bottom &&\n\t\t\t\t\t\titem_el_rect.right <= rectangle.right\n\t\t\t\t\t));\n\t\t\t\t} else {\n\t\t\t\t\tif (event.type === \"pointerdown\" && (event.ctrlKey || event.metaKey)) {\n\t\t\t\t\t\t// toggle with Ctrl+click\n\t\t\t\t\t\tif (item_el === item_el_to_select) {\n\t\t\t\t\t\t\t$(item_el).toggleClass(\"selected\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// select with click or arrow keys,\n\t\t\t\t\t\t// but if holding Ctrl it should only move focus, not select.\n\t\t\t\t\t\tif (!event.ctrlKey && !event.metaKey) {\n\t\t\t\t\t\t\titem_el.classList.toggle(\"selected\", item_el === item_el_to_select);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\titem_el.classList.toggle(\"focused\", item_el === item_el_to_select);\n\t\t\t});\n\t\t\tif (delay_scroll) {\n\t\t\t\t// Windows 98 does this for clicks.\n\t\t\t\t// I'm not sure if it's to make it less jarring (I feel like there's a case for that),\n\t\t\t\t// or if it's to avoid some problems with drag and drop perhaps.\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\titem_el_to_select.scrollIntoView({ block: \"nearest\" });\n\t\t\t\t}, 500);\n\t\t\t} else {\n\t\t\t\titem_el_to_select.scrollIntoView({ block: \"nearest\" });\n\t\t\t}\n\t\t\tupdateStatus();\n\n\t\t\tif (!event.shiftKey) {\n\t\t\t\tselection_anchor_item_el = item_el_to_select;\n\t\t\t}\n\t\t}\n\n\t\tfunction navigate_grid(move_x, move_y, event) {\n\t\t\t// @TODO: how this is supposed to work for icons not aligned to the grid?\n\t\t\t// I can imagine a few ways of doing it, like scanning for the nearest icon with a sweeping line or perhaps a \"cone\" (triangle) (changing width line)\n\t\t\t// but it'd be nice to know for sure\n\n\t\t\tlet $starting_icon = $folder_view.find(\".desktop-icon.focused\");\n\t\t\t// ideally we'd keep a focused icon always,\n\t\t\t// use the nearest icon upwards after a delete etc.\n\t\t\t// but I can't guarantee that\n\t\t\tif ($starting_icon.length == 0) {\n\t\t\t\t$starting_icon = $folder_view.find(\".desktop-icon\");\n\t\t\t}\n\t\t\tif ($starting_icon.length == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// @TODO: use the actual grid size, not a calculated item size\n\t\t\t// or make it more grid-agnostic (Windows 98 allowed freely moving icons around)\n\t\t\tconst item_width = $starting_icon.outerWidth();\n\t\t\tconst item_height = $starting_icon.outerHeight();\n\t\t\t// const item_pos = $starting_icon.position();\n\t\t\tconst item_pos = $starting_icon[0].getBoundingClientRect();\n\t\t\tlet x = item_pos.left;// + item_width / 2;\n\t\t\tlet y = item_pos.top;// + item_height / 2;\n\t\t\tx += move_x * item_width;\n\t\t\ty += move_y * item_height;\n\t\t\tconst candidates = $folder_view.find(\".desktop-icon\").toArray().sort(function (a, b) {\n\t\t\t\t// const a_pos = $(a).position();\n\t\t\t\t// const b_pos = $(b).position();\n\t\t\t\tconst a_pos = a.getBoundingClientRect();\n\t\t\t\tconst b_pos = b.getBoundingClientRect();\n\t\t\t\tconst a_dist = Math.abs(a_pos.left - x) + Math.abs(a_pos.top - y);\n\t\t\t\tconst b_dist = Math.abs(b_pos.left - x) + Math.abs(b_pos.top - y);\n\t\t\t\treturn a_dist - b_dist;\n\t\t\t});\n\t\t\tconst $icon = $(candidates[0]);\n\t\t\tif ($icon.length > 0) {\n\t\t\t\tselect_item($icon[0], event);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tvar stat = function (file_path) {\n\t\t\t// fs should be guaranteed available at this point\n\t\t\t// as this function is currently used\n\t\t\tvar fs = BrowserFS.BFSRequire('fs');\n\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\tfs.stat(file_path, function (err, stats) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t}\n\t\t\t\t\tresolve(stats);\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t\tvar icon_id_from_stats_and_path = function (stats, file_path) {\n\t\t\tif (stats.isDirectory()) {\n\t\t\t\t// if extending this to different folder icons,\n\t\t\t\t// note that \"folder\" is relied on (for sorting)\n\t\t\t\treturn \"folder\";\n\t\t\t}\n\t\t\tvar file_extension = helpers.file_extension_from_path(file_path);\n\t\t\t// TODO: look inside exe for icons\n\t\t\tvar icon_name = file_extension_icons[file_extension.toLowerCase()];\n\t\t\treturn icon_name || \"document\";\n\t\t};\n\t\tvar icons_from_icon_id = function (icon_id) {\n\t\t\treturn {\n\t\t\t\t16: helpers.getIconPath(icon_id, 16),\n\t\t\t\t32: helpers.getIconPath(icon_id, 32),\n\t\t\t\t48: helpers.getIconPath(icon_id, 48),\n\t\t\t};\n\t\t};\n\n\t\t// var add_fs_item = function(file_path, x, y){\n\t\tvar add_fs_item = function (initial_file_name, x, y) {\n\t\t\tvar initial_file_path = folder_path + initial_file_name;\n\t\t\tvar item = new FolderViewItem({\n\t\t\t\ttitle: initial_file_name,\n\t\t\t\topen: async function () {\n\t\t\t\t\tif (openFolder) {\n\t\t\t\t\t\tlet stats = item.resolvedStats;\n\t\t\t\t\t\tif (!stats) {\n\t\t\t\t\t\t\tif (item.pendingStatPromise) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tstats = await item.pendingStatPromise;\n\t\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\t\talert(`Failed to get info about '${item.file_path}':\\n\\n${error}`);\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\talert(`Cannot open '${item.file_path}'. File type information not available.`);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (stats.isDirectory()) {\n\t\t\t\t\t\t\topenFolder(item.file_path);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (openFileOrFolder) {\n\t\t\t\t\t\topenFileOrFolder(item.file_path);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\talert(`No handler for opening files or folders.`);\n\t\t\t\t},\n\t\t\t\trename: (new_name) => {\n\t\t\t\t\tvar fs = BrowserFS.BFSRequire('fs');\n\t\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\t\tconst new_file_path = folder_path + new_name;\n\t\t\t\t\t\tfs.rename(item.file_path, new_file_path, function (err) {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\titem.file_path = new_file_path;\n\t\t\t\t\t\t\titem.title = new_name;\n\t\t\t\t\t\t\titem.element.dataset.filePath = new_file_path;\n\t\t\t\t\t\t\tif (item.resolvedStats) {\n\t\t\t\t\t\t\t\tconst icon_id = icon_id_from_stats_and_path(item.resolvedStats, new_file_path);\n\t\t\t\t\t\t\t\titem.setIcons(icons_from_icon_id(icon_id));\n\t\t\t\t\t\t\t} // else the icon will be updated when the stats are resolved\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tshortcut: initial_file_path.match(/\\.url$/),\n\t\t\t\tfile_path: initial_file_path,\n\t\t\t\ticonSize: icon_size_by_view_mode[self.config.view_mode],\n\t\t\t});\n\t\t\titem.pendingStatPromise = stat(initial_file_path);\n\t\t\titem.pendingStatPromise.then((stats) => {\n\t\t\t\titem.pendingStatPromise = null;\n\t\t\t\titem.resolvedStats = stats; // trying to indicate in the name the async nature\n\t\t\t\t// @TODO: know which sizes are available\n\t\t\t\tconst icon_id = icon_id_from_stats_and_path(stats, item.file_path);\n\t\t\t\titem.setIcons(icons_from_icon_id(icon_id));\n\t\t\t}, (error) => {\n\t\t\t\t// Without this, the folder view infinitely recursed arranging items because\n\t\t\t\t// it was waiting for the promise to be settled (resolved or rejected),\n\t\t\t\t// but checking for item.pendingStatPromise to see if it's still pending.\n\t\t\t\titem.pendingStatPromise = null;\n\t\t\t});\n\t\t\tself.add_item(item);\n\t\t\t$(item.element).css({\n\t\t\t\tleft: x,\n\t\t\t\ttop: y,\n\t\t\t});\n\t\t};\n\t\tvar drop_file = function (file, x, y) {\n\n\t\t\tvar Buffer = BrowserFS.BFSRequire('buffer').Buffer;\n\t\t\tvar fs = BrowserFS.BFSRequire('fs');\n\n\t\t\tvar file_path = folder_path + file.name;\n\n\t\t\tvar reader = new FileReader;\n\t\t\treader.onerror = function (error) {\n\t\t\t\tthrow error;\n\t\t\t};\n\t\t\treader.onload = function (e) {\n\t\t\t\tvar buffer = Buffer.from(reader.result);\n\t\t\t\tfs.writeFile(file_path, buffer, { flag: \"wx\" }, function (error) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tif (error.code === \"EEXIST\") {\n\t\t\t\t\t\t\t// TODO: options to replace or keep both files with numbers like \"file (1).txt\"\n\t\t\t\t\t\t\talert(\"File already exists!\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t}\n\t\t\t\t\t// TODO: could do utimes as well with file.lastModified or file.lastModifiedDate\n\n\t\t\t\t\tadd_fs_item(file.name, x, y);\n\t\t\t\t});\n\t\t\t};\n\t\t\treader.readAsArrayBuffer(file);\n\t\t};\n\n\t\tvar dragover_pageX = 0;\n\t\tvar dragover_pageY = 0;\n\t\t$folder_view.on(\"dragover\", function (e) {\n\t\t\te.preventDefault();\n\t\t\tdragover_pageX = e.originalEvent.pageX;\n\t\t\tdragover_pageY = e.originalEvent.pageY;\n\t\t});\n\t\t$folder_view.on(\"drop\", function (e) {\n\t\t\te.preventDefault();\n\t\t\tvar x = e.originalEvent.pageX || dragover_pageX;\n\t\t\tvar y = e.originalEvent.pageY || e.dragover_pageY\n\t\t\t// TODO: handle dragging icons onto other icons\n\t\t\twithFilesystem(function () {\n\t\t\t\tvar files = e.originalEvent.dataTransfer.files;\n\t\t\t\t$.map(files, function (file) {\n\t\t\t\t\t// TODO: stagger positions, don't just put everything on top of each other\n\t\t\t\t\t// also center on the mouse position; currently it's placed via the top left\n\t\t\t\t\tdrop_file(file, x, y);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\treturn FolderView;\n});\ndefine('skylark-98js/os-gui/$Window',[\n\t\"skylark-jquery\",\n\t\"../win98\"\n],function($,win98js){\n\n\t// TODO: E\\(\"([a-z]+)\"\\) -> \"<$1>\" or get rid of jQuery as a dependency\n\tfunction E(tagName) {\n\t\treturn document.createElement(tagName);\n\t}\n\n\tfunction element_to_string(element) {\n\t\t// returns a CSS-selector-like string for the given element\n\t\t// if (element instanceof Element) { // doesn't work with different window.Element from iframes\n\t\tif (typeof element === \"object\" && \"tagName\" in element) {\n\t\t\treturn element.tagName.toLowerCase() +\n\t\t\t\t(element.id ? \"#\" + element.id : \"\") +\n\t\t\t\t(element.className ? \".\" + element.className.split(\" \").join(\".\") : \"\") +\n\t\t\t\t(element.src ? `[src=\"${element.src}\"]` : \"\") + // Note: not escaped; may not actually work as a selector (but this is for debugging)\n\t\t\t\t(element.srcdoc ? \"[srcdoc]\" : \"\") + // (srcdoc can be long)\n\t\t\t\t(element.href ? `[href=\"${element.href}\"]` : \"\");\n\t\t} else if (element) {\n\t\t\treturn element.constructor.name;\n\t\t} else {\n\t\t\treturn `${element}`;\n\t\t}\n\t}\n\n\tfunction find_tabstops(container_el) {\n\t\tconst $el = $(container_el);\n\t\t// This function finds focusable controls, but not necessarily all of them;\n\t\t// for radio elements, it only gives one: either the checked one, or the first one if none are checked.\n\n\t\t// Note: for audio[controls], Chrome at least has two tabstops (the audio element and three dots menu button).\n\t\t// It might be possible to detect this in the shadow DOM, I don't know, I haven't worked with the shadow DOM.\n\t\t// But it might be more reliable to make a dummy tabstop element to detect when you tab out of the first/last element.\n\t\t// Also for iframes!\n\t\t// Assuming that doesn't mess with screen readers.\n\t\t// Right now you can't tab to the three dots menu if it's the last element.\n\t\t// @TODO: see what ally.js does. Does it handle audio[controls]? https://allyjs.io/api/query/tabsequence.html\n\n\t\tlet $controls = $el.find(`\n\t\t\tinput:enabled,\n\t\t\ttextarea:enabled,\n\t\t\tselect:enabled,\n\t\t\tbutton:enabled,\n\t\t\ta[href],\n\t\t\t[tabIndex='0'],\n\t\t\tdetails summary,\n\t\t\tiframe,\n\t\t\tobject,\n\t\t\tembed,\n\t\t\tvideo[controls],\n\t\t\taudio[controls],\n\t\t\t[contenteditable]:not([contenteditable='false'])\n\t\t`).filter(\":visible\");\n\t\t// const $controls = $el.find(\":tabbable\"); // https://api.jqueryui.com/tabbable-selector/\n\n\t\t// Radio buttons should be treated as a group with one tabstop.\n\t\t// If there's no selected (\"checked\") radio, it should still visit the group,\n\t\t// but if there is a selected radio in the group, it should skip all unselected radios in the group.\n\t\tconst radios = {}; // best radio found so far, per group\n\t\tconst to_skip = [];\n\t\tfor (const el of $controls.toArray()) {\n\t\t\tif (el.nodeName.toLowerCase() === \"input\" && el.type === \"radio\") {\n\t\t\t\tif (radios[el.name]) {\n\t\t\t\t\tif (el.checked) {\n\t\t\t\t\t\tto_skip.push(radios[el.name]);\n\t\t\t\t\t\tradios[el.name] = el;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tto_skip.push(el);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tradios[el.name] = el;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst $tabstops = $controls.not(to_skip);\n\t\t// debug viz:\n\t\t// $tabstops.css({boxShadow: \"0 0 2px 2px green\"});\n\t\t// $(to_skip).css({boxShadow: \"0 0 2px 2px gray\"})\n\t\treturn $tabstops;\n\t}\n\tvar $G = $(window);\n\n\n\t$Window.Z_INDEX = 5;\n\n\tvar minimize_slots = []; // for if there's no taskbar\n\n\t// @TODO: make this a class,\n\t// instead of a weird pseudo-class\n\tfunction $Window(options) {\n\t\toptions = options || {};\n\t\t// @TODO: handle all option defaults here\n\t\t// and validate options.\n\n\t\tvar $w = $(E(\"div\")).addClass(\"window os-window\").appendTo(\"body\");\n\t\t$w[0].$window = $w;\n\t\t$w.element = $w[0];\n\t\t$w[0].id = `os-window-${Math.random().toString(36).substr(2, 9)}`;\n\t\t$w.$titlebar = $(E(\"div\")).addClass(\"window-titlebar\").appendTo($w);\n\t\t$w.$title_area = $(E(\"div\")).addClass(\"window-title-area\").appendTo($w.$titlebar);\n\t\t$w.$title = $(E(\"span\")).addClass(\"window-title\").appendTo($w.$title_area);\n\t\tif (options.toolWindow) {\n\t\t\toptions.minimizeButton = false;\n\t\t\toptions.maximizeButton = false;\n\t\t}\n\t\tif (options.minimizeButton !== false) {\n\t\t\t$w.$minimize = $(E(\"button\")).addClass(\"window-minimize-button window-action-minimize window-button\").appendTo($w.$titlebar);\n\t\t\t$w.$minimize.attr(\"aria-label\", \"Minimize window\"); // @TODO: for taskbarless minimized windows, \"restore\"\n\t\t\t$w.$minimize.append(\"<span class='window-button-icon'></span>\");\n\t\t}\n\t\tif (options.maximizeButton !== false) {\n\t\t\t$w.$maximize = $(E(\"button\")).addClass(\"window-maximize-button window-action-maximize window-button\").appendTo($w.$titlebar);\n\t\t\t$w.$maximize.attr(\"aria-label\", \"Maximize or restore window\"); // @TODO: specific text for the state\n\t\t\tif (!options.resizable) {\n\t\t\t\t$w.$maximize.attr(\"disabled\", true);\n\t\t\t}\n\t\t\t$w.$maximize.append(\"<span class='window-button-icon'></span>\");\n\t\t}\n\t\tif (options.closeButton !== false) {\n\t\t\t$w.$x = $(E(\"button\")).addClass(\"window-close-button window-action-close window-button\").appendTo($w.$titlebar);\n\t\t\t$w.$x.attr(\"aria-label\", \"Close window\");\n\t\t\t$w.$x.append(\"<span class='window-button-icon'></span>\");\n\t\t}\n\t\t$w.$content = $(E(\"div\")).addClass(\"window-content\").appendTo($w);\n\t\t$w.$content.attr(\"tabIndex\", \"-1\");\n\t\t$w.$content.css(\"outline\", \"none\");\n\t\tif (options.toolWindow) {\n\t\t\t$w.addClass(\"tool-window\");\n\t\t}\n\t\tif (options.parentWindow) {\n\t\t\toptions.parentWindow.addChildWindow($w);\n\t\t\t// semantic parent logic is currently only suited for tool windows\n\t\t\t// for dialog windows, it would make the dialog window not show as focused\n\t\t\t// (alternatively, I could simply, when following the semantic parent chain, look for windows that are not tool windows)\n\t\t\tif (options.toolWindow) {\n\t\t\t\t$w[0].dataset.semanticParent = options.parentWindow[0].id;\n\t\t\t}\n\t\t}\n\n\t\tvar $component = options.$component;\n\t\tif (typeof options.icon === \"object\" && \"tagName\" in options.icon) {\n\t\t\toptions.icons = { any: options.icon };\n\t\t} else if (options.icon) {\n\t\t\t// old terrible API using globals that you have to define\n\t\t\tconsole.warn(\"DEPRECATED: use options.icons instead of options.icon, e.g. new $Window({icons: {16: 'app-16x16.png', any: 'app-icon.svg'}})\");\n\t\t\tif (typeof $Icon !== \"undefined\" && typeof TITLEBAR_ICON_SIZE !== \"undefined\") {\n\t\t\t\t$w.icon_name = options.icon;\n\t\t\t\t$w.$icon = $Icon(options.icon, TITLEBAR_ICON_SIZE).prependTo($w.$titlebar);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Use {icon: img_element} or {icons: {16: url_or_img_element}} options\");\n\t\t\t}\n\t\t}\n\t\t$w.icons = options.icons || {};\n\t\tlet iconSize = 16;\n\t\t$w.setTitlebarIconSize = function (target_icon_size) {\n\t\t\tif ($w.icons) {\n\t\t\t\t$w.$icon && $w.$icon.remove();\n\t\t\t\t$w.$icon = $($w.getIconAtSize(target_icon_size));\n\t\t\t\t$w.$icon.prependTo($w.$titlebar);\n\t\t\t}\n\t\t\ticonSize = target_icon_size;\n\t\t\t$w.trigger(\"icon-change\");\n\t\t};\n\t\t$w.getTitlebarIconSize = function () {\n\t\t\treturn iconSize;\n\t\t};\n\t\t// @TODO: this could be a static method, like OSGUI.getIconAtSize(icons, targetSize)\n\t\t$w.getIconAtSize = function (target_icon_size) {\n\t\t\tlet icon_size;\n\t\t\tif ($w.icons[target_icon_size]) {\n\t\t\t\ticon_size = target_icon_size;\n\t\t\t} else if ($w.icons[\"any\"]) {\n\t\t\t\ticon_size = \"any\";\n\t\t\t} else {\n\t\t\t\tconst sizes = Object.keys($w.icons).filter(size => isFinite(size) && isFinite(parseFloat(size)));\n\t\t\t\tsizes.sort((a, b) => Math.abs(a - target_icon_size) - Math.abs(b - target_icon_size));\n\t\t\t\ticon_size = sizes[0];\n\t\t\t}\n\t\t\tif (icon_size) {\n\t\t\t\tconst icon = $w.icons[icon_size];\n\t\t\t\tlet icon_element;\n\t\t\t\tif (icon.nodeType !== undefined) {\n\t\t\t\t\ticon_element = icon.cloneNode(true);\n\t\t\t\t} else {\n\t\t\t\t\ticon_element = E(\"img\");\n\t\t\t\t\tconst $icon = $(icon_element);\n\t\t\t\t\tif (icon.srcset) {\n\t\t\t\t\t\t$icon.attr(\"srcset\", icon.srcset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$icon.attr(\"src\", icon.src || icon);\n\t\t\t\t\t}\n\t\t\t\t\t$icon.attr({\n\t\t\t\t\t\twidth: icon_size,\n\t\t\t\t\t\theight: icon_size,\n\t\t\t\t\t\tdraggable: false,\n\t\t\t\t\t});\n\t\t\t\t\t$icon.css({\n\t\t\t\t\t\twidth: target_icon_size,\n\t\t\t\t\t\theight: target_icon_size,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn icon_element;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\t// @TODO: automatically update icon size based on theme (with a CSS variable)\n\t\t$w.setTitlebarIconSize(iconSize);\n\n\t\t$w.getIconName = () => {\n\t\t\tconsole.warn(\"DEPRECATED: use $w.icons object instead of $w.icon_name\");\n\t\t\treturn $w.icon_name;\n\t\t};\n\t\t$w.setIconByID = (icon_name) => {\n\t\t\tconsole.warn(\"DEPRECATED: use $w.setIcons(icons) instead of $w.setIconByID(icon_name)\");\n\t\t\tvar old_$icon = $w.$icon;\n\t\t\t$w.$icon = $Icon(icon_name, TITLEBAR_ICON_SIZE);\n\t\t\told_$icon.replaceWith($w.$icon);\n\t\t\t$w.icon_name = icon_name;\n\t\t\t$w.task && $w.task.updateIcon();\n\t\t\t$w.trigger(\"icon-change\");\n\t\t\treturn $w;\n\t\t};\n\t\t$w.setIcons = (icons) => {\n\t\t\t$w.icons = icons;\n\t\t\t$w.setTitlebarIconSize(iconSize);\n\t\t\t$w.task && $w.task.updateIcon();\n\t\t\t// icon-change already sent by setTitlebarIconSize\n\t\t};\n\n\t\tif ($component) {\n\t\t\t$w.addClass(\"component-window\");\n\t\t}\n\n\t\tsetTimeout(() => {\n\t\t\tif (get_direction() == \"rtl\") {\n\t\t\t\t$w.addClass(\"rtl\"); // for reversing the titlebar gradient\n\t\t\t}\n\t\t}, 0);\n\n\t\t// returns writing/layout direction, \"ltr\" or \"rtl\"\n\t\tfunction get_direction() {\n\t\t\treturn window.get_direction ? window.get_direction() : getComputedStyle($w[0]).direction;\n\t\t}\n\n\t\t// This is very silly, using jQuery's event handling to implement simpler event handling.\n\t\t// But I'll implement it in a non-silly way at least when I remove jQuery. Maybe sooner.\n\t\tconst $event_target = $({});\n\t\tconst make_simple_listenable = (name) => {\n\t\t\treturn (callback) => {\n\t\t\t\tconst fn = () => {\n\t\t\t\t\tcallback();\n\t\t\t\t};\n\t\t\t\t$event_target.on(name, fn);\n\t\t\t\tconst dispose = () => {\n\t\t\t\t\t$event_target.off(name, fn);\n\t\t\t\t};\n\t\t\t\treturn dispose;\n\t\t\t};\n\t\t};\n\t\t$w.onFocus = make_simple_listenable(\"focus\");\n\t\t$w.onBlur = make_simple_listenable(\"blur\");\n\t\t$w.onClosed = make_simple_listenable(\"closed\");\n\n\t\t$w.setDimensions = ({ innerWidth, innerHeight, outerWidth, outerHeight }) => {\n\t\t\tlet width_from_frame, height_from_frame;\n\t\t\t// It's good practice to make all measurements first, then update the DOM.\n\t\t\t// Once you update the DOM, the browser has to recalculate layout, which can be slow.\n\t\t\tif (innerWidth) {\n\t\t\t\twidth_from_frame = $w.outerWidth() - $w.$content.outerWidth();\n\t\t\t}\n\t\t\tif (innerHeight) {\n\t\t\t\theight_from_frame = $w.outerHeight() - $w.$content.outerHeight();\n\t\t\t\tconst $menu_bar = $w.$content.find(\".menus\"); // only if inside .content; might move to a slot outside .content later\n\t\t\t\tif ($menu_bar.length) {\n\t\t\t\t\t// maybe this isn't technically part of the frame, per se? but it's part of the non-client area, which is what I technically mean.\n\t\t\t\t\theight_from_frame += $menu_bar.outerHeight();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (outerWidth) {\n\t\t\t\t$w.outerWidth(outerWidth);\n\t\t\t}\n\t\t\tif (outerHeight) {\n\t\t\t\t$w.outerHeight(outerHeight);\n\t\t\t}\n\t\t\tif (innerWidth) {\n\t\t\t\t$w.outerWidth(innerWidth + width_from_frame);\n\t\t\t}\n\t\t\tif (innerHeight) {\n\t\t\t\t$w.outerHeight(innerHeight + height_from_frame);\n\t\t\t}\n\t\t};\n\t\t$w.setDimensions(options);\n\n\t\tlet child_$windows = [];\n\t\t$w.addChildWindow = ($child_window) => {\n\t\t\tchild_$windows.push($child_window);\n\t\t};\n\t\tconst showAsFocused = () => {\n\t\t\tif ($w.hasClass(\"focused\")) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t$w.addClass(\"focused\");\n\t\t\t$event_target.triggerHandler(\"focus\");\n\t\t\t$w.trigger(\"focus\");\n\t\t};\n\t\tconst stopShowingAsFocused = () => {\n\t\t\tif (!$w.hasClass(\"focused\")) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t$w.removeClass(\"focused\");\n\t\t\t$event_target.triggerHandler(\"blur\");\n\t\t\t$w.trigger(\"blur\");\n\t\t};\n\t\t$w.focus = () => {\n\t\t\t// showAsFocused();\t\n\t\t\t$w.bringToFront();\n\t\t\trefocus();\n\t\t};\n\t\t$w.blur = () => {\n\t\t\tstopShowingAsFocused();\n\t\t\tif (document.activeElement && document.activeElement.closest(\".window\") == $w[0]) {\n\t\t\t\tdocument.activeElement.blur();\n\t\t\t}\n\t\t};\n\n\t\tif (options.toolWindow) {\n\t\t\tif (options.parentWindow) {\n\t\t\t\toptions.parentWindow.onFocus(showAsFocused);\n\t\t\t\toptions.parentWindow.onBlur(stopShowingAsFocused);\n\t\t\t\t// TODO: also show as focused if focus is within the window\n\n\t\t\t\t// initial state\n\t\t\t\t// might need a setTimeout, idk...\n\t\t\t\tif (document.activeElement && document.activeElement.closest(\".window\") == options.parentWindow[0]) {\n\t\t\t\t\tshowAsFocused();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// the browser window is the parent window\n\t\t\t\t// show focus whenever the browser window is focused\n\t\t\t\t$(window).on(\"focus\", showAsFocused);\n\t\t\t\t$(window).on(\"blur\", stopShowingAsFocused);\n\t\t\t\t// initial state\n\t\t\t\tif (document.hasFocus()) {\n\t\t\t\t\tshowAsFocused();\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// global focusout is needed, to continue showing as focused while child windows or menu popups are focused (@TODO: Is this redundant with focusin?)\n\t\t\t// global focusin is needed, to show as focused when a child window becomes focused (when perhaps nothing was focused before, so no focusout event)\n\t\t\t// global blur is needed, to show as focused when an iframe gets focus, because focusin/out doesn't fire at all in that case\n\t\t\t// global focus is needed, to stop showing as focused when an iframe loses focus\n\t\t\t// pretty ridiculous!!\n\t\t\t// but it still doesn't handle the case where the browser window is not focused, and the user clicks an iframe directly.\n\t\t\t// for that, we need to listen inside the iframe, because no events are fired at all outside in that case,\n\t\t\t// and :focus/:focus-within doesn't work with iframes so we can't even do a hack with transitionstart.\n\t\t\t// @TODO: simplify the strategy; I ended up piling a few strategies on top of each other, and the earlier ones may be redundant.\n\t\t\t// In particular, 1. I ended up making it proactively inject into iframes, rather than when focused since there's a case where focus can't be detected otherwise.\n\t\t\t// 2. I ended up simulating focusin events for iframes.\n\t\t\t// I may want to rely on that, or, I may want to remove that and set up a refocus chain directly instead,\n\t\t\t// avoiding refocus() which may interfere with drag operations in an iframe when focusing the iframe (e.g. clicking into Paint to draw or drag a sub-window).\n\n\t\t\t// console.log(\"adding global focusin/focusout/blur/focus for window\", $w[0].id);\n\t\t\tconst global_focus_update_handler = make_focus_in_out_handler($w[0], true); // must be $w and not $content so semantic parent chain works, with [data-semantic-parent] pointing to the window not the content\n\t\t\twindow.addEventListener(\"focusin\", global_focus_update_handler);\n\t\t\twindow.addEventListener(\"focusout\", global_focus_update_handler);\n\t\t\twindow.addEventListener(\"blur\", global_focus_update_handler);\n\t\t\twindow.addEventListener(\"focus\", global_focus_update_handler);\n\n\t\t\tfunction setupIframe(iframe) {\n\t\t\t\tif (!focus_update_handlers_by_container.has(iframe)) {\n\t\t\t\t\tconst iframe_update_focus = make_focus_in_out_handler(iframe, false);\n\t\t\t\t\t// this also operates as a flag to prevent multiple handlers from being added, or waiting for the iframe to load duplicately\n\t\t\t\t\tfocus_update_handlers_by_container.set(iframe, iframe_update_focus);\n\n\t\t\t\t\t// @TODO: try removing setTimeout(s)\n\t\t\t\t\tsetTimeout(() => { // for iframe src to be set? I forget.\n\t\t\t\t\t\t// Note: try must be INSIDE setTimeout, not outside, to work.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst wait_for_iframe_load = (callback) => {\n\t\t\t\t\t\t\t\t// Note: error may occur accessing iframe.contentDocument; this must be handled by the caller.\n\t\t\t\t\t\t\t\t// To that end, this function must access it synchronously, to allow the caller to handle the error.\n\t\t\t\t\t\t\t\tif (iframe.contentDocument.readyState == \"complete\") {\n\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// iframe.contentDocument.addEventListener(\"readystatechange\", () => {\n\t\t\t\t\t\t\t\t\t// \tif (iframe.contentDocument.readyState == \"complete\") {\n\t\t\t\t\t\t\t\t\t// \t\tcallback();\n\t\t\t\t\t\t\t\t\t// \t}\n\t\t\t\t\t\t\t\t\t// });\n\t\t\t\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\t\t\t\twait_for_iframe_load(callback);\n\t\t\t\t\t\t\t\t\t}, 100);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\twait_for_iframe_load(() => {\n\t\t\t\t\t\t\t\t// console.log(\"adding focusin/focusout/blur/focus for iframe\", iframe);\n\t\t\t\t\t\t\t\tiframe.contentWindow.addEventListener(\"focusin\", iframe_update_focus);\n\t\t\t\t\t\t\t\tiframe.contentWindow.addEventListener(\"focusout\", iframe_update_focus);\n\t\t\t\t\t\t\t\tiframe.contentWindow.addEventListener(\"blur\", iframe_update_focus);\n\t\t\t\t\t\t\t\tiframe.contentWindow.addEventListener(\"focus\", iframe_update_focus);\n\t\t\t\t\t\t\t\tobserveIframes(iframe.contentDocument);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\twarn_iframe_access(iframe, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 100);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction observeIframes(container_node) {\n\t\t\t\tconst observer = new MutationObserver((mutations) => {\n\t\t\t\t\tfor (const mutation of mutations) {\n\t\t\t\t\t\tfor (const node of mutation.addedNodes) {\n\t\t\t\t\t\t\tif (node.tagName == \"IFRAME\") {\n\t\t\t\t\t\t\t\tsetupIframe(node);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tobserver.observe(container_node, { childList: true, subtree: true });\n\t\t\t\t// needed in recursive calls (for iframes inside iframes)\n\t\t\t\t// (for the window, it shouldn't be able to have iframes yet)\n\t\t\t\tfor (const iframe of container_node.querySelectorAll(\"iframe\")) {\n\t\t\t\t\tsetupIframe(iframe);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tobserveIframes($w.$content[0]);\n\t\t\t\n\t\t\tfunction make_focus_in_out_handler(logical_container_el, is_root) {\n\t\t\t\t// In case of iframes, logical_container_el is the iframe, and container_node is the iframe's contentDocument.\n\t\t\t\t// container_node is not a parameter here because it can change over time, may be an empty document before the iframe is loaded.\n\n\t\t\t\treturn function handle_focus_in_out(event) {\n\t\t\t\t\tconst container_node = logical_container_el.tagName == \"IFRAME\" ? logical_container_el.contentDocument : logical_container_el;\n\t\t\t\t\tconst document = container_node.ownerDocument /*??*/ ||  container_node;\n\t\t\t\t\t// is this equivalent?\n\t\t\t\t\t// const document = logical_container_el.tagName == \"IFRAME\" ? logical_container_el.contentDocument : logical_container_el.ownerDocument;\n\n\t\t\t\t\t// console.log(`handling ${event.type} for container`, container_el);\n\t\t\t\t\tlet newly_focused = event ? (event.type === \"focusout\" || event.type === \"blur\") ? event.relatedTarget : event.target : document.activeElement;\n\t\t\t\t\tif (event && event.type === \"blur\") {\n\t\t\t\t\t\tnewly_focused = null; // only handle iframe\n\t\t\t\t\t}\n\n\t\t\t\t\t// console.log(`[${$w.title()}] (is_root=${is_root})`, `newly_focused is (preliminarily)`, element_to_string(newly_focused), `\\nlogical_container_el`, logical_container_el, `\\ncontainer_node`, container_node, `\\ndocument.activeElement`, document.activeElement, `\\ndocument.hasFocus()`, document.hasFocus(), `\\ndocument`, document);\n\n\t\t\t\t\t// Iframes are stingy about focus events, so we need to check if focus is actually within an iframe.\n\t\t\t\t\tif (\n\t\t\t\t\t\tdocument.activeElement &&\n\t\t\t\t\t\tdocument.activeElement.tagName === \"IFRAME\" &&\n\t\t\t\t\t\t(event && event.type === \"focusout\" || event && event.type === \"blur\") &&\n\t\t\t\t\t\t!newly_focused // doesn't exist for security reasons in this case\n\t\t\t\t\t) {\n\t\t\t\t\t\tnewly_focused = document.activeElement;\n\t\t\t\t\t\t// console.log(`[${$w.title()}] (is_root=${is_root})`, `newly_focused is (actually)`, element_to_string(newly_focused));\n\t\t\t\t\t}\n\n\t\t\t\t\tconst outside_or_at_exactly =\n\t\t\t\t\t\t!newly_focused ||\n\t\t\t\t\t\t// contains() only works with DOM nodes (elements and documents), not window objects.\n\t\t\t\t\t\t// Since container_node is a DOM node, it will never have a Window inside of it (ignoring iframes).\n\t\t\t\t\t\tnewly_focused.window === newly_focused || // is a Window object (cross-frame test)\n\t\t\t\t\t\t!container_node.contains(newly_focused); // Note: node.contains(node) === true\n\t\t\t\t\tconst firmly_outside = outside_or_at_exactly && container_node !== newly_focused;\n\n\t\t\t\t\t// console.log(`[${$w.title()}] (is_root=${is_root})`, `outside_or_at_exactly=${outside_or_at_exactly}`, `firmly_outside=${firmly_outside}`);\n\t\t\t\t\tif (firmly_outside && is_root) {\n\t\t\t\t\t\tstopShowingAsFocused();\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\t!outside_or_at_exactly &&\n\t\t\t\t\t\tnewly_focused.tagName !== \"HTML\" &&\n\t\t\t\t\t\tnewly_focused.tagName !== \"BODY\" &&\n\t\t\t\t\t\tnewly_focused !== container_node &&\n\t\t\t\t\t\t!newly_focused.matches(\".window-content\") &&\n\t\t\t\t\t\t!newly_focused.closest(\".menus\") &&\n\t\t\t\t\t\t!newly_focused.closest(\".window-titlebar\")\n\t\t\t\t\t) {\n\t\t\t\t\t\tlast_focus_by_container.set(logical_container_el, newly_focused); // overwritten for iframes below\n\t\t\t\t\t\tdebug_focus_tracking(document, container_node, newly_focused, is_root);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t!outside_or_at_exactly &&\n\t\t\t\t\t\tnewly_focused.tagName === \"IFRAME\"\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst iframe = newly_focused;\n\t\t\t\t\t\t// console.log(\"iframe\", iframe, onfocusin_by_container.has(iframe));\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst focus_in_iframe = iframe.contentDocument.activeElement;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tfocus_in_iframe &&\n\t\t\t\t\t\t\t\tfocus_in_iframe.tagName !== \"HTML\" &&\n\t\t\t\t\t\t\t\tfocus_in_iframe.tagName !== \"BODY\" &&\n\t\t\t\t\t\t\t\t!focus_in_iframe.closest(\".menus\")\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t// last_focus_by_container.set(logical_container_el, iframe); // done above\n\t\t\t\t\t\t\t\tlast_focus_by_container.set(iframe, focus_in_iframe);\n\t\t\t\t\t\t\t\tdebug_focus_tracking(iframe.contentDocument, iframe.contentDocument, focus_in_iframe, is_root);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\twarn_iframe_access(iframe, e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// For child windows and menu popups, follow \"semantic parent\" chain.\n\t\t\t\t\t// Menu popups and child windows aren't descendants of the window they belong to,\n\t\t\t\t\t// but should keep the window shown as focused.\n\t\t\t\t\t// (In principle this sort of feature could be useful for focus tracking*,\n\t\t\t\t\t// but right now it's only for child windows and menu popups, which should not be tracked for refocus,\n\t\t\t\t\t// so I'm doing this after last_focus_by_container.set, for now anyway.)\n\t\t\t\t\t// ((*: and it may even be surprising if it doesn't work, if one sees the attribute on menus and attempts to use it.\n\t\t\t\t\t// But who's going to see that? The menus close so it's a pain to see the DOM structure! :P **))\n\t\t\t\t\t// (((**: without window.debugKeepMenusOpen)))\n\t\t\t\t\tif (is_root) {\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t// if (!newly_focused?.closest) {\n\t\t\t\t\t\t\t// \tconsole.warn(\"what is this?\", newly_focused);\n\t\t\t\t\t\t\t// \tbreak;\n\t\t\t\t\t\t\t// }\n\t\t\t\t\t\t\tconst waypoint = newly_focused && newly_focused.closest && newly_focused.closest(\"[data-semantic-parent]\");\n\t\t\t\t\t\t\tif (waypoint) {\n\t\t\t\t\t\t\t\tconst id = waypoint.dataset.semanticParent;\n\t\t\t\t\t\t\t\tconst parent = waypoint.ownerDocument.getElementById(id);\n\t\t\t\t\t\t\t\t// console.log(\"following semantic parent, from\", newly_focused, \"\\nto\", parent, \"\\nvia\", waypoint);\n\t\t\t\t\t\t\t\tnewly_focused = parent;\n\t\t\t\t\t\t\t\tif (!parent) {\n\t\t\t\t\t\t\t\t\tconsole.warn(\"semantic parent not found with id\", id);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (true);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Note: allowing showing window as focused from listeners inside iframe (non-root) too,\n\t\t\t\t\t// in order to handle clicking an iframe when the browser window was not previously focused (e.g. after reload)\n\t\t\t\t\tif (\n\t\t\t\t\t\tnewly_focused &&\n\t\t\t\t\t\tnewly_focused.window !== newly_focused && // cross-frame test for Window object\n\t\t\t\t\t\tcontainer_node.contains(newly_focused)\n\t\t\t\t\t) {\n\t\t\t\t\t\tshowAsFocused();\n\t\t\t\t\t\t$w.bringToFront();\n\t\t\t\t\t\tif (!is_root) {\n\t\t\t\t\t\t\t// trigger focusin events for iframes\n\t\t\t\t\t\t\t// @TODO: probably don't need showAsFocused() here since it'll be handled externally (on this simulated focusin),\n\t\t\t\t\t\t\t// and might not need a lot of other logic frankly if I'm simulating focusin events\n\t\t\t\t\t\t\tlet el = logical_container_el;\n\t\t\t\t\t\t\twhile (el) {\n\t\t\t\t\t\t\t\t// console.log(\"dispatching focusin event for\", el);\n\t\t\t\t\t\t\t\tel.dispatchEvent(new Event(\"focusin\", {\n\t\t\t\t\t\t\t\t\tbubbles: true,\n\t\t\t\t\t\t\t\t\ttarget: el,\n\t\t\t\t\t\t\t\t\tview: el.ownerDocument.defaultView,\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t\tel = el.currentView && el.currentView.frameElement;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (is_root) {\n\t\t\t\t\t\tstopShowingAsFocused();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// initial state is unfocused\n\t\t}\n\n\t\t$w.css(\"touch-action\", \"none\");\n\n\t\tlet minimize_target_el = null; // taskbar button (optional)\n\t\t$w.setMinimizeTarget = function (new_taskbar_button_el) {\n\t\t\tminimize_target_el = new_taskbar_button_el;\n\t\t};\n\n\t\tlet task;\n\t\tObject.defineProperty($w, \"task\", {\n\t\t\tget() {\n\t\t\t\treturn task;\n\t\t\t},\n\t\t\tset(new_task) {\n\t\t\t\tconsole.warn(\"DEPRECATED: use $w.setMinimizeTarget(taskbar_button_el) instead of setting $window.task object\");\n\t\t\t\ttask = new_task;\n\t\t\t},\n\t\t});\n\n\t\tlet before_minimize;\n\t\t$w.minimize = () => {\n\t\t\tminimize_target_el = minimize_target_el || task && task.$task[0];\n\t\t\tif (animating_titlebar) {\n\t\t\t\twhen_done_animating_titlebar.push($w.minimize);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ($w.is(\":visible\")) {\n\t\t\t\tif (minimize_target_el && !$w.hasClass(\"minimized-without-taskbar\")) {\n\t\t\t\t\tconst before_rect = $w.$titlebar[0].getBoundingClientRect();\n\t\t\t\t\tconst after_rect = minimize_target_el.getBoundingClientRect();\n\t\t\t\t\t$w.animateTitlebar(before_rect, after_rect, () => {\n\t\t\t\t\t\t$w.hide();\n\t\t\t\t\t\t$w.blur();\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// no taskbar\n\n\t\t\t\t\t// @TODO: make this metrically similar to what Windows 98 does\n\t\t\t\t\t// @TODO: DRY! This is copied heavily from maximize()\n\t\t\t\t\t// @TODO: after minimize (without taskbar) and maximize, restore should restore original position before minimize\n\t\t\t\t\t// OR should it not maximize but restore the unmaximized state? I think I tested it but I forget.\n\n\t\t\t\t\tconst to_width = 150;\n\t\t\t\t\tconst spacing = 10;\n\t\t\t\t\tif ($w.hasClass(\"minimized-without-taskbar\")) {\n\t\t\t\t\t\t// unminimizing\n\t\t\t\t\t\tminimize_slots[$w._minimize_slot_index] = null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// minimizing\n\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\twhile (minimize_slots[i]) {\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$w._minimize_slot_index = i;\n\t\t\t\t\t\tminimize_slots[i] = $w;\n\t\t\t\t\t}\n\t\t\t\t\tconst to_x = $w._minimize_slot_index * (to_width + spacing) + 10;\n\t\t\t\t\tconst titlebar_height = $w.$titlebar.outerHeight();\n\t\t\t\t\tlet before_unminimize;\n\t\t\t\t\tconst instantly_minimize = () => {\n\t\t\t\t\t\tbefore_minimize = {\n\t\t\t\t\t\t\tposition: $w.css(\"position\"),\n\t\t\t\t\t\t\tleft: $w.css(\"left\"),\n\t\t\t\t\t\t\ttop: $w.css(\"top\"),\n\t\t\t\t\t\t\twidth: $w.css(\"width\"),\n\t\t\t\t\t\t\theight: $w.css(\"height\"),\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t$w.addClass(\"minimized-without-taskbar\");\n\t\t\t\t\t\tif ($w.hasClass(\"maximized\")) {\n\t\t\t\t\t\t\t$w.removeClass(\"maximized\");\n\t\t\t\t\t\t\t$w.addClass(\"was-maximized\");\n\t\t\t\t\t\t\t$w.$maximize.removeClass(\"window-action-restore\");\n\t\t\t\t\t\t\t$w.$maximize.addClass(\"window-action-maximize\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$w.$minimize.removeClass(\"window-action-minimize\");\n\t\t\t\t\t\t$w.$minimize.addClass(\"window-action-restore\");\n\t\t\t\t\t\tif (before_unminimize) {\n\t\t\t\t\t\t\t$w.css({\n\t\t\t\t\t\t\t\tposition: before_unminimize.position,\n\t\t\t\t\t\t\t\tleft: before_unminimize.left,\n\t\t\t\t\t\t\t\ttop: before_unminimize.top,\n\t\t\t\t\t\t\t\twidth: before_unminimize.width,\n\t\t\t\t\t\t\t\theight: before_unminimize.height,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$w.css({\n\t\t\t\t\t\t\t\tposition: \"fixed\",\n\t\t\t\t\t\t\t\ttop: `calc(100% - ${titlebar_height + 5}px)`,\n\t\t\t\t\t\t\t\tleft: to_x,\n\t\t\t\t\t\t\t\twidth: to_width,\n\t\t\t\t\t\t\t\theight: titlebar_height,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tconst instantly_unminimize = () => {\n\t\t\t\t\t\tbefore_unminimize = {\n\t\t\t\t\t\t\tposition: $w.css(\"position\"),\n\t\t\t\t\t\t\tleft: $w.css(\"left\"),\n\t\t\t\t\t\t\ttop: $w.css(\"top\"),\n\t\t\t\t\t\t\twidth: $w.css(\"width\"),\n\t\t\t\t\t\t\theight: $w.css(\"height\"),\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t$w.removeClass(\"minimized-without-taskbar\");\n\t\t\t\t\t\tif ($w.hasClass(\"was-maximized\")) {\n\t\t\t\t\t\t\t$w.removeClass(\"was-maximized\");\n\t\t\t\t\t\t\t$w.addClass(\"maximized\");\n\t\t\t\t\t\t\t$w.$maximize.removeClass(\"window-action-maximize\");\n\t\t\t\t\t\t\t$w.$maximize.addClass(\"window-action-restore\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$w.$minimize.removeClass(\"window-action-restore\");\n\t\t\t\t\t\t$w.$minimize.addClass(\"window-action-minimize\");\n\t\t\t\t\t\t$w.css({ width: \"\", height: \"\" });\n\t\t\t\t\t\tif (before_minimize) {\n\t\t\t\t\t\t\t$w.css({\n\t\t\t\t\t\t\t\tposition: before_minimize.position,\n\t\t\t\t\t\t\t\tleft: before_minimize.left,\n\t\t\t\t\t\t\t\ttop: before_minimize.top,\n\t\t\t\t\t\t\t\twidth: before_minimize.width,\n\t\t\t\t\t\t\t\theight: before_minimize.height,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tconst before_rect = $w.$titlebar[0].getBoundingClientRect();\n\t\t\t\t\tlet after_rect;\n\t\t\t\t\t$w.css(\"transform\", \"\");\n\t\t\t\t\tif ($w.hasClass(\"minimized-without-taskbar\")) {\n\t\t\t\t\t\tinstantly_unminimize();\n\t\t\t\t\t\tafter_rect = $w.$titlebar[0].getBoundingClientRect();\n\t\t\t\t\t\tinstantly_minimize();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tinstantly_minimize();\n\t\t\t\t\t\tafter_rect = $w.$titlebar[0].getBoundingClientRect();\n\t\t\t\t\t\tinstantly_unminimize();\n\t\t\t\t\t}\n\t\t\t\t\t$w.animateTitlebar(before_rect, after_rect, () => {\n\t\t\t\t\t\tif ($w.hasClass(\"minimized-without-taskbar\")) {\n\t\t\t\t\t\t\tinstantly_unminimize();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinstantly_minimize();\n\t\t\t\t\t\t\t$w.blur();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t$w.unminimize = () => {\n\t\t\tif (animating_titlebar) {\n\t\t\t\twhen_done_animating_titlebar.push($w.unminimize);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ($w.hasClass(\"minimized-without-taskbar\")) {\n\t\t\t\t$w.minimize();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ($w.is(\":hidden\")) {\n\t\t\t\tconst before_rect = minimize_target_el.getBoundingClientRect();\n\t\t\t\t$w.show();\n\t\t\t\tconst after_rect = $w.$titlebar[0].getBoundingClientRect();\n\t\t\t\t$w.hide();\n\t\t\t\t$w.animateTitlebar(before_rect, after_rect, () => {\n\t\t\t\t\t$w.show();\n\t\t\t\t\t$w.bringToFront();\n\t\t\t\t\t$w.focus();\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tlet before_maximize;\n\t\t$w.maximize = () => {\n\t\t\tif (!options.resizable) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (animating_titlebar) {\n\t\t\t\twhen_done_animating_titlebar.push($w.maximize);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ($w.hasClass(\"minimized-without-taskbar\")) {\n\t\t\t\t$w.minimize();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst instantly_maximize = () => {\n\t\t\t\tbefore_maximize = {\n\t\t\t\t\tposition: $w.css(\"position\"),\n\t\t\t\t\tleft: $w.css(\"left\"),\n\t\t\t\t\ttop: $w.css(\"top\"),\n\t\t\t\t\twidth: $w.css(\"width\"),\n\t\t\t\t\theight: $w.css(\"height\"),\n\t\t\t\t};\n\n\t\t\t\t$w.addClass(\"maximized\");\n\t\t\t\tconst $taskbar = $(\".taskbar\");\n\t\t\t\tconst scrollbar_width = window.innerWidth - $(window).width();\n\t\t\t\tconst scrollbar_height = window.innerHeight - $(window).height();\n\t\t\t\tconst taskbar_height = $taskbar.length ? $taskbar.outerHeight() + 1 : 0;\n\t\t\t\t$w.css({\n\t\t\t\t\tposition: \"fixed\",\n\t\t\t\t\ttop: 0,\n\t\t\t\t\tleft: 0,\n\t\t\t\t\twidth: `calc(100vw - ${scrollbar_width}px)`,\n\t\t\t\t\theight: `calc(100vh - ${scrollbar_height}px - ${taskbar_height}px)`,\n\t\t\t\t});\n\t\t\t};\n\t\t\tconst instantly_unmaximize = () => {\n\t\t\t\t$w.removeClass(\"maximized\");\n\t\t\t\t$w.css({ width: \"\", height: \"\" });\n\t\t\t\tif (before_maximize) {\n\t\t\t\t\t$w.css({\n\t\t\t\t\t\tposition: before_maximize.position,\n\t\t\t\t\t\tleft: before_maximize.left,\n\t\t\t\t\t\ttop: before_maximize.top,\n\t\t\t\t\t\twidth: before_maximize.width,\n\t\t\t\t\t\theight: before_maximize.height,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst before_rect = $w.$titlebar[0].getBoundingClientRect();\n\t\t\tlet after_rect;\n\t\t\t$w.css(\"transform\", \"\");\n\t\t\tconst restoring = $w.hasClass(\"maximized\");\n\t\t\tif (restoring) {\n\t\t\t\tinstantly_unmaximize();\n\t\t\t\tafter_rect = $w.$titlebar[0].getBoundingClientRect();\n\t\t\t\tinstantly_maximize();\n\t\t\t} else {\n\t\t\t\tinstantly_maximize();\n\t\t\t\tafter_rect = $w.$titlebar[0].getBoundingClientRect();\n\t\t\t\tinstantly_unmaximize();\n\t\t\t}\n\t\t\t$w.animateTitlebar(before_rect, after_rect, () => {\n\t\t\t\tif (restoring) {\n\t\t\t\t\tinstantly_unmaximize(); // finalize in some way\n\t\t\t\t\t$w.$maximize.removeClass(\"window-action-restore\");\n\t\t\t\t\t$w.$maximize.addClass(\"window-action-maximize\");\n\t\t\t\t} else {\n\t\t\t\t\tinstantly_maximize(); // finalize in some way\n\t\t\t\t\t$w.$maximize.removeClass(\"window-action-maximize\");\n\t\t\t\t\t$w.$maximize.addClass(\"window-action-restore\");\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\t$w.restore = () => {\n\t\t\tif ($w.is(\".minimized-without-taskbar, .minimized\")) {\n\t\t\t\t$w.unminimize();\n\t\t\t} else if ($w.is(\".maximized\")) {\n\t\t\t\t$w.maximize();\n\t\t\t}\n\t\t};\n\t\t// must not pass event to functions by accident; also methods may not be defined yet\n\t\t$w.$minimize && $w.$minimize.on(\"click\", (e)=> { $w.minimize(); });\n\t\t$w.$maximize && $w.$maximize.on(\"click\", (e)=> { $w.maximize(); });\n\t\t$w.$x && $w.$x.on(\"click\", (e)=> { $w.close(); });\n\t\t$w.$title_area.on(\"dblclick\", (e)=> { $w.maximize(); });\n\n\t\t$w.css({\n\t\t\tposition: \"absolute\",\n\t\t\tzIndex: $Window.Z_INDEX++\n\t\t});\n\t\t$w.bringToFront = () => {\n\t\t\t$w.css({\n\t\t\t\tzIndex: $Window.Z_INDEX++\n\t\t\t});\n\t\t\tfor (const $childWindow of child_$windows) {\n\t\t\t\t$childWindow.bringToFront();\n\t\t\t}\n\t\t};\n\n\t\t// Keep track of last focused elements per container,\n\t\t// where containers include:\n\t\t// - window (global focus tracking)\n\t\t// - $w[0] (window-local, for restoring focus when refocusing window)\n\t\t// - any iframes that are same-origin (for restoring focus when refocusing window)\n\t\t// @TODO: should these be WeakMaps? probably.\n\t\t// @TODO: share this Map between all windows? but clean it up when destroying windows? or would a WeakMap take care of that?\n\t\tvar last_focus_by_container = new Map(); // element to restore focus to, by container\n\t\tvar focus_update_handlers_by_container = new Map(); // event handlers by container; note use as a flag to avoid adding multiple handlers\n\t\tvar debug_svg_by_container = new Map(); // visualization\n\t\tvar debug_svgs_in_window = []; // visualization\n\t\tvar warned_iframes = new WeakSet(); // prevent spamming console\n\n\t\tconst warn_iframe_access = (iframe, error) => {\n\t\t\tconst log_template = (message) => [`OS-GUI.js failed to access an iframe (${element_to_string(iframe)}) for focus integration.\n\t${message}\n\tOriginal error:\n\t`, error];\n\n\t\t\tlet cross_origin;\n\t\t\tif (iframe.srcdoc) {\n\t\t\t\tcross_origin = false;\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tconst url = new URL(iframe.src);\n\t\t\t\t\tcross_origin = url.origin !== window.location.origin; // shouldn't need to use iframe.ownerDocument.location.origin because intermediate iframes must be same-origin\n\t\t\t\t} catch (parse_error) {\n\t\t\t\t\tconsole.error(...log_template(`This may be a bug in OS-GUI. Is this a cross-origin iframe? Failed to parse URL (${parse_error}).`));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cross_origin) {\n\t\t\t\tif (options.iframes && options.iframes.ignoreCrossOrigin && !warned_iframes.has(iframe)) {\n\t\t\t\t\tconsole.warn(...log_template(`Only same-origin iframes can work with focus integration (showing window as focused, refocusing last focused controls).\n\tIf you can re-host the content on the same origin, you can resolve this and enable focus integration.\n\tYou can also disable this warning by passing {iframes: {ignoreCrossOrigin: true}} to $Window.`));\n\t\t\t\t\twarned_iframes.add(iframe);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.error(...log_template(`This may be a bug in OS-GUI, since it doesn't appear to be a cross-origin iframe.`));\n\t\t\t}\n\t\t};\n\n\t\tconst debug_focus_tracking = (document, container_el, descendant_el, is_root) => {\n\t\t\tif (!$Window.DEBUG_FOCUS) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet svg = debug_svg_by_container.get(container_el);\n\t\t\tif (!svg) {\n\t\t\t\tsvg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n\t\t\t\tsvg.style.position = \"fixed\";\n\t\t\t\tsvg.style.top = \"0\";\n\t\t\t\tsvg.style.left = \"0\";\n\t\t\t\tsvg.style.width = \"100%\";\n\t\t\t\tsvg.style.height = \"100%\";\n\t\t\t\tsvg.style.pointerEvents = \"none\";\n\t\t\t\tsvg.style.zIndex = \"100000000\";\n\t\t\t\tsvg.style.direction = \"ltr\"; // position labels correctly\n\t\t\t\tdebug_svg_by_container.set(container_el, svg);\n\t\t\t\tdebug_svgs_in_window.push(svg);\n\t\t\t\tdocument.body.appendChild(svg);\n\t\t\t}\n\t\t\tsvg._container_el = container_el;\n\t\t\tsvg._descendant_el = descendant_el;\n\t\t\tsvg._is_root = is_root;\n\t\t\tanimate_debug_focus_tracking();\n\t\t};\n\t\tconst update_debug_focus_tracking = (svg) => {\n\t\t\tconst container_el = svg._container_el;\n\t\t\tconst descendant_el = svg._descendant_el;\n\t\t\tconst is_root = svg._is_root;\n\n\t\t\twhile (svg.lastChild) {\n\t\t\t\tsvg.removeChild(svg.lastChild);\n\t\t\t}\n\t\t\tconst descendant_rect = descendant_el.getBoundingClientRect && descendant_el.getBoundingClientRect() ||/*??*/ { left: 0, top: 0, width: innerWidth, height: innerHeight, right: innerWidth, bottom: innerHeight };\n\t\t\tconst container_rect = container_el.getBoundingClientRect && ontainer_el.getBoundingClientRect() ||/*??*/ { left: 0, top: 0, width: innerWidth, height: innerHeight, right: innerWidth, bottom: innerHeight };\n\t\t\t// draw rectangles with labels\n\t\t\tfor (const rect of [descendant_rect, container_rect]) {\n\t\t\t\tconst rect_el = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n\t\t\t\trect_el.setAttribute(\"x\", rect.left);\n\t\t\t\trect_el.setAttribute(\"y\", rect.top);\n\t\t\t\trect_el.setAttribute(\"width\", rect.width);\n\t\t\t\trect_el.setAttribute(\"height\", rect.height);\n\t\t\t\trect_el.setAttribute(\"stroke\", rect === descendant_rect ? \"#f44\" : \"#f44\");\n\t\t\t\trect_el.setAttribute(\"stroke-width\", \"2\");\n\t\t\t\trect_el.setAttribute(\"fill\", \"none\");\n\t\t\t\tif (!is_root) {\n\t\t\t\t\trect_el.setAttribute(\"stroke-dasharray\", \"5,5\");\n\t\t\t\t}\n\t\t\t\tsvg.appendChild(rect_el);\n\t\t\t\tconst text_el = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n\t\t\t\ttext_el.setAttribute(\"x\", rect.left);\n\t\t\t\ttext_el.setAttribute(\"y\", rect.top + (rect === descendant_rect ? 20 : 0)); // align container text on outside, descendant text on inside\n\t\t\t\ttext_el.setAttribute(\"fill\", rect === descendant_rect ? \"#f44\" : \"aqua\");\n\t\t\t\ttext_el.setAttribute(\"font-size\", \"20\");\n\t\t\t\ttext_el.style.textShadow = \"1px 1px 1px black, 0 0 10px black\";\n\t\t\t\ttext_el.textContent = element_to_string(rect === descendant_rect ? descendant_el : container_el);\n\t\t\t\tsvg.appendChild(text_el);\n\t\t\t}\n\t\t\t// draw lines connecting the two rects\n\t\t\tconst lines = [\n\t\t\t\t[descendant_rect.left, descendant_rect.top, container_rect.left, container_rect.top],\n\t\t\t\t[descendant_rect.right, descendant_rect.top, container_rect.right, container_rect.top],\n\t\t\t\t[descendant_rect.left, descendant_rect.bottom, container_rect.left, container_rect.bottom],\n\t\t\t\t[descendant_rect.right, descendant_rect.bottom, container_rect.right, container_rect.bottom],\n\t\t\t];\n\t\t\tfor (const line of lines) {\n\t\t\t\tconst line_el = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n\t\t\t\tline_el.setAttribute(\"x1\", line[0]);\n\t\t\t\tline_el.setAttribute(\"y1\", line[1]);\n\t\t\t\tline_el.setAttribute(\"x2\", line[2]);\n\t\t\t\tline_el.setAttribute(\"y2\", line[3]);\n\t\t\t\tline_el.setAttribute(\"stroke\", \"green\");\n\t\t\t\tline_el.setAttribute(\"stroke-width\", \"2\");\n\t\t\t\tsvg.appendChild(line_el);\n\t\t\t}\n\t\t};\n\t\tlet debug_animation_frame_id;\n\t\tconst animate_debug_focus_tracking = () => {\n\t\t\tcancelAnimationFrame(debug_animation_frame_id);\n\t\t\tif (!$Window.DEBUG_FOCUS) {\n\t\t\t\tclean_up_debug_focus_tracking();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdebug_animation_frame_id = requestAnimationFrame(animate_debug_focus_tracking);\n\t\t\tfor (const svg of debug_svgs_in_window) {\n\t\t\t\tupdate_debug_focus_tracking(svg);\n\t\t\t}\n\t\t};\n\t\tconst clean_up_debug_focus_tracking = () => {\n\t\t\tcancelAnimationFrame(debug_animation_frame_id);\n\t\t\tfor (const svg of debug_svgs_in_window) {\n\t\t\t\tsvg.remove();\n\t\t\t}\n\t\t\tdebug_svgs_in_window.length = 0;\n\t\t\tdebug_svg_by_container.clear();\n\t\t};\n\n\t\tconst refocus = (container_el = $w.$content[0]) => {\n\t\t\tconst logical_container_el = container_el.matches(\".window-content\") ? $w[0] : container_el;\n\t\t\tconst last_focus = last_focus_by_container.get(logical_container_el);\n\t\t\tif (last_focus) {\n\t\t\t\tlast_focus.focus({ preventScroll: true });\n\t\t\t\tif (last_focus.tagName === \"IFRAME\") {\n\t\t\t\t\ttry {\n\t\t\t\t\t\trefocus(last_focus);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\twarn_iframe_access(last_focus, e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst $tabstops = find_tabstops(container_el);\n\t\t\tconst $default = $tabstops.filter(\".default\");\n\t\t\tif ($default.length) {\n\t\t\t\t$default[0].focus({ preventScroll: true });\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ($tabstops.length) {\n\t\t\t\tif ($tabstops[0].tagName === \"IFRAME\") {\n\t\t\t\t\ttry {\n\t\t\t\t\t\trefocus($tabstops[0]); // not .contentDocument.body because we want the container tracked by last_focus_by_container\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\twarn_iframe_access($tabstops[0], e);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$tabstops[0].focus({ preventScroll: true });\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (options.toolWindow && options.parentWindow) {\n\t\t\t\toptions.parentWindow.triggerHandler(\"refocus-window\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcontainer_el.focus({ preventScroll: true });\n\t\t\tif (container_el.tagName === \"IFRAME\") {\n\t\t\t\ttry {\n\t\t\t\t\trefocus(container_el.contentDocument.body);\n\t\t\t\t} catch (e) {\n\t\t\t\t\twarn_iframe_access(container_el, e);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t$w.on(\"refocus-window\", () => {\n\t\t\trefocus();\n\t\t});\n\n\t\t// redundant events are for handling synthetic events,\n\t\t// which may be sent individually, rather than in tandem\n\t\t$w.on(\"pointerdown mousedown\", handle_pointer_activation);\n\t\t// Note that jQuery treats some events differently, and can't listen for some synthetic events\n\t\t// but pointerdown and mousedown seem to be supported. That said, if you trigger() either,\n\t\t// addEventListener() handlers will not be called. So if I remove the dependency on jQuery,\n\t\t// it will not be possible to listen for some .trigger() events.\n\t\t// https://jsfiddle.net/1j01/ndvwts9y/1/\n\n\t\t// Assumption: focusin comes after pointerdown/mousedown\n\t\t// This is probably guaranteed, because you can prevent the default of focusing from pointerdown/mousedown\n\t\t$G.on(\"focusin\", (e) => {\n\t\t\tlast_focus_by_container.set(window, e.target);\n\t\t\t// debug_focus_tracking(document, window, e.target);\n\t\t});\n\n\t\tfunction handle_pointer_activation(event) {\n\t\t\t// console.log(\"handle_pointer_activation\", event.type, event.target);\n\t\t\t$w.bringToFront();\n\t\t\t// Test cases where it should refocus the last focused control in the window:\n\t\t\t// - Click in the blank space of the window\n\t\t\t//   - Click in blank space again now that something's focused\n\t\t\t// - Click on the window title bar\n\t\t\t//   - Click on title bar buttons\n\t\t\t// - Closing a second window should focus the first window\n\t\t\t//   - Open a dialog window from an app window that has a tool window, then close the dialog window\n\t\t\t//     - @TODO: Even if the tool window has controls, it should focus the parent window, I think\n\t\t\t// - Clicking on a control in the window should focus said control\n\t\t\t// - Clicking on a disabled control in the window should focus the window\n\t\t\t//   - Make sure to test this with another window previously focused\n\t\t\t// - Simulated clicks (important for JS Paint's eye gaze and speech recognition modes)\n\t\t\t// - (@TODO: Should clicking a child window focus the parent window?)\n\t\t\t// - After potentially selecting text but not selecting anything\n\t\t\t// It should NOT refocus when:\n\t\t\t// - Clicking on a control in a different window\n\t\t\t// - When other event handlers set focus\n\t\t\t//   - Using the keyboard to focus something outside the window, such as a menu popup\n\t\t\t//   - Clicking a control that focuses something outside the window\n\t\t\t//     - Button that opens another window (e.g. Recursive Dialog button in tests)\n\t\t\t//     - Button that focuses a control in another window (e.g. Focus Other button in tests)\n\t\t\t// - Trying to select text\n\n\t\t\t// Wait for other pointerdown handlers and default behavior, and focusin events.\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tconst last_focus_global = last_focus_by_container.get(window);\n\t\t\t\t// const last_focus_in_window = last_focus_by_container.get($w.$content[0]);\n\t\t\t\t// console.log(\"a tick after\", event.type, { last_focus_in_window, last_focus_global, activeElement: document.activeElement, win_elem: $w[0] });\n\t\t\t\t// console.log(\"did focus change?\", document.activeElement !== last_focus_global);\n\n\t\t\t\t// If something programmatically got focus, don't refocus.\n\t\t\t\tif (\n\t\t\t\t\tdocument.activeElement &&\n\t\t\t\t\tdocument.activeElement !== document &&\n\t\t\t\t\tdocument.activeElement !== document.body &&\n\t\t\t\t\tdocument.activeElement !== $w.$content[0] &&\n\t\t\t\t\tdocument.activeElement !== last_focus_global\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// If menus got focus, don't refocus.\n\t\t\t\tif (document.activeElement && document.activeElement.closest && document.activeElement.closest(\".menus, .menu-popup\")) {\n\t\t\t\t\t// console.log(\"click in menus\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If the element is selectable, wait until the click is done and see if anything was selected first.\n\t\t\t\t// This is a bit of a weird compromise, for now.\n\t\t\t\tconst target_style = getComputedStyle(event.target);\n\t\t\t\tif (target_style.userSelect !== \"none\") {\n\t\t\t\t\t// Immediately show the window as focused, just don't refocus a specific control.\n\t\t\t\t\t$w.$content.focus();\n\n\t\t\t\t\t$w.one(\"pointerup pointercancel\", () => {\n\t\t\t\t\t\trequestAnimationFrame(() => { // this seems to make it more reliable in regards to double clicking\n\t\t\t\t\t\t\tif (!getSelection().toString().trim()) {\n\t\t\t\t\t\t\t\trefocus();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// Set focus to the last focused control, which should be updated if a click just occurred.\n\t\t\t\trefocus();\n\t\t\t});\n\t\t}\n\n\t\t$w.on(\"keydown\", (e) => {\n\t\t\tif (e.isDefaultPrevented()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (e.ctrlKey || e.altKey || e.metaKey) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// console.log(\"keydown\", e.key, e.target);\n\t\t\tif (e.target.closest(\".menus\")) {\n\t\t\t\t// console.log(\"keydown in menus\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst $buttons = $w.$content.find(\"button\");\n\t\t\tconst $focused = $(document.activeElement);\n\t\t\tconst focused_index = $buttons.index($focused);\n\t\t\tswitch (e.keyCode) {\n\t\t\t\tcase 40: // Down\n\t\t\t\tcase 39: // Right\n\t\t\t\t\tif ($focused.is(\"button\") && !e.shiftKey) {\n\t\t\t\t\t\tif (focused_index < $buttons.length - 1) {\n\t\t\t\t\t\t\t$buttons[focused_index + 1].focus();\n\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 38: // Up\n\t\t\t\tcase 37: // Left\n\t\t\t\t\tif ($focused.is(\"button\") && !e.shiftKey) {\n\t\t\t\t\t\tif (focused_index > 0) {\n\t\t\t\t\t\t\t$buttons[focused_index - 1].focus();\n\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 32: // Space\n\t\t\t\tcase 13: // Enter (doesn't actually work in chrome because the button gets clicked immediately)\n\t\t\t\t\tif ($focused.is(\"button\") && !e.shiftKey) {\n\t\t\t\t\t\t$focused.addClass(\"pressed\");\n\t\t\t\t\t\tconst release = () => {\n\t\t\t\t\t\t\t$focused.removeClass(\"pressed\");\n\t\t\t\t\t\t\t$focused.off(\"focusout\", release);\n\t\t\t\t\t\t\t$(window).off(\"keyup\", keyup);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst keyup = (e) => {\n\t\t\t\t\t\t\tif (e.keyCode === 32 || e.keyCode === 13) {\n\t\t\t\t\t\t\t\trelease();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\t$focused.on(\"focusout\", release);\n\t\t\t\t\t\t$(window).on(\"keyup\", keyup);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9: { // Tab\n\t\t\t\t\t// wrap around when tabbing through controls in a window\n\t\t\t\t\tconst $controls = find_tabstops($w.$content[0]);\n\t\t\t\t\tif ($controls.length > 0) {\n\t\t\t\t\t\tconst focused_control_index = $controls.index($focused);\n\t\t\t\t\t\tif (e.shiftKey) {\n\t\t\t\t\t\t\tif (focused_control_index === 0) {\n\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\t$controls[$controls.length - 1].focus();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (focused_control_index === $controls.length - 1) {\n\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\t$controls[0].focus();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 27: // Escape\n\t\t\t\t\t// @TODO: make this optional, and probably default false\n\t\t\t\t\t$w.close();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\n\t\t$w.applyBounds = () => {\n\t\t\t// TODO: outerWidth vs width? not sure\n\t\t\tconst bound_width = Math.max(document.body.scrollWidth, innerWidth);\n\t\t\tconst bound_height = Math.max(document.body.scrollHeight, innerHeight);\n\t\t\t$w.css({\n\t\t\t\tleft: Math.max(0, Math.min(bound_width - $w.width(), $w.position().left)),\n\t\t\t\ttop: Math.max(0, Math.min(bound_height - $w.height(), $w.position().top)),\n\t\t\t});\n\t\t};\n\n\t\t$w.bringTitleBarInBounds = () => {\n\t\t\t// Try to make the titlebar always accessible\n\t\t\tconst bound_width = Math.max(document.body.scrollWidth, innerWidth);\n\t\t\tconst bound_height = Math.max(document.body.scrollHeight, innerHeight);\n\t\t\tconst min_horizontal_pixels_on_screen = 40; // enough for space past a close button\n\t\t\t$w.css({\n\t\t\t\tleft: Math.max(\n\t\t\t\t\tmin_horizontal_pixels_on_screen - $w.outerWidth(),\n\t\t\t\t\tMath.min(\n\t\t\t\t\t\tbound_width - min_horizontal_pixels_on_screen,\n\t\t\t\t\t\t$w.position().left\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\ttop: Math.max(0, Math.min(\n\t\t\t\t\tbound_height - $w.$titlebar.outerHeight() - 5,\n\t\t\t\t\t$w.position().top\n\t\t\t\t)),\n\t\t\t});\n\t\t};\n\n\t\t$w.center = () => {\n\t\t\t$w.css({\n\t\t\t\tleft: (innerWidth - $w.width()) / 2 + window.scrollX,\n\t\t\t\ttop: (innerHeight - $w.height()) / 2 + window.scrollY,\n\t\t\t});\n\t\t\t$w.applyBounds();\n\t\t};\n\n\n\t\t$G.on(\"resize\", $w.bringTitleBarInBounds);\n\n\t\tvar drag_offset_x, drag_offset_y, drag_pointer_x, drag_pointer_y, drag_pointer_id;\n\t\tvar update_drag = (e) => {\n\t\t\tif (drag_pointer_id === (e.pointerId ||/*??*/ e.originalEvent.pointerId)) {\n\t\t\t\tdrag_pointer_x = e.clientX ||/*??*/ drag_pointer_x;\n\t\t\t\tdrag_pointer_y = e.clientY ||/*??*/ drag_pointer_y;\n\t\t\t}\n\t\t\t$w.css({\n\t\t\t\tleft: drag_pointer_x + scrollX - drag_offset_x,\n\t\t\t\ttop: drag_pointer_y + scrollY - drag_offset_y,\n\t\t\t});\n\t\t};\n\t\t$w.$titlebar.css(\"touch-action\", \"none\");\n\t\t$w.$titlebar.on(\"selectstart\", (e) => { // preventing mousedown would break :active state, I'm not sure if just selectstart is enough...\n\t\t\te.preventDefault();\n\t\t});\n\t\t$w.$titlebar.on(\"mousedown\", \"button\", (e) => {\n\t\t\t// Prevent focus on titlebar buttons.\n\t\t\t// This can break the :active state. In Firefox, a setTimeout before any focus() was enough,\n\t\t\t// but now in Chrome 95, focus() breaks the :active state too, and setTimeout only delays the brokenness,\n\t\t\t// so I have to use a CSS class now for the pressed state.\n\t\t\trefocus();\n\t\t\t// Emulate :enabled:active:hover state with .pressing class\n\t\t\tconst button = e.currentTarget;\n\t\t\tif (!$(button).is(\":enabled\")) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbutton.classList.add(\"pressing\");\n\t\t\tconst release = (event) => {\n\t\t\t\t// blur is just to handle the edge case of alt+tabbing/ctrl+tabbing away\n\t\t\t\tif (event && event.type === \"blur\") {\n\t\t\t\t\t// if (document.activeElement?.tagName === \"IFRAME\") {\n\t\t\t\t\tif (document.hasFocus()) {\n\t\t\t\t\t\treturn; // the window isn't really blurred; an iframe got focus\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbutton.classList.remove(\"pressing\");\n\t\t\t\t$G.off(\"mouseup blur\", release);\n\t\t\t\t$(button).off(\"mouseenter\", on_mouse_enter);\n\t\t\t\t$(button).off(\"mouseleave\", on_mouse_leave);\n\t\t\t};\n\t\t\tconst on_mouse_enter = () => { button.classList.add(\"pressing\"); };\n\t\t\tconst on_mouse_leave = () => { button.classList.remove(\"pressing\"); };\n\t\t\t$G.on(\"mouseup blur\", release);\n\t\t\t$(button).on(\"mouseenter\", on_mouse_enter);\n\t\t\t$(button).on(\"mouseleave\", on_mouse_leave);\n\t\t});\n\t\t$w.$titlebar.on(\"pointerdown\", (e) => {\n\t\t\tif ($(e.target).closest(\"button\").length) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ($w.hasClass(\"maximized\")) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst customEvent = $.Event(\"window-drag-start\");\n\t\t\t$w.trigger(customEvent);\n\t\t\tif (customEvent.isDefaultPrevented()) {\n\t\t\t\treturn; // allow custom drag behavior of component windows in jspaint (Tools / Colors)\n\t\t\t}\n\t\t\tdrag_offset_x = e.clientX + scrollX - $w.position().left;\n\t\t\tdrag_offset_y = e.clientY + scrollY - $w.position().top;\n\t\t\tdrag_pointer_x = e.clientX;\n\t\t\tdrag_pointer_y = e.clientY;\n\t\t\tdrag_pointer_id = (e.pointerId ||/*??*/ e.originalEvent.pointerId);\n\t\t\t$G.on(\"pointermove\", update_drag);\n\t\t\t$G.on(\"scroll\", update_drag);\n\t\t\t$(\"body\").addClass(\"dragging\"); // for when mouse goes over an iframe\n\t\t});\n\t\t$G.on(\"pointerup pointercancel\", (e) => {\n\t\t\tif ((e.pointerId ||/*??*/ e.originalEvent.pointerId) !== drag_pointer_id) { return; }\n\t\t\t$G.off(\"pointermove\", update_drag);\n\t\t\t$G.off(\"scroll\", update_drag);\n\t\t\t$(\"body\").removeClass(\"dragging\");\n\t\t\t// $w.applyBounds(); // Windows doesn't really try to keep windows on screen\n\t\t\t// but you also can't really drag off of the desktop, whereas here you can drag to way outside the web page.\n\t\t\t$w.bringTitleBarInBounds();\n\t\t\tdrag_pointer_id = -1; // prevent bringTitleBarInBounds from making the window go to top left when unminimizing window from taskbar after previously dragging it\n\t\t});\n\t\t$w.$titlebar.on(\"dblclick\", (e) => {\n\t\t\tif ($component) {\n\t\t\t\t$component.dock();\n\t\t\t}\n\t\t});\n\n\t\tif (options.resizable) {\n\n\t\t\tconst HANDLE_MIDDLE = 0;\n\t\t\tconst HANDLE_START = -1;\n\t\t\tconst HANDLE_END = 1;\n\t\t\tconst HANDLE_LEFT = HANDLE_START;\n\t\t\tconst HANDLE_RIGHT = HANDLE_END;\n\t\t\tconst HANDLE_TOP = HANDLE_START;\n\t\t\tconst HANDLE_BOTTOM = HANDLE_END;\n\n\t\t\t[\n\t\t\t\t[HANDLE_TOP, HANDLE_RIGHT], // ↗\n\t\t\t\t[HANDLE_TOP, HANDLE_MIDDLE], // ↑\n\t\t\t\t[HANDLE_TOP, HANDLE_LEFT], // ↖\n\t\t\t\t[HANDLE_MIDDLE, HANDLE_LEFT], // ←\n\t\t\t\t[HANDLE_BOTTOM, HANDLE_LEFT], // ↙\n\t\t\t\t[HANDLE_BOTTOM, HANDLE_MIDDLE], // ↓\n\t\t\t\t[HANDLE_BOTTOM, HANDLE_RIGHT], // ↘\n\t\t\t\t[HANDLE_MIDDLE, HANDLE_RIGHT], // →\n\t\t\t].forEach(([y_axis, x_axis]) => {\n\t\t\t\t// const resizes_height = y_axis !== HANDLE_MIDDLE;\n\t\t\t\t// const resizes_width = x_axis !== HANDLE_MIDDLE;\n\t\t\t\tconst $handle = $(\"<div>\").addClass(\"handle\").appendTo($w);\n\n\t\t\t\tlet cursor = \"\";\n\t\t\t\tif (y_axis === HANDLE_TOP) { cursor += \"n\"; }\n\t\t\t\tif (y_axis === HANDLE_BOTTOM) { cursor += \"s\"; }\n\t\t\t\tif (x_axis === HANDLE_LEFT) { cursor += \"w\"; }\n\t\t\t\tif (x_axis === HANDLE_RIGHT) { cursor += \"e\"; }\n\t\t\t\tcursor += \"-resize\";\n\n\t\t\t\t// Note: MISNOMER: innerWidth() is less \"inner\" than width(), because it includes padding!\n\t\t\t\t// Here's a little diagram of sorts:\n\t\t\t\t// outerWidth(true): margin, [ outerWidth(): border, [ innerWidth(): padding, [ width(): content ] ] ]\n\t\t\t\tconst handle_thickness = ($w.outerWidth() - $w.width()) / 2; // padding + border\n\t\t\t\tconst border_width = ($w.outerWidth() - $w.innerWidth()) / 2; // border; need to outset the handles by this amount so they overlap the border + padding, and not the content\n\t\t\t\tconst window_frame_height = $w.outerHeight() - $w.$content.outerHeight(); // includes titlebar and borders, padding, but not content\n\t\t\t\tconst window_frame_width = $w.outerWidth() - $w.$content.outerWidth(); // includes borders, padding, but not content\n\t\t\t\t$handle.css({\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\ttop: y_axis === HANDLE_TOP ? -border_width : y_axis === HANDLE_MIDDLE ? `calc(${handle_thickness}px - ${border_width}px)` : \"\",\n\t\t\t\t\tbottom: y_axis === HANDLE_BOTTOM ? -border_width : \"\",\n\t\t\t\t\tleft: x_axis === HANDLE_LEFT ? -border_width : x_axis === HANDLE_MIDDLE ? `calc(${handle_thickness}px - ${border_width}px)` : \"\",\n\t\t\t\t\tright: x_axis === HANDLE_RIGHT ? -border_width : \"\",\n\t\t\t\t\twidth: x_axis === HANDLE_MIDDLE ? `calc(100% - ${handle_thickness}px * 2 + ${border_width * 2}px)` : `${handle_thickness}px`,\n\t\t\t\t\theight: y_axis === HANDLE_MIDDLE ? `calc(100% - ${handle_thickness}px * 2 + ${border_width * 2}px)` : `${handle_thickness}px`,\n\t\t\t\t\t// background: x_axis === HANDLE_MIDDLE || y_axis === HANDLE_MIDDLE ? \"rgba(255,0,0,0.4)\" : \"rgba(0,255,0,0.8)\",\n\t\t\t\t\ttouchAction: \"none\",\n\t\t\t\t\tcursor,\n\t\t\t\t});\n\n\t\t\t\tlet rect;\n\t\t\t\tlet resize_offset_x, resize_offset_y, resize_pointer_x, resize_pointer_y, resize_pointer_id;\n\t\t\t\t$handle.on(\"pointerdown\", (e) => {\n\t\t\t\t\te.preventDefault();\n\n\t\t\t\t\t$G.on(\"pointermove\", handle_pointermove);\n\t\t\t\t\t$G.on(\"scroll\", update_resize); // scroll doesn't have clientX/Y, so we have to remember it\n\t\t\t\t\t$(\"body\").addClass(\"dragging\"); // for when mouse goes over an iframe\n\t\t\t\t\t$G.on(\"pointerup pointercancel\", end_resize);\n\n\t\t\t\t\trect = {\n\t\t\t\t\t\tx: $w.position().left,\n\t\t\t\t\t\ty: $w.position().top,\n\t\t\t\t\t\twidth: $w.outerWidth(),\n\t\t\t\t\t\theight: $w.outerHeight(),\n\t\t\t\t\t};\n\n\t\t\t\t\tresize_offset_x = e.clientX + scrollX - rect.x - (x_axis === HANDLE_RIGHT ? rect.width : 0);\n\t\t\t\t\tresize_offset_y = e.clientY + scrollY - rect.y - (y_axis === HANDLE_BOTTOM ? rect.height : 0);\n\t\t\t\t\tresize_pointer_x = e.clientX;\n\t\t\t\t\tresize_pointer_y = e.clientY;\n\t\t\t\t\tresize_pointer_id = (e.pointerId ||/*??*/ e.originalEvent.pointerId);\n\n\t\t\t\t\t$handle[0].setPointerCapture(resize_pointer_id); // keeps cursor consistent when mouse moves over other elements\n\n\t\t\t\t\t// handle_pointermove(e); // was useful for checking that the offset is correct (should not do anything, if it's correct!)\n\t\t\t\t});\n\t\t\t\tfunction handle_pointermove(e) {\n\t\t\t\t\tif ((e.pointerId ||/*??*/ e.originalEvent.pointerId) !== resize_pointer_id) { return; }\n\t\t\t\t\tresize_pointer_x = e.clientX;\n\t\t\t\t\tresize_pointer_y = e.clientY;\n\t\t\t\t\tupdate_resize();\n\t\t\t\t}\n\t\t\t\tfunction end_resize(e) {\n\t\t\t\t\tif ((e.pointerId ||/*??*/ e.originalEvent.pointerId) !== resize_pointer_id) { return; }\n\t\t\t\t\t$G.off(\"pointermove\", handle_pointermove);\n\t\t\t\t\t$G.off(\"scroll\", onscroll);\n\t\t\t\t\t$(\"body\").removeClass(\"dragging\");\n\t\t\t\t\t$G.off(\"pointerup pointercancel\", end_resize);\n\t\t\t\t\t$w.bringTitleBarInBounds();\n\t\t\t\t}\n\t\t\t\tfunction update_resize() {\n\t\t\t\t\tconst mouse_x = resize_pointer_x + scrollX - resize_offset_x;\n\t\t\t\t\tconst mouse_y = resize_pointer_y + scrollY - resize_offset_y;\n\t\t\t\t\tlet delta_x = 0;\n\t\t\t\t\tlet delta_y = 0;\n\t\t\t\t\tlet width, height;\n\t\t\t\t\tif (x_axis === HANDLE_RIGHT) {\n\t\t\t\t\t\tdelta_x = 0;\n\t\t\t\t\t\twidth = ~~(mouse_x - rect.x);\n\t\t\t\t\t} else if (x_axis === HANDLE_LEFT) {\n\t\t\t\t\t\tdelta_x = ~~(mouse_x - rect.x);\n\t\t\t\t\t\twidth = ~~(rect.x + rect.width - mouse_x);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twidth = ~~(rect.width);\n\t\t\t\t\t}\n\t\t\t\t\tif (y_axis === HANDLE_BOTTOM) {\n\t\t\t\t\t\tdelta_y = 0;\n\t\t\t\t\t\theight = ~~(mouse_y - rect.y);\n\t\t\t\t\t} else if (y_axis === HANDLE_TOP) {\n\t\t\t\t\t\tdelta_y = ~~(mouse_y - rect.y);\n\t\t\t\t\t\theight = ~~(rect.y + rect.height - mouse_y);\n\t\t\t\t\t} else {\n\t\t\t\t\t\theight = ~~(rect.height);\n\t\t\t\t\t}\n\t\t\t\t\tlet new_rect = {\n\t\t\t\t\t\tx: rect.x + delta_x,\n\t\t\t\t\t\ty: rect.y + delta_y,\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\theight,\n\t\t\t\t\t};\n\n\t\t\t\t\tnew_rect.width = Math.max(1, new_rect.width);\n\t\t\t\t\tnew_rect.height = Math.max(1, new_rect.height);\n\n\t\t\t\t\t// Constraints\n\t\t\t\t\tif (options.constrainRect) {\n\t\t\t\t\t\tnew_rect = options.constrainRect(new_rect, x_axis, y_axis);\n\t\t\t\t\t}\n\t\t\t\t\tnew_rect.width = Math.max(new_rect.width, options.minOuterWidth ||/*??*/ 100);\n\t\t\t\t\tnew_rect.height = Math.max(new_rect.height, options.minOuterHeight ||/*??*/ 0);\n\t\t\t\t\tnew_rect.width = Math.max(new_rect.width, (options.minInnerWidth ||/*??*/ 0) + window_frame_width);\n\t\t\t\t\tnew_rect.height = Math.max(new_rect.height, (options.minInnerHeight ||/*??*/ 0) + window_frame_height);\n\t\t\t\t\t// prevent free movement via resize past minimum size\n\t\t\t\t\tif (x_axis === HANDLE_LEFT) {\n\t\t\t\t\t\tnew_rect.x = Math.min(new_rect.x, rect.x + rect.width - new_rect.width);\n\t\t\t\t\t}\n\t\t\t\t\tif (y_axis === HANDLE_TOP) {\n\t\t\t\t\t\tnew_rect.y = Math.min(new_rect.y, rect.y + rect.height - new_rect.height);\n\t\t\t\t\t}\n\n\t\t\t\t\t$w.css({\n\t\t\t\t\t\ttop: new_rect.y,\n\t\t\t\t\t\tleft: new_rect.x,\n\t\t\t\t\t});\n\t\t\t\t\t$w.outerWidth(new_rect.width);\n\t\t\t\t\t$w.outerHeight(new_rect.height);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t$w.$Button = (text, handler) => {\n\t\t\tvar $b = $(E(\"button\"))\n\t\t\t\t.appendTo($w.$content)\n\t\t\t\t.text(text)\n\t\t\t\t.on(\"click\", () => {\n\t\t\t\t\tif (handler) {\n\t\t\t\t\t\thandler();\n\t\t\t\t\t}\n\t\t\t\t\t$w.close();\n\t\t\t\t});\n\t\t\treturn $b;\n\t\t};\n\t\t$w.title = title => {\n\t\t\tif (title) {\n\t\t\t\t$w.$title.text(title);\n\t\t\t\t$w.trigger(\"title-change\");\n\t\t\t\tif ($w.task) {\n\t\t\t\t\t$w.task.updateTitle();\n\t\t\t\t}\n\t\t\t\treturn $w;\n\t\t\t} else {\n\t\t\t\treturn $w.$title.text();\n\t\t\t}\n\t\t};\n\t\t$w.getTitle = () => {\n\t\t\treturn $w.title();\n\t\t};\n\t\tlet animating_titlebar = false;\n\t\tlet when_done_animating_titlebar = []; // queue of functions to call when done animating,\n\t\t// so maximize() / minimize() / restore() eventually gives the same result as if there was no animation\n\t\t$w.animateTitlebar = (from, to, callback = () => { }) => {\n\t\t\t// flying titlebar animation\n\t\t\tanimating_titlebar = true;\n\t\t\tconst $eye_leader = $w.$titlebar.clone(true);\n\t\t\t$eye_leader.find(\"button\").remove();\n\t\t\t$eye_leader.appendTo(\"body\");\n\t\t\tconst duration_ms = $Window.OVERRIDE_TRANSITION_DURATION ||/*??*/ 200; // TODO: how long?\n\t\t\tconst duration_str = `${duration_ms}ms`;\n\t\t\t$eye_leader.css({\n\t\t\t\ttransition: `left ${duration_str} linear, top ${duration_str} linear, width ${duration_str} linear, height ${duration_str} linear`,\n\t\t\t\tposition: \"fixed\",\n\t\t\t\tzIndex: 10000000,\n\t\t\t\tpointerEvents: \"none\",\n\t\t\t\tleft: from.left,\n\t\t\t\ttop: from.top,\n\t\t\t\twidth: from.width,\n\t\t\t\theight: from.height,\n\t\t\t});\n\t\t\tsetTimeout(() => {\n\t\t\t\t$eye_leader.css({\n\t\t\t\t\tleft: to.left,\n\t\t\t\t\ttop: to.top,\n\t\t\t\t\twidth: to.width,\n\t\t\t\t\theight: to.height,\n\t\t\t\t});\n\t\t\t}, 5);\n\t\t\tlet handled_transition_completion = false;\n\t\t\tconst handle_transition_completion = () => {\n\t\t\t\tif (handled_transition_completion) {\n\t\t\t\t\treturn; // ignore multiple calls (an idempotency pattern)\n\t\t\t\t} else {\n\t\t\t\t\thandled_transition_completion = true;\n\t\t\t\t}\n\t\t\t\tanimating_titlebar = false;\n\t\t\t\t$eye_leader.remove();\n\t\t\t\tcallback();\n\t\t\t\tlet anima = when_done_animating_titlebar.shift()\n\t\t\t\tanima && anima(); // relies on animating_titlebar = false;\n\t\t\t};\n\t\t\t$eye_leader.on(\"transitionend transitioncancel\", handle_transition_completion);\n\t\t\tsetTimeout(handle_transition_completion, duration_ms * 1.2);\n\t\t};\n\t\t$w.close = (force) => {\n\t\t\tif (force && force !== true) {\n\t\t\t\tthrow new TypeError(\"force must be a boolean or undefined, not \" + Object.prototype.toString.call(force));\n\t\t\t}\n\t\t\tif (!force) {\n\t\t\t\tvar e = $.Event(\"close\");\n\t\t\t\t$w.trigger(e);\n\t\t\t\tif (e.isDefaultPrevented()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($component) {\n\t\t\t\t$component.detach();\n\t\t\t}\n\t\t\t$w.closed = true;\n\t\t\t$event_target.triggerHandler(\"closed\");\n\t\t\t$w.trigger(\"closed\");\n\t\t\t// TODO: change usages of \"close\" to \"closed\" where appropriate\n\t\t\t// and probably rename the \"close\" event (\"before[-]close\"? \"may-close\"? \"close-request\"?)\n\n\t\t\t// MUST be after any events are triggered!\n\t\t\t$w.remove();\n\n\t\t\t// TODO: support modals, which should focus what was focused before the modal was opened.\n\t\t\t// (Note: must consider the element being removed from the DOM, or hidden, or made un-focusable)\n\t\t\t// (Also: modals should steal focus / be brought to the front when focusing the parent window, and the parent window's content should be inert/uninteractive)\n\t\t\t\n\t\t\t// Focus next-topmost window\n\t\t\tvar $next_topmost = $($(\".window:visible\").toArray().sort((a, b) => b.style.zIndex - a.style.zIndex)[0]);\n\t\t\t$next_topmost.triggerHandler(\"refocus-window\");\n\n\t\t\t// Cleanup\n\t\t\tclean_up_debug_focus_tracking();\n\t\t};\n\t\t$w.closed = false;\n\n\t\tlet current_menu_bar;\n\t\t// @TODO: should this be like setMenus(menu_definitions)?\n\t\t// It seems like setMenuBar(menu_bar) might be prone to bugs\n\t\t// trying to set the same menu bar on multiple windows.\n\t\t$w.setMenuBar = (menu_bar) => {\n\t\t\t// $w.find(\".menus\").remove(); // ugly, if only because of the class name haha\n\t\t\tif (current_menu_bar) {\n\t\t\t\tcurrent_menu_bar.element.remove();\n\t\t\t}\n\t\t\tif (menu_bar) {\n\t\t\t\t$w.$titlebar.after(menu_bar.element);\n\t\t\t\tmenu_bar.setKeyboardScope($w[0]);\n\t\t\t\tcurrent_menu_bar = menu_bar;\n\t\t\t}\n\t\t};\n\n\t\tif (options.title) {\n\t\t\t$w.title(options.title);\n\t\t}\n\n\t\tif (!$component) {\n\t\t\t$w.center();\n\t\t}\n\n\t\t// mustHaveMethods($w, windowInterfaceMethods);\n\n\t\treturn $w;\n\t}\n\n\tfunction $FormWindow(title) {\n\t\tvar $w = new $Window();\n\n\t\t$w.title(title);\n\t\t$w.$form = $(E(\"form\")).appendTo($w.$content);\n\t\t$w.$main = $(E(\"div\")).appendTo($w.$form);\n\t\t$w.$buttons = $(E(\"div\")).appendTo($w.$form).addClass(\"button-group\");\n\n\t\t$w.$Button = (label, action) => {\n\t\t\tvar $b = $(E(\"button\")).appendTo($w.$buttons).text(label);\n\t\t\t$b.on(\"click\", (e) => {\n\t\t\t\t// prevent the form from submitting\n\t\t\t\t// @TODO: instead, prevent the form's submit event\n\t\t\t\te.preventDefault();\n\n\t\t\t\taction();\n\t\t\t});\n\n\t\t\t$b.on(\"pointerdown\", () => {\n\t\t\t\t$b.focus();\n\t\t\t});\n\n\t\t\treturn $b;\n\t\t};\n\n\t\treturn $w;\n\t}\n\n\t$Window.$FormWindow = $FormWindow;\n\t\n\treturn $Window;\n});\n\ndefine('skylark-98js/iframe-windows',[\n\t\"skylark-jquery\",\n\t\"./win98\",\n\t\"./os-gui/$Window\"\n],function($,win98js,$Window){\n\tvar programs_being_loaded = 0;\n\n\tvar $G = $(window);\n\t\n\tfunction enhance_iframe(iframe) {\n\t\tvar $iframe = $(iframe);\n\n\t\t$(\"body\").addClass(\"loading-program\");\n\t\tprograms_being_loaded += 1;\n\n\t\t$iframe.on(\"load\", function () {\n\n\t\t\tif (--programs_being_loaded <= 0) {\n\t\t\t\t$(\"body\").removeClass(\"loading-program\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconsole.assert(iframe.contentWindow.document === iframe.contentDocument); // just something that won't get optimized away if we were to ever use a minifier (or by the JIT compiler??)\n\t\t\t} catch (e) {\n\t\t\t\tconsole.warn(`[enhance_iframe] iframe integration is not available for '${iframe.src}'`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (window.themeCSSProperties) {\n\t\t\t\tapplyTheme(themeCSSProperties, iframe.contentDocument.documentElement);\n\t\t\t}\n\n\t\t\t// Let the iframe to handle mouseup events outside itself\n\t\t\t// (without using setPointerCapture)\n\t\t\tiframe.contentDocument.addEventListener(\"mousedown\", (event) => {\n\t\t\t\tvar delegate_pointerup = function () {\n\t\t\t\t\tif (iframe.contentWindow && iframe.contentWindow.jQuery) {\n\t\t\t\t\t\tiframe.contentWindow.jQuery(\"body\").trigger(\"pointerup\");\n\t\t\t\t\t}\n\t\t\t\t\tif (iframe.contentWindow) {\n\t\t\t\t\t\tconst event = new iframe.contentWindow.MouseEvent(\"mouseup\", { button: 0 });\n\t\t\t\t\t\tiframe.contentWindow.dispatchEvent(event);\n\t\t\t\t\t\tconst event2 = new iframe.contentWindow.MouseEvent(\"mouseup\", { button: 2 });\n\t\t\t\t\t\tiframe.contentWindow.dispatchEvent(event2);\n\t\t\t\t\t}\n\t\t\t\t\tclean_up_delegation();\n\t\t\t\t};\n\t\t\t\t// @TODO: delegate pointermove events too?\n\t\t\t\t// @TODO: do delegation in os-gui.js library instead\n\t\t\t\t// is it delegation? I think I mean proxying (but I'm really tired and don't have internet right now so I can't say for sure haha)\n\n\t\t\t\t$G.on(\"mouseup blur\", delegate_pointerup);\n\t\t\t\tiframe.contentDocument.addEventListener(\"mouseup\", clean_up_delegation);\n\t\t\t\tfunction clean_up_delegation() {\n\t\t\t\t\t$G.off(\"mouseup blur\", delegate_pointerup);\n\t\t\t\t\tiframe.contentDocument.removeEventListener(\"mouseup\", clean_up_delegation);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Let the containing page handle keyboard events, with an opportunity to cancel them\n\t\t\tproxy_keyboard_events(iframe);\n\n\t\t\t// on Wayback Machine, and iframe's url not saved yet\n\t\t\tif (iframe.contentDocument.querySelector(\"#error #livewebInfo.available\")) {\n\t\t\t\tvar message = document.createElement(\"div\");\n\t\t\t\tmessage.style.position = \"absolute\";\n\t\t\t\tmessage.style.left = \"0\";\n\t\t\t\tmessage.style.right = \"0\";\n\t\t\t\tmessage.style.top = \"0\";\n\t\t\t\tmessage.style.bottom = \"0\";\n\t\t\t\tmessage.style.background = \"#c0c0c0\";\n\t\t\t\tmessage.style.color = \"#000\";\n\t\t\t\tmessage.style.padding = \"50px\";\n\t\t\t\tiframe.contentDocument.body.appendChild(message);\n\t\t\t\tmessage.innerHTML = `<a target=\"_blank\">Save this url in the Wayback Machine</a>`;\n\t\t\t\tmessage.querySelector(\"a\").href =\n\t\t\t\t\t\"https://web.archive.org/save/https://98.js.org/\" +\n\t\t\t\t\tiframe.src.replace(/.*https:\\/\\/98.js.org\\/?/, \"\");\n\t\t\t\tmessage.querySelector(\"a\").style.color = \"blue\";\n\t\t\t}\n\n\t\t\tvar $contentWindow = $(iframe.contentWindow);\n\t\t\t$contentWindow.on(\"pointerdown click\", function (e) {\n\t\t\t\tiframe.$window && iframe.$window.focus();\n\n\t\t\t\t// from close_menus in $MenuBar\n\t\t\t\t$(\".menu-button\").trigger(\"release\");\n\t\t\t\t// Close any rogue floating submenus\n\t\t\t\t$(\".menu-popup\").hide();\n\t\t\t});\n\t\t\t// We want to disable pointer events for other iframes, but not this one\n\t\t\t$contentWindow.on(\"pointerdown\", function (e) {\n\t\t\t\t$iframe.css(\"pointer-events\", \"all\");\n\t\t\t\t$(\"body\").addClass(\"drag\");\n\t\t\t});\n\t\t\t$contentWindow.on(\"pointerup\", function (e) {\n\t\t\t\t$(\"body\").removeClass(\"drag\");\n\t\t\t\t$iframe.css(\"pointer-events\", \"\");\n\t\t\t});\n\t\t\t// $(\"iframe\").css(\"pointer-events\", \"\"); is called elsewhere.\n\t\t\t// Otherwise iframes would get stuck in this interaction mode\n\n\t\t\tiframe.contentWindow.close = function () {\n\t\t\t\tiframe.$window && iframe.$window.close();\n\t\t\t};\n\t\t\t// TODO: hook into saveAs (a la FileSaver.js) and another function for opening files\n\t\t\t// iframe.contentWindow.saveAs = function(){\n\t\t\t// \tsaveAsDialog();\n\t\t\t// };\n\n\t\t\t// Don't override alert (except within the specific pages)\n\t\t\t// but override the underlying message box function that\n\t\t\t// the alert override uses, so that the message boxes can\n\t\t\t// go outside the window.\n\t\t\tiframe.contentWindow.showMessageBox = (options) => {\n\t\t\t\treturn showMessageBox({\n\t\t\t\t\ttitle: options.title /*??*/ ||  iframe.contentWindow.defaultMessageBoxTitle,\n\t\t\t\t\t...options,\n\t\t\t\t});\n\t\t\t};\n\t\t});\n\t\t$iframe.css({\n\t\t\tminWidth: 0,\n\t\t\tminHeight: 0, // overrides user agent styling apparently, fixes Sound Recorder\n\t\t\tflex: 1,\n\t\t\tborder: 0, // overrides user agent styling\n\t\t});\n\t}\n\n\t// Let the containing page handle keyboard events, with an opportunity to cancel them\n\tfunction proxy_keyboard_events(iframe) {\n\t\t// Note: iframe must be same-origin, or this will fail.\n\t\tfor (const event_type of [\"keyup\", \"keydown\", \"keypress\"]) {\n\t\t\tiframe.contentWindow.addEventListener(event_type, (event) => {\n\t\t\t\tconst proxied_event = new KeyboardEvent(event_type, {\n\t\t\t\t\ttarget: iframe,\n\t\t\t\t\tview: iframe.ownerDocument.defaultView,\n\t\t\t\t\tbubbles: true,\n\t\t\t\t\tcancelable: true,\n\t\t\t\t\tkey: event.key,\n\t\t\t\t\tkeyCode: event.keyCode,\n\t\t\t\t\twhich: event.which,\n\t\t\t\t\tcode: event.code,\n\t\t\t\t\tshiftKey: event.shiftKey,\n\t\t\t\t\tctrlKey: event.ctrlKey,\n\t\t\t\t\tmetaKey: event.metaKey,\n\t\t\t\t\taltKey: event.altKey,\n\t\t\t\t\trepeat: event.repeat,\n\t\t\t\t\t//...@TODO: should it copy ALL properties?\n\t\t\t\t});\n\t\t\t\tconst result = iframe.dispatchEvent(proxied_event);\n\t\t\t\t// console.log(\"proxied\", event, \"as\", proxied_event, \"result\", result);\n\t\t\t\tif (!result) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}, true);\n\t\t}\n\t}\n\n\tfunction make_iframe_window(options) {\n\t\t///options.resizable ??= true;\n\t\tif (options.resizable == undefined) {\n\t\t\toptions.resizable = true;\n\t\t}\n\t\tvar $win = new $Window(options);\n\n\t\tvar $iframe = $win.$iframe = $(\"<iframe>\").attr({ src: options.src });\n\t\tenhance_iframe($iframe[0]);\n\t\t$win.$content.append($iframe);\n\t\tvar iframe = $win.iframe = $iframe[0];\n\t\t// TODO: should I instead of having iframe.$window, have a get$Window type of dealio?\n\t\t// where all is $window needed?\n\t\t// I know it's used from within the iframe contents as frameElement.$window\n\t\tiframe.$window = $win;\n\n\t\t$iframe.on(\"load\", function () {\n\t\t\t$win.show();\n\t\t\t$win.focus();\n\t\t});\n\n\t\t$win.$content.css({\n\t\t\tdisplay: \"flex\",\n\t\t\tflexDirection: \"column\",\n\t\t});\n\n\t\t// TODO: cascade windows\n\t\t$win.center();\n\t\t$win.hide();\n\n\t\treturn $win;\n\t}\n\n\t// Fix dragging things (i.e. windows) over iframes (i.e. other windows)\n\t// (when combined with a bit of css, .drag iframe { pointer-events: none; })\n\t// (and a similar thing in make_iframe_window)\n\t$(window).on(\"pointerdown\", function (e) {\n\t\t//console.log(e.type);\n\t\t$(\"body\").addClass(\"drag\");\n\t});\n\t$(window).on(\"pointerup dragend blur\", function (e) {\n\t\t//console.log(e.type);\n\t\tif (e.type === \"blur\") {\n\t\t\tif (document.activeElement.tagName.match(/iframe/i)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t$(\"body\").removeClass(\"drag\");\n\t\t$(\"iframe\").css(\"pointer-events\", \"\");\n\t});\n\n\treturn {\n\t\tenhance_iframe,\n\t\tproxy_keyboard_events,\n\t\tmake_iframe_window\n\t}\n\n});\ndefine('skylark-98js/Task',[\n\t\"skylark-jquery\",\n\t\"./win98\"\n],function($,win98js){\n\tfunction Task(win) {\n\t\tTask.all_tasks.push(this);\n\n\t\tthis.$window = win;\n\t\t\n\t\tconst $task = this.$task = $(\"<button class='task toggle'/>\").appendTo($(\".tasks\"));\n\t\tconst $title = $(\"<span class='title'/>\");\n\n\t\tthis.updateTitle = () => {\n\t\t\t$title.text(win.getTitle());\n\t\t};\n\n\t\tlet $icon;\n\t\tthis.updateIcon = () => {\n\t\t\tconst old_$icon = $icon;\n\t\t\t$icon = win.getIconAtSize(16);\n\t\t\tif (!$icon) {\n\t\t\t\t// $icon = $(\"<img src='images/icons/task-16x16.png'/>\");\n\t\t\t\told_$icon && old_$icon.remove();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (old_$icon) {\n\t\t\t\told_$icon.replaceWith($icon);\n\t\t\t} else {\n\t\t\t\t$task.prepend($icon);\n\t\t\t}\n\t\t};\n\n\t\tthis.updateTitle();\n\t\tthis.updateIcon();\n\n\t\twin.on(\"title-change\", this.updateTitle);\n\t\twin.on(\"icon-change\", this.updateIcon);\n\n\t\twin.setMinimizeTarget($task[0]);\n\n\t\t$task.append($icon, $title);\n\t\t$task.on(\"pointerdown\", function (e) {\n\t\t\te.preventDefault(); // prevent focus, so that the window keeps focus and we can know for minimization if it it should be focused or minimized\n\t\t\t// @TODO: do it on whole taskbar\n\t\t});\n\t\t$task.on(\"click\", function () {\n\t\t\tif ($task.hasClass(\"selected\")) {\n\t\t\t\twin.minimize();\n\t\t\t\twin.blur();\n\t\t\t} else {\n\t\t\t\twin.unminimize();\n\t\t\t\twin.bringToFront();\n\t\t\t\twin.focus();\n\t\t\t}\n\t\t});\n\n\t\t/*\n\t\twin.onFocus(() => {\n\t\t\t$task.addClass(\"selected\");\n\t\t});\n\t\twin.onBlur(() => {\n\t\t\t$task.removeClass(\"selected\");\n\t\t});\n\t\twin.onClosed(() => {\n\t\t\t$task.remove();\n\t\t\tconst index = Task.all_tasks.indexOf(this);\n\t\t\tif (index !== -1) {\n\t\t\t\tTask.all_tasks.splice(index, 1);\n\t\t\t}\n\t\t});\n\t\t*/\n\t\twin.on(\"focus\",() => {\n\t\t\t$task.addClass(\"selected\");\n\t\t});\n\t\twin.on(\"blur\",() => {\n\t\t\t$task.removeClass(\"selected\");\n\t\t});\n\t\twin.on(\"closed\",() => {\n\t\t\t$task.remove();\n\t\t\tconst index = Task.all_tasks.indexOf(this);\n\t\t\tif (index !== -1) {\n\t\t\t\tTask.all_tasks.splice(index, 1);\n\t\t\t}\n\t\t});\n\n\t\tif (win.is && win.is(\":visible\")) {\n\t\t\twin.focus();\n\t\t}\n\t}\n\n\tTask.all_tasks = [];\n\n\treturn Task;\n\n});\ndefine('skylark-98js/visualizer-overlay',[\n\t\"skylark-jquery\",\n\t\"./win98\"\n],function($,win98js){\n\tfunction getOffset(element, fromElement) {\n\t\tlet el = element,\n\t\t\toffsetLeft = 0,\n\t\t\toffsetTop = 0;\n\n\t\tdo {\n\t\t\toffsetLeft += el.offsetLeft;\n\t\t\toffsetTop += el.offsetTop;\n\n\t\t\tel = el.offsetParent;\n\t\t} while (el && el !== fromElement);\n\n\t\treturn { offsetLeft, offsetTop };\n\t}\n\n\twindow.monkey_patch_render = (obj) => obj.render();\n\n\tclass VisualizerOverlay {\n\t\tconstructor(visualizerCanvas, renderOptions) {\n\t\t\tthis.visualizerCanvas = visualizerCanvas;\n\n\t\t\tthis.wrappyCanvas = document.createElement(\"canvas\");\n\t\t\tthis.wrappyCtx = this.wrappyCanvas.getContext(\"2d\");\n\n\t\t\tthis.overlayCanvases = [];\n\t\t\tthis.animateFns = [];\n\n\t\t\twindow.monkey_patch_render = (obj) => {\n\t\t\t\t// check for Butterchurn's Visualizer class\n\t\t\t\tif (obj.audio && obj.renderer) {\n\t\t\t\t\tobj.render();\n\t\t\t\t\tthis.render(renderOptions);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treturn obj.render();\n\t\t\t};\n\t\t}\n\n\t\tmakeOverlayCanvas(windowEl) {\n\t\t\tconst canvas = document.createElement(\"canvas\");\n\t\t\tconst ctx = canvas.getContext(\"2d\");\n\t\t\tcanvas.style.position = \"absolute\";\n\t\t\tcanvas.style.left = \"0\";\n\t\t\tcanvas.style.top = \"0\";\n\t\t\tcanvas.style.pointerEvents = \"none\";\n\t\t\tcanvas.style.mixBlendMode = \"color-dodge\";\n\t\t\tcanvas.style.willChange = \"opacity\"; // hint fixes flickering in chrome\n\t\t\tcanvas.className = \"visualizer-overlay-canvas\";\n\t\t\twindowEl.appendChild(canvas);\n\t\t\tthis.overlayCanvases.push(canvas);\n\t\t\tthis.animateFns.push(options => {\n\t\t\t\tctx.clearRect(0, 0, canvas.width, canvas.height);\n\t\t\t\tconst scale =\n\t\t\t\t\t(windowEl.classList.contains(\"doubled\") ? 2 : 1) *\n\t\t\t\t\t(window.devicePixelRatio || 1);\n\t\t\t\tif (\n\t\t\t\t\tcanvas.width !== windowEl.clientWidth * scale ||\n\t\t\t\t\tcanvas.height !== windowEl.clientHeight * scale\n\t\t\t\t) {\n\t\t\t\t\tcanvas.width = windowEl.clientWidth * scale;\n\t\t\t\t\tcanvas.height = windowEl.clientHeight * scale;\n\t\t\t\t}\n\t\t\t\tcanvas.style.width = windowEl.clientWidth + \"px\";\n\t\t\t\tcanvas.style.height = windowEl.clientHeight + \"px\";\n\t\t\t\tconst stuff = windowEl.querySelectorAll(\"*\");\n\t\t\t\tArray.from(stuff)\n\t\t\t\t\t.map(el => {\n\t\t\t\t\t\tconst width = el.clientWidth;\n\t\t\t\t\t\tconst height = el.clientHeight;\n\t\t\t\t\t\tconst area = width * height;\n\t\t\t\t\t\treturn { element: el, width, height, area };\n\t\t\t\t\t})\n\t\t\t\t\t.filter(({ area }) => area > 0)\n\t\t\t\t\t.sort((a, b) => b.area - a.area)\n\t\t\t\t\t.forEach(({ element, width, height, area }) => {\n\t\t\t\t\t\tconst { offsetLeft, offsetTop } = getOffset(element, windowEl);\n\t\t\t\t\t\tctx.save();\n\t\t\t\t\t\tctx.scale(scale, scale);\n\t\t\t\t\t\tctx.translate(offsetLeft, offsetTop);\n\t\t\t\t\t\tif (options.stretch) {\n\t\t\t\t\t\t\tctx.drawImage(this.wrappyCanvas, 0, 0, width, height);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctx.drawImage(\n\t\t\t\t\t\t\t\tthis.wrappyCanvas,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\twidth,\n\t\t\t\t\t\t\t\theight,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\twidth,\n\t\t\t\t\t\t\t\theight\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (area < 30 * 30) {\n\t\t\t\t\t\t\tctx.globalCompositeOperation = \"destination-out\";\n\t\t\t\t\t\t\tctx.globalAlpha = 0.5;\n\t\t\t\t\t\t\tctx.fillStyle = \"black\";\n\t\t\t\t\t\t\tctx.fillRect(0, 0, width, height);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tctx.restore();\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\trender(options) {\n\t\t\tconst { visualizerCanvas, wrappyCanvas, wrappyCtx, animateFns } = this;\n\t\t\tconst { width, height } = visualizerCanvas;\n\t\t\tif (options.mirror) {\n\t\t\t\tconst drawImage = () => {\n\t\t\t\t\twrappyCtx.drawImage(\n\t\t\t\t\t\tvisualizerCanvas,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\theight,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\theight\n\t\t\t\t\t);\n\t\t\t\t\t// zoom in the source area:\n\t\t\t\t\t// wrappyCtx.drawImage(visualizerCanvas, width/4, height/4, width/2, height/2, 0, 0, width, height);\n\t\t\t\t\t// wrappyCtx.drawImage(visualizerCanvas, width/4, height/4, width/4, height/4, 0, 0, width, height);\n\t\t\t\t\t// for testing:\n\t\t\t\t\t// wrappyCtx.fillStyle = \"aqua\";\n\t\t\t\t\t// wrappyCtx.fillRect(0, 0, width, height);\n\t\t\t\t};\n\t\t\t\twrappyCanvas.width = width * 2;\n\t\t\t\twrappyCanvas.height = height * 2;\n\t\t\t\twrappyCtx.save();\n\t\t\t\tdrawImage();\n\t\t\t\twrappyCtx.translate(0, height);\n\t\t\t\twrappyCtx.scale(1, -1);\n\t\t\t\twrappyCtx.translate(0, -height);\n\t\t\t\tdrawImage();\n\t\t\t\twrappyCtx.translate(width, 0);\n\t\t\t\twrappyCtx.scale(-1, 1);\n\t\t\t\twrappyCtx.translate(-width, 0);\n\t\t\t\tdrawImage();\n\t\t\t\twrappyCtx.translate(0, height);\n\t\t\t\twrappyCtx.scale(1, -1);\n\t\t\t\twrappyCtx.translate(0, -height);\n\t\t\t\tdrawImage();\n\t\t\t\twrappyCtx.restore();\n\t\t\t} else if (options.tile) {\n\t\t\t\twrappyCanvas.width = width * 2;\n\t\t\t\twrappyCanvas.height = height * 2;\n\t\t\t\tfor (let xi = 0; xi < 2; xi++) {\n\t\t\t\t\tfor (let yi = 0; yi < 2; yi++) {\n\t\t\t\t\t\twrappyCtx.drawImage(\n\t\t\t\t\t\t\tvisualizerCanvas,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\twidth,\n\t\t\t\t\t\t\theight,\n\t\t\t\t\t\t\twidth * xi,\n\t\t\t\t\t\t\theight * yi,\n\t\t\t\t\t\t\twidth,\n\t\t\t\t\t\t\theight\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twrappyCanvas.width = width;\n\t\t\t\twrappyCanvas.height = height;\n\t\t\t\twrappyCtx.drawImage(visualizerCanvas, 0, 0, width, height);\n\t\t\t}\n\n\t\t\tanimateFns.forEach(fn => fn(options));\n\t\t}\n\t\tcleanUp() {\n\t\t\tthis.overlayCanvases.forEach(canvas => {\n\t\t\t\tcanvas.remove();\n\t\t\t});\n\t\t\twindow.monkey_patch_render = (obj) => obj.render();\n\t\t}\n\t\tfadeOutAndCleanUp() {\n\t\t\tthis.fadeOut();\n\t\t\tthis.overlayCanvases[0].addEventListener(\"transitionend\", () => {\n\t\t\t\tthis.cleanUp();\n\t\t\t});\n\t\t}\n\t\tfadeOut() {\n\t\t\tthis.overlayCanvases.forEach(canvas => {\n\t\t\t\tcanvas.style.transition =\n\t\t\t\t\t\"opacity 1s cubic-bezier(0.125, 0.960, 0.475, 0.915)\";\n\t\t\t\tcanvas.style.opacity = \"0\";\n\t\t\t});\n\t\t}\n\t\tfadeIn() {\n\t\t\tthis.overlayCanvases.forEach(canvas => {\n\t\t\t\tcanvas.style.transition = \"opacity 0.2s ease\";\n\t\t\t\tcanvas.style.opacity = \"1\";\n\t\t\t});\n\t\t}\n\t}\n\n\n\treturn VisualizerOverlay;\n});\ndefine('skylark-98js/programs',[\n\t\"skylark-jquery\",\n\t\"skylark-browserfs\",\n\t\"./win98\",\n\t\"./filesystem-setup\",\n\t\"./helpers\",\n\t\"./FolderViewItem\",\n\t\"./iframe-windows\",\n\t\"./Task\",\n\t\"./visualizer-overlay\",\n\t\"./os-gui/$Window\"\n],function($,BrowserFS, win98js,FilesystemSetup,helpers,FolderViewItem,iframeWindows,Task,VisualizerOverlay, $Window){\n\tlet make_iframe_window = iframeWindows.make_iframe_window;\n\n\tfunction show_help(options) {\n\t\tconst $help_window = $Window({\n\t\t\ttitle: options.title || \"Help Topics\",\n\t\t\ticons: iconsAtTwoSizes(\"chm\"),\n\t\t\tresizable: true,\n\t\t})\n\t\t$help_window.addClass(\"help-window\");\n\n\t\tlet ignore_one_load = true;\n\t\tlet back_length = 0;\n\t\tlet forward_length = 0;\n\n\t\tconst $main = $(E(\"div\")).addClass(\"main\");\n\t\tconst $toolbar = $(E(\"div\")).addClass(\"toolbar\");\n\t\tconst add_toolbar_button = (name, sprite_n, action_fn, enabled_fn) => {\n\t\t\tconst $button = $(\"<button class='lightweight'>\")\n\t\t\t\t.append($(\"<span>\").text(name))\n\t\t\t\t.appendTo($toolbar)\n\t\t\t\t.on(\"click\", () => {\n\t\t\t\t\taction_fn();\n\t\t\t\t});\n\t\t\t$(\"<div class='icon'/>\")\n\t\t\t\t.appendTo($button)\n\t\t\t\t.css({\n\t\t\t\t\tbackgroundPosition: `${-sprite_n * 55}px 0px`,\n\t\t\t\t});\n\t\t\tconst update_enabled = () => {\n\t\t\t\t$button[0].disabled = enabled_fn && !enabled_fn();\n\t\t\t};\n\t\t\tupdate_enabled();\n\t\t\t$help_window.on(\"click\", \"*\", update_enabled);\n\t\t\t$help_window.on(\"update-buttons\", update_enabled);\n\t\t\treturn $button;\n\t\t};\n\t\tconst measure_sidebar_width = () =>\n\t\t\t$contents.outerWidth() +\n\t\t\tparseFloat(getComputedStyle($contents[0]).getPropertyValue(\"margin-left\")) +\n\t\t\tparseFloat(getComputedStyle($contents[0]).getPropertyValue(\"margin-right\")) +\n\t\t\t$resizer.outerWidth();\n\t\tconst $hide_button = add_toolbar_button(\"Hide\", 0, () => {\n\t\t\tconst toggling_width = measure_sidebar_width();\n\t\t\t$contents.hide();\n\t\t\t$resizer.hide();\n\t\t\t$hide_button.hide();\n\t\t\t$show_button.show();\n\t\t\t$help_window.width($help_window.width() - toggling_width);\n\t\t\t$help_window.css(\"left\", $help_window.offset().left + toggling_width);\n\t\t});\n\t\tconst $show_button = add_toolbar_button(\"Show\", 5, () => {\n\t\t\t$contents.show();\n\t\t\t$resizer.show();\n\t\t\t$show_button.hide();\n\t\t\t$hide_button.show();\n\t\t\tconst toggling_width = measure_sidebar_width();\n\t\t\t$help_window.width($help_window.width() + toggling_width);\n\t\t\t$help_window.css(\"left\", $help_window.offset().left - toggling_width);\n\t\t\t// $help_window.applyBounds() would push the window to fit (before trimming it only if needed)\n\t\t\t// Trim the window to fit (especially for if maximized)\n\t\t\tif ($help_window.offset().left < 0) {\n\t\t\t\t$help_window.width($help_window.width() + $help_window.offset().left);\n\t\t\t\t$help_window.css(\"left\", 0);\n\t\t\t}\n\t\t}).hide();\n\t\tadd_toolbar_button(\"Back\", 1, () => {\n\t\t\t$iframe[0].contentWindow.history.back();\n\t\t\tignore_one_load = true;\n\t\t\tback_length -= 1;\n\t\t\tforward_length += 1;\n\t\t}, () => back_length > 0);\n\t\tadd_toolbar_button(\"Forward\", 2, () => {\n\t\t\t$iframe[0].contentWindow.history.forward();\n\t\t\tignore_one_load = true;\n\t\t\tforward_length -= 1;\n\t\t\tback_length += 1;\n\t\t}, () => forward_length > 0);\n\t\tadd_toolbar_button(\"Options\", 3, () => { }, () => false); // TODO: hotkey and underline on O\n\t\tadd_toolbar_button(\"Web Help\", 4, () => {\n\t\t\tiframe.src = \"help/online_support.htm\";\n\t\t});\n\n\t\tconst $iframe = $(\"<iframe sandbox='allow-same-origin allow-scripts allow-forms allow-modals allow-popups allow-downloads'>\")\n\t\t\t.attr({ src: \"help/default.html\" })\n\t\t\t.addClass(\"inset-deep\");\n\t\tconst iframe = $iframe[0];\n\t\tenhance_iframe(iframe);\n\t\tiframe.$window = $help_window; // for focus handling integration\n\t\tconst $resizer = $(E(\"div\")).addClass(\"resizer\");\n\t\tconst $contents = $(E(\"ul\")).addClass(\"contents inset-deep\");\n\n\t\t// TODO: fix race conditions\n\t\t$iframe.on(\"load\", () => {\n\t\t\tif (!ignore_one_load) {\n\t\t\t\tback_length += 1;\n\t\t\t\tforward_length = 0;\n\t\t\t}\n\t\t\tiframe.contentWindow.location.href\n\t\t\tignore_one_load = false;\n\t\t\t$help_window.triggerHandler(\"update-buttons\");\n\t\t});\n\n\t\t$main.append($contents, $resizer, $iframe);\n\t\t$help_window.$content.append($toolbar, $main);\n\n\t\t$help_window.css({ width: 800, height: 600 });\n\n\t\t$iframe.attr({ name: \"help-frame\" });\n\t\t$iframe.css({\n\t\t\tbackgroundColor: \"white\",\n\t\t\tborder: \"\",\n\t\t\tmargin: \"1px\",\n\t\t});\n\t\t$contents.css({\n\t\t\tmargin: \"1px\",\n\t\t});\n\t\t$help_window.center();\n\n\t\t$main.css({\n\t\t\tposition: \"relative\", // for resizer\n\t\t});\n\n\t\tconst resizer_width = 4;\n\t\t$resizer.css({\n\t\t\tcursor: \"ew-resize\",\n\t\t\twidth: resizer_width,\n\t\t\tboxSizing: \"border-box\",\n\t\t\tbackground: \"var(--ButtonFace)\",\n\t\t\tborderLeft: \"1px solid var(--ButtonShadow)\",\n\t\t\tboxShadow: \"inset 1px 0 0 var(--ButtonHilight)\",\n\t\t\ttop: 0,\n\t\t\tbottom: 0,\n\t\t\tzIndex: 1,\n\t\t});\n\t\t$resizer.on(\"pointerdown\", (e) => {\n\t\t\tlet pointermove, pointerup;\n\t\t\tconst getPos = (e) =>\n\t\t\t\tMath.min($help_window.width() - 100, Math.max(20,\n\t\t\t\t\te.clientX - $help_window.$content.offset().left\n\t\t\t\t));\n\t\t\t$G.on(\"pointermove\", pointermove = (e) => {\n\t\t\t\t$resizer.css({\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\tleft: getPos(e)\n\t\t\t\t});\n\t\t\t\t$contents.css({\n\t\t\t\t\tmarginRight: resizer_width,\n\t\t\t\t});\n\t\t\t});\n\t\t\t$G.on(\"pointerup\", pointerup = (e) => {\n\t\t\t\t$G.off(\"pointermove\", pointermove);\n\t\t\t\t$G.off(\"pointerup\", pointerup);\n\t\t\t\t$resizer.css({\n\t\t\t\t\tposition: \"\",\n\t\t\t\t\tleft: \"\"\n\t\t\t\t});\n\t\t\t\t$contents.css({\n\t\t\t\t\tflexBasis: getPos(e) - resizer_width,\n\t\t\t\t\tmarginRight: \"\",\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tconst parse_object_params = $object => {\n\t\t\t// parse an $(<object>) to a plain object of key value pairs\n\t\t\tconst object = {};\n\t\t\tfor (const param of $object.children(\"param\").get()) {\n\t\t\t\tobject[param.name] = param.value;\n\t\t\t}\n\t\t\treturn object;\n\t\t};\n\n\t\tlet $last_expanded;\n\n\t\tconst make_$item = text => {\n\t\t\tconst $item = $(E(\"div\")).addClass(\"item\").text(text);\n\t\t\t$item.on(\"mousedown\", () => {\n\t\t\t\t$contents.find(\".item\").removeClass(\"selected\");\n\t\t\t\t$item.addClass(\"selected\");\n\t\t\t});\n\t\t\t$item.on(\"click\", () => {\n\t\t\t\tconst $li = $item.parent();\n\t\t\t\tif ($li.is(\".folder\")) {\n\t\t\t\t\tif ($last_expanded) {\n\t\t\t\t\t\t$last_expanded.not($li).removeClass(\"expanded\");\n\t\t\t\t\t}\n\t\t\t\t\t$li.toggleClass(\"expanded\");\n\t\t\t\t\t$last_expanded = $li;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn $item;\n\t\t};\n\n\t\tconst $default_item_li = $(E(\"li\")).addClass(\"page\");\n\t\t$default_item_li.append(make_$item(\"Welcome to Help\").on(\"click\", () => {\n\t\t\t$iframe.attr({ src: \"help/default.html\" });\n\t\t}));\n\t\t$contents.append($default_item_li);\n\n\t\tfunction renderItemFromContents(source_li, $folder_items_ul) {\n\t\t\tconst object = parse_object_params($(source_li).children(\"object\"));\n\t\t\tif ($(source_li).find(\"li\").length > 0) {\n\n\t\t\t\tconst $folder_li = $(E(\"li\")).addClass(\"folder\");\n\t\t\t\t$folder_li.append(make_$item(object.Name));\n\t\t\t\t$contents.append($folder_li);\n\n\t\t\t\tconst $folder_items_ul = $(E(\"ul\"));\n\t\t\t\t$folder_li.append($folder_items_ul);\n\n\t\t\t\t$(source_li).children(\"ul\").children().get().forEach((li) => {\n\t\t\t\t\trenderItemFromContents(li, $folder_items_ul);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst $item_li = $(E(\"li\")).addClass(\"page\");\n\t\t\t\t$item_li.append(make_$item(object.Name).on(\"click\", () => {\n\t\t\t\t\t$iframe.attr({ src: `${options.root}/${object.Local}` });\n\t\t\t\t}));\n\t\t\t\tif ($folder_items_ul) {\n\t\t\t\t\t$folder_items_ul.append($item_li);\n\t\t\t\t} else {\n\t\t\t\t\t$contents.append($item_li);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t$.get(options.contentsFile, hhc => {\n\t\t\t$($.parseHTML(hhc)).filter(\"ul\").children().get().forEach((li) => {\n\t\t\t\trenderItemFromContents(li, null);\n\t\t\t});\n\t\t});\n\n\t\t// @TODO: keyboard accessability\n\t\t// $help_window.on(\"keydown\", (e)=> {\n\t\t// \tswitch(e.keyCode){\n\t\t// \t\tcase 37:\n\t\t// \t\t\tshow_error_message(\"MOVE IT\");\n\t\t// \t\t\tbreak;\n\t\t// \t}\n\t\t// });\n\t\tvar task = new Task($help_window);\n\t\ttask.$help_window = $help_window;\n\t\treturn task;\n\t}\n\n\tfunction Notepad(file_path) {\n\t\t// TODO: DRY the default file names and title code (use document.title of the page in the iframe, in make_iframe_window)\n\t\tvar document_title = file_path ? file_name_from_path(file_path) : \"Untitled\";\n\t\tvar win_title = document_title + \" - Notepad\";\n\t\t// TODO: focus existing window if file is currently open?\n\n\t\tvar $win = make_iframe_window({\n\t\t\tsrc: \"programs/notepad/index.html\" + (file_path ? (\"?path=\" + file_path) : \"\"),\n\t\t\ticons: iconsAtTwoSizes(\"notepad\"),\n\t\t\ttitle: win_title,\n\t\t\touterWidth: 480,\n\t\t\touterHeight: 321,\n\t\t\tresizable: true,\n\t\t});\n\t\treturn new Task($win);\n\t}\n\tNotepad.acceptsFilePaths = true;\n\n\tfunction Paint(file_path) {\n\t\tvar $win = make_iframe_window({\n\t\t\tsrc: \"programs/jspaint/index.html\",\n\t\t\ticons: iconsAtTwoSizes(\"paint\"),\n\t\t\t// NOTE: in Windows 98, \"untitled\" is lowercase, but TODO: we should just make it consistent\n\t\t\ttitle: \"untitled - Paint\",\n\t\t\touterWidth: 275,\n\t\t\touterHeight: 400,\n\t\t\tminOuterWidth: 275,\n\t\t\tminOuterHeight: 400,\n\t\t});\n\n\t\tvar contentWindow = $win.$iframe[0].contentWindow;\n\n\t\tvar waitUntil = function (test, interval, callback) {\n\t\t\tif (test()) {\n\t\t\t\tcallback();\n\t\t\t} else {\n\t\t\t\tsetTimeout(waitUntil, interval, test, interval, callback);\n\t\t\t}\n\t\t};\n\n\t\tconst systemHooks = {\n\t\t\treadBlobFromHandle: (file_path) => {\n\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\tFilesystemSetup.withFilesystem(() => {\n\t\t\t\t\t\tvar fs = BrowserFS.BFSRequire(\"fs\");\n\t\t\t\t\t\tfs.readFile(file_path, (err, buffer) => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst byte_array = new Uint8Array(buffer);\n\t\t\t\t\t\t\tconst blob = new Blob([byte_array]);\n\t\t\t\t\t\t\tconst file_name = file_path.replace(/.*\\//g, \"\");\n\t\t\t\t\t\t\tconst file = new File([blob], file_name);\n\t\t\t\t\t\t\tresolve(file);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t},\n\t\t\twriteBlobToHandle: async (file_path, blob) => {\n\t\t\t\tconst arrayBuffer = await blob.arrayBuffer();\n\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\tFilesystemSetup.withFilesystem(()=> {\n\t\t\t\t\t\tconst fs = BrowserFS.BFSRequire(\"fs\");\n\t\t\t\t\t\tconst { Buffer } = BrowserFS.BFSRequire(\"buffer\");\n\t\t\t\t\t\tconst buffer = Buffer.from(arrayBuffer);\n\t\t\t\t\t\tfs.writeFile(file_path, buffer, (err)=> {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t},\n\t\t\tsetWallpaperCentered: (canvas) => {\n\t\t\t\tcanvas.toBlob((blob) => {\n\t\t\t\t\tsetDesktopWallpaper(blob, \"no-repeat\", true);\n\t\t\t\t});\n\t\t\t},\n\t\t\tsetWallpaperTiled: (canvas) => {\n\t\t\t\tcanvas.toBlob((blob) => {\n\t\t\t\t\tsetDesktopWallpaper(blob, \"repeat\", true);\n\t\t\t\t});\n\t\t\t},\n\t\t};\n\n\t\t// it seems like I should be able to use onload here, but when it works (overrides the function),\n\t\t// it for some reason *breaks the scrollbar styling* in jspaint\n\t\t// I don't know what's going on there\n\n\t\t// contentWindow.addEventListener(\"load\", function(){\n\t\t// $(contentWindow).on(\"load\", function(){\n\t\t// $win.$iframe.load(function(){\n\t\t// $win.$iframe[0].addEventListener(\"load\", function(){\n\t\twaitUntil(()=> contentWindow.systemHooks, 500, ()=> {\n\t\t\tObject.assign(contentWindow.systemHooks, systemHooks);\n\n\t\t\tlet $help_window;\n\t\t\tcontentWindow.show_help = () => {\n\t\t\t\tif ($help_window) {\n\t\t\t\t\t$help_window.focus();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t$help_window = show_help({\n\t\t\t\t\ttitle: \"Paint Help\",\n\t\t\t\t\tcontentsFile: \"programs/jspaint/help/mspaint.hhc\",\n\t\t\t\t\troot: \"programs/jspaint/help\",\n\t\t\t\t}).$help_window;\n\t\t\t\t$help_window.on(\"close\", () => {\n\t\t\t\t\t$help_window = null;\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tif (file_path) {\n\t\t\t\t// window.initial_system_file_handle = ...; is too late to set this here\n\t\t\t\t// contentWindow.open_from_file_handle(...); doesn't exist\n\t\t\t\tsystemHooks.readBlobFromHandle(file_path).then(file => {\n\t\t\t\t\tif (file) {\n\t\t\t\t\t\tcontentWindow.open_from_file(file, file_path);\n\t\t\t\t\t}\n\t\t\t\t}, (error) => {\n\t\t\t\t\t// this handler may not always called for errors, sometimes error message is shown via readBlobFromHandle\n\t\t\t\t\tcontentWindow.show_error_message(`Failed to open file ${file_path}`, error);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tvar old_update_title = contentWindow.update_title;\n\t\t\tcontentWindow.update_title = () => {\n\t\t\t\told_update_title();\n\t\t\t\t$win.title(contentWindow.document.title);\n\t\t\t};\n\t\t});\n\n\t\treturn new Task($win);\n\t}\n\tPaint.acceptsFilePaths = true;\n\n\tfunction Minesweeper() {\n\t\tvar $win = make_iframe_window({\n\t\t\tsrc: \"programs/minesweeper/index.html\",\n\t\t\ticons: iconsAtTwoSizes(\"minesweeper\"),\n\t\t\ttitle: \"Minesweeper\",\n\t\t\tinnerWidth: 280,\n\t\t\tinnerHeight: 320 + 21,\n\t\t\tresizable: false,\n\t\t});\n\t\treturn new Task($win);\n\t}\n\n\tfunction SoundRecorder(file_path) {\n\t\t// TODO: DRY the default file names and title code (use document.title of the page in the iframe, in make_iframe_window)\n\t\tvar document_title = file_path ? file_name_from_path(file_path) : \"Sound\";\n\t\tvar win_title = document_title + \" - Sound Recorder\";\n\t\t// TODO: focus existing window if file is currently open?\n\t\tvar $win = make_iframe_window({\n\t\t\tsrc: \"programs/sound-recorder/index.html\" + (file_path ? (\"?path=\" + file_path) : \"\"),\n\t\t\ticons: iconsAtTwoSizes(\"speaker\"),\n\t\t\ttitle: win_title,\n\t\t\tinnerWidth: 270,\n\t\t\tinnerHeight: 108 + 21,\n\t\t\tminInnerWidth: 270,\n\t\t\tminInnerHeight: 108 + 21,\n\t\t});\n\t\treturn new Task($win);\n\t}\n\tSoundRecorder.acceptsFilePaths = true;\n\n\tfunction Solitaire() {\n\t\tvar $win = make_iframe_window({\n\t\t\tsrc: \"programs/js-solitaire/index.html\",\n\t\t\ticons: iconsAtTwoSizes(\"solitaire\"),\n\t\t\ttitle: \"Solitaire\",\n\t\t\tinnerWidth: 585,\n\t\t\tinnerHeight: 384 + 21,\n\t\t});\n\t\treturn new Task($win);\n\t}\n\n\tfunction showScreensaver(iframeSrc) {\n\t\tconst mouseDistanceToExit = 15;\n\t\tconst $iframe = $(\"<iframe>\").attr(\"src\", iframeSrc);\n\t\tconst $backing = $(\"<div>\");\n\t\t$backing.css({\n\t\t\tposition: \"fixed\",\n\t\t\tleft: 0,\n\t\t\ttop: 0,\n\t\t\twidth: \"100%\",\n\t\t\theight: \"100%\",\n\t\t\tzIndex: $Window.Z_INDEX + 9998,\n\t\t\tcursor: \"none\",\n\t\t\tbackgroundColor: \"black\",\n\t\t});\n\t\t$iframe.css({\n\t\t\tposition: \"fixed\",\n\t\t\tleft: 0,\n\t\t\ttop: 0,\n\t\t\twidth: \"100%\",\n\t\t\theight: \"100%\",\n\t\t\tzIndex: $Window.Z_INDEX + 9999,\n\t\t\tborder: 0,\n\t\t\tpointerEvents: \"none\",\n\t\t});\n\t\t$backing.appendTo(\"body\");\n\t\t$iframe.appendTo(\"body\");\n\t\tconst cleanUp = () => {\n\t\t\t$backing.remove();\n\t\t\t$iframe.remove();\n\t\t\tconst prevent = (event) => {\n\t\t\t\tevent.preventDefault();\n\t\t\t};\n\t\t\t$(window).on(\"contextmenu\", prevent);\n\t\t\tsetTimeout(() => {\n\t\t\t\t$(window).off(\"contextmenu\", prevent);\n\t\t\t\twindow.removeEventListener(\"keydown\", keydownHandler, true);\n\t\t\t}, 500);\n\t\t};\n\t\tconst keydownHandler = (event) => {\n\t\t\t// Trying to let you change the display or capture the output\n\t\t\t// not allowing Ctrl+PrintScreen etc. because no modifiers\n\t\t\tif (!([\"F11\", \"F12\", \"ZoomToggle\", \"PrintScreen\", \"MediaRecord\", \"BrightnessDown\", \"BrightnessUp\", \"Dimmer\"].includes(event.key))) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tevent.stopPropagation();\n\t\t\t\tcleanUp();\n\t\t\t}\n\t\t};\n\t\tlet startMouseX, startMouseY;\n\t\t$backing.on(\"mousemove pointermove\", (event) => {\n\t\t\tif (startMouseX === undefined) {\n\t\t\t\tstartMouseX = event.pageX;\n\t\t\t\tstartMouseY = event.pageY;\n\t\t\t}\n\t\t\tif (Math.hypot(startMouseX - event.pageX, startMouseY - event.pageY) > mouseDistanceToExit) {\n\t\t\t\tcleanUp();\n\t\t\t}\n\t\t});\n\t\t$backing.on(\"mousedown pointerdown touchstart\", (event) => {\n\t\t\tevent.preventDefault();\n\t\t\tcleanUp();\n\t\t});\n\t\t// useCapture needed for scenario where you hit Enter, with a desktop icon selected\n\t\t// (If it relaunches the screensaver, it's like you can't exit it!)\n\t\twindow.addEventListener(\"keydown\", keydownHandler, true);\n\t}\n\n\tfunction Pipes() {\n\t\tconst options = { hideUI: true };\n\t\tshowScreensaver(`programs/pipes/index.html#${encodeURIComponent(JSON.stringify(options))}`);\n\t}\n\n\tfunction FlowerBox() {\n\t\tshowScreensaver(\"programs/3D-FlowerBox/index.html\");\n\t}\n\n\tfunction CommandPrompt() {\n\t\tvar $win = make_iframe_window({\n\t\t\tsrc: \"programs/command/index.html\",\n\t\t\ticons: iconsAtTwoSizes(\"msdos\"),\n\t\t\ttitle: \"MS-DOS Prompt\",\n\t\t\t// TODO: default dimensions\n\t\t\tinnerWidth: 640,\n\t\t\tinnerHeight: 400,\n\t\t\tconstrainRect(rect, x_axis, y_axis) {\n\t\t\t\tconst char_width = 8;\n\t\t\t\tconst char_height = 16;\n\t\t\t\tconst border = ($win.outerWidth() - $win.$content.outerWidth()) / 2;\n\t\t\t\tconst inner_rect = {\n\t\t\t\t\tx: rect.x + border,\n\t\t\t\t\ty: rect.y + border + $win.$titlebar.outerHeight(),\n\t\t\t\t\twidth: rect.width - $win.outerWidth() + $win.$content.outerWidth(),\n\t\t\t\t\theight: rect.height - $win.outerHeight() + $win.$content.outerHeight(),\n\t\t\t\t};\n\t\t\t\tconst new_inner_rect = {\n\t\t\t\t\twidth: Math.floor(inner_rect.width / char_width) * char_width,\n\t\t\t\t\theight: Math.floor(inner_rect.height / char_height) * char_height,\n\t\t\t\t};\n\t\t\t\tconst new_rect = {\n\t\t\t\t\tx: inner_rect.x - border,\n\t\t\t\t\ty: inner_rect.y - border - $win.$titlebar.outerHeight(),\n\t\t\t\t\twidth: new_inner_rect.width + $win.outerWidth() - $win.$content.outerWidth(),\n\t\t\t\t\theight: new_inner_rect.height + $win.outerHeight() - $win.$content.outerHeight(),\n\t\t\t\t};\n\t\t\t\tif (x_axis === -1) {\n\t\t\t\t\tnew_rect.x = rect.x + rect.width - new_rect.width;\n\t\t\t\t}\n\t\t\t\tif (y_axis === -1) {\n\t\t\t\t\tnew_rect.y = rect.y + rect.height - new_rect.height;\n\t\t\t\t}\n\t\t\t\treturn new_rect;\n\t\t\t},\n\t\t\t// TODO: make the API simpler / more flexible like:\n\t\t\t// constrainDimensions({ innerWidth, innerHeight }) {\n\t\t\t// \tconst charWidth = 8;\n\t\t\t// \tconst charHeight = 16;\n\t\t\t// \tinnerWidth = Math.floor(innerWidth / charWidth) * charWidth;\n\t\t\t// \tinnerHeight = Math.floor(innerHeight / charHeight) * charHeight;\n\t\t\t// \treturn { innerWidth, innerHeight };\n\t\t\t// },\n\t\t});\n\t\treturn new Task($win);\n\t}\n\n\tfunction Calculator() {\n\t\tvar $win = make_iframe_window({\n\t\t\tsrc: \"programs/calculator/index.html\",\n\t\t\ticons: iconsAtTwoSizes(\"calculator\"),\n\t\t\ttitle: \"Calculator\",\n\t\t\tinnerWidth: 256,\n\t\t\tinnerHeight: 208 + 21,\n\t\t\tminInnerWidth: 256,\n\t\t\tminInnerHeight: 208 + 21,\n\t\t});\n\t\treturn new Task($win);\n\t}\n\n\tfunction Pinball() {\n\t\tvar $win = make_iframe_window({\n\t\t\tsrc: \"programs/pinball/space-cadet.html\",\n\t\t\ticons: iconsAtTwoSizes(\"pinball\"),\n\t\t\ttitle: \"3D Pinball for Windows - Space Cadet\",\n\t\t\tinnerWidth: 600,\n\t\t\tinnerHeight: 416 + 20, // @TODO: where's this 20 coming from?\n\t\t\tminInnerWidth: 600,\n\t\t\tminInnerHeight: 416 + 20,\n\t\t\t// resizable: false, // @TODO (maybe) once gray maximized button is implemented\n\t\t\toverride_alert: false, // to handle the alert as a fatal error, and to compensate for overzealous preventDefault()\n\t\t});\n\t\tconst $splash = $(\"<div>\").css({\n\t\t\tposition: \"fixed\",\n\t\t\ttop: 0,\n\t\t\tleft: 0,\n\t\t\twidth: \"100%\",\n\t\t\theight: \"100%\",\n\t\t\tbackground: \"url(images/pinball-splash.png) no-repeat center center\",\n\t\t\tbackgroundColor: \"black\",\n\t\t\tzIndex: $Window.Z_INDEX + 6000,\n\t\t}).appendTo(\"body\");\n\t\tsetTimeout(() => {\n\t\t\t$splash.remove(); // just in case\n\t\t}, 5000);\n\t\t$win.$content.find(\"iframe\").on(\"game-loaded\", () => { // custom event dispatched from within the iframe\n\t\t\t$splash.remove();\n\t\t});\n\t\t$win.$content.find(\"iframe\").on(\"game-load-failed\", () => { // custom event dispatched from within the iframe\n\t\t\t$splash.remove();\n\t\t\t// on some systems, if the game fails to load,\n\t\t\t// it may result in the canvas showing through to the desktop behind the browser window\n\t\t\t// let's call it a feature, tie it in thematically,\n\t\t\t// and pretend like we did it on purpose, to baffle and amuse.\n\t\t\t// This happens for me on Chrome on Ubuntu with Xfce, when coming out of suspend.\n\t\t\t// It says \"Could not create renderer / Couldn't find matching render driver\"\n\t\t\t// It keeps happening with live reload, but stops on a regular reload, or duplicating the tab.\n\t\t\t$win.title(\"Wormhole Window - Space Cadet\");\n\t\t});\n\t\treturn new Task($win);\n\t}\n\n\tfunction Explorer(address) {\n\t\t// TODO: DRY the default file names and title code (use document.title of the page in the iframe, in make_iframe_window)\n\t\tvar document_title = address;\n\t\tvar win_title = document_title;\n\t\t// TODO: focus existing window if folder is currently open\n\t\tvar $win = make_iframe_window({\n\t\t\tsrc: \"programs/explorer/index.html\" + (address ? (\"?address=\" + encodeURIComponent(address)) : \"\"),\n\t\t\ticons: iconsAtTwoSizes(\"folder-open\"),\n\t\t\ttitle: win_title,\n\t\t\t// this is based on one measurement, but it uses different sizes depending on the screen resolution,\n\t\t\t// and may be different for different Explorer window types (Microsoft Internet Explorer, \"Exploring\", normal Windows Explorer*),\n\t\t\t// and may store the window positions, even for different types or folders, so I might have a non-standard default size measurement.\n\t\t\t// *See different types (resized for posing this screenshot): https://imgur.com/nxAcT9C\n\t\t\tinnerWidth: Math.min(856, innerWidth * 0.9),\n\t\t\tinnerHeight: Math.min(547, innerHeight * 0.7),\n\t\t});\n\t\treturn new Task($win);\n\t}\n\tExplorer.acceptsFilePaths = true;\n\n\tvar webamp_bundle_loaded = false;\n\tvar load_winamp_bundle_if_not_loaded = function (includeButterchurn, callback) {\n\t\t// FIXME: webamp_bundle_loaded not actually set to true when loaded\n\t\t// TODO: also maybe handle already-loading-but-not-done\n\t\tif (webamp_bundle_loaded) {\n\t\t\tcallback();\n\t\t} else {\n\t\t\t// TODO: parallelize (if possible)\n\t\t\t$.getScript(\"programs/winamp/lib/webamp.bundle.min.js\", () => {\n\t\t\t\tif (includeButterchurn) {\n\t\t\t\t\t$.getScript(\"programs/winamp/lib/butterchurn.min.js\", () => {\n\t\t\t\t\t\t$.getScript(\"programs/winamp/lib/butterchurnPresets.min.js\", () => {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t// from https://github.com/jberg/butterchurn/blob/master/src/isSupported.js\n\tconst isButterchurnSupported = () => {\n\t\tconst canvas = document.createElement('canvas');\n\t\tlet gl;\n\t\ttry {\n\t\t\tgl = canvas.getContext('webgl2');\n\t\t} catch (x) {\n\t\t\tgl = null;\n\t\t}\n\n\t\tconst webGL2Supported = !!gl;\n\t\tconst audioApiSupported = !!(window.AudioContext || window.webkitAudioContext);\n\n\t\treturn webGL2Supported && audioApiSupported;\n\t};\n\n\tlet webamp;\n\tlet $webamp;\n\tlet winamp_task;\n\tlet winamp_interface;\n\tlet winamp_loading = false;\n\t// TODO: support opening multiple files at once\n\tfunction openWinamp(file_path) {\n\t\tconst filePathToBlob = (file_path) => {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tFilesystemSetup.withFilesystem(function () {\n\t\t\t\t\tvar fs = BrowserFS.BFSRequire(\"fs\");\n\t\t\t\t\tfs.readFile(file_path, function (err, buffer) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst byte_array = new Uint8Array(buffer);\n\t\t\t\t\t\tconst blob = new Blob([byte_array]);\n\t\t\t\t\t\tresolve(blob);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\tconst filePathToTrack = async (file_path) => {\n\t\t\tconst blob = await filePathToBlob(file_path);\n\t\t\tconst blob_url = URL.createObjectURL(blob);\n\t\t\t// TODO: revokeObjectURL\n\t\t\tconst track = {\n\t\t\t\turl: blob_url,\n\t\t\t\tdefaultName: file_name_from_path(file_path).replace(/\\.[a-z0-9]+$/i, \"\"),\n\t\t\t};\n\t\t\treturn track;\n\t\t};\n\n\t\tconst whenLoaded = async () => {\n\t\t\tif ($webamp.css(\"display\") === \"none\") {\n\t\t\t\twinamp_interface.unminimize();\n\t\t\t}\n\n\t\t\twinamp_interface.focus();\n\n\t\t\tif (file_path) {\n\t\t\t\tif (file_path.match(/(\\.wsz|\\.zip)$/i)) {\n\t\t\t\t\tconst blob = await filePathToBlob(file_path);\n\t\t\t\t\tconst url = URL.createObjectURL(blob);\n\t\t\t\t\twebamp.setSkinFromUrl(url);\n\t\t\t\t} else if (file_path.match(/(\\.m3u|\\.pls)$/i)) {\n\t\t\t\t\talert(\"Sorry, we don't support playlists yet.\");\n\t\t\t\t} else {\n\t\t\t\t\tconst track = await filePathToTrack(file_path);\n\t\t\t\t\twebamp.setTracksToPlay([track]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twinamp_loading = false;\n\t\t}\n\t\tif (winamp_task) {\n\t\t\twhenLoaded()\n\t\t\treturn;\n\t\t}\n\t\tif (winamp_loading) {\n\t\t\treturn; // TODO: queue up files?\n\t\t}\n\t\twinamp_loading = true;\n\n\t\t// This check creates a WebGL context, so don't do it if you try to open Winamp while it's opening or open.\n\t\t// (Otherwise it will lead to \"WARNING: Too many active WebGL contexts. Oldest context will be lost.\")\n\t\tconst includeButterchurn = isButterchurnSupported();\n\n\t\tload_winamp_bundle_if_not_loaded(includeButterchurn, function () {\n\t\t\tconst webamp_options = {\n\t\t\t\tinitialTracks: [{\n\t\t\t\t\tmetaData: {\n\t\t\t\t\t\tartist: \"DJ Mike Llama\",\n\t\t\t\t\t\ttitle: \"Llama Whippin' Intro\",\n\t\t\t\t\t},\n\t\t\t\t\turl: \"programs/winamp/mp3/llama-2.91.mp3\",\n\t\t\t\t\tduration: 5.322286,\n\t\t\t\t}],\n\t\t\t\t// initialSkin: {\n\t\t\t\t// \turl: \"programs/winamp/skins/base-2.91.wsz\",\n\t\t\t\t// },\n\t\t\t\tenableHotkeys: true,\n\t\t\t\thandleTrackDropEvent: (event) =>\n\t\t\t\t\tPromise.all(\n\t\t\t\t\t\tdragging_file_paths.map(filePathToTrack)\n\t\t\t\t\t),\n\t\t\t\t// TODO: filePickers\n\t\t\t};\n\t\t\tif (includeButterchurn) {\n\t\t\t\twebamp_options.__butterchurnOptions = {\n\t\t\t\t\timportButterchurn: () => Promise.resolve(window.butterchurn),\n\t\t\t\t\tgetPresets: () => {\n\t\t\t\t\t\tconst presets = window.butterchurnPresets.getPresets();\n\t\t\t\t\t\treturn Object.keys(presets).map((name) => {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tbutterchurnPresetObject: presets[name]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t\tbutterchurnOpen: true,\n\t\t\t\t};\n\t\t\t\twebamp_options.__initialWindowLayout = {\n\t\t\t\t\tmain: { position: { x: 0, y: 0 } },\n\t\t\t\t\tequalizer: { position: { x: 0, y: 116 } },\n\t\t\t\t\tplaylist: { position: { x: 0, y: 232 }, size: [0, 4] },\n\t\t\t\t\tmilkdrop: { position: { x: 275, y: 0 }, size: [7, 12] }\n\t\t\t\t};\n\t\t\t}\n\t\t\twebamp = new Webamp(webamp_options);\n\n\t\t\tvar visual_container = document.createElement(\"div\");\n\t\t\tvisual_container.classList.add(\"webamp-visual-container\");\n\t\t\tvisual_container.style.position = \"absolute\";\n\t\t\tvisual_container.style.left = \"0\";\n\t\t\tvisual_container.style.right = \"0\";\n\t\t\tvisual_container.style.top = \"0\";\n\t\t\tvisual_container.style.bottom = \"0\";\n\t\t\tvisual_container.style.pointerEvents = \"none\";\n\t\t\tdocument.body.appendChild(visual_container);\n\t\t\t// Render after the skin has loaded.\n\t\t\twebamp.renderWhenReady(visual_container).then(() => {\n\t\t\t\twindow.console && console.log(\"Webamp rendered\");\n\n\t\t\t\t$webamp = $(\"#webamp\");\n\t\t\t\t// Bring window to front, initially and when clicked\n\t\t\t\t$webamp.css({\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\tleft: 0,\n\t\t\t\t\ttop: 0,\n\t\t\t\t\tzIndex: $Window.Z_INDEX++\n\t\t\t\t});\n\n\t\t\t\tconst $eventTarget = $({});\n\t\t\t\tconst makeSimpleListenable = (name) => {\n\t\t\t\t\treturn (callback) => {\n\t\t\t\t\t\tconst fn = () => {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t};\n\t\t\t\t\t\t$eventTarget.on(name, fn);\n\t\t\t\t\t\tconst dispose = () => {\n\t\t\t\t\t\t\t$eventTarget.off(name, fn);\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn dispose;\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\twinamp_interface = {};\n\t\t\t\twinamp_interface.onFocus = makeSimpleListenable(\"focus\");\n\t\t\t\twinamp_interface.onBlur = makeSimpleListenable(\"blur\");\n\t\t\t\twinamp_interface.onClosed = makeSimpleListenable(\"closed\");\n\t\t\t\twinamp_interface.getIconAtSize = (target_icon_size) => {\n\t\t\t\t\tif (target_icon_size !== 32 && target_icon_size !== 16) {\n\t\t\t\t\t\ttarget_icon_size = 32;\n\t\t\t\t\t}\n\t\t\t\t\tconst img = document.createElement(\"img\");\n\t\t\t\t\timg.src = helpers.getIconPath(\"winamp2\", target_icon_size);\n\t\t\t\t\treturn img;\n\t\t\t\t};\n\t\t\t\twinamp_interface.bringToFront = () => {\n\t\t\t\t\t$webamp.css({\n\t\t\t\t\t\tzIndex: $Window.Z_INDEX++\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\twinamp_interface.element = winamp_interface[0] = $webamp[0]; // for checking z-index in window switcher\n\t\t\t\twinamp_interface.hasClass = (className) => { // also for window switcher (@TODO: clean this stuff up)\n\t\t\t\t\tif (className === \"focused\") {\n\t\t\t\t\t\treturn $webamp.hasClass(\"focused\");\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\t\t\t\twinamp_interface.focus = () => {\n\t\t\t\t\tif (!$webamp.hasClass(\"focused\")) {\n\t\t\t\t\t\t$webamp.addClass(\"focused\");\n\t\t\t\t\t\twinamp_interface.bringToFront();\n\t\t\t\t\t\t$eventTarget.triggerHandler(\"focus\");\n\t\t\t\t\t\t// @TODO: focus last focused window/control?\n\t\t\t\t\t\t$webamp.find(\"#main-window [tabindex='-1']\").focus();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\twinamp_interface.blur = () => {\n\t\t\t\t\tif ($webamp.hasClass(\"focused\")) {\n\t\t\t\t\t\t$webamp.removeClass(\"focused\");\n\t\t\t\t\t\t$eventTarget.triggerHandler(\"blur\");\n\t\t\t\t\t\t// TODO: really blur\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\twinamp_interface.minimize = () => {\n\t\t\t\t\t// TODO: are these actually useful or does webamp hide it?\n\t\t\t\t\t$webamp.hide();\n\t\t\t\t};\n\t\t\t\twinamp_interface.unminimize = () => {\n\t\t\t\t\t// more to the point does this work necessarily??\n\t\t\t\t\t$webamp.show();\n\t\t\t\t\t// $webamp.focus();\n\t\t\t\t};\n\t\t\t\twinamp_interface.close = () => {\n\t\t\t\t\t// not allowing canceling close event in this case (generally used *by* an application (for \"Save changes?\"), not outside of it)\n\t\t\t\t\t// TODO: probably something like winamp_task.close()\n\t\t\t\t\t// winamp_interface.triggerHandler(\"close\");\n\t\t\t\t\t// winamp_interface.triggerHandler(\"closed\");\n\t\t\t\t\twebamp.dispose();\n\t\t\t\t\t$webamp.remove();\n\n\t\t\t\t\t$eventTarget.triggerHandler(\"closed\");\n\n\t\t\t\t\twebamp = null;\n\t\t\t\t\t$webamp = null;\n\t\t\t\t\twinamp_task = null;\n\t\t\t\t\twinamp_interface = null;\n\t\t\t\t};\n\t\t\t\twinamp_interface.getTitle = () => {\n\t\t\t\t\tlet taskTitle = \"Winamp 2.91\";\n\t\t\t\t\tconst $cell = $webamp.find(\".playlist-track-titles .track-cell.current\");\n\t\t\t\t\tif ($cell.length) {\n\t\t\t\t\t\ttaskTitle = `${$cell.text()} - Winamp`;\n\t\t\t\t\t\tswitch (webamp.getMediaStatus()) {\n\t\t\t\t\t\t\tcase \"STOPPED\":\n\t\t\t\t\t\t\t\ttaskTitle = `${taskTitle} [Stopped]`\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"PAUSED\":\n\t\t\t\t\t\t\t\ttaskTitle = `${taskTitle} [Paused]`\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn taskTitle;\n\t\t\t\t};\n\t\t\t\twinamp_interface.setMinimizeTarget = () => {\n\t\t\t\t\t// dummy function; it won't animate to the minimize target anyway\n\t\t\t\t\t// (did Winamp on Windows 98 animate minimize/restore?)\n\t\t\t\t};\n\t\t\t\t// @TODO: this wasn't supposed to be part of the API, but it's needed for the taskbar\n\t\t\t\twinamp_interface.on = (event_name, callback) => {\n\t\t\t\t\tif (event_name === \"title-change\") {\n\t\t\t\t\t\twebamp.onTrackDidChange(callback);\n\t\t\t\t\t} else if (event_name === \"icon-change\") {\n\t\t\t\t\t\t// icon will never change\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn(`Unsupported event: ${event_name}`);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\thelpers.mustHaveMethods(winamp_interface, helpers.windowInterfaceMethods);\n\n\t\t\t\tlet raf_id;\n\t\t\t\tlet global_pointerdown;\n\n\t\t\t\twinamp_task = new Task(winamp_interface);\n\t\t\t\twebamp.onClose(function () {\n\t\t\t\t\twinamp_interface.close();\n\t\t\t\t\tcancelAnimationFrame(raf_id);\n\t\t\t\t\tvisualizerOverlay.fadeOutAndCleanUp();\n\t\t\t\t});\n\t\t\t\twebamp.onMinimize(function () {\n\t\t\t\t\twinamp_interface.minimize();\n\t\t\t\t});\n\n\t\t\t\t$webamp.on(\"focusin\", () => {\n\t\t\t\t\twinamp_interface.focus();\n\t\t\t\t});\n\t\t\t\t$webamp.on(\"focusout\", () => {\n\t\t\t\t\t// could use relatedTarget, no?\n\t\t\t\t\tif (\n\t\t\t\t\t\t!document.activeElement ||\n\t\t\t\t\t\t!document.activeElement.closest ||\n\t\t\t\t\t\t!document.activeElement.closest(\"#webamp\")\n\t\t\t\t\t) {\n\t\t\t\t\t\twinamp_interface.blur();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tconst visualizerOverlay = new VisualizerOverlay(\n\t\t\t\t\t$webamp.find(\".gen-window canvas\")[0],\n\t\t\t\t\t{ mirror: true, stretch: true },\n\t\t\t\t);\n\n\t\t\t\t// TODO: replace with setInterval\n\t\t\t\t// Note: can't access butterchurn canvas image data during a requestAnimationFrame here\n\t\t\t\t// because of double buffering\n\t\t\t\tconst animate = () => {\n\t\t\t\t\tconst windowElements = $(\".os-window, .window:not(.gen-window)\").toArray();\n\t\t\t\t\twindowElements.forEach(windowEl => {\n\t\t\t\t\t\tif (!windowEl.hasOverlayCanvas) {\n\t\t\t\t\t\t\tvisualizerOverlay.makeOverlayCanvas(windowEl);\n\t\t\t\t\t\t\twindowEl.hasOverlayCanvas = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tif (webamp.getMediaStatus() === \"PLAYING\") {\n\t\t\t\t\t\tvisualizerOverlay.fadeIn();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvisualizerOverlay.fadeOut();\n\t\t\t\t\t}\n\t\t\t\t\traf_id = requestAnimationFrame(animate);\n\t\t\t\t};\n\t\t\t\traf_id = requestAnimationFrame(animate);\n\n\t\t\t\twhenLoaded()\n\t\t\t}, (error) => {\n\t\t\t\t// TODO: show_error_message(\"Failed to load Webamp:\", error);\n\t\t\t\talert(\"Failed to render Webamp:\\n\\n\" + error);\n\t\t\t\tconsole.error(error);\n\t\t\t});\n\t\t});\n\t}\n\topenWinamp.acceptsFilePaths = true;\n\n\t/*\n\tfunction saveAsDialog(){\n\t\tvar $win = new $Window();\n\t\t$win.title(\"Save As\");\n\t\treturn $win;\n\t}\n\tfunction openFileDialog(){\n\t\tvar $win = new $Window();\n\t\t$win.title(\"Open\");\n\t\treturn $win;\n\t}\n\t*/\n\n\tfunction openURLFile(file_path) {\n\t\tFilesystemSetup.withFilesystem(function () {\n\t\t\tvar fs = BrowserFS.BFSRequire(\"fs\");\n\t\t\tfs.readFile(file_path, \"utf8\", function (err, content) {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn alert(err);\n\t\t\t\t}\n\t\t\t\t// it's supposed to be an ini-style file, but lets handle files that are literally just a URL as well, just in case\n\t\t\t\tvar match = content.match(/URL\\s*=\\s*([^\\n\\r]+)/i);\n\t\t\t\tvar url = match ? match[1] : content;\n\t\t\t\tExplorer(url);\n\t\t\t});\n\t\t});\n\t}\n\topenURLFile.acceptsFilePaths = true;\n\n\tfunction openThemeFile(file_path) {\n\t\tFilesystemSetup.withFilesystem(function () {\n\t\t\tvar fs = BrowserFS.BFSRequire(\"fs\");\n\t\t\tfs.readFile(file_path, \"utf8\", function (err, content) {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn alert(err);\n\t\t\t\t}\n\t\t\t\tloadThemeFromText(content);\n\t\t\t\ttry {\n\t\t\t\t\tlocalStorage.setItem(\"desktop-theme\", content);\n\t\t\t\t\tlocalStorage.setItem(\"desktop-theme-path\", file_path);\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// no local storage\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\topenThemeFile.acceptsFilePaths = true;\n\n\t// Note: extensions must be lowercase here. This is used to implement case-insensitive matching.\n\tvar file_extension_associations = {\n\t\t// Fonts:\n\t\t// - eot (Embedded OpenType)\n\t\t// - otf (OpenType)\n\t\t// - ttf (TrueType)\n\t\t// - woff (Web Open Font Format)\n\t\t// - woff2 (Web Open Font Format 2)\n\t\t// - (also svg but that's mainly an image format)\n\n\t\t// Misc binary:\n\t\t// - wasm (WebAssembly)\n\t\t// - o (Object file)\n\t\t// - so (Shared Object)\n\t\t// - dll (Dynamic Link Library)\n\t\t// - exe (Executable file)\n\t\t// - a (static library)\n\t\t// - lib (static library)\n\t\t// - pdb (Program Debug database)\n\t\t// - idb (Intermediate Debug file)\n\t\t// - bcmap (Binary Character Map)\n\t\t// - bin (generic binary file extension)\n\n\t\t// Text:\n\t\t\"\": Notepad, // bare files such as LICENSE, Makefile, CNAME, etc.\n\t\tahk: Notepad,\n\t\tai: Paint,\n\t\tbat: Notepad,\n\t\tcheck_cache: Notepad,\n\t\tcmake: Notepad,\n\t\tcmd: Notepad,\n\t\tconf: Notepad,\n\t\tcpp: Notepad,\n\t\tcss: Notepad,\n\t\td: Notepad,\n\t\teditorconfig: Notepad,\n\t\tfilters: Notepad,\n\t\tgitattributes: Notepad,\n\t\tgitignore: Notepad,\n\t\tgitrepo: Notepad,\n\t\th: Notepad,\n\t\thhc: Notepad,\n\t\thhk: Notepad,\n\t\thtml: Notepad,\n\t\tini: Notepad,\n\t\tjs: Notepad,\n\t\tjson: Notepad,\n\t\tlog: Notepad,\n\t\tmake: Notepad,\n\t\tmap: Notepad,\n\t\tmarks: Notepad,\n\t\tmd: Notepad,\n\t\tprettierignore: Notepad,\n\t\tproperties: Notepad,\n\t\trc: Notepad,\n\t\trsp: Notepad,\n\t\tsh: Notepad,\n\t\tts: Notepad,\n\t\ttxt: Notepad,\n\t\tvcxproj: Notepad,\n\t\twebmanifest: Notepad,\n\t\txml: Notepad,\n\t\tyml: Notepad,\n\n\t\t// Images:\n\t\tbmp: Paint,\n\t\tcur: Paint,\n\t\teps: Paint,\n\t\tgif: Paint,\n\t\ticns: Paint,\n\t\tico: Paint,\n\t\tjpeg: Paint,\n\t\tjpg: Paint,\n\t\tkra: Paint,\n\t\tpbm: Paint,\n\t\tpdf: Paint, // yes I added PDF support to JS Paint (not all formats listed here are supported though)\n\t\tpdn: Paint,\n\t\tpgm: Paint,\n\t\tpng: Paint,\n\t\tpnm: Paint,\n\t\tppm: Paint,\n\t\tps: Paint,\n\t\tpsd: Paint,\n\t\tsvg: Paint,\n\t\ttga: Paint,\n\t\ttif: Paint,\n\t\ttiff: Paint,\n\t\twebp: Paint,\n\t\txbm: Paint,\n\t\txcf: Paint,\n\t\txcfbz2: Paint,\n\t\txcfgz: Paint,\n\t\txpm: Paint,\n\n\t\t// Winamp Skins:\n\t\twsz: openWinamp, // winamp skin zip\n\t\tzip: openWinamp, // MIGHT be a winamp skin zip, so might as well for now\n\n\t\t// Audio:\n\t\twav: SoundRecorder,\n\t\tmp3: openWinamp,\n\t\togg: openWinamp,\n\t\twma: openWinamp,\n\t\tm4a: openWinamp,\n\t\taac: openWinamp,\n\t\tflac: openWinamp,\n\t\tmka: openWinamp,\n\t\tmpc: openWinamp,\n\t\t\"mp+\": openWinamp,\n\n\t\t// Playlists:\n\t\tm3u: openWinamp,\n\t\tpls: openWinamp,\n\n\t\t// Misc:\n\t\thtm: Explorer,\n\t\thtml: Explorer,\n\t\turl: openURLFile,\n\t\ttheme: openThemeFile,\n\t\tthemepack: openThemeFile,\n\t};\n\n\t// Note: global systemExecuteFile called by explorer\n\tfunction systemExecuteFile(file_path) {\n\t\t// execute file with default handler\n\t\t// like the START command in CMD.EXE\n\n\t\tFilesystemSetup.withFilesystem(function () {\n\t\t\tvar fs = BrowserFS.BFSRequire(\"fs\");\n\t\t\tfs.stat(file_path, function (err, stats) {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn alert(\"Failed to get info about \" + file_path + \"\\n\\n\" + err);\n\t\t\t\t}\n\t\t\t\tif (stats.isDirectory()) {\n\t\t\t\t\tExplorer(file_path);\n\t\t\t\t} else {\n\t\t\t\t\tvar file_extension = file_extension_from_path(file_path);\n\t\t\t\t\tvar program = file_extension_associations[file_extension.toLowerCase()];\n\t\t\t\t\tif (program) {\n\t\t\t\t\t\tif (!program.acceptsFilePaths) {\n\t\t\t\t\t\t\talert(program.name + \" does not support opening files via the virtual filesystem yet\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprogram(file_path);\n\t\t\t\t\t} else {\n\t\t\t\t\t\talert(\"No program is associated with \" + file_extension + \" files\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\n\n\tfunction initDesktopFolderView(folder_view) {\n\t\t// TODO: base all the desktop icons off of the filesystem\n\t\t// Note: `C:\\Windows\\Desktop` doesn't contain My Computer, My Documents, Network Neighborhood, Recycle Bin, or Internet Explorer,\n\t\t// or Connect to the Internet, or Setup MSN Internet Access,\n\t\t// whereas `Desktop` does (that's the full address it shows; it's one of them \"special locations\")\n\t\tvar add_icon_not_via_filesystem = function (options) {\n\t\t\tfolder_view.add_item(new FolderViewItem({\n\t\t\t\ticons: {\n\t\t\t\t\t// @TODO: know what sizes are available\n\t\t\t\t\t[helpers.DESKTOP_ICON_SIZE]: helpers.getIconPath(options.iconID, helpers.DESKTOP_ICON_SIZE),\n\t\t\t\t},\n\t\t\t\t...options,\n\t\t\t}));\n\t\t};\n\t\tadd_icon_not_via_filesystem({\n\t\t\ttitle: \"My Computer\",\n\t\t\ticonID: \"my-computer\",\n\t\t\topen: function () { systemExecuteFile(\"/\"); },\n\t\t\t// file_path: \"/\",\n\t\t\tis_system_folder: true,\n\t\t});\n\t\tadd_icon_not_via_filesystem({\n\t\t\ttitle: \"My Documents\",\n\t\t\ticonID: \"my-documents-folder\",\n\t\t\topen: function () { systemExecuteFile(\"/my-documents\"); },\n\t\t\t// file_path: \"/my-documents/\",\n\t\t\tis_system_folder: true,\n\t\t});\n\t\tadd_icon_not_via_filesystem({\n\t\t\ttitle: \"Network Neighborhood\",\n\t\t\ticonID: \"network\",\n\t\t\topen: function () { systemExecuteFile(\"/network-neighborhood\"); },\n\t\t\t// file_path: \"/network-neighborhood/\",\n\t\t\tis_system_folder: true,\n\t\t});\n\t\tadd_icon_not_via_filesystem({\n\t\t\ttitle: \"Recycle Bin\",\n\t\t\ticonID: \"recycle-bin\",\n\t\t\topen: function () { Explorer(\"https://www.epa.gov/recycle/\"); },\n\t\t\tis_system_folder: true,\n\t\t});\n\t\tadd_icon_not_via_filesystem({\n\t\t\ttitle: \"My Pictures\",\n\t\t\ticonID: \"folder\",\n\t\t\topen: function () { systemExecuteFile(\"/my-pictures\"); },\n\t\t\t// file_path: \"/my-pictures/\",\n\t\t\tis_system_folder: true,\n\t\t});\n\t\tadd_icon_not_via_filesystem({\n\t\t\ttitle: \"Internet Explorer\",\n\t\t\ticonID: \"internet-explorer\",\n\t\t\topen: function () { Explorer(\"https://www.google.com/\"); }\n\t\t});\n\t\tadd_icon_not_via_filesystem({\n\t\t\ttitle: \"Paint\",\n\t\t\ticonID: \"paint\",\n\t\t\topen: Paint,\n\t\t\tshortcut: true\n\t\t});\n\t\tadd_icon_not_via_filesystem({\n\t\t\ttitle: \"Minesweeper\",\n\t\t\ticonID: \"minesweeper\",\n\t\t\topen: Minesweeper,\n\t\t\tshortcut: true\n\t\t});\n\t\tadd_icon_not_via_filesystem({\n\t\t\ttitle: \"Sound Recorder\",\n\t\t\ticonID: \"speaker\",\n\t\t\topen: SoundRecorder,\n\t\t\tshortcut: true\n\t\t});\n\t\tadd_icon_not_via_filesystem({\n\t\t\ttitle: \"Solitaire\",\n\t\t\ticonID: \"solitaire\",\n\t\t\topen: Solitaire,\n\t\t\tshortcut: true\n\t\t});\n\t\tadd_icon_not_via_filesystem({\n\t\t\ttitle: \"Notepad\",\n\t\t\ticonID: \"notepad\",\n\t\t\topen: Notepad,\n\t\t\tshortcut: true\n\t\t});\n\t\tadd_icon_not_via_filesystem({\n\t\t\ttitle: \"Winamp\",\n\t\t\ticonID: \"winamp2\",\n\t\t\topen: openWinamp,\n\t\t\tshortcut: true\n\t\t});\n\t\tadd_icon_not_via_filesystem({\n\t\t\ttitle: \"3D Pipes\",\n\t\t\ticonID: \"pipes\",\n\t\t\topen: Pipes,\n\t\t\tshortcut: true\n\t\t});\n\t\tadd_icon_not_via_filesystem({\n\t\t\ttitle: \"3D Flower Box\",\n\t\t\ticonID: \"pipes\",\n\t\t\topen: FlowerBox,\n\t\t\tshortcut: true\n\t\t});\n\t\tadd_icon_not_via_filesystem({\n\t\t\ttitle: \"MS-DOS Prompt\",\n\t\t\ticonID: \"msdos\",\n\t\t\topen: CommandPrompt,\n\t\t\tshortcut: true\n\t\t});\n\t\tadd_icon_not_via_filesystem({\n\t\t\ttitle: \"Calculator\",\n\t\t\ticonID: \"calculator\",\n\t\t\topen: Calculator,\n\t\t\tshortcut: true\n\t\t});\n\t\tadd_icon_not_via_filesystem({\n\t\t\ttitle: \"Pinball\",\n\t\t\ticonID: \"pinball\",\n\t\t\topen: Pinball,\n\t\t\tshortcut: true\n\t\t});\n\n\t\tfolder_view.arrange_icons();\n\n\t}\n\n\n\tfunction iconsAtTwoSizes(iconID) {\n\t\treturn {\n\t\t\t16: `images/icons/${iconID}-16x16.png`,\n\t\t\t32: `images/icons/${iconID}-32x32.png`,\n\t\t};\n\t}\n\n\treturn {\n\t\tsystemExecuteFile,\n\t\tinitDesktopFolderView\n\t};\n\n});\ndefine('skylark-98js/$desktop',[\n\t\"skylark-jquery\",\n\t\"./win98\",\n\t\"./FolderView\",\n\t\"./programs\"\n],function($,win98js,FolderView,programs){\n    \"use strict\";\n\n\tconst desktop_folder_path = \"/desktop/\";\n\n\tvar $desktop = $(\".desktop\");\n\t$desktop.css(\"touch-action\", \"none\"); // TODO: should this be in FolderView, or is it to prevent scrolling the page or what?\n\n\tvar folder_view = new FolderView(desktop_folder_path, {\n\t\tasDesktop: true,\n\t\topenFileOrFolder: (path) => { // Note: may not be defined yet, so wrapping with a function.\n\t\t\tprograms.systemExecuteFile(path);\n\t\t},\n\t});\n\t$(folder_view.element).appendTo($desktop);\n\n\tfunction setDesktopWallpaper(file, repeat, saveToLocalStorage) {\n\t\tconst blob_url = URL.createObjectURL(file);\n\t\t$desktop.css({\n\t\t\tbackgroundImage: `url(${blob_url})`,\n\t\t\tbackgroundRepeat: repeat,\n\t\t\tbackgroundPosition: \"center\",\n\t\t\tbackgroundSize: \"auto\",\n\t\t});\n\t\tif (saveToLocalStorage) {\n\t\t\tvar fr = new FileReader();\n\t\t\twindow.fr = fr;\n\t\t\tfr.onload = () => {\n\t\t\t\tlocalStorage.setItem(\"wallpaper-data-url\", fr.result);\n\t\t\t\tlocalStorage.setItem(\"wallpaper-repeat\", repeat);\n\t\t\t};\n\t\t\tfr.onerror = () => {\n\t\t\t\tconsole.error(\"Error reading file (for setting wallpaper)\", file);\n\t\t\t};\n\t\t\tfr.readAsDataURL(file);\n\t\t}\n\t}\n\ttry {\n\t\tvar wallpaper_data_url = localStorage.getItem(\"wallpaper-data-url\");\n\t\tvar wallpaper_repeat = localStorage.getItem(\"wallpaper-repeat\");\n\t\tvar theme_file_content = localStorage.getItem(\"desktop-theme\");\n\t\tif (wallpaper_data_url) {\n\t\t\tfetch(wallpaper_data_url).then(r => r.blob()).then(file => {\n\t\t\t\tsetDesktopWallpaper(file, wallpaper_repeat, false);\n\t\t\t});\n\t\t}\n\t\tif (theme_file_content) {\n\t\t\tloadThemeFromText(theme_file_content);\n\t\t}\n\t} catch (error) {\n\t\tconsole.error(error);\n\t}\n\n\t// Prevent drag and drop from redirecting the page (the browser default behavior for files)\n\t// TODO: only prevent if there are actually files; there's nothing that uses text inputs atm that's not in an iframe, so it doesn't matter YET (afaik)\n\t// $G.on(\"dragover\", function(e){\n\t// \te.preventDefault();\n\t// });\n\t// $G.on(\"drop\", function(e){\n\t// \te.preventDefault();\n\t// });\n\n\tfunction loadThemeFile(file) {\n\t\tvar reader = new FileReader();\n\t\treader.onload = () => {\n\t\t\tloadThemeFromText(reader.result);\n\t\t};\n\t\treader.readAsText(file);\n\t}\n\tfunction applyTheme(cssProperties, documentElement = document.documentElement) {\n\t\tapplyCSSProperties(cssProperties, { element: documentElement, recurseIntoIframes: true });\n\t}\n\tfunction loadThemeFromText(fileText) {\n\t\tvar cssProperties = parseThemeFileString(fileText);\n\t\tapplyTheme(cssProperties);\n\t\twindow.themeCSSProperties = cssProperties;\n\t}\n\n\t$(\"html\").on(\"dragover\", function (event) {\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\t});\n\t$(\"html\").on(\"dragleave\", function (event) {\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\t});\n\t$(\"html\").on(\"drop\", function (event) {\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\t\tvar files = [...event.originalEvent.dataTransfer.files];\n\t\tfor (var file of files) {\n\t\t\tif (file.name.match(/\\.theme(pack)?$/i)) {\n\t\t\t\tloadThemeFile(file);\n\t\t\t}\n\t\t}\n\t});\n\n\t// Despite overflow:hidden on html and body,\n\t// focusing elements that are partially offscreen can still scroll the page.\n\t// For example, with opening Paint and moving it partially offscreen and opening Image > Attributes,\n\t// the default focused button can scroll the entire desktop.\n\t// We need to prevent (reset) scroll, and also avoid scrollIntoView().\n\t$(window).on(\"scroll focusin\", () => {\n\t\twindow.scrollTo(0, 0);\n\t});\n\n\n\tprograms.initDesktopFolderView(folder_view);\n\n\n\t$desktop.reflow();\n\n\treturn win98js.$desktop = $desktop;\n});\ndefine('skylark-98js/$start-menu',[\n\t\"skylark-jquery\",\n\t\"./win98\",\n\t\"./os-gui/$Window\"\n],function($,win98js,$Window){\n\t// TODO: start menu\n\n\t/*\n\t// if running from file: protocol, try to sniff the username >:)\n\tvar username_match = location.href.match(/\\/(Users|home)\\/(\\w+)\\//);\n\tvar username = username_match && username_match[1] || \"Admin\";\n\t*/\n\n\tvar $start_menu = $(\".start-menu\");\n\t$start_menu.hide();\n\t// TODO: legitimate contents or whatever\n\tvar open_start_menu = function () {\n\t\t$start_button.addClass(\"selected\");\n\t\t$start_menu.attr(\"hidden\", null);\n\t\t$start_menu.slideDown(100); // DOWN AS IN UP (stupid jQuery)\n\t\t$start_menu.css({ zIndex: ++$Window.Z_INDEX + 5001 });\n\t};\n\tvar close_start_menu = function () {\n\t\t$start_button.removeClass(\"selected\");\n\t\t$start_menu.attr(\"hidden\", \"hidden\");\n\t\t$start_menu.hide();\n\t};\n\tvar toggle_start_menu = function () {\n\t\tif ($start_menu.is(\":hidden\")) {\n\t\t\topen_start_menu();\n\t\t} else {\n\t\t\tclose_start_menu();\n\t\t}\n\t};\n\n\tvar $start_button = $(\".start-button\");\n\t$start_button.on(\"pointerdown\", function () {\n\t\ttoggle_start_menu();\n\t});\n\n\t$(\"body\").on(\"pointerdown\", function (e) {\n\t\tif ($(e.target).closest(\".start-menu, .start-button\").length === 0) {\n\t\t\tclose_start_menu();\n\t\t}\n\t});\n\t// Note: A lot of the time it's good to use focusout (in jQuery, or else blur with useCapture?[1]) as opposed to \n\t// That might be the case here as well, but maybe not since programs opening might grab focus and that probably shouldn't close the start menu\n\t// Although at the operating system level it would probably prevent focus switching in the first place, so maybe we could do that\n\t// The point being this is an operating system control and so it may warrant special handling,\n\t// but generally I'd recommend making a control focusable and detecting loss of focus as in this answer:\n\t// [1]: https://stackoverflow.com/a/38317768/2624876\n\n\t$(window).on(\"keydown\", function (e) {\n\t\tif (e.which === 27) { // Esc to close\n\t\t\tclose_start_menu();\n\t\t}\n\t});\n\n\treturn $start_menu;\n});\ndefine('skylark-98js/$taskbar-time',[\n\t\"skylark-jquery\",\n\t\"./win98\"\n],function($,win98js){\n\tvar $time = $(\".taskbar-time\");\n\tvar update_time = function () {\n\t\t$time.text(new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }));\n\t\t$time.attr(\"title\", new Date().toLocaleString([], { weekday: 'long', month: 'long', day: '2-digit', minute: '2-digit', hour: '2-digit' }));\n\t\tsetTimeout(update_time, 1000);\n\t};\n\tupdate_time();\n\n\treturn $time;\n});\n\ndefine('skylark-98js/msgbox',[\n\t\"skylark-jquery\",\n\t\"./win98\",\n\t\"./os-gui/$Window\"\n],function($,win98js,$Window){\n\t// Prefer a function injected from outside an iframe,\n\t// which will make dialogs that can go outside the iframe.\n\t// Note that this API must be kept in sync with the version in jspaint.\n\n\t// Note `defaultMessageBoxTitle` handling in make_iframe_window\n\t// Any other default parameters need to be handled there (as it works now)\n\n\tvar chord_audio = new Audio(\"/audio/CHORD.WAV\");\n\n\twindow.showMessageBox = window.showMessageBox || (({\n\t\ttitle = window.defaultMessageBoxTitle /*??*/ ||  \"Alert\",\n\t\tmessage,\n\t\tmessageHTML,\n\t\tbuttons = [{ label: \"OK\", value: \"ok\", default: true }],\n\t\ticonID = \"warning\", // \"error\", \"warning\", \"info\", or \"nuke\" for deleting files/folders\n\t\twindowOptions = {}, // for controlling width, etc.\n\t}) => {\n\t\tlet $window, $message;\n\t\tconst promise = new Promise((resolve, reject) => {\n\t\t\t$window = new $Window(Object.assign({\n\t\t\t\ttitle,\n\t\t\t\tresizable: false,\n\t\t\t\tinnerWidth: 400,\n\t\t\t\tmaximizeButton: false,\n\t\t\t\tminimizeButton: false,\n\t\t\t}, windowOptions));\n\t\t\t// $window.addClass(\"dialog-window horizontal-buttons\");\n\t\t\t$message =\n\t\t\t\t$(\"<div>\").css({\n\t\t\t\t\ttextAlign: \"left\",\n\t\t\t\t\tfontFamily: \"MS Sans Serif, Arial, sans-serif\",\n\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\tmarginTop: \"22px\",\n\t\t\t\t\tflex: 1,\n\t\t\t\t\tminWidth: 0, // Fixes hidden overflow, see https://css-tricks.com/flexbox-truncated-text/\n\t\t\t\t\twhiteSpace: \"normal\", // overriding .window:not(.squish)\n\t\t\t\t});\n\t\t\tif (messageHTML) {\n\t\t\t\t$message.html(messageHTML);\n\t\t\t} else if (message) { // both are optional because you may populate later with dynamic content\n\t\t\t\t$message.text(message).css({\n\t\t\t\t\twhiteSpace: \"pre-wrap\",\n\t\t\t\t\twordWrap: \"break-word\",\n\t\t\t\t});\n\t\t\t}\n\t\t\t$(\"<div>\").append(\n\t\t\t\t$(\"<img width='32' height='32'>\").attr(\"src\", `../../images/icons/${iconID}-32x32-8bpp.png`).css({\n\t\t\t\t\tmargin: \"16px\",\n\t\t\t\t\tdisplay: \"block\",\n\t\t\t\t}),\n\t\t\t\t$message\n\t\t\t).css({\n\t\t\t\tdisplay: \"flex\",\n\t\t\t\tflexDirection: \"row\",\n\t\t\t}).appendTo($window.$content);\n\n\t\t\t$window.$content.css({\n\t\t\t\ttextAlign: \"center\",\n\t\t\t});\n\t\t\tfor (const button of buttons) {\n\t\t\t\tconst $button = $window.$Button(button.label, () => {\n\t\t\t\t\tbutton.action && button.action(); // API may be required for using user gesture requiring APIs\n\t\t\t\t\tresolve(button.value);\n\t\t\t\t\t$window.close(); // actually happens automatically\n\t\t\t\t});\n\t\t\t\tif (button.default) {\n\t\t\t\t\t$button.addClass(\"default\");\n\t\t\t\t\t$button.focus();\n\t\t\t\t\tsetTimeout(() => $button.focus(), 0); // @TODO: why is this needed? does it have to do with the iframe window handling?\n\t\t\t\t}\n\t\t\t\t$button.css({\n\t\t\t\t\tminWidth: 75,\n\t\t\t\t\theight: 23,\n\t\t\t\t\tmargin: \"16px 2px\",\n\t\t\t\t});\n\t\t\t}\n\t\t\t$window.on(\"focusin\", \"button\", (event) => {\n\t\t\t\t$(event.currentTarget).addClass(\"default\");\n\t\t\t});\n\t\t\t$window.on(\"focusout\", \"button\", (event) => {\n\t\t\t\t$(event.currentTarget).removeClass(\"default\");\n\t\t\t});\n\t\t\t$window.on(\"closed\", () => {\n\t\t\t\tresolve(\"closed\"); // or \"cancel\"? do you need to distinguish?\n\t\t\t});\n\t\t\t$window.center();\n\t\t});\n\t\tpromise.$window = $window;\n\t\tpromise.$message = $message;\n\t\tpromise.promise = promise; // for easy destructuring\n\t\ttry {\n\t\t\tchord_audio.play();\n\t\t} catch (error) {\n\t\t\tconsole.log(`Failed to play ${chord_audio.src}: `, error);\n\t\t}\n\t\treturn promise;\n\t});\n\n\twindow.alert = (message) => {\n\t\tshowMessageBox({ message });\n\t};\n\n});\ndefine('skylark-clippy/Queue',['skylark-jquery'], function ($) {\n    'use strict';\n    class Queue {\n        constructor(onEmptyCallback) {\n            this._queue = [];\n            this._onEmptyCallback = onEmptyCallback;\n        }\n        queue(func) {\n            this._queue.push(func);\n            if (this._queue.length === 1 && !this._active) {\n                this._progressQueue();\n            }\n        }\n        _progressQueue() {\n            if (!this._queue.length) {\n                this._onEmptyCallback();\n                return;\n            }\n            let f = this._queue.shift();\n            this._active = true;\n            let completeFunction = $.proxy(this.next, this);\n            f(completeFunction);\n        }\n        clear() {\n            this._queue = [];\n        }\n        next() {\n            this._active = false;\n            this._progressQueue();\n        }\n    }\n\n    return Queue;\n});\ndefine('skylark-clippy/Animator',['skylark-jquery'], function ($) {\n    'use strict';\n    class Animator {\n        constructor(el, path, data, sounds) {\n            this._el = el;\n            this._data = data;\n            this._path = path;\n            this._currentFrameIndex = 0;\n            this._currentFrame = undefined;\n            this._exiting = false;\n            this._currentAnimation = undefined;\n            this._endCallback = undefined;\n            this._started = false;\n            this._sounds = {};\n            this.currentAnimationName = undefined;\n            this.preloadSounds(sounds);\n            this._overlays = [this._el];\n            let curr = this._el;\n            this._setupElement(this._el);\n            for (let i = 1; i < this._data.overlayCount; i++) {\n                let inner = this._setupElement($('<div></div>'));\n                curr.append(inner);\n                this._overlays.push(inner);\n                curr = inner;\n            }\n        }\n        _setupElement(el) {\n            let frameSize = this._data.framesize;\n            el.css('display', 'none');\n            el.css({\n                width: frameSize[0],\n                height: frameSize[1]\n            });\n            el.css('background', \"url('\" + this._path + \"/map.png') no-repeat\");\n            return el;\n        }\n        animations() {\n            let r = [];\n            let d = this._data.animations;\n            for (let n in d) {\n                r.push(n);\n            }\n            return r;\n        }\n        preloadSounds(sounds) {\n            for (let i = 0; i < this._data.sounds.length; i++) {\n                let snd = this._data.sounds[i];\n                let uri = sounds[snd];\n                if (!uri)\n                    continue;\n                this._sounds[snd] = new Audio(uri);\n            }\n        }\n        hasAnimation(name) {\n            return !!this._data.animations[name];\n        }\n        exitAnimation() {\n            this._exiting = true;\n        }\n        showAnimation(animationName, stateChangeCallback) {\n            this._exiting = false;\n            if (!this.hasAnimation(animationName)) {\n                return false;\n            }\n            this._currentAnimation = this._data.animations[animationName];\n            this.currentAnimationName = animationName;\n            if (!this._started) {\n                this._step();\n                this._started = true;\n            }\n            this._currentFrameIndex = 0;\n            this._currentFrame = undefined;\n            this._endCallback = stateChangeCallback;\n            return true;\n        }\n        _draw() {\n            let images = [];\n            if (this._currentFrame)\n                images = this._currentFrame.images || [];\n            for (let i = 0; i < this._overlays.length; i++) {\n                if (i < images.length) {\n                    let xy = images[i];\n                    let bg = -xy[0] + 'px ' + -xy[1] + 'px';\n                    this._overlays[i].css({\n                        'background-position': bg,\n                        'display': 'block'\n                    });\n                } else {\n                    this._overlays[i].css('display', 'none');\n                }\n            }\n        }\n        _getNextAnimationFrame() {\n            if (!this._currentAnimation)\n                return undefined;\n            if (!this._currentFrame)\n                return 0;\n            let currentFrame = this._currentFrame;\n            let branching = this._currentFrame.branching;\n            if (this._exiting && currentFrame.exitBranch !== undefined) {\n                return currentFrame.exitBranch;\n            } else if (branching) {\n                let rnd = Math.random() * 100;\n                for (let i = 0; i < branching.branches.length; i++) {\n                    let branch = branching.branches[i];\n                    if (rnd <= branch.weight) {\n                        return branch.frameIndex;\n                    }\n                    rnd -= branch.weight;\n                }\n            }\n            return this._currentFrameIndex + 1;\n        }\n        _playSound() {\n            let s = this._currentFrame.sound;\n            if (!s)\n                return;\n            let audio = this._sounds[s];\n            if (audio)\n                audio.play();\n        }\n        _atLastFrame() {\n            return this._currentFrameIndex >= this._currentAnimation.frames.length - 1;\n        }\n        _step() {\n            if (!this._currentAnimation)\n                return;\n            let newFrameIndex = Math.min(this._getNextAnimationFrame(), this._currentAnimation.frames.length - 1);\n            let frameChanged = !this._currentFrame || this._currentFrameIndex !== newFrameIndex;\n            this._currentFrameIndex = newFrameIndex;\n            if (!(this._atLastFrame() && this._currentAnimation.useExitBranching)) {\n                this._currentFrame = this._currentAnimation.frames[this._currentFrameIndex];\n            }\n            this._draw();\n            this._playSound();\n            this._loop = window.setTimeout($.proxy(this._step, this), this._currentFrame.duration);\n            if (this._endCallback && frameChanged && this._atLastFrame()) {\n                if (this._currentAnimation.useExitBranching && !this._exiting) {\n                    this._endCallback(this.currentAnimationName, Animator.States.WAITING);\n                } else {\n                    this._endCallback(this.currentAnimationName, Animator.States.EXITED);\n                }\n            }\n        }\n        pause() {\n            window.clearTimeout(this._loop);\n        }\n        resume() {\n            this._step();\n        }\n    }\n    \n    Animator.States = {\n        WAITING: 1,\n        EXITED: 0\n    };\n\n    return Animator;\n});\ndefine('skylark-clippy/Balloon',['skylark-jquery'], function ($) {\n    'use strict';\n    class Balloon {\n        constructor(targetEl) {\n            this._targetEl = targetEl;\n            this._hidden = true;\n            this._setup();\n            this.WORD_SPEAK_TIME = 200;\n            this.CLOSE_BALLOON_DELAY = 2000;\n            this._BALLOON_MARGIN = 15;\n        }\n        _setup() {\n            this._balloon = $('<div class=\"clippy-balloon\"><div class=\"clippy-tip\"></div><div class=\"clippy-content\"></div></div> ').hide();\n            this._content = this._balloon.find('.clippy-content');\n            $(document.body).append(this._balloon);\n        }\n        reposition() {\n            let sides = [\n                'top-left',\n                'top-right',\n                'bottom-left',\n                'bottom-right'\n            ];\n            for (let i = 0; i < sides.length; i++) {\n                let s = sides[i];\n                this._position(s);\n                if (!this._isOut())\n                    break;\n            }\n        }\n        _position(side) {\n            let o = this._targetEl.offset();\n            let h = this._targetEl.height();\n            let w = this._targetEl.width();\n            o.top -= $(window).scrollTop();\n            o.left -= $(window).scrollLeft();\n            let bH = this._balloon.outerHeight();\n            let bW = this._balloon.outerWidth();\n            this._balloon.removeClass('clippy-top-left');\n            this._balloon.removeClass('clippy-top-right');\n            this._balloon.removeClass('clippy-bottom-right');\n            this._balloon.removeClass('clippy-bottom-left');\n            let left, top;\n            switch (side) {\n            case 'top-left':\n                left = o.left + w - bW;\n                top = o.top - bH - this._BALLOON_MARGIN;\n                break;\n            case 'top-right':\n                left = o.left;\n                top = o.top - bH - this._BALLOON_MARGIN;\n                break;\n            case 'bottom-right':\n                left = o.left;\n                top = o.top + h + this._BALLOON_MARGIN;\n                break;\n            case 'bottom-left':\n                left = o.left + w - bW;\n                top = o.top + h + this._BALLOON_MARGIN;\n                break;\n            }\n            this._balloon.css({\n                top: top,\n                left: left\n            });\n            this._balloon.addClass('clippy-' + side);\n        }\n        _isOut() {\n            let o = this._balloon.offset();\n            let bH = this._balloon.outerHeight();\n            let bW = this._balloon.outerWidth();\n            let wW = $(window).width();\n            let wH = $(window).height();\n            let sT = $(document).scrollTop();\n            let sL = $(document).scrollLeft();\n            let top = o.top - sT;\n            let left = o.left - sL;\n            let m = 5;\n            if (top - m < 0 || left - m < 0)\n                return true;\n            return top + bH + m > wH || left + bW + m > wW;\n        }\n        speak(complete, text, hold) {\n            this._hidden = false;\n            this.show();\n            let c = this._content;\n            c.height('auto');\n            c.width('auto');\n            c.text(text);\n            c.height(c.height());\n            c.width(c.width());\n            c.text('');\n            this.reposition();\n            this._complete = complete;\n            this._sayWords(text, hold, complete);\n        }\n        show() {\n            if (this._hidden)\n                return;\n            this._balloon.show();\n        }\n        hide(fast) {\n            if (fast) {\n                this._balloon.hide();\n                return;\n            }\n            this._hiding = window.setTimeout($.proxy(this._finishHideBalloon, this), this.CLOSE_BALLOON_DELAY);\n        }\n        _finishHideBalloon() {\n            if (this._active)\n                return;\n            this._balloon.hide();\n            this._hidden = true;\n            this._hiding = null;\n        }\n        _sayWords(text, hold, complete) {\n            this._active = true;\n            this._hold = hold;\n            let words = text.split(/[^\\S-]/);\n            let time = this.WORD_SPEAK_TIME;\n            let el = this._content;\n            let idx = 1;\n            this._addWord = $.proxy(function () {\n                if (!this._active)\n                    return;\n                if (idx > words.length) {\n                    delete this._addWord;\n                    this._active = false;\n                    if (!this._hold) {\n                        complete();\n                        this.hide();\n                    }\n                } else {\n                    el.text(words.slice(0, idx).join(' '));\n                    idx++;\n                    this._loop = window.setTimeout($.proxy(this._addWord, this), time);\n                }\n            }, this);\n            this._addWord();\n        }\n        close() {\n            if (this._active) {\n                this._hold = false;\n            } else if (this._hold) {\n                this._complete();\n            }\n        }\n        pause() {\n            window.clearTimeout(this._loop);\n            if (this._hiding) {\n                window.clearTimeout(this._hiding);\n                this._hiding = null;\n            }\n        }\n        resume() {\n            if (this._addWord) {\n                this._addWord();\n            } else if (!this._hold && !this._hidden) {\n                this._hiding = window.setTimeout($.proxy(this._finishHideBalloon, this), this.CLOSE_BALLOON_DELAY);\n            }\n        }\n    }\n\n    return Balloon;\n});\ndefine('skylark-clippy/Agent',[\n    'skylark-jquery',\n    './Queue',\n    './Animator',\n    './Balloon'\n], function ($, Queue, Animator, Balloon) {\n    'use strict';\n     class Agent {\n        constructor(path, data, sounds) {\n            this.path = path;\n            this._queue = new Queue($.proxy(this._onQueueEmpty, this));\n            this._el = $('<div class=\"clippy\"></div>').hide();\n            $(document.body).append(this._el);\n            this._animator = new Animator(this._el, path, data, sounds);\n            this._balloon = new Balloon(this._el);\n            this._setupEvents();\n        }\n        gestureAt(x, y) {\n            let d = this._getDirection(x, y);\n            let gAnim = 'Gesture' + d;\n            let lookAnim = 'Look' + d;\n            let animation = this.hasAnimation(gAnim) ? gAnim : lookAnim;\n            return this.play(animation);\n        }\n        hide(fast, callback) {\n            this._hidden = true;\n            let el = this._el;\n            this.stop();\n            if (fast) {\n                this._el.hide();\n                this.stop();\n                this.pause();\n                if (callback)\n                    callback();\n                return;\n            }\n            return this._playInternal('Hide', function () {\n                el.hide();\n                this.pause();\n                if (callback)\n                    callback();\n            });\n        }\n        moveTo(x, y, duration) {\n            let dir = this._getDirection(x, y);\n            let anim = 'Move' + dir;\n            if (duration === undefined)\n                duration = 1000;\n            this._addToQueue(function (complete) {\n                if (duration === 0) {\n                    this._el.css({\n                        top: y,\n                        left: x\n                    });\n                    this.reposition();\n                    complete();\n                    return;\n                }\n                if (!this.hasAnimation(anim)) {\n                    this._el.animate({\n                        top: y,\n                        left: x\n                    }, duration, complete);\n                    return;\n                }\n                let callback = $.proxy(function (name, state) {\n                    if (state === Animator.States.EXITED) {\n                        complete();\n                    }\n                    if (state === Animator.States.WAITING) {\n                        this._el.animate({\n                            top: y,\n                            left: x\n                        }, duration, $.proxy(function () {\n                            this._animator.exitAnimation();\n                        }, this));\n                    }\n                }, this);\n                this._playInternal(anim, callback);\n            }, this);\n        }\n        _playInternal(animation, callback) {\n            if (this._isIdleAnimation() && this._idleDfd && this._idleDfd.state() === 'pending') {\n                this._idleDfd.done($.proxy(function () {\n                    this._playInternal(animation, callback);\n                }, this));\n            }\n            this._animator.showAnimation(animation, callback);\n        }\n        play(animation, timeout, cb) {\n            if (!this.hasAnimation(animation))\n                return false;\n            if (timeout === undefined)\n                timeout = 5000;\n            this._addToQueue(function (complete) {\n                let completed = false;\n                let callback = function (name, state) {\n                    if (state === Animator.States.EXITED) {\n                        completed = true;\n                        if (cb)\n                            cb();\n                        complete();\n                    }\n                };\n                if (timeout) {\n                    window.setTimeout($.proxy(function () {\n                        if (completed)\n                            return;\n                        this._animator.exitAnimation();\n                    }, this), timeout);\n                }\n                this._playInternal(animation, callback);\n            }, this);\n            return true;\n        }\n        show(fast) {\n            this._hidden = false;\n            if (fast) {\n                this._el.show();\n                this.resume();\n                this._onQueueEmpty();\n                return;\n            }\n            if (this._el.css('top') === 'auto' || !this._el.css('left') === 'auto') {\n                let left = $(window).width() * 0.8;\n                let top = ($(window).height() + $(document).scrollTop()) * 0.8;\n                this._el.css({\n                    top: top,\n                    left: left\n                });\n            }\n            this.resume();\n            return this.play('Show');\n        }\n        speak(text, hold) {\n            this._addToQueue(function (complete) {\n                this._balloon.speak(complete, text, hold);\n            }, this);\n        }\n        closeBalloon() {\n            this._balloon.hide();\n        }\n        delay(time) {\n            time = time || 250;\n            this._addToQueue(function (complete) {\n                this._onQueueEmpty();\n                window.setTimeout(complete, time);\n            });\n        }\n        stopCurrent() {\n            this._animator.exitAnimation();\n            this._balloon.close();\n        }\n        stop() {\n            this._queue.clear();\n            this._animator.exitAnimation();\n            this._balloon.hide();\n        }\n        hasAnimation(name) {\n            return this._animator.hasAnimation(name);\n        }\n        animations() {\n            return this._animator.animations();\n        }\n        animate() {\n            let animations = this.animations();\n            let anim = animations[Math.floor(Math.random() * animations.length)];\n            if (anim.indexOf('Idle') === 0) {\n                return this.animate();\n            }\n            return this.play(anim);\n        }\n        _getDirection(x, y) {\n            let offset = this._el.offset();\n            let h = this._el.height();\n            let w = this._el.width();\n            let centerX = offset.left + w / 2;\n            let centerY = offset.top + h / 2;\n            let a = centerY - y;\n            let b = centerX - x;\n            let r = Math.round(180 * Math.atan2(a, b) / Math.PI);\n            if (-45 <= r && r < 45)\n                return 'Right';\n            if (45 <= r && r < 135)\n                return 'Up';\n            if (135 <= r && r <= 180 || -180 <= r && r < -135)\n                return 'Left';\n            if (-135 <= r && r < -45)\n                return 'Down';\n            return 'Top';\n        }\n        _onQueueEmpty() {\n            if (this._hidden || this._isIdleAnimation())\n                return;\n            let idleAnim = this._getIdleAnimation();\n            this._idleDfd = $.Deferred();\n            this._animator.showAnimation(idleAnim, $.proxy(this._onIdleComplete, this));\n        }\n        _onIdleComplete(name, state) {\n            if (state === Animator.States.EXITED) {\n                this._idleDfd.resolve();\n            }\n        }\n        _isIdleAnimation() {\n            let c = this._animator.currentAnimationName;\n            return c && c.indexOf('Idle') === 0;\n        }\n        _getIdleAnimation() {\n            let animations = this.animations();\n            let r = [];\n            for (let i = 0; i < animations.length; i++) {\n                let a = animations[i];\n                if (a.indexOf('Idle') === 0) {\n                    r.push(a);\n                }\n            }\n            let idx = Math.floor(Math.random() * r.length);\n            return r[idx];\n        }\n        _setupEvents() {\n            $(window).on('resize', $.proxy(this.reposition, this));\n            this._el.on('mousedown', $.proxy(this._onMouseDown, this));\n            this._el.on('dblclick', $.proxy(this._onDoubleClick, this));\n        }\n        _onDoubleClick() {\n            if (!this.play('ClickedOn')) {\n                this.animate();\n            }\n        }\n        reposition() {\n            if (!this._el.is(':visible'))\n                return;\n            let o = this._el.offset();\n            let bH = this._el.outerHeight();\n            let bW = this._el.outerWidth();\n            let wW = $(window).width();\n            let wH = $(window).height();\n            let sT = $(window).scrollTop();\n            let sL = $(window).scrollLeft();\n            let top = o.top - sT;\n            let left = o.left - sL;\n            let m = 5;\n            if (top - m < 0) {\n                top = m;\n            } else if (top + bH + m > wH) {\n                top = wH - bH - m;\n            }\n            if (left - m < 0) {\n                left = m;\n            } else if (left + bW + m > wW) {\n                left = wW - bW - m;\n            }\n            this._el.css({\n                left: left,\n                top: top\n            });\n            this._balloon.reposition();\n        }\n        _onMouseDown(e) {\n            e.preventDefault();\n            this._startDrag(e);\n        }\n        _startDrag(e) {\n            this.pause();\n            this._balloon.hide(true);\n            this._offset = this._calculateClickOffset(e);\n            this._moveHandle = $.proxy(this._dragMove, this);\n            this._upHandle = $.proxy(this._finishDrag, this);\n            $(window).on('mousemove', this._moveHandle);\n            $(window).on('mouseup', this._upHandle);\n            this._dragUpdateLoop = window.setTimeout($.proxy(this._updateLocation, this), 10);\n        }\n        _calculateClickOffset(e) {\n            let mouseX = e.pageX;\n            let mouseY = e.pageY;\n            let o = this._el.offset();\n            return {\n                top: mouseY - o.top,\n                left: mouseX - o.left\n            };\n        }\n        _updateLocation() {\n            this._el.css({\n                top: this._targetY,\n                left: this._targetX\n            });\n            this._dragUpdateLoop = window.setTimeout($.proxy(this._updateLocation, this), 10);\n        }\n        _dragMove(e) {\n            e.preventDefault();\n            let x = e.clientX - this._offset.left;\n            let y = e.clientY - this._offset.top;\n            this._targetX = x;\n            this._targetY = y;\n        }\n        _finishDrag() {\n            window.clearTimeout(this._dragUpdateLoop);\n            $(window).off('mousemove', this._moveHandle);\n            $(window).off('mouseup', this._upHandle);\n            this._balloon.show();\n            this.reposition();\n            this.resume();\n        }\n        _addToQueue(func, scope) {\n            if (scope)\n                func = $.proxy(func, scope);\n            this._queue.queue(func);\n        }\n        pause() {\n            this._animator.pause();\n            this._balloon.pause();\n        }\n        resume() {\n            this._animator.resume();\n            this._balloon.resume();\n        }\n    }\n\n    return Agent;\n});\ndefine('skylark-clippy/loads',[\n    'skylark-jquery',\n    './Agent'\n], function ($, Agent) {\n    'use strict';\n    class load {\n        constructor(name, successCb, failCb, base_path) {\n            base_path = base_path || window.CLIPPY_CDN || 'https://gitcdn.xyz/repo/pi0/clippyjs/master/assets/agents/';\n            let path = base_path + name;\n            let mapDfd = load._loadMap(path);\n            let agentDfd = load._loadAgent(name, path);\n            let soundsDfd = load._loadSounds(name, path);\n            let data;\n            agentDfd.done(function (d) {\n                data = d;\n            });\n            let sounds;\n            soundsDfd.done(function (d) {\n                sounds = d;\n            });\n            let cb = function () {\n                let a = new Agent(path, data, sounds);\n                successCb(a);\n            };\n            $.when(mapDfd, agentDfd, soundsDfd).done(cb).fail(failCb);\n        }\n        static _loadMap(path) {\n            let dfd = load._maps[path];\n            if (dfd)\n                return dfd;\n            dfd = load._maps[path] = $.Deferred();\n            let src = path + '/map.png';\n            let img = new Image();\n            img.onload = dfd.resolve;\n            img.onerror = dfd.reject;\n            img.setAttribute('src', src);\n            return dfd.promise();\n        }\n        static _loadSounds(name, path) {\n            let dfd = load._sounds[name];\n            if (dfd)\n                return dfd;\n            dfd = load._sounds[name] = $.Deferred();\n            let audio = document.createElement('audio');\n            let canPlayMp3 = !!audio.canPlayType && '' !== audio.canPlayType('audio/mpeg');\n            let canPlayOgg = !!audio.canPlayType && '' !== audio.canPlayType('audio/ogg; codecs=\"vorbis\"');\n            if (!canPlayMp3 && !canPlayOgg) {\n                dfd.resolve({});\n            } else {\n                let src = path + (canPlayMp3 ? '/sounds-mp3.js' : '/sounds-ogg.js');\n                load._loadScript(src);\n            }\n            return dfd.promise();\n        }\n        static _loadAgent(name, path) {\n            let dfd = load._data[name];\n            if (dfd)\n                return dfd;\n            dfd = load._getAgentDfd(name);\n            let src = path + '/agent.js';\n            load._loadScript(src);\n            return dfd.promise();\n        }\n        static _loadScript(src) {\n            let script = document.createElement('script');\n            script.setAttribute('src', src);\n            script.setAttribute('async', 'async');\n            script.setAttribute('type', 'text/javascript');\n            document.head.appendChild(script);\n        }\n        static _getAgentDfd(name) {\n            let dfd = load._data[name];\n            if (!dfd) {\n                dfd = load._data[name] = $.Deferred();\n            }\n            return dfd;\n        }\n    }\n    load._maps = {};\n    load._sounds = {};\n    load._data = {};\n    function ready(name, data) {\n        let dfd = load._getAgentDfd(name);\n        dfd.resolve(data);\n    }\n    function soundsReady(name, data) {\n        let dfd = load._sounds[name];\n        if (!dfd) {\n            dfd = load._sounds[name] = $.Deferred();\n        }\n        dfd.resolve(data);\n    }\n    return {\n        load: load,\n        ready: ready,\n        soundsReady: soundsReady\n    };\n});\ndefine('skylark-clippy/main',[\n    \"skylark-langx/skylark\",\n    './Agent',\n    './Animator',\n    './Queue',\n    './Balloon',\n    './loads'\n], function (skylark,Agent, Animator, Queue, Balloon, loads) {\n    'use strict';\n\n    const clippy = {\n        Agent,\n        Animator,\n        Queue,\n        Balloon,\n        \"load\" : loads.load,\n        \"ready\": loads.ready,\n        \"soundsReady\": loads.soundsReady\n    };\n    return skylark.attach(\"intg.clippy\",clippy);\n\n});\ndefine('skylark-clippy', ['skylark-clippy/main'], function (main) { return main; });\n\ndefine('skylark-98js/window-switcher',[\n\t\"skylark-jquery\",\n\t\"skylark-clippy\",\n\t\"./win98\",\n\t\"./Task\"\n],function($,clippy,win98js,Task){\n\t\n\tvar $window_switcher = $(\"<div class='window-switcher outset-deep'>\");\n\tvar $window_switcher_list = $(\"<ul class='window-switcher-list'>\").appendTo($window_switcher);\n\tvar $window_switcher_window_name = $(\"<div class='window-switcher-window-name inset-deep'>\").appendTo($window_switcher);\n\tvar agent;\n\tvar used_window_switcher = false;\n\n\tfunction activate_window($window) {\n\t\t// console.log(\"Activating window:\", $window);\n\t\t$window.unminimize();\n\t\t$window.bringToFront();\n\t\t$window.focus(); // unminimize will focus but only if it was minimized (that's the current behavior anyway)\n\t}\n\n\tfunction show_window_switcher(cycle_backwards) {\n\t\tif ($window_switcher.is(\":visible\")) {\n\t\t\tcycle_window_switcher(cycle_backwards);\n\t\t\treturn;\n\t\t}\n\t\t$window_switcher_list.empty();\n\t\tconst tasks = Task.all_tasks;\n\t\tif (tasks.length === 1) {\n\t\t\tactivate_window(tasks[0].$window);\n\t\t\tif (!used_window_switcher) {\n\t\t\t\tagent && agent.stopCurrent(); // needed to continue on from the message with `hold` set (speak(message, true))\n\t\t\t\tagent && agent.speak(\"If there's only one window, Alt+` will switch to it right away.\");\n\t\t\t\t// used_window_switcher = true; // allow the switching message to be spoken later\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (tasks.length < 2) {\n\t\t\treturn;\n\t\t}\n\t\ttasks.sort((a, b) =>\n\t\t\t// using z-index, as it's similar to last-used order\n\t\t\tb.$window[0].style.zIndex - a.$window[0].style.zIndex\n\t\t);\n\t\tfor (const task of tasks) {\n\t\t\tvar $window = task.$window;\n\t\t\tvar $item = $(\"<li>\").addClass(\"window-switcher-item\");\n\t\t\t$item.append($window.getIconAtSize(32) /*??*/ ||  $(\"<img>\").attr({\n\t\t\t\tsrc: \"/images/icons/task-32x32.png\",\n\t\t\t\twidth: 32,\n\t\t\t\theight: 32,\n\t\t\t\talt: $window.getTitle()\n\t\t\t}));\n\t\t\t$item.data(\"$window\", $window);\n\t\t\t// $item.on(\"click\", function () { // Windows 98 didn't allow clicking items in the window switcher.\n\t\t\t// \tactivate_window($window);\n\t\t\t// });\n\t\t\t$window_switcher_list.append($item);\n\t\t\tif ($window.hasClass(\"focused\")) {\n\t\t\t\t$item.addClass(\"active\");\n\t\t\t}\n\t\t}\n\t\tcycle_window_switcher(cycle_backwards);\n\t\t$window_switcher.appendTo(\"body\");\n\t\t// console.log(\"Showing window switcher\", $window_switcher[0]);\n\t\tif (!used_window_switcher) {\n\t\t\tagent && agent.stopCurrent(); // needed to continue on from the message with `hold` set (speak(message, true))\n\t\t\t// Um, if you know about Alt+Tab, you can guess about how Alt+` works. But Clippy is supposed to be annoying, right?\n\t\t\tagent && agent.speak(\"There you go! Press grave accent until you get to the window you want.\");\n\t\t\tused_window_switcher = true;\n\t\t}\n\t}\n\tfunction cycle_window_switcher(cycle_backwards) {\n\t\tconst items = $window_switcher.find(\".window-switcher-item\").toArray();\n\t\tconst $active = $window_switcher.find(\".active\");\n\t\tconst old_index = items.indexOf($active[0]);\n\t\tconst new_index = ((old_index + (cycle_backwards ? -1 : 1)) + items.length) % items.length;\n\t\t$active.removeClass(\"active\");\n\t\tconst new_item = items[new_index];\n\t\t$(new_item).addClass(\"active\");\n\t\t$window_switcher_window_name.text($(new_item).data(\"$window\").getTitle());\n\t}\n\tfunction window_switcher_close_and_select() {\n\t\tif (!$window_switcher.is(\":visible\")) {\n\t\t\treturn;\n\t\t}\n\t\tconst $active = $window_switcher.find(\".active\");\n\t\tif ($active.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tactivate_window($active.data(\"$window\"));\n\t\t$window_switcher.remove(); // must remove only after getting data()\n\t}\n\tfunction window_switcher_cancel() {\n\t\t$window_switcher.remove();\n\t}\n\n\twindow.addEventListener(\"keydown\", handle_keydown, true);\n\twindow.addEventListener(\"keyup\", handle_keyup, true);\n\twindow.addEventListener(\"blur\", window_switcher_cancel); // this may be from an iframe getting focus (e.g. an app was loading), but in that case we might not be able to get the keyup anyways\n\t// @TODO: detect if it's an iframe we've integrated with and thus could get the keyup event\n\t// @TODO: also detect blur inside iframes, to cancel window switching\n\n\tvar iid;\n\tvar alt_held = false; // for detecting likely Alt+Tab\n\tvar notice_shown = false;\n\tfunction handle_keydown(e) {\n\t\tif (e.altKey && (e.key === \"4\" || e.key === \"F4\")) { // we can't actually intercept Alt+F4, but might as well try, right?\n\t\t\te.preventDefault();\n\t\t\tconst $window = e.target.closest(\".os-window\") && e.target.closest(\".os-window\").$window;\n\t\t\tconsole.log(\"Alt+4 detected, closing window\", $window, e.target);\n\t\t\t$window && $window.close();\n\t\t}\n\t\t// console.log(e.key, e.code);\n\t\tif (e.altKey && (e.code === \"Backquote\" || e.code === \"Tab\")) {\n\t\t\tshow_window_switcher(e.shiftKey);\n\t\t} else {\n\t\t\twindow_switcher_cancel();\n\t\t}\n\t\tif (e.key === \"Alt\") {\n\t\t\talt_held = true;\n\t\t\t// console.log(\"Alt held\");\n\t\t\tclearInterval(iid);\n\t\t\tiid = setInterval(look_for_focus_loss, 200);\n\t\t}\n\t}\n\tfunction handle_keyup(e) {\n\t\t// console.log(\"keyup\", e.key, e.code);\n\t\t// if (e.key === \"Alt\") { // on my Ubuntu XFCE, it's giving \"Meta\" if Shift is held\n\t\tif (!e.altKey) {\n\t\t\talt_held = false;\n\t\t\tclearInterval(iid);\n\t\t\t// console.log(\"Alt released\");\n\t\t\twindow_switcher_close_and_select();\n\t\t}\n\t}\n\tfunction look_for_focus_loss() {\n\t\t// Welcome to Heuristic Hurdles! I'm your host, Hacky Hairy. Today we're going to be detecting Alt+Tab.\n\t\t// Alt+Tab is a common shortcut for switching between windows, but we can't actually intercept it.\n\t\t// In fact, the browser doesn't even know about it. It's handled by the window manager directly.\n\t\t// We'll have to pick another shortcut, but who's going to know about it? Wouldn't it be nice if we could at least detect Alt+Tab,\n\t\t// to inform users of the new shortcut? How are we going to do that, in mere JavaScript?\n\t\t// Heuristics! *queue Heuristic Hurdles theme song*\n\n\t\t// console.log(\"alt_held\", alt_held, \"!top.document.hasFocus()\", !top.document.hasFocus(), \"top.document.hasFocus()\", top.document.hasFocus(), \"top.document\", top.document, \"top.activeElement\", top.document.activeElement);\n\t\tif (alt_held && !top.document.hasFocus()) {\n\t\t\t// Some things like closing a window with Alt+4 can cause the document to lose focus, without Alt+Tab.\n\t\t\t// But if the window's really lost focus, we shouldn't be able to focus an element in it to focus the document.\n\t\t\t// So we can use that to refine the heuristic.\n\t\t\tif (\n\t\t\t\t!top.document.activeElement ||\n\t\t\t\ttop.document.activeElement === top.document.body ||\n\t\t\t\ttop.document.activeElement === top.document.documentElement\n\t\t\t) {\n\t\t\t\t// try focusing the document (or window, rather)\n\t\t\t\ttop.focus();\n\t\t\t\tif (top.document.hasFocus()) {\n\t\t\t\t\t// console.log(\"Focused document\");\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\t// console.log(\"Couldn't focus document, so you've probably Alt+Tabbed\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// console.log(\"Active element is\", top.document.activeElement, \" despite hasFocus() being false so you've probably Alt+Tabbed\");\n\t\t\t}\n\n\t\t\t// False positives:\n\t\t\t// - Alt+D focuses the address bar in Chrome\n\t\t\t// - Hold Alt and click outside the browser window\n\t\t\t// - Alt+Space shows the system window menu on some platforms, and on Ubuntu XFCE in Firefox this causes a false positive but not in Chrome apparently (weird!)\n\t\t\t// - Alt+(number) focuses a tab in Chrome, but it actually lets us cancel it; @TODO: detect this as not an Alt+Tab (could use a timeout after any key pressed while holding Alt)\n\n\t\t\tclearInterval(iid);\n\t\t\talt_held = false;\n\n\t\t\tif (Task.all_tasks.length < 2) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!notice_shown) {\n\t\t\t\tnew clippy.load(\"Clippy\", function (loaded_agent) {\n\t\t\t\t\tagent = loaded_agent;\n\t\t\t\t\tagent.show();\n\t\t\t\t\tconst message = \"It looks like you're trying to switch windows.\\n\\nUse Alt+` (grave accent) instead of Alt+Tab within the 98.js desktop.\\n\\nAlso, use Alt+4 instead of Alt+F4 to close windows.\";\n\t\t\t\t\tagent.speak(message, true);\n\t\t\t\t\t// held message causes double click to not animate Clippy, for some reason (even after message is cleared)\n\t\t\t\t\t$(agent._el).one(\"dblclick\", function () {\n\t\t\t\t\t\tagent.stopCurrent();\n\t\t\t\t\t\tagent.animate();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tnotice_shown = true;\n\t\t\t}\n\t\t}\n\t}\n\n});\n\ndefine('skylark-98js/main',[\r\n\t\"./$desktop\",\r\n\t\"./$start-menu\",\r\n\t\"./$taskbar-time\",\r\n\t\"./filesystem-setup\",\r\n\t\"./FolderView\",\r\n\t\"./FolderViewItem\",\r\n\t\"./msgbox\",\r\n\t\"./Task\",\r\n\t\"./visualizer-overlay\",\r\n\t\"./window-switcher\"\r\n],function(){\r\n\t\r\n});\ndefine('skylark-98js', ['skylark-98js/main'], function (main) { return main; });\n\n"]}